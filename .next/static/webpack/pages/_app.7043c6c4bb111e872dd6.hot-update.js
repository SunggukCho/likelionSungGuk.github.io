self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md":
/*!*************************************************************************!*\
  !*** ./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Typescript 시작하기\"\r\ndate: \"2021.04.14\"\r\ntags: \r\n  - typescript\r\n---\r\n\r\n\r\n\r\n# 타입스크립트 fundamentals - 타입, 함수, 인터페이스, enum, 클래스\r\n\r\n\r\n## 1. 기본타입\r\n\r\n변수선언방식 변수명 : 타입 = 값;\r\n\r\n```tsx\r\nlet str: string = 'hi'\r\nlet num: number = 10;\r\nlet isLoggedIn: boolean = false;\r\n```\r\n\r\n### Array\r\n\r\n요소의 집합\r\n\r\n```tsx\r\nlet arr: number[] = [1, 2, 3];\r\narr[2] = 100;\r\n\r\n// 타입이 다르므로 에러\r\narr[2] = 'hi';\r\n```\r\n\r\n### Tuple\r\n\r\n**길이가 고정**되고 요소 **타입이 지정**된 배열\r\n\r\n```tsx\r\nlet tuple: [string, number] = ['hi', 10];\r\n\r\n//길이가 고정되기때문에 에러뜸\r\ntuple[5] = 'hello';\r\n// number타입에 string 할당 x 에러\r\ntuple[1] = 'hi';\r\n\r\n```\r\n\r\n### Enum\r\n\r\n**상수**들의 집합이다.\r\n\r\n```tsx\r\nenum Avengers { Capt, IronMan, Thor }\r\nlet hero: Avengers = Avengers.Capt;\r\n\r\nconsole.log(hero); // 0\r\n\r\n//읽기전용이라서 할당불가 에러\r\nAvengers.Capt = 3;\r\n```\r\n\r\n### Any\r\n\r\n자바스크립트의 변수랑 똑같다. 뭐든 할당 가능\r\n\r\n```tsx\r\nlet str: any = 'hi';\r\nlet num: any = 10;\r\nlet arr: any = ['a', 2, true];\r\n\r\n//any라서 num에 'hi' 할당 가능\r\nnum = 'hi';\r\n```\r\n\r\n### Void\r\n\r\nundefined와 null만 할당가능하다. 일반적으로 반환하지 않는 **함수**에서 사용\r\n\r\n```tsx\r\nlet unuseful: void = undefined;\r\nfunction notuse(): void {\r\n  console.log('sth');\r\n}\r\n```\r\n\r\n### never\r\n\r\n에러를 throw 하거나 절대 반환하지 않는 함수(무한루프일때 쓰이네요)\r\n\r\n```tsx\r\nfunction neverEnd(): never {\r\n  while (true) {\r\n\r\n  }\r\n}\r\n\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n```\r\n\r\n## 2. 함수\r\n\r\n### 함수의 기본적인 타입 선언\r\n\r\n자바스크립트와의 차이점은 **매개 변수**와 **반환 값**에 타입 부여\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n\treturn a + b;\r\n}\r\n```\r\n\r\n### 함수의 인자\r\n\r\n전달 인자의 수가 더 많거나 적거나 하면 당연히 안되겠죠? 당연히 타입도 다르면 안되요\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // error, too few parameters\r\n```\r\n\r\n### 선택적 매개변수\r\n\r\n하지만 매개변수에 ?를 달아주면 그 전달인자를 넘기지 않아도 됩니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b?: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 10\r\n```\r\n\r\n```tsx\r\n// error 필수 매개변수가 선택적 매개변수 \r\n// 선택적 매개변수가 앞에 있으면 안됩니다.\r\nfunction sum(a?: number, b: number): number {\r\n  return a + b;\r\n}\r\n```\r\n\r\n기본값도 설정해 줄 수 있습니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b = 100): number {\r\n  return a + b;\r\n}\r\nsum(10, undefined); // 110\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 110\r\n```\r\n\r\n### 인터페이스\r\n\r\n인터페이스는 상호간의 정의한 약속이나 규칙을 의미한다.\r\n\r\n객체의 속성과 속성타입\r\n\r\n함수의 매개변수나 반환타입\r\n\r\n배열과 객체를 접근하는 방식\r\n\r\n클래스\r\n\r\nlogAge 메소드는 age라는 속성을 갖고 number타입을 갖는 객체를 받는것을 약속했다.\r\n\r\n```tsx\r\nlet person = { name: 'Capt', age: 28 };\r\n\r\nfunction logAge(obj: { age: number }) {\r\n  console.log(obj.age); // 28\r\n}\r\nlogAge(person); // 28\r\n```\r\n\r\n```tsx\r\ninterface personAge {\r\n  age: number;\r\n}\r\n\r\nfunction logAge(obj: personAge) {\r\n  console.log(obj.age);\r\n}\r\nlet person = { name: 'Capt', age: 28 };\r\nlogAge(person);\r\n```\r\n\r\n### 옵션속성\r\n\r\n아까 매개변수때와 마찬가지로 ?를 붙혀주면 그 속성을 모두 다 꼭 사용하지 않아도 됩니다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  name: string;\r\n  hop?: number;  \r\n}\r\n\r\nlet myBeer = {\r\n  name: 'Saporo'\r\n};\r\nfunction brewBeer(beer: CraftBeer) {\r\n  console.log(beer.name); // Saporo\r\n}\r\nbrewBeer(myBeer);\r\n```\r\n\r\n### 읽기 전용 속성\r\n\r\nreadonly가 붙은 속성은 읽는것만 된다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  readonly brand: string;\r\n}\r\n\r\nlet myBeer: CraftBeer = {\r\n  brand: 'Belgian Monk'\r\n};\r\nmyBeer.brand = 'Korean Carpenter'; // error!\r\n```\r\n\r\n### 읽기 전용 배열\r\n\r\nReadonlyArray로 선언하면 배열 내용 변경 불가ReadonlyArray로 선언하면 배열 내용 변경 불가\r\n\r\n```tsx\r\nlet arr: ReadonlyArray<number> = [1,2,3];\r\narr.splice(0,1); // error\r\narr.push(4); // error\r\narr[0] = 100; // error\r\narr = [10, 20, 30]; // error\r\n```\r\n\r\n객체 선언과 관련된 타입 체킹\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  brand?: string;\r\n}\r\n\r\nfunction brewBeer(beer: CraftBeer) {\r\n  // ..\r\n}\r\nbrewBeer({ brandon: 'what' }); // 속성이 다르니 에러뜹니다.\r\n```\r\n\r\n이러면 타입 체크를 무시한다.\r\n\r\n```tsx\r\nlet myBeer = { brandon: 'what' }';\r\nbrewBeer(myBeer as CraftBeer);\r\n```\r\n\r\n### 함수 타입\r\n\r\n함수 매개변수와 반환타입도 인터페이스 정의가 가능하다.\r\n\r\n```tsx\r\ninterface login {\r\n  (username: string, password: string): boolean;\r\n}\r\n\r\nlet loginUser: login; // 함수 저장할 변수 선언\r\nloginUser = function(id: string, pw: string) {\r\n  console.log('로그인 했습니다');\r\n  return true;\r\n}\r\n```\r\n\r\n클래스 타입\r\n\r\n자바의 인터페이스와 목적이 비슷한데\r\n\r\n어떤 인터페이스를 implements한 클래스가 있다면\r\n\r\n인터페이스의 메소드와 변수가 있다는 것을 보장한다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  beerName: string;\r\n  nameBeer(beer: string): void;\r\n}\r\n\r\nclass myBeer implements CraftBeer {\r\n  beerName: string = 'Baby Guinness';\r\n  nameBeer(b: string) {\r\n    this.beerName = b;\r\n  }\r\n  constructor() {}\r\n}\r\n```\r\n\r\n인터페이스 끼리 상속도 가능합니다.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n}\r\ninterface Drinker {\r\n  drink: string;\r\n}\r\ninterface Developer extends Person {\r\n  skill: string;\r\n}\r\nlet fe = {} as Developer;\r\nfe.name = 'josh';\r\nfe.skill = 'TypeScript';\r\nfe.drink = 'Beer';\r\n```\r\n\r\n## 4. Enum\r\n\r\n> 특정 값들의 **집합**을 의미하는 자료형으로 크게 {숫자형 이넘, 문자형 이넘} 두 가지가 있다\r\n\r\n- Enum이라는 개념을 이해하기 어려웠던 이유는, javascript에는 enum이 없었기 때문이다. (하지만 검색해보니 C언어에서는 제공하는 것 같음.)\r\n\r\n### 4-1. 숫자형 이넘\r\n\r\n```tsx\r\nenum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n특이한 것은 이렇게 선언하면  양방향으로 호출할 수 있는 특이한 자료구조가 된다는 것이다.\r\n\r\n```tsx\r\nconsole.log(Direction[1])    // \"Up\"\r\nconsole.log(Direction[\"Up\"]) // 1\r\nconsole.log(Direction[3])    // \"Left\"\r\n```\r\n\r\n이와 같이 숫자형 Enum에서 Direction.Up 으로 1값을 얻거나 반대로 Direction[1]로 \"Up\"값을 얻는 것을 **`리버스 매핑`** 이라고 한다.\r\n\r\n이렇게 초기값을 선언해주면 1, 2, 3, 4 의 순서로 1씩 증가하며 할당된다. 만약,\r\n\r\n```tsx\r\nenum Direction {\r\n\tUp, \r\n\tDown,\r\n\tLeft,\r\n\tRight\r\n}\r\n```\r\n\r\n으로 선언되었다면 Up - 0 , Down - 1, Left - 2, Right - 3이 된다.\r\n\r\n### 4-2 숫자형 enum 사용\r\n\r\n```tsx\r\nenum Response {\r\n  No = 0,\r\n  Yes = 1,\r\n}\r\n\r\nfunction respond(recipient: string, message: Response): void {\r\n  console.log(recipient, message)\r\n}\r\n\r\nrespond(\"Captain Pangyo\", Response.Yes);\r\n\r\n--------------------\r\n[LOG]: \"Captain Pangyo\",  1\r\n```\r\n\r\n### 4-3. 문자형 enum\r\n\r\n> 문자형 이넘은 이넘 값 전부 다 특정 문자 또는 다른 이넘 값으로 초기화 해줘야 합니다.\r\n\r\n```tsx\r\nenum Direction {\r\n    Up = \"UP\",\r\n    Down = \"DOWN\",\r\n    Left = \"LEFT\",\r\n    Right = \"RIGHT\",\r\n}\r\n```\r\n\r\n** 복합 enums **\r\n\r\n문자와 숫자를 혼합하여 enum을 생성할 수 있으나, 권장하지 않는 방식!\r\n\r\n```tsx\r\nenum BooleanLikeHeterogeneousEnum {\r\n    No = 0,\r\n    Yes = \"YES\",\r\n}\r\n```\r\n\r\n### 4-4. 런타임 시점에서의 이넘 특징\r\n\r\n이넘은 런타임시에 실제 객체 형태로 존재합니다. 예를 들어 아래와 같은 이넘 코드가 있을 때\r\n\r\n```tsx\r\nenum E {\r\n  X, Y, Z\r\n}\r\n\r\nfunction getX(obj: { X: number }) {\r\n  return obj.X;\r\n}\r\ngetX(E); // 이넘 E의 X는 숫자이기 때문에 정상 동작\r\n-----\r\nQuiz. \r\ngetX(E)값을 변수에 넣어서 출력한다면, 얼마나 나올까?\r\n```\r\n\r\n### 4-5. 컴파일 시점에서의 이넘 특징\r\n\r\n```tsx\r\nenum LogLevel {\r\n  ERROR, WARN, INFO, DEBUG\r\n}\r\n\r\n// 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\r\ntype LogLevelStrings = keyof typeof LogLevel;\r\n\r\nfunction printImportant(key: LogLevelStrings, message: string) {\r\n    const num = LogLevel[key];\r\n    if (num <= LogLevel.WARN) {\r\n       console.log('Log level key is: ', key);\r\n       console.log('Log level value is: ', num);\r\n       console.log('Log level message is: ', message);\r\n    }\r\n}\r\nprintImportant('ERROR', 'This is a message');\r\n\r\n-------\r\n[LOG]: \"Log level key is: \",  \"ERROR\" \r\n[LOG]: \"Log level value is: \",  0 \r\n[LOG]: \"Log level message is: \",  \"This is a message\"\r\n```\r\n\r\n### 4-6. Typescript enum을 사용하는 이유\r\n\r\nEnum은 추상화의 수단이다.\r\n\r\n다국어 코드 (Language Code)를 할당한다고 생각해보자\r\n\r\n```tsx\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\n\r\nconst code: LanguageCode = 'ko'\r\n\r\nconsole.log(code) // [LOG]: \"ko\"\r\n\r\n하지만 \r\ncost code: LanguageCode = 'hahahaha'\r\n와 같이 코드를 짜면 typescript에서 에러로 표시해준다.\r\n```\r\n\r\n이것도 좋지만 데이터 양이 많아지면 가독성이 많이 떨어진다.\r\n\r\n우리가 원하는 것은 korean을 검색하면 'ko'라는 코드가 나왔으면 하는 것이고 기존 방식으로는 다음과 같이 두 가지 방법이 있다.\r\n\r\n```tsx\r\n// 이렇게 하면 언어 코드가 위아래에 중복되고\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nlet code: LanguageCode = english\r\nconsole.log(code) // \"en\"\r\n```\r\n\r\n```tsx\r\n// 이렇게 하면 코드가 너무 길어집니다\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = typeof korean | typeof english | typeof japanese | typeof chinese | typeof spanish\r\nlet code: LanguageCode = spanish\r\nconsole.log(code) // \"es\"\r\n```\r\n\r\n이러한 이유 때문에 리터럴의 타입과 값에 이름을 붙인 `enum`을 활용하면 가독성을 크게 높일 수 있습니다.\r\n\r\n```tsx\r\nenum LanguageCode {\r\n  korean = 'ko',\r\n  english = 'en',\r\n  japanese = 'ja',\r\n  chinese = 'zh',\r\n  spanish = 'es',\r\n}\r\n// 여기서 \r\n// LanguageCode.korean === 'ko'\r\n// (의미상) LanguageCode === 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nconst code: LanguageCode = LanguageCode.korean\r\nconsole.log(code) // \"ko\"\r\n```\r\n\r\n### 4-7. Typescript enum을 사용하지 않는 이유\r\n\r\n### Tree-shaking은 무엇인가요?\r\n\r\nTree-shaking이란 간단하게 말해 사용하지 않는 코드를 삭제하는 기능을 말합니다. 나무를 흔들면 죽은 잎사귀들이 떨어지는 모습에 착안해 Tree-shaking이라고 부릅니다. Tree-shaking을 통해 export했지만 아무 데서도 import하지 않은 모듈이나 사용하지 않는 코드를 삭제해서 번들 크기를 줄여 페이지가 표시되는 시간을 단축할 수 있습니다.\r\n\r\n하지만 enum을 사용하게 되면 Tree-shaking이 되지 않습니다.\r\n\r\n결론적으로  Tree-shaking 관점에서 보았을 때 아래와 같은 순서로 사용하시길 추천하며 글을 마치겠습니다.\r\n\r\n> Union Types > const enum > enum\r\n\r\n**정리**\r\n\r\n- 같은 ‘종류’를 나타내는 여러 개의 숫자 혹은 문자열을 다뤄야 하는데, \r\n각각 적당한 이름을 붙여서 코드의 가독성을 높이고 싶다면 enum을 사용!\r\n\r\n## 5. 연산자를 이용한 타입 정의\r\n\r\n### 5-1. Union Type ( | )\r\n\r\n유니온 타입(Union Type)이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입\r\n\r\n```tsx\r\nfunction logText(text: string | number) {\r\n  // ...\r\n}\r\n```\r\n\r\n- text는 string이거나 (OR || ) number이다. 즉, 둘 다 올 수 있다는 뜻.\r\n- 이처럼 `|` 연산자를 이용하여 타입을 여러 개 연결하는 방식을 `유니온 타입 정의 방식` 이라 부른다.\r\n\r\n```tsx\r\nfunction getAge(age: number | string) {\r\n  if (typeof age === 'number') {\r\n    age.toFixed(); // 정상 동작, age의 타입이 `number`로 추론되기 때문에 숫자 관련된 API를 쉽게 자동완성 할 수 있다.\r\n    return age;\r\n  }\r\n  if (typeof age === 'string') {\r\n    return age;\r\n  }\r\n  return new TypeError('age must be number or string');\r\n}\r\nconsole.log(getAge(10))\r\nconsole.log(getAge('Hello World'))\r\nconsole.log(getAge(true))\r\n--- 출력 ---\r\n[LOG]: 10 \r\n[LOG]: \"Hello World\" \r\n[LOG]: age must be number or string\r\n```\r\n\r\n### 5-2. Intersection Type ( & )\r\n\r\n여러 타입을 모두 만족하는 하나의 타입을 의미.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: number;\r\n}\r\ntype Capt = Person & Developer;\r\n```\r\n\r\n```tsx\r\n// Capt의 타입은\r\n\r\n{\r\n  name: string;\r\n  age: number;\r\n  skill: string;\r\n}\r\n```\r\n\r\n![Intersection Type](https://joshua1988.github.io/ts/assets/img/intersection-diagram.01f4fdfe.png)\r\n\r\n### 5-3. Union Type을 쓸 때 주의할 점\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: string;\r\n}\r\nfunction introduce(someone: Person | Developer) {\r\n  someone.name; // O 정상 동작\r\n  someone.age; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n  someone.skill; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n}\r\n```\r\n\r\n유니온 타입은 A도 될 수 있고 B도 될 수 있는 타입이지라고 생각하면 파라미터의 타입이 Person도 되고 Developer도 될테니까 함수 안에서 당연히 이 인터페이스들이 제공하는 속성들인 age나 skill를 사용할 수 있겠지라고 생각할 수 있습니다. \r\n\r\n하지만, 타입스크립트 관점에서는 introduce() 함수를 호출하는 시점에 Person 타입이 올지 Developer 타입이 올지 알 수가 없기 때문에 어느 타입이 들어오든 간에 오류가 안 나는 방향으로 타입을 추론하게 됩니다.\r\n\r\n따라서 위의 예시 같은 경우에는 의도와는 달리 [someone.name](http://someone.name) 만 정상적으로 작동하게 됩니다.\r\n\r\n## 6. Class\r\n\r\n### 6-1. Readonly\r\n\r\n```tsx\r\nclass Developer {\r\n    readonly name: string;\r\n    constructor(theName: string) {\r\n        this.name = theName;\r\n    }\r\n}\r\nlet john = new Developer(\"John\");\r\njohn.name = \"John\"; // error! name is readonly.\r\nconsole.log(john)\r\n--- 출력 ---\r\n[LOG]: Developer: {\r\n  \"name\": \"John\"\r\n}\r\n```\r\n\r\n### 6-2. Accessor\r\n\r\n타입스크립트는 객체의 특정 속성의 접근과 할당에 대해 제어할 수 있습니다. 이를 위해선 해당 객체가 클래스로 생성한 객체여야 합니다. 아래의 간단한 예제를 봅시다.\r\n\r\n```tsx\r\nclass Developer {\r\n  name: string;\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton';\r\n```\r\n\r\n위 코드는 클래스로 생성한 객체의 `name` 속성에 `Josh Bolton`이라는 값을 대입한 코드입니다. 이제 `josh`라는 객체의 `name` 속성은 `Josh Bolton`이라는 값을 갖겠죠.\r\n\r\n여기서 만약 `name` 속성에 제약 사항을 추가하고 싶다면 아래와 같이 `get`과 `set`을 활용합니다.\r\n\r\n```tsx\r\nclass Developer {\r\n  private name: string;\r\n  \r\n  get name(): string {\r\n    return this.name;\r\n  }\r\n\r\n  set name(newValue: string) {\r\n    if (newValue && newValue.length > 5) {\r\n      throw new Error('이름이 너무 깁니다');\r\n    }\r\n    this.name = newValue;\r\n  }\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton'; // Error\r\njosh.name = 'Josh';\r\n```\r\n\r\nTIP!\r\nget만 선언하고 set을 선언하지 않는 경우에는 자동으로 readonly로 인식됩니다.\r\n\r\n### 6-3. Abstract Class\r\n\r\n추상 클래스(Abstract Class)는 인터페이스와 비슷한 역할을 하면서도 조금 다른 특징을 갖고 있습니다. 추상 클래스는 특정 클래스의 상속 대상이 되는 클래스이며 좀 더 상위 레벨에서 속성, 메서드의 모양을 정의합니다.\r\n\r\n```tsx\r\nabstract class Developer {\r\n  abstract coding(): void; // 'abstract'가 붙으면 상속 받은 클래스에서 무조건 구현해야 함\r\n  drink(): void {\r\n    console.log('drink sth');\r\n  }\r\n}\r\n\r\nclass FrontEndDeveloper extends Developer {\r\n  coding(): void {\r\n    // Developer 클래스를 상속 받은 클래스에서 무조건 정의해야 하는 메서드\r\n    console.log('develop web');\r\n  }\r\n  design(): void {\r\n    console.log('design web');\r\n  }\r\n}\r\nconst dev = new Developer(); // error: cannot create an instance of an abstract class\r\nconst josh = new FrontEndDeveloper();\r\njosh.coding(); // develop web\r\njosh.drink(); // drink sth\r\njosh.design(); // design web\r\n```\r\n\r\n\r\n\r\n\r\n---\r\nReferences\r\nhttps://joshua1988.github.io/ts/\r\n\r\n[TypeScript enum을 사용하는 이유](https://medium.com/@seungha_kim_IT/typescript-enum을-사용하는-이유-3b3ccd8e5552)\r\n\r\n[TypeScript enum을 사용하지 않는 게 좋은 이유](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/)\r\n\r\n[C언어 Enum](https://dojang.io/mod/page/view.php?id=480)");

/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS90eXBlc2NyaXB0LzIwMjEtMDQtMTQtVHlwZXNjcmlwdC3si5zsnpHtlZjquLAubWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLCtEQUFlLCtNQUErTSxpRUFBaUUsb0NBQW9DLHNGQUFzRixpQkFBaUIsd0NBQXdDLHlIQUF5SCxnREFBZ0QsbURBQW1ELGtGQUFrRixzQkFBc0IsdUNBQXVDLDBCQUEwQixvREFBb0QsNkZBQTZGLHNCQUFzQixrQ0FBa0MsOENBQThDLGtJQUFrSSw2QkFBNkIseUJBQXlCLEtBQUssc0hBQXNILG9CQUFvQixXQUFXLEtBQUssZ0RBQWdELGlDQUFpQyxLQUFLLCtKQUErSixtQkFBbUIsS0FBSywrSUFBK0ksbUJBQW1CLEtBQUssZ0JBQWdCLDBCQUEwQiwwQ0FBMEMscUtBQXFLLG1CQUFtQixLQUFLLGdCQUFnQiwwQkFBMEIsMENBQTBDLHdJQUF3SSxtQkFBbUIsS0FBSyw2RkFBNkYsbUJBQW1CLEtBQUssdUJBQXVCLDJCQUEyQiwwQ0FBMEMsNk9BQTZPLHlCQUF5Qiw4QkFBOEIsY0FBYyxHQUFHLDJCQUEyQixXQUFXLG1CQUFtQixvREFBb0Qsa0JBQWtCLEtBQUsseUNBQXlDLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsbUJBQW1CLHdIQUF3SCxtQkFBbUIsbUJBQW1CLE9BQU8sc0JBQXNCLDBCQUEwQix3Q0FBd0MsNkJBQTZCLGVBQWUscUJBQXFCLG1HQUFtRyw2QkFBNkIsS0FBSyxpQ0FBaUMsaUNBQWlDLHNDQUFzQyxzS0FBc0ssb0JBQW9CLHlCQUF5QiwwQkFBMEIsZ0NBQWdDLCtFQUErRSxxQkFBcUIsS0FBSyw0Q0FBNEMsZ0JBQWdCLGNBQWMsa0JBQWtCLEVBQUUsaUZBQWlGLGtCQUFrQixFQUFFLGtDQUFrQyxpR0FBaUcsb0RBQW9ELEtBQUssNkJBQTZCLGtFQUFrRSw4QkFBOEIsa0JBQWtCLEtBQUssaUtBQWlLLHVCQUF1QixtQ0FBbUMsS0FBSywyQ0FBMkMseUNBQXlDLDJCQUEyQiwwQkFBMEIsT0FBTyxzQkFBc0IsS0FBSyxzRUFBc0UsbUJBQW1CLEtBQUssdUJBQXVCLG9CQUFvQixLQUFLLHdDQUF3QyxvQkFBb0IsS0FBSyxlQUFlLGNBQWMscUJBQXFCLDRCQUE0QixzQkFBc0IsaUVBQWlFLGVBQWUsaUtBQWlLLG1EQUFtRCxvWkFBb1osZ0RBQWdELGdJQUFnSSxnQ0FBZ0Msc0VBQXNFLDBDQUEwQyxrREFBa0QsMExBQTBMLG1HQUFtRyxtSUFBbUksMENBQTBDLDRIQUE0SCxrQkFBa0IsNEJBQTRCLFlBQVksR0FBRyxtQkFBbUIsS0FBSyxZQUFZLDJKQUEySixtQ0FBbUMsK0NBQStDLGlEQUFpRCx3RUFBd0Usa0NBQWtDLG1DQUFtQyxrREFBa0Qsb0RBQW9ELDBEQUEwRCxTQUFTLEtBQUssaURBQWlELDgyQ0FBODJDLDhHQUE4RyxnN0JBQWc3QixpQkFBaUIsOExBQThMLG9DQUFvQyxzQkFBc0IscUZBQXFGLE9BQU8sb0NBQW9DLG1CQUFtQixPQUFPLDJEQUEyRCxLQUFLLGlUQUFpVCxtQkFBbUIsa0JBQWtCLEtBQUsseUJBQXlCLG1CQUFtQixvQkFBb0IsS0FBSyxtQ0FBbUMsOENBQThDLG1CQUFtQixrQkFBa0Isb0JBQW9CLEtBQUssMkxBQTJMLG1CQUFtQixrQkFBa0IsS0FBSyx5QkFBeUIsbUJBQW1CLG9CQUFvQixLQUFLLHFEQUFxRCxtQkFBbUIsNkJBQTZCLHFEQUFxRCxzQ0FBc0MsNmNBQTZjLDhCQUE4QixzQ0FBc0MsZ0NBQWdDLFNBQVMsS0FBSyx1Q0FBdUMseUJBQXlCLHNGQUFzRiw2QkFBNkIsc0tBQXNLLG1CQUFtQixLQUFLLGlDQUFpQyw4QkFBOEIsdU9BQXVPLDJCQUEyQixnQ0FBZ0MseUJBQXlCLE9BQU8sc0NBQXNDLDhDQUE4Qyx3Q0FBd0MsU0FBUyw2QkFBNkIsT0FBTyxLQUFLLGlDQUFpQyw4QkFBOEIsZ0NBQWdDLHlSQUF5Uiw4QkFBOEIsK0RBQStELGlDQUFpQyxPQUFPLEtBQUssbURBQW1ELHNCQUFzQix3RkFBd0YsT0FBTyxzQkFBc0Isa0NBQWtDLE9BQU8sS0FBSyxnQ0FBZ0Msa0dBQWtHLGtCQUFrQixnQ0FBZ0MsK0JBQStCLDJYQUEyWCxFIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3BhZ2VzL19hcHAuNzA0M2M2YzRiYjExMWU4NzJkZDYuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJUeXBlc2NyaXB0IOyLnOyeke2VmOq4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wNC4xNFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gdHlwZXNjcmlwdFxcclxcbi0tLVxcclxcblxcclxcblxcclxcblxcclxcbiMg7YOA7J6F7Iqk7YGs66a97Yq4IGZ1bmRhbWVudGFscyAtIO2DgOyehSwg7ZWo7IiYLCDsnbjthLDtjpjsnbTsiqQsIGVudW0sIO2BtOuemOyKpFxcclxcblxcclxcblxcclxcbiMjIDEuIOq4sOuzuO2DgOyehVxcclxcblxcclxcbuuzgOyImOyEoOyWuOuwqeyLnSDrs4DsiJjrqoUgOiDtg4DsnoUgPSDqsJI7XFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IHN0cjogc3RyaW5nID0gJ2hpJ1xcclxcbmxldCBudW06IG51bWJlciA9IDEwO1xcclxcbmxldCBpc0xvZ2dlZEluOiBib29sZWFuID0gZmFsc2U7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIEFycmF5XFxyXFxuXFxyXFxu7JqU7IaM7J2YIOynke2VqVxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBhcnI6IG51bWJlcltdID0gWzEsIDIsIDNdO1xcclxcbmFyclsyXSA9IDEwMDtcXHJcXG5cXHJcXG4vLyDtg4DsnoXsnbQg64uk66W066+A66GcIOyXkOufrFxcclxcbmFyclsyXSA9ICdoaSc7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIFR1cGxlXFxyXFxuXFxyXFxuKirquLjsnbTqsIAg6rOg7KCVKirrkJjqs6Ag7JqU7IaMICoq7YOA7J6F7J20IOyngOyglSoq65CcIOuwsOyXtFxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCB0dXBsZTogW3N0cmluZywgbnVtYmVyXSA9IFsnaGknLCAxMF07XFxyXFxuXFxyXFxuLy/quLjsnbTqsIAg6rOg7KCV65CY6riw65WM66y47JeQIOyXkOufrOucuFxcclxcbnR1cGxlWzVdID0gJ2hlbGxvJztcXHJcXG4vLyBudW1iZXLtg4DsnoXsl5Agc3RyaW5nIO2VoOuLuSB4IOyXkOufrFxcclxcbnR1cGxlWzFdID0gJ2hpJztcXHJcXG5cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgRW51bVxcclxcblxcclxcbioq7IOB7IiYKirrk6TsnZgg7KeR7ZWp7J2064ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gQXZlbmdlcnMgeyBDYXB0LCBJcm9uTWFuLCBUaG9yIH1cXHJcXG5sZXQgaGVybzogQXZlbmdlcnMgPSBBdmVuZ2Vycy5DYXB0O1xcclxcblxcclxcbmNvbnNvbGUubG9nKGhlcm8pOyAvLyAwXFxyXFxuXFxyXFxuLy/snb3quLDsoITsmqnsnbTrnbzshJwg7ZWg64u567aI6rCAIOyXkOufrFxcclxcbkF2ZW5nZXJzLkNhcHQgPSAzO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyBBbnlcXHJcXG5cXHJcXG7snpDrsJTsiqTtgazrpr3tirjsnZgg67OA7IiY656RIOuYkeqwmeuLpC4g662Q65OgIO2VoOuLuSDqsIDriqVcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgc3RyOiBhbnkgPSAnaGknO1xcclxcbmxldCBudW06IGFueSA9IDEwO1xcclxcbmxldCBhcnI6IGFueSA9IFsnYScsIDIsIHRydWVdO1xcclxcblxcclxcbi8vYW5565287IScIG51beyXkCAnaGknIO2VoOuLuSDqsIDriqVcXHJcXG5udW0gPSAnaGknO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyBWb2lkXFxyXFxuXFxyXFxudW5kZWZpbmVk7JmAIG51bGzrp4wg7ZWg64u56rCA64ql7ZWY64ukLiDsnbzrsJjsoIHsnLzroZwg67CY7ZmY7ZWY7KeAIOyViuuKlCAqKu2VqOyImCoq7JeQ7IScIOyCrOyaqVxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCB1bnVzZWZ1bDogdm9pZCA9IHVuZGVmaW5lZDtcXHJcXG5mdW5jdGlvbiBub3R1c2UoKTogdm9pZCB7XFxyXFxuICBjb25zb2xlLmxvZygnc3RoJyk7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiMjIyBuZXZlclxcclxcblxcclxcbuyXkOufrOulvCB0aHJvdyDtlZjqsbDrgpgg7KCI64yAIOuwmO2ZmO2VmOyngCDslYrripQg7ZWo7IiYKOustO2VnOujqO2UhOydvOuVjCDsk7DsnbTrhKTsmpQpXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gbmV2ZXJFbmQoKTogbmV2ZXIge1xcclxcbiAgd2hpbGUgKHRydWUpIHtcXHJcXG5cXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZTogc3RyaW5nKTogbmV2ZXIge1xcclxcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiMjIDIuIO2VqOyImFxcclxcblxcclxcbiMjIyDtlajsiJjsnZgg6riw67O47KCB7J24IO2DgOyehSDshKDslrhcXHJcXG5cXHJcXG7snpDrsJTsiqTtgazrpr3tirjsmYDsnZgg7LCo7J207KCQ7J2AICoq66ek6rCcIOuzgOyImCoq7JmAICoq67CY7ZmYIOqwkioq7JeQIO2DgOyehSDrtoDsl6xcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBzdW0oYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xcclxcblxcdHJldHVybiBhICsgYjtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIO2VqOyImOydmCDsnbjsnpBcXHJcXG5cXHJcXG7soITri6wg7J247J6Q7J2YIOyImOqwgCDrjZQg66eO6rGw64KYIOyggeqxsOuCmCDtlZjrqbQg64u57Jew7Z6IIOyViOuQmOqyoOyjoD8g64u57Jew7Z6IIO2DgOyeheuPhCDri6TrpbTrqbQg7JWI65CY7JqUXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gc3VtKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcXHJcXG4gIHJldHVybiBhICsgYjtcXHJcXG59XFxyXFxuc3VtKDEwLCAyMCk7IC8vIDMwXFxyXFxuc3VtKDEwLCAyMCwgMzApOyAvLyBlcnJvciwgdG9vIG1hbnkgcGFyYW1ldGVyc1xcclxcbnN1bSgxMCk7IC8vIGVycm9yLCB0b28gZmV3IHBhcmFtZXRlcnNcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7ISg7YOd7KCBIOunpOqwnOuzgOyImFxcclxcblxcclxcbu2VmOyngOunjCDrp6TqsJzrs4DsiJjsl5AgP+ulvCDri6zslYTso7zrqbQg6re4IOyghOuLrOyduOyekOulvCDrhJjquLDsp4Ag7JWK7JWE64+EIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBzdW0oYTogbnVtYmVyLCBiPzogbnVtYmVyKTogbnVtYmVyIHtcXHJcXG4gIHJldHVybiBhICsgYjtcXHJcXG59XFxyXFxuc3VtKDEwLCAyMCk7IC8vIDMwXFxyXFxuc3VtKDEwLCAyMCwgMzApOyAvLyBlcnJvciwgdG9vIG1hbnkgcGFyYW1ldGVyc1xcclxcbnN1bSgxMCk7IC8vIDEwXFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuLy8gZXJyb3Ig7ZWE7IiYIOunpOqwnOuzgOyImOqwgCDshKDtg53soIEg66ek6rCc67OA7IiYIFxcclxcbi8vIOyEoO2DneyggSDrp6TqsJzrs4DsiJjqsIAg7JWe7JeQIOyeiOycvOuptCDslYjrkKnri4jri6QuXFxyXFxuZnVuY3Rpb24gc3VtKGE/OiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XFxyXFxuICByZXR1cm4gYSArIGI7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbuq4sOuzuOqwkuuPhCDshKTsoJXtlbQg7KSEIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gc3VtKGE6IG51bWJlciwgYiA9IDEwMCk6IG51bWJlciB7XFxyXFxuICByZXR1cm4gYSArIGI7XFxyXFxufVxcclxcbnN1bSgxMCwgdW5kZWZpbmVkKTsgLy8gMTEwXFxyXFxuc3VtKDEwLCAyMCwgMzApOyAvLyBlcnJvciwgdG9vIG1hbnkgcGFyYW1ldGVyc1xcclxcbnN1bSgxMCk7IC8vIDExMFxcclxcbmBgYFxcclxcblxcclxcbiMjIyDsnbjthLDtjpjsnbTsiqRcXHJcXG5cXHJcXG7snbjthLDtjpjsnbTsiqTripQg7IOB7Zi46rCE7J2YIOygleydmO2VnCDslb3sho3snbTrgpgg6rec7LmZ7J2EIOydmOuvuO2VnOuLpC5cXHJcXG5cXHJcXG7qsJ3ssrTsnZgg7IaN7ISx6rO8IOyGjeyEse2DgOyehVxcclxcblxcclxcbu2VqOyImOydmCDrp6TqsJzrs4DsiJjrgpgg67CY7ZmY7YOA7J6FXFxyXFxuXFxyXFxu67Cw7Je06rO8IOqwneyytOulvCDsoJHqt7ztlZjripQg67Cp7IudXFxyXFxuXFxyXFxu7YG0656Y7IqkXFxyXFxuXFxyXFxubG9nQWdlIOuplOyGjOuTnOuKlCBhZ2XrnbzripQg7IaN7ISx7J2EIOqwluqzoCBudW1iZXLtg4DsnoXsnYQg6rCW64qUIOqwneyytOulvCDrsJvripTqsoPsnYQg7JW97IaN7ZaI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBwZXJzb24gPSB7IG5hbWU6ICdDYXB0JywgYWdlOiAyOCB9O1xcclxcblxcclxcbmZ1bmN0aW9uIGxvZ0FnZShvYmo6IHsgYWdlOiBudW1iZXIgfSkge1xcclxcbiAgY29uc29sZS5sb2cob2JqLmFnZSk7IC8vIDI4XFxyXFxufVxcclxcbmxvZ0FnZShwZXJzb24pOyAvLyAyOFxcclxcbmBgYFxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBwZXJzb25BZ2Uge1xcclxcbiAgYWdlOiBudW1iZXI7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGxvZ0FnZShvYmo6IHBlcnNvbkFnZSkge1xcclxcbiAgY29uc29sZS5sb2cob2JqLmFnZSk7XFxyXFxufVxcclxcbmxldCBwZXJzb24gPSB7IG5hbWU6ICdDYXB0JywgYWdlOiAyOCB9O1xcclxcbmxvZ0FnZShwZXJzb24pO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyDsmLXshZjsho3shLFcXHJcXG5cXHJcXG7slYTquYwg66ek6rCc67OA7IiY65WM7JmAIOuniOywrOqwgOyngOuhnCA/66W8IOu2me2YgOyjvOuptCDqt7gg7IaN7ISx7J2EIOuqqOuRkCDri6Qg6rytIOyCrOyaqe2VmOyngCDslYrslYTrj4Qg65Cp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBDcmFmdEJlZXIge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgaG9wPzogbnVtYmVyOyAgXFxyXFxufVxcclxcblxcclxcbmxldCBteUJlZXIgPSB7XFxyXFxuICBuYW1lOiAnU2Fwb3JvJ1xcclxcbn07XFxyXFxuZnVuY3Rpb24gYnJld0JlZXIoYmVlcjogQ3JhZnRCZWVyKSB7XFxyXFxuICBjb25zb2xlLmxvZyhiZWVyLm5hbWUpOyAvLyBTYXBvcm9cXHJcXG59XFxyXFxuYnJld0JlZXIobXlCZWVyKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7J296riwIOyghOyaqSDsho3shLFcXHJcXG5cXHJcXG5yZWFkb25seeqwgCDrtpnsnYAg7IaN7ISx7J2AIOydveuKlOqyg+unjCDrkJzri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIENyYWZ0QmVlciB7XFxyXFxuICByZWFkb25seSBicmFuZDogc3RyaW5nO1xcclxcbn1cXHJcXG5cXHJcXG5sZXQgbXlCZWVyOiBDcmFmdEJlZXIgPSB7XFxyXFxuICBicmFuZDogJ0JlbGdpYW4gTW9uaydcXHJcXG59O1xcclxcbm15QmVlci5icmFuZCA9ICdLb3JlYW4gQ2FycGVudGVyJzsgLy8gZXJyb3IhXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIOydveq4sCDsoITsmqkg67Cw7Je0XFxyXFxuXFxyXFxuUmVhZG9ubHlBcnJheeuhnCDshKDslrjtlZjrqbQg67Cw7Je0IOuCtOyaqSDrs4Dqsr0g67aI6rCAUmVhZG9ubHlBcnJheeuhnCDshKDslrjtlZjrqbQg67Cw7Je0IOuCtOyaqSDrs4Dqsr0g67aI6rCAXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IGFycjogUmVhZG9ubHlBcnJheTxudW1iZXI+ID0gWzEsMiwzXTtcXHJcXG5hcnIuc3BsaWNlKDAsMSk7IC8vIGVycm9yXFxyXFxuYXJyLnB1c2goNCk7IC8vIGVycm9yXFxyXFxuYXJyWzBdID0gMTAwOyAvLyBlcnJvclxcclxcbmFyciA9IFsxMCwgMjAsIDMwXTsgLy8gZXJyb3JcXHJcXG5gYGBcXHJcXG5cXHJcXG7qsJ3ssrQg7ISg7Ja46rO8IOq0gOugqOuQnCDtg4DsnoUg7LK07YK5XFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIENyYWZ0QmVlciB7XFxyXFxuICBicmFuZD86IHN0cmluZztcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gYnJld0JlZXIoYmVlcjogQ3JhZnRCZWVyKSB7XFxyXFxuICAvLyAuLlxcclxcbn1cXHJcXG5icmV3QmVlcih7IGJyYW5kb246ICd3aGF0JyB9KTsgLy8g7IaN7ISx7J20IOuLpOultOuLiCDsl5Drn6zrnLnri4jri6QuXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J2065+s66m0IO2DgOyehSDssrTtgazrpbwg66y07Iuc7ZWc64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBteUJlZXIgPSB7IGJyYW5kb246ICd3aGF0JyB9JztcXHJcXG5icmV3QmVlcihteUJlZXIgYXMgQ3JhZnRCZWVyKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7ZWo7IiYIO2DgOyehVxcclxcblxcclxcbu2VqOyImCDrp6TqsJzrs4DsiJjsmYAg67CY7ZmY7YOA7J6F64+EIOyduO2EsO2OmOydtOyKpCDsoJXsnZjqsIAg6rCA64ql7ZWY64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBsb2dpbiB7XFxyXFxuICAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW47XFxyXFxufVxcclxcblxcclxcbmxldCBsb2dpblVzZXI6IGxvZ2luOyAvLyDtlajsiJgg7KCA7J6l7ZWgIOuzgOyImCDshKDslrhcXHJcXG5sb2dpblVzZXIgPSBmdW5jdGlvbihpZDogc3RyaW5nLCBwdzogc3RyaW5nKSB7XFxyXFxuICBjb25zb2xlLmxvZygn66Gc6re47J24IO2WiOyKteuLiOuLpCcpO1xcclxcbiAgcmV0dXJuIHRydWU7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbu2BtOuemOyKpCDtg4DsnoVcXHJcXG5cXHJcXG7snpDrsJTsnZgg7J247YSw7Y6Y7J207Iqk7JmAIOuqqeyggeydtCDruYTsirftlZzrjbBcXHJcXG5cXHJcXG7slrTrlqQg7J247YSw7Y6Y7J207Iqk66W8IGltcGxlbWVudHPtlZwg7YG0656Y7Iqk6rCAIOyeiOuLpOuptFxcclxcblxcclxcbuyduO2EsO2OmOydtOyKpOydmCDrqZTshozrk5zsmYAg67OA7IiY6rCAIOyeiOuLpOuKlCDqsoPsnYQg67O07J6l7ZWc64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBDcmFmdEJlZXIge1xcclxcbiAgYmVlck5hbWU6IHN0cmluZztcXHJcXG4gIG5hbWVCZWVyKGJlZXI6IHN0cmluZyk6IHZvaWQ7XFxyXFxufVxcclxcblxcclxcbmNsYXNzIG15QmVlciBpbXBsZW1lbnRzIENyYWZ0QmVlciB7XFxyXFxuICBiZWVyTmFtZTogc3RyaW5nID0gJ0JhYnkgR3Vpbm5lc3MnO1xcclxcbiAgbmFtZUJlZXIoYjogc3RyaW5nKSB7XFxyXFxuICAgIHRoaXMuYmVlck5hbWUgPSBiO1xcclxcbiAgfVxcclxcbiAgY29uc3RydWN0b3IoKSB7fVxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7snbjthLDtjpjsnbTsiqQg64G866asIOyDgeyGjeuPhCDqsIDriqXtlanri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIFBlcnNvbiB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxufVxcclxcbmludGVyZmFjZSBEcmlua2VyIHtcXHJcXG4gIGRyaW5rOiBzdHJpbmc7XFxyXFxufVxcclxcbmludGVyZmFjZSBEZXZlbG9wZXIgZXh0ZW5kcyBQZXJzb24ge1xcclxcbiAgc2tpbGw6IHN0cmluZztcXHJcXG59XFxyXFxubGV0IGZlID0ge30gYXMgRGV2ZWxvcGVyO1xcclxcbmZlLm5hbWUgPSAnam9zaCc7XFxyXFxuZmUuc2tpbGwgPSAnVHlwZVNjcmlwdCc7XFxyXFxuZmUuZHJpbmsgPSAnQmVlcic7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgNC4gRW51bVxcclxcblxcclxcbj4g7Yq57KCVIOqwkuuTpOydmCAqKuynke2VqSoq7J2EIOydmOuvuO2VmOuKlCDsnpDro4ztmJXsnLzroZwg7YGs6rKMIHvsiKvsnpDtmJUg7J2064SYLCDrrLjsnpDtmJUg7J2064SYfSDrkZAg6rCA7KeA6rCAIOyeiOuLpFxcclxcblxcclxcbi0gRW51beydtOudvOuKlCDqsJzrhZDsnYQg7J207ZW07ZWY6riwIOyWtOugpOyboOuNmCDsnbTsnKDripQsIGphdmFzY3JpcHTsl5DripQgZW51beydtCDsl4bsl4jquLAg65WM66y47J2064ukLiAo7ZWY7KeA66eMIOqygOyDie2VtOuztOuLiCBD7Ja47Ja07JeQ7ISc64qUIOygnOqzte2VmOuKlCDqsoMg6rCZ7J2MLilcXHJcXG5cXHJcXG4jIyMgNC0xLiDsiKvsnpDtmJUg7J2064SYXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBEaXJlY3Rpb24ge1xcclxcbiAgVXAgPSAxLFxcclxcbiAgRG93bixcXHJcXG4gIExlZnQsXFxyXFxuICBSaWdodFxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7tirnsnbTtlZwg6rKD7J2AIOydtOugh+qyjCDshKDslrjtlZjrqbQgIOyWkeuwqe2WpeycvOuhnCDtmLjstpztlaAg7IiYIOyeiOuKlCDtirnsnbTtlZwg7J6Q66OM6rWs7KGw6rCAIOuQnOuLpOuKlCDqsoPsnbTri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuY29uc29sZS5sb2coRGlyZWN0aW9uWzFdKSAgICAvLyBcXFwiVXBcXFwiXFxyXFxuY29uc29sZS5sb2coRGlyZWN0aW9uW1xcXCJVcFxcXCJdKSAvLyAxXFxyXFxuY29uc29sZS5sb2coRGlyZWN0aW9uWzNdKSAgICAvLyBcXFwiTGVmdFxcXCJcXHJcXG5gYGBcXHJcXG5cXHJcXG7snbTsmYAg6rCZ7J20IOyIq+yekO2YlSBFbnVt7JeQ7IScIERpcmVjdGlvbi5VcCDsnLzroZwgMeqwkuydhCDslrvqsbDrgpgg67CY64yA66GcIERpcmVjdGlvblsxXeuhnCBcXFwiVXBcXFwi6rCS7J2EIOyWu+uKlCDqsoPsnYQgKipg66as67KE7IqkIOunpO2VkWAqKiDsnbTrnbzqs6Ag7ZWc64ukLlxcclxcblxcclxcbuydtOugh+qyjCDstIjquLDqsJLsnYQg7ISg7Ja47ZW07KO866m0IDEsIDIsIDMsIDQg7J2YIOyInOyEnOuhnCAx7JSpIOymneqwgO2VmOupsCDtlaDri7nrkJzri6QuIOunjOyVvSxcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIERpcmVjdGlvbiB7XFxyXFxuXFx0VXAsIFxcclxcblxcdERvd24sXFxyXFxuXFx0TGVmdCxcXHJcXG5cXHRSaWdodFxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7snLzroZwg7ISg7Ja465CY7JeI64uk66m0IFVwIC0gMCAsIERvd24gLSAxLCBMZWZ0IC0gMiwgUmlnaHQgLSAz7J20IOuQnOuLpC5cXHJcXG5cXHJcXG4jIyMgNC0yIOyIq+yekO2YlSBlbnVtIOyCrOyaqVxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gUmVzcG9uc2Uge1xcclxcbiAgTm8gPSAwLFxcclxcbiAgWWVzID0gMSxcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gcmVzcG9uZChyZWNpcGllbnQ6IHN0cmluZywgbWVzc2FnZTogUmVzcG9uc2UpOiB2b2lkIHtcXHJcXG4gIGNvbnNvbGUubG9nKHJlY2lwaWVudCwgbWVzc2FnZSlcXHJcXG59XFxyXFxuXFxyXFxucmVzcG9uZChcXFwiQ2FwdGFpbiBQYW5neW9cXFwiLCBSZXNwb25zZS5ZZXMpO1xcclxcblxcclxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxyXFxuW0xPR106IFxcXCJDYXB0YWluIFBhbmd5b1xcXCIsICAxXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDQtMy4g66y47J6Q7ZiVIGVudW1cXHJcXG5cXHJcXG4+IOusuOyekO2YlSDsnbTrhJjsnYAg7J2064SYIOqwkiDsoITrtoAg64ukIO2KueyglSDrrLjsnpAg65iQ64qUIOuLpOuluCDsnbTrhJgg6rCS7Jy866GcIOy0iOq4sO2ZlCDtlbTspJjslbwg7ZWp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gRGlyZWN0aW9uIHtcXHJcXG4gICAgVXAgPSBcXFwiVVBcXFwiLFxcclxcbiAgICBEb3duID0gXFxcIkRPV05cXFwiLFxcclxcbiAgICBMZWZ0ID0gXFxcIkxFRlRcXFwiLFxcclxcbiAgICBSaWdodCA9IFxcXCJSSUdIVFxcXCIsXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbioqIOuzte2VqSBlbnVtcyAqKlxcclxcblxcclxcbuusuOyekOyZgCDsiKvsnpDrpbwg7Zi87ZWp7ZWY7JesIGVudW3snYQg7IOd7ISx7ZWgIOyImCDsnojsnLzrgpgsIOq2jOyepe2VmOyngCDslYrripQg67Cp7IudIVxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gQm9vbGVhbkxpa2VIZXRlcm9nZW5lb3VzRW51bSB7XFxyXFxuICAgIE5vID0gMCxcXHJcXG4gICAgWWVzID0gXFxcIllFU1xcXCIsXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiMjIyA0LTQuIOufsO2DgOyehCDsi5zsoJDsl5DshJzsnZgg7J2064SYIO2KueynlVxcclxcblxcclxcbuydtOuEmOydgCDrn7Dtg4DsnoTsi5zsl5Ag7Iuk7KCcIOqwneyytCDtmJXtg5zroZwg7KG07J6s7ZWp64uI64ukLiDsmIjrpbwg65Ok7Ja0IOyVhOuemOyZgCDqsJnsnYAg7J2064SYIOy9lOuTnOqwgCDsnojsnYQg65WMXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBFIHtcXHJcXG4gIFgsIFksIFpcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZ2V0WChvYmo6IHsgWDogbnVtYmVyIH0pIHtcXHJcXG4gIHJldHVybiBvYmouWDtcXHJcXG59XFxyXFxuZ2V0WChFKTsgLy8g7J2064SYIEXsnZggWOuKlCDsiKvsnpDsnbTquLAg65WM66y47JeQIOygleyDgSDrj5nsnpFcXHJcXG4tLS0tLVxcclxcblF1aXouIFxcclxcbmdldFgoRSnqsJLsnYQg67OA7IiY7JeQIOuEo+yWtOyEnCDstpzroKXtlZzri6TrqbQsIOyWvOuniOuCmCDrgpjsmKzquYw/XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDQtNS4g7Lu07YyM7J28IOyLnOygkOyXkOyEnOydmCDsnbTrhJgg7Yq57KeVXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBMb2dMZXZlbCB7XFxyXFxuICBFUlJPUiwgV0FSTiwgSU5GTywgREVCVUdcXHJcXG59XFxyXFxuXFxyXFxuLy8gJ0VSUk9SJyB8ICdXQVJOJyB8ICdJTkZPJyB8ICdERUJVRyc7XFxyXFxudHlwZSBMb2dMZXZlbFN0cmluZ3MgPSBrZXlvZiB0eXBlb2YgTG9nTGV2ZWw7XFxyXFxuXFxyXFxuZnVuY3Rpb24gcHJpbnRJbXBvcnRhbnQoa2V5OiBMb2dMZXZlbFN0cmluZ3MsIG1lc3NhZ2U6IHN0cmluZykge1xcclxcbiAgICBjb25zdCBudW0gPSBMb2dMZXZlbFtrZXldO1xcclxcbiAgICBpZiAobnVtIDw9IExvZ0xldmVsLldBUk4pIHtcXHJcXG4gICAgICAgY29uc29sZS5sb2coJ0xvZyBsZXZlbCBrZXkgaXM6ICcsIGtleSk7XFxyXFxuICAgICAgIGNvbnNvbGUubG9nKCdMb2cgbGV2ZWwgdmFsdWUgaXM6ICcsIG51bSk7XFxyXFxuICAgICAgIGNvbnNvbGUubG9nKCdMb2cgbGV2ZWwgbWVzc2FnZSBpczogJywgbWVzc2FnZSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxucHJpbnRJbXBvcnRhbnQoJ0VSUk9SJywgJ1RoaXMgaXMgYSBtZXNzYWdlJyk7XFxyXFxuXFxyXFxuLS0tLS0tLVxcclxcbltMT0ddOiBcXFwiTG9nIGxldmVsIGtleSBpczogXFxcIiwgIFxcXCJFUlJPUlxcXCIgXFxyXFxuW0xPR106IFxcXCJMb2cgbGV2ZWwgdmFsdWUgaXM6IFxcXCIsICAwIFxcclxcbltMT0ddOiBcXFwiTG9nIGxldmVsIG1lc3NhZ2UgaXM6IFxcXCIsICBcXFwiVGhpcyBpcyBhIG1lc3NhZ2VcXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDQtNi4gVHlwZXNjcmlwdCBlbnVt7J2EIOyCrOyaqe2VmOuKlCDsnbTsnKBcXHJcXG5cXHJcXG5FbnVt7J2AIOy2lOyDge2ZlOydmCDsiJjri6jsnbTri6QuXFxyXFxuXFxyXFxu64uk6rWt7Ja0IOy9lOuTnCAoTGFuZ3VhZ2UgQ29kZSnrpbwg7ZWg64u57ZWc64uk6rOgIOyDneqwge2VtOuztOyekFxcclxcblxcclxcbmBgYHRzeFxcclxcbnR5cGUgTGFuZ3VhZ2VDb2RlID0gJ2tvJyB8ICdlbicgfCAnamEnIHwgJ3poJyB8ICdlcydcXHJcXG5cXHJcXG5jb25zdCBjb2RlOiBMYW5ndWFnZUNvZGUgPSAna28nXFxyXFxuXFxyXFxuY29uc29sZS5sb2coY29kZSkgLy8gW0xPR106IFxcXCJrb1xcXCJcXHJcXG5cXHJcXG7tlZjsp4Drp4wgXFxyXFxuY29zdCBjb2RlOiBMYW5ndWFnZUNvZGUgPSAnaGFoYWhhaGEnXFxyXFxu7JmAIOqwmeydtCDsvZTrk5zrpbwg7Kec66m0IHR5cGVzY3JpcHTsl5DshJwg7JeQ65+s66GcIO2RnOyLnO2VtOykgOuLpC5cXHJcXG5gYGBcXHJcXG5cXHJcXG7snbTqsoPrj4Qg7KKL7KeA66eMIOuNsOydtO2EsCDslpHsnbQg66eO7JWE7KeA66m0IOqwgOuPheyEseydtCDrp47snbQg65ao7Ja07KeE64ukLlxcclxcblxcclxcbuyasOumrOqwgCDsm5DtlZjripQg6rKD7J2AIGtvcmVhbuydhCDqsoDsg4ntlZjrqbQgJ2tvJ+udvOuKlCDsvZTrk5zqsIAg64KY7JmU7Jy866m0IO2VmOuKlCDqsoPsnbTqs6Ag6riw7KG0IOuwqeyLneycvOuhnOuKlCDri6TsnYzqs7wg6rCZ7J20IOuRkCDqsIDsp4Ag67Cp67KV7J20IOyeiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG4vLyDsnbTroIfqsowg7ZWY66m0IOyWuOyWtCDsvZTrk5zqsIAg7JyE7JWE656Y7JeQIOykkeuzteuQmOqzoFxcclxcbmNvbnN0IGtvcmVhbiA9ICdrbydcXHJcXG5jb25zdCBlbmdsaXNoID0gJ2VuJ1xcclxcbmNvbnN0IGphcGFuZXNlID0gJ2phJ1xcclxcbmNvbnN0IGNoaW5lc2UgPSAnemgnXFxyXFxuY29uc3Qgc3BhbmlzaCA9ICdlcydcXHJcXG50eXBlIExhbmd1YWdlQ29kZSA9ICdrbycgfCAnZW4nIHwgJ2phJyB8ICd6aCcgfCAnZXMnXFxyXFxubGV0IGNvZGU6IExhbmd1YWdlQ29kZSA9IGVuZ2xpc2hcXHJcXG5jb25zb2xlLmxvZyhjb2RlKSAvLyBcXFwiZW5cXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuLy8g7J2066CH6rKMIO2VmOuptCDsvZTrk5zqsIAg64SI66y0IOq4uOyWtOynkeuLiOuLpFxcclxcbmNvbnN0IGtvcmVhbiA9ICdrbydcXHJcXG5jb25zdCBlbmdsaXNoID0gJ2VuJ1xcclxcbmNvbnN0IGphcGFuZXNlID0gJ2phJ1xcclxcbmNvbnN0IGNoaW5lc2UgPSAnemgnXFxyXFxuY29uc3Qgc3BhbmlzaCA9ICdlcydcXHJcXG50eXBlIExhbmd1YWdlQ29kZSA9IHR5cGVvZiBrb3JlYW4gfCB0eXBlb2YgZW5nbGlzaCB8IHR5cGVvZiBqYXBhbmVzZSB8IHR5cGVvZiBjaGluZXNlIHwgdHlwZW9mIHNwYW5pc2hcXHJcXG5sZXQgY29kZTogTGFuZ3VhZ2VDb2RlID0gc3BhbmlzaFxcclxcbmNvbnNvbGUubG9nKGNvZGUpIC8vIFxcXCJlc1xcXCJcXHJcXG5gYGBcXHJcXG5cXHJcXG7snbTrn6ztlZwg7J207JygIOuVjOusuOyXkCDrpqzthLDrn7TsnZgg7YOA7J6F6rO8IOqwkuyXkCDsnbTrpoTsnYQg67aZ7J24IGBlbnVtYOydhCDtmZzsmqntlZjrqbQg6rCA64+F7ISx7J2EIO2BrOqyjCDrhpLsnbwg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIExhbmd1YWdlQ29kZSB7XFxyXFxuICBrb3JlYW4gPSAna28nLFxcclxcbiAgZW5nbGlzaCA9ICdlbicsXFxyXFxuICBqYXBhbmVzZSA9ICdqYScsXFxyXFxuICBjaGluZXNlID0gJ3poJyxcXHJcXG4gIHNwYW5pc2ggPSAnZXMnLFxcclxcbn1cXHJcXG4vLyDsl6zquLDshJwgXFxyXFxuLy8gTGFuZ3VhZ2VDb2RlLmtvcmVhbiA9PT0gJ2tvJ1xcclxcbi8vICjsnZjrr7jsg4EpIExhbmd1YWdlQ29kZSA9PT0gJ2tvJyB8ICdlbicgfCAnamEnIHwgJ3poJyB8ICdlcydcXHJcXG5jb25zdCBjb2RlOiBMYW5ndWFnZUNvZGUgPSBMYW5ndWFnZUNvZGUua29yZWFuXFxyXFxuY29uc29sZS5sb2coY29kZSkgLy8gXFxcImtvXFxcIlxcclxcbmBgYFxcclxcblxcclxcbiMjIyA0LTcuIFR5cGVzY3JpcHQgZW51beydhCDsgqzsmqntlZjsp4Ag7JWK64qUIOydtOycoFxcclxcblxcclxcbiMjIyBUcmVlLXNoYWtpbmfsnYAg66y07JeH7J246rCA7JqUP1xcclxcblxcclxcblRyZWUtc2hha2luZ+ydtOuegCDqsITri6jtlZjqsowg66eQ7ZW0IOyCrOyaqe2VmOyngCDslYrripQg7L2U65Oc66W8IOyCreygnO2VmOuKlCDquLDriqXsnYQg66eQ7ZWp64uI64ukLiDrgpjrrLTrpbwg7Z2U65Ok66m0IOyjveydgCDsno7sgqzqt4Drk6TsnbQg65ao7Ja07KeA64qUIOuqqOyKteyXkCDssKnslYjtlbQgVHJlZS1zaGFraW5n7J2065286rOgIOu2gOumheuLiOuLpC4gVHJlZS1zaGFraW5n7J2EIO2Gte2VtCBleHBvcnTtlojsp4Drp4wg7JWE66y0IOuNsOyEnOuPhCBpbXBvcnTtlZjsp4Ag7JWK7J2AIOuqqOuTiOydtOuCmCDsgqzsmqntlZjsp4Ag7JWK64qUIOy9lOuTnOulvCDsgq3soJztlbTshJwg67KI65OkIO2BrOq4sOulvCDspITsl6wg7Y6Y7J207KeA6rCAIO2RnOyLnOuQmOuKlCDsi5zqsITsnYQg64uo7LaV7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu7ZWY7KeA66eMIGVudW3snYQg7IKs7Jqp7ZWY6rKMIOuQmOuptCBUcmVlLXNoYWtpbmfsnbQg65CY7KeAIOyViuyKteuLiOuLpC5cXHJcXG5cXHJcXG7qsrDroaDsoIHsnLzroZwgIFRyZWUtc2hha2luZyDqtIDsoJDsl5DshJwg67O07JWY7J2EIOuVjCDslYTrnpjsmYAg6rCZ7J2AIOyInOyEnOuhnCDsgqzsmqntlZjsi5zquLgg7LaU7LKc7ZWY66mwIOq4gOydhCDrp4jsuZjqsqDsirXri4jri6QuXFxyXFxuXFxyXFxuPiBVbmlvbiBUeXBlcyA+IGNvbnN0IGVudW0gPiBlbnVtXFxyXFxuXFxyXFxuKirsoJXrpqwqKlxcclxcblxcclxcbi0g6rCZ7J2AIOKAmOyiheulmOKAmeulvCDrgpjtg4DrgrTripQg7Jes65+sIOqwnOydmCDsiKvsnpAg7Zi57J2AIOusuOyekOyXtOydhCDri6TrpITslbwg7ZWY64qU642wLCBcXHJcXG7qsIHqsIEg7KCB64u57ZWcIOydtOumhOydhCDrtpnsl6zshJwg7L2U65Oc7J2YIOqwgOuPheyEseydhCDrhpLsnbTqs6Ag7Iu264uk66m0IGVudW3snYQg7IKs7JqpIVxcclxcblxcclxcbiMjIDUuIOyXsOyCsOyekOulvCDsnbTsmqntlZwg7YOA7J6FIOygleydmFxcclxcblxcclxcbiMjIyA1LTEuIFVuaW9uIFR5cGUgKCB8IClcXHJcXG5cXHJcXG7snKDri4jsmKgg7YOA7J6FKFVuaW9uIFR5cGUp7J20656AIOyekOuwlOyKpO2BrOumve2KuOydmCBPUiDsl7DsgrDsnpAofHwp7JmAIOqwmeydtCBB7J206rGw64KYIELsnbTri6Qg652864qUIOydmOuvuOydmCDtg4DsnoVcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBsb2dUZXh0KHRleHQ6IHN0cmluZyB8IG51bWJlcikge1xcclxcbiAgLy8gLi4uXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbi0gdGV4dOuKlCBzdHJpbmfsnbTqsbDrgpggKE9SIHx8ICkgbnVtYmVy7J2064ukLiDspoksIOuRmCDri6Qg7JisIOyImCDsnojri6TripQg65y7Llxcclxcbi0g7J207LKY65+8IGB8YCDsl7DsgrDsnpDrpbwg7J207Jqp7ZWY7JesIO2DgOyeheydhCDsl6zrn6wg6rCcIOyXsOqysO2VmOuKlCDrsKnsi53snYQgYOycoOuLiOyYqCDtg4DsnoUg7KCV7J2YIOuwqeyLnWAg7J206528IOu2gOuluOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBnZXRBZ2UoYWdlOiBudW1iZXIgfCBzdHJpbmcpIHtcXHJcXG4gIGlmICh0eXBlb2YgYWdlID09PSAnbnVtYmVyJykge1xcclxcbiAgICBhZ2UudG9GaXhlZCgpOyAvLyDsoJXsg4Eg64+Z7J6RLCBhZ2XsnZgg7YOA7J6F7J20IGBudW1iZXJg66GcIOy2lOuhoOuQmOq4sCDrlYzrrLjsl5Ag7Iir7J6QIOq0gOugqOuQnCBBUEnrpbwg7Im96rKMIOyekOuPmeyZhOyEsSDtlaAg7IiYIOyeiOuLpC5cXHJcXG4gICAgcmV0dXJuIGFnZTtcXHJcXG4gIH1cXHJcXG4gIGlmICh0eXBlb2YgYWdlID09PSAnc3RyaW5nJykge1xcclxcbiAgICByZXR1cm4gYWdlO1xcclxcbiAgfVxcclxcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ2FnZSBtdXN0IGJlIG51bWJlciBvciBzdHJpbmcnKTtcXHJcXG59XFxyXFxuY29uc29sZS5sb2coZ2V0QWdlKDEwKSlcXHJcXG5jb25zb2xlLmxvZyhnZXRBZ2UoJ0hlbGxvIFdvcmxkJykpXFxyXFxuY29uc29sZS5sb2coZ2V0QWdlKHRydWUpKVxcclxcbi0tLSDstpzroKUgLS0tXFxyXFxuW0xPR106IDEwIFxcclxcbltMT0ddOiBcXFwiSGVsbG8gV29ybGRcXFwiIFxcclxcbltMT0ddOiBhZ2UgbXVzdCBiZSBudW1iZXIgb3Igc3RyaW5nXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDUtMi4gSW50ZXJzZWN0aW9uIFR5cGUgKCAmIClcXHJcXG5cXHJcXG7sl6zrn6wg7YOA7J6F7J2EIOuqqOuRkCDrp4zsobHtlZjripQg7ZWY64KY7J2YIO2DgOyeheydhCDsnZjrr7guXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIFBlcnNvbiB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBhZ2U6IG51bWJlcjtcXHJcXG59XFxyXFxuaW50ZXJmYWNlIERldmVsb3BlciB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBza2lsbDogbnVtYmVyO1xcclxcbn1cXHJcXG50eXBlIENhcHQgPSBQZXJzb24gJiBEZXZlbG9wZXI7XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuLy8gQ2FwdOydmCDtg4DsnoXsnYBcXHJcXG5cXHJcXG57XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBhZ2U6IG51bWJlcjtcXHJcXG4gIHNraWxsOiBzdHJpbmc7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiFbSW50ZXJzZWN0aW9uIFR5cGVdKGh0dHBzOi8vam9zaHVhMTk4OC5naXRodWIuaW8vdHMvYXNzZXRzL2ltZy9pbnRlcnNlY3Rpb24tZGlhZ3JhbS4wMWY0ZmRmZS5wbmcpXFxyXFxuXFxyXFxuIyMjIDUtMy4gVW5pb24gVHlwZeydhCDsk7gg65WMIOyjvOydmO2VoCDsoJBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgUGVyc29uIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIGFnZTogbnVtYmVyO1xcclxcbn1cXHJcXG5pbnRlcmZhY2UgRGV2ZWxvcGVyIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIHNraWxsOiBzdHJpbmc7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGludHJvZHVjZShzb21lb25lOiBQZXJzb24gfCBEZXZlbG9wZXIpIHtcXHJcXG4gIHNvbWVvbmUubmFtZTsgLy8gTyDsoJXsg4Eg64+Z7J6RXFxyXFxuICBzb21lb25lLmFnZTsgLy8gWCDtg4DsnoUg7Jik66WYIC0+IO2DgOyeheyKpO2BrOumve2KuOyXkOyEnCDruajqsITspITroZwg7ZGc7Iuc7ZW07KSMXFxyXFxuICBzb21lb25lLnNraWxsOyAvLyBYIO2DgOyehSDsmKTrpZggLT4g7YOA7J6F7Iqk7YGs66a97Yq47JeQ7IScIOu5qOqwhOykhOuhnCDtkZzsi5ztlbTspIxcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu7Jyg64uI7JioIO2DgOyeheydgCBB64+EIOuQoCDsiJgg7J6I6rOgIELrj4Qg65CgIOyImCDsnojripQg7YOA7J6F7J207KeA65286rOgIOyDneqwge2VmOuptCDtjIzrnbzrr7jthLDsnZgg7YOA7J6F7J20IFBlcnNvbuuPhCDrkJjqs6AgRGV2ZWxvcGVy64+EIOuQoO2FjOuLiOq5jCDtlajsiJgg7JWI7JeQ7IScIOuLueyXsO2eiCDsnbQg7J247YSw7Y6Y7J207Iqk65Ok7J20IOygnOqzte2VmOuKlCDsho3shLHrk6TsnbggYWdl64KYIHNraWxs66W8IOyCrOyaqe2VoCDsiJgg7J6I6rKg7KeA65286rOgIOyDneqwge2VoCDsiJgg7J6I7Iq164uI64ukLiBcXHJcXG5cXHJcXG7tlZjsp4Drp4wsIO2DgOyeheyKpO2BrOumve2KuCDqtIDsoJDsl5DshJzripQgaW50cm9kdWNlKCkg7ZWo7IiY66W8IO2YuOy2nO2VmOuKlCDsi5zsoJDsl5AgUGVyc29uIO2DgOyeheydtCDsmKzsp4AgRGV2ZWxvcGVyIO2DgOyeheydtCDsmKzsp4Ag7JWMIOyImOqwgCDsl4bquLAg65WM66y47JeQIOyWtOuKkCDtg4DsnoXsnbQg65Ok7Ja07Jik65OgIOqwhOyXkCDsmKTrpZjqsIAg7JWIIOuCmOuKlCDrsKntlqXsnLzroZwg7YOA7J6F7J2EIOy2lOuhoO2VmOqyjCDrkKnri4jri6QuXFxyXFxuXFxyXFxu65Sw65287IScIOychOydmCDsmIjsi5wg6rCZ7J2AIOqyveyasOyXkOuKlCDsnZjrj4TsmYDripQg64us66asIFtzb21lb25lLm5hbWVdKGh0dHA6Ly9zb21lb25lLm5hbWUpIOunjCDsoJXsg4HsoIHsnLzroZwg7J6R64+Z7ZWY6rKMIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG4jIyA2LiBDbGFzc1xcclxcblxcclxcbiMjIyA2LTEuIFJlYWRvbmx5XFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuY2xhc3MgRGV2ZWxvcGVyIHtcXHJcXG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xcclxcbiAgICBjb25zdHJ1Y3Rvcih0aGVOYW1lOiBzdHJpbmcpIHtcXHJcXG4gICAgICAgIHRoaXMubmFtZSA9IHRoZU5hbWU7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxubGV0IGpvaG4gPSBuZXcgRGV2ZWxvcGVyKFxcXCJKb2huXFxcIik7XFxyXFxuam9obi5uYW1lID0gXFxcIkpvaG5cXFwiOyAvLyBlcnJvciEgbmFtZSBpcyByZWFkb25seS5cXHJcXG5jb25zb2xlLmxvZyhqb2huKVxcclxcbi0tLSDstpzroKUgLS0tXFxyXFxuW0xPR106IERldmVsb3Blcjoge1xcclxcbiAgXFxcIm5hbWVcXFwiOiBcXFwiSm9oblxcXCJcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDYtMi4gQWNjZXNzb3JcXHJcXG5cXHJcXG7tg4DsnoXsiqTtgazrpr3tirjripQg6rCd7LK07J2YIO2KueyglSDsho3shLHsnZgg7KCR6re86rO8IO2VoOuLueyXkCDrjIDtlbQg7KCc7Ja07ZWgIOyImCDsnojsirXri4jri6QuIOydtOulvCDsnITtlbTshKAg7ZW064u5IOqwneyytOqwgCDtgbTrnpjsiqTroZwg7IOd7ISx7ZWcIOqwneyytOyXrOyVvCDtlanri4jri6QuIOyVhOuemOydmCDqsITri6jtlZwg7JiI7KCc66W8IOu0heyLnOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5jbGFzcyBEZXZlbG9wZXIge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbn1cXHJcXG5jb25zdCBqb3NoID0gbmV3IERldmVsb3BlcigpO1xcclxcbmpvc2gubmFtZSA9ICdKb3NoIEJvbHRvbic7XFxyXFxuYGBgXFxyXFxuXFxyXFxu7JyEIOy9lOuTnOuKlCDtgbTrnpjsiqTroZwg7IOd7ISx7ZWcIOqwneyytOydmCBgbmFtZWAg7IaN7ISx7JeQIGBKb3NoIEJvbHRvbmDsnbTrnbzripQg6rCS7J2EIOuMgOyehe2VnCDsvZTrk5zsnoXri4jri6QuIOydtOygnCBgam9zaGDrnbzripQg6rCd7LK07J2YIGBuYW1lYCDsho3shLHsnYAgYEpvc2ggQm9sdG9uYOydtOudvOuKlCDqsJLsnYQg6rCW6rKg7KOgLlxcclxcblxcclxcbuyXrOq4sOyEnCDrp4zslb0gYG5hbWVgIOyGjeyEseyXkCDsoJzslb0g7IKs7ZWt7J2EIOy2lOqwgO2VmOqzoCDsi7bri6TrqbQg7JWE656Y7JmAIOqwmeydtCBgZ2V0YOqzvCBgc2V0YOydhCDtmZzsmqntlanri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuY2xhc3MgRGV2ZWxvcGVyIHtcXHJcXG4gIHByaXZhdGUgbmFtZTogc3RyaW5nO1xcclxcbiAgXFxyXFxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xcclxcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xcclxcbiAgfVxcclxcblxcclxcbiAgc2V0IG5hbWUobmV3VmFsdWU6IHN0cmluZykge1xcclxcbiAgICBpZiAobmV3VmFsdWUgJiYgbmV3VmFsdWUubGVuZ3RoID4gNSkge1xcclxcbiAgICAgIHRocm93IG5ldyBFcnJvcign7J2066aE7J20IOuEiOustCDquYHri4jri6QnKTtcXHJcXG4gICAgfVxcclxcbiAgICB0aGlzLm5hbWUgPSBuZXdWYWx1ZTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuY29uc3Qgam9zaCA9IG5ldyBEZXZlbG9wZXIoKTtcXHJcXG5qb3NoLm5hbWUgPSAnSm9zaCBCb2x0b24nOyAvLyBFcnJvclxcclxcbmpvc2gubmFtZSA9ICdKb3NoJztcXHJcXG5gYGBcXHJcXG5cXHJcXG5USVAhXFxyXFxuZ2V066eMIOyEoOyWuO2VmOqzoCBzZXTsnYQg7ISg7Ja47ZWY7KeAIOyViuuKlCDqsr3smrDsl5DripQg7J6Q64+Z7Jy866GcIHJlYWRvbmx566GcIOyduOyLneuQqeuLiOuLpC5cXHJcXG5cXHJcXG4jIyMgNi0zLiBBYnN0cmFjdCBDbGFzc1xcclxcblxcclxcbuy2lOyDgSDtgbTrnpjsiqQoQWJzdHJhY3QgQ2xhc3Mp64qUIOyduO2EsO2OmOydtOyKpOyZgCDruYTsirftlZwg7Jet7ZWg7J2EIO2VmOuptOyEnOuPhCDsobDquIgg64uk66W4IO2KueynleydhCDqsJbqs6Ag7J6I7Iq164uI64ukLiDstpTsg4Eg7YG0656Y7Iqk64qUIO2KueyglSDtgbTrnpjsiqTsnZgg7IOB7IaNIOuMgOyDgeydtCDrkJjripQg7YG0656Y7Iqk7J2066mwIOyigCDrjZQg7IOB7JyEIOugiOuyqOyXkOyEnCDsho3shLEsIOuplOyEnOuTnOydmCDrqqjslpHsnYQg7KCV7J2Y7ZWp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmFic3RyYWN0IGNsYXNzIERldmVsb3BlciB7XFxyXFxuICBhYnN0cmFjdCBjb2RpbmcoKTogdm9pZDsgLy8gJ2Fic3RyYWN0J+qwgCDrtpnsnLzrqbQg7IOB7IaNIOuwm+ydgCDtgbTrnpjsiqTsl5DshJwg66y07KGw6rG0IOq1rO2YhO2VtOyVvCDtlahcXHJcXG4gIGRyaW5rKCk6IHZvaWQge1xcclxcbiAgICBjb25zb2xlLmxvZygnZHJpbmsgc3RoJyk7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbmNsYXNzIEZyb250RW5kRGV2ZWxvcGVyIGV4dGVuZHMgRGV2ZWxvcGVyIHtcXHJcXG4gIGNvZGluZygpOiB2b2lkIHtcXHJcXG4gICAgLy8gRGV2ZWxvcGVyIO2BtOuemOyKpOulvCDsg4Hsho0g67Cb7J2AIO2BtOuemOyKpOyXkOyEnCDrrLTsobDqsbQg7KCV7J2Y7ZW07JW8IO2VmOuKlCDrqZTshJzrk5xcXHJcXG4gICAgY29uc29sZS5sb2coJ2RldmVsb3Agd2ViJyk7XFxyXFxuICB9XFxyXFxuICBkZXNpZ24oKTogdm9pZCB7XFxyXFxuICAgIGNvbnNvbGUubG9nKCdkZXNpZ24gd2ViJyk7XFxyXFxuICB9XFxyXFxufVxcclxcbmNvbnN0IGRldiA9IG5ldyBEZXZlbG9wZXIoKTsgLy8gZXJyb3I6IGNhbm5vdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gYWJzdHJhY3QgY2xhc3NcXHJcXG5jb25zdCBqb3NoID0gbmV3IEZyb250RW5kRGV2ZWxvcGVyKCk7XFxyXFxuam9zaC5jb2RpbmcoKTsgLy8gZGV2ZWxvcCB3ZWJcXHJcXG5qb3NoLmRyaW5rKCk7IC8vIGRyaW5rIHN0aFxcclxcbmpvc2guZGVzaWduKCk7IC8vIGRlc2lnbiB3ZWJcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5SZWZlcmVuY2VzXFxyXFxuaHR0cHM6Ly9qb3NodWExOTg4LmdpdGh1Yi5pby90cy9cXHJcXG5cXHJcXG5bVHlwZVNjcmlwdCBlbnVt7J2EIOyCrOyaqe2VmOuKlCDsnbTsnKBdKGh0dHBzOi8vbWVkaXVtLmNvbS9Ac2V1bmdoYV9raW1fSVQvdHlwZXNjcmlwdC1lbnVt7J2ELeyCrOyaqe2VmOuKlC3snbTsnKAtM2IzY2NkOGU1NTUyKVxcclxcblxcclxcbltUeXBlU2NyaXB0IGVudW3snYQg7IKs7Jqp7ZWY7KeAIOyViuuKlCDqsowg7KKL7J2AIOydtOycoF0oaHR0cHM6Ly9lbmdpbmVlcmluZy5saW5lY29ycC5jb20va28vYmxvZy90eXBlc2NyaXB0LWVudW0tdHJlZS1zaGFraW5nLylcXHJcXG5cXHJcXG5bQ+yWuOyWtCBFbnVtXShodHRwczovL2RvamFuZy5pby9tb2QvcGFnZS92aWV3LnBocD9pZD00ODApXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==