self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md":
/*!*************************************************************************!*\
  !*** ./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Typescript 시작하기\"\r\ndate: \"2021.04.14\"\r\ntags: \r\n  - typescript\r\n  - 타입스크립트\r\n---\r\n\r\n\r\n\r\n# 타입스크립트 fundamentals - 타입, 함수, 인터페이스, enum, 클래스\r\n\r\n\r\n## 1. 기본타입\r\n\r\n변수선언방식 변수명 : 타입 = 값;\r\n\r\n```tsx\r\nlet str: string = 'hi'\r\nlet num: number = 10;\r\nlet isLoggedIn: boolean = false;\r\n```\r\n\r\n### Array\r\n\r\n요소의 집합\r\n\r\n```tsx\r\nlet arr: number[] = [1, 2, 3];\r\narr[2] = 100;\r\n\r\n// 타입이 다르므로 에러\r\narr[2] = 'hi';\r\n```\r\n\r\n### Tuple\r\n\r\n**길이가 고정**되고 요소 **타입이 지정**된 배열\r\n\r\n```tsx\r\nlet tuple: [string, number] = ['hi', 10];\r\n\r\n//길이가 고정되기때문에 에러뜸\r\ntuple[5] = 'hello';\r\n// number타입에 string 할당 x 에러\r\ntuple[1] = 'hi';\r\n\r\n```\r\n\r\n### Enum\r\n\r\n**상수**들의 집합이다.\r\n\r\n```tsx\r\nenum Avengers { Capt, IronMan, Thor }\r\nlet hero: Avengers = Avengers.Capt;\r\n\r\nconsole.log(hero); // 0\r\n\r\n//읽기전용이라서 할당불가 에러\r\nAvengers.Capt = 3;\r\n```\r\n\r\n### Any\r\n\r\n자바스크립트의 변수랑 똑같다. 뭐든 할당 가능\r\n\r\n```tsx\r\nlet str: any = 'hi';\r\nlet num: any = 10;\r\nlet arr: any = ['a', 2, true];\r\n\r\n//any라서 num에 'hi' 할당 가능\r\nnum = 'hi';\r\n```\r\n\r\n### Void\r\n\r\nundefined와 null만 할당가능하다. 일반적으로 반환하지 않는 **함수**에서 사용\r\n\r\n```tsx\r\nlet unuseful: void = undefined;\r\nfunction notuse(): void {\r\n  console.log('sth');\r\n}\r\n```\r\n\r\n### never\r\n\r\n에러를 throw 하거나 절대 반환하지 않는 함수(무한루프일때 쓰이네요)\r\n\r\n```tsx\r\nfunction neverEnd(): never {\r\n  while (true) {\r\n\r\n  }\r\n}\r\n\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n```\r\n\r\n## 2. 함수\r\n\r\n### 함수의 기본적인 타입 선언\r\n\r\n자바스크립트와의 차이점은 **매개 변수**와 **반환 값**에 타입 부여\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n\treturn a + b;\r\n}\r\n```\r\n\r\n### 함수의 인자\r\n\r\n전달 인자의 수가 더 많거나 적거나 하면 당연히 안되겠죠? 당연히 타입도 다르면 안되요\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // error, too few parameters\r\n```\r\n\r\n### 선택적 매개변수\r\n\r\n하지만 매개변수에 ?를 달아주면 그 전달인자를 넘기지 않아도 됩니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b?: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 10\r\n```\r\n\r\n```tsx\r\n// error 필수 매개변수가 선택적 매개변수 \r\n// 선택적 매개변수가 앞에 있으면 안됩니다.\r\nfunction sum(a?: number, b: number): number {\r\n  return a + b;\r\n}\r\n```\r\n\r\n기본값도 설정해 줄 수 있습니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b = 100): number {\r\n  return a + b;\r\n}\r\nsum(10, undefined); // 110\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 110\r\n```\r\n\r\n### 인터페이스\r\n\r\n인터페이스는 상호간의 정의한 약속이나 규칙을 의미한다.\r\n\r\n객체의 속성과 속성타입\r\n\r\n함수의 매개변수나 반환타입\r\n\r\n배열과 객체를 접근하는 방식\r\n\r\n클래스\r\n\r\nlogAge 메소드는 age라는 속성을 갖고 number타입을 갖는 객체를 받는것을 약속했다.\r\n\r\n```tsx\r\nlet person = { name: 'Capt', age: 28 };\r\n\r\nfunction logAge(obj: { age: number }) {\r\n  console.log(obj.age); // 28\r\n}\r\nlogAge(person); // 28\r\n```\r\n\r\n```tsx\r\ninterface personAge {\r\n  age: number;\r\n}\r\n\r\nfunction logAge(obj: personAge) {\r\n  console.log(obj.age);\r\n}\r\nlet person = { name: 'Capt', age: 28 };\r\nlogAge(person);\r\n```\r\n\r\n### 옵션속성\r\n\r\n아까 매개변수때와 마찬가지로 ?를 붙혀주면 그 속성을 모두 다 꼭 사용하지 않아도 됩니다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  name: string;\r\n  hop?: number;  \r\n}\r\n\r\nlet myBeer = {\r\n  name: 'Saporo'\r\n};\r\nfunction brewBeer(beer: CraftBeer) {\r\n  console.log(beer.name); // Saporo\r\n}\r\nbrewBeer(myBeer);\r\n```\r\n\r\n### 읽기 전용 속성\r\n\r\nreadonly가 붙은 속성은 읽는것만 된다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  readonly brand: string;\r\n}\r\n\r\nlet myBeer: CraftBeer = {\r\n  brand: 'Belgian Monk'\r\n};\r\nmyBeer.brand = 'Korean Carpenter'; // error!\r\n```\r\n\r\n### 읽기 전용 배열\r\n\r\nReadonlyArray로 선언하면 배열 내용 변경 불가ReadonlyArray로 선언하면 배열 내용 변경 불가\r\n\r\n```tsx\r\nlet arr: ReadonlyArray<number> = [1,2,3];\r\narr.splice(0,1); // error\r\narr.push(4); // error\r\narr[0] = 100; // error\r\narr = [10, 20, 30]; // error\r\n```\r\n\r\n객체 선언과 관련된 타입 체킹\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  brand?: string;\r\n}\r\n\r\nfunction brewBeer(beer: CraftBeer) {\r\n  // ..\r\n}\r\nbrewBeer({ brandon: 'what' }); // 속성이 다르니 에러뜹니다.\r\n```\r\n\r\n이러면 타입 체크를 무시한다.\r\n\r\n```tsx\r\nlet myBeer = { brandon: 'what' }';\r\nbrewBeer(myBeer as CraftBeer);\r\n```\r\n\r\n### 함수 타입\r\n\r\n함수 매개변수와 반환타입도 인터페이스 정의가 가능하다.\r\n\r\n```tsx\r\ninterface login {\r\n  (username: string, password: string): boolean;\r\n}\r\n\r\nlet loginUser: login; // 함수 저장할 변수 선언\r\nloginUser = function(id: string, pw: string) {\r\n  console.log('로그인 했습니다');\r\n  return true;\r\n}\r\n```\r\n\r\n클래스 타입\r\n\r\n자바의 인터페이스와 목적이 비슷한데\r\n\r\n어떤 인터페이스를 implements한 클래스가 있다면\r\n\r\n인터페이스의 메소드와 변수가 있다는 것을 보장한다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  beerName: string;\r\n  nameBeer(beer: string): void;\r\n}\r\n\r\nclass myBeer implements CraftBeer {\r\n  beerName: string = 'Baby Guinness';\r\n  nameBeer(b: string) {\r\n    this.beerName = b;\r\n  }\r\n  constructor() {}\r\n}\r\n```\r\n\r\n인터페이스 끼리 상속도 가능합니다.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n}\r\ninterface Drinker {\r\n  drink: string;\r\n}\r\ninterface Developer extends Person {\r\n  skill: string;\r\n}\r\nlet fe = {} as Developer;\r\nfe.name = 'josh';\r\nfe.skill = 'TypeScript';\r\nfe.drink = 'Beer';\r\n```\r\n\r\n## 4. Enum\r\n\r\n> 특정 값들의 **집합**을 의미하는 자료형으로 크게 {숫자형 이넘, 문자형 이넘} 두 가지가 있다\r\n\r\n- Enum이라는 개념을 이해하기 어려웠던 이유는, javascript에는 enum이 없었기 때문이다. (하지만 검색해보니 C언어에서는 제공하는 것 같음.)\r\n\r\n### 4-1. 숫자형 이넘\r\n\r\n```tsx\r\nenum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n특이한 것은 이렇게 선언하면  양방향으로 호출할 수 있는 특이한 자료구조가 된다는 것이다.\r\n\r\n```tsx\r\nconsole.log(Direction[1])    // \"Up\"\r\nconsole.log(Direction[\"Up\"]) // 1\r\nconsole.log(Direction[3])    // \"Left\"\r\n```\r\n\r\n이와 같이 숫자형 Enum에서 Direction.Up 으로 1값을 얻거나 반대로 Direction[1]로 \"Up\"값을 얻는 것을 **`리버스 매핑`** 이라고 한다.\r\n\r\n이렇게 초기값을 선언해주면 1, 2, 3, 4 의 순서로 1씩 증가하며 할당된다. 만약,\r\n\r\n```tsx\r\nenum Direction {\r\n\tUp, \r\n\tDown,\r\n\tLeft,\r\n\tRight\r\n}\r\n```\r\n\r\n으로 선언되었다면 Up - 0 , Down - 1, Left - 2, Right - 3이 된다.\r\n\r\n### 4-2 숫자형 enum 사용\r\n\r\n```tsx\r\nenum Response {\r\n  No = 0,\r\n  Yes = 1,\r\n}\r\n\r\nfunction respond(recipient: string, message: Response): void {\r\n  console.log(recipient, message)\r\n}\r\n\r\nrespond(\"Captain Pangyo\", Response.Yes);\r\n\r\n--------------------\r\n[LOG]: \"Captain Pangyo\",  1\r\n```\r\n\r\n### 4-3. 문자형 enum\r\n\r\n> 문자형 이넘은 이넘 값 전부 다 특정 문자 또는 다른 이넘 값으로 초기화 해줘야 합니다.\r\n\r\n```tsx\r\nenum Direction {\r\n    Up = \"UP\",\r\n    Down = \"DOWN\",\r\n    Left = \"LEFT\",\r\n    Right = \"RIGHT\",\r\n}\r\n```\r\n\r\n** 복합 enums **\r\n\r\n문자와 숫자를 혼합하여 enum을 생성할 수 있으나, 권장하지 않는 방식!\r\n\r\n```tsx\r\nenum BooleanLikeHeterogeneousEnum {\r\n    No = 0,\r\n    Yes = \"YES\",\r\n}\r\n```\r\n\r\n### 4-4. 런타임 시점에서의 이넘 특징\r\n\r\n이넘은 런타임시에 실제 객체 형태로 존재합니다. 예를 들어 아래와 같은 이넘 코드가 있을 때\r\n\r\n```tsx\r\nenum E {\r\n  X, Y, Z\r\n}\r\n\r\nfunction getX(obj: { X: number }) {\r\n  return obj.X;\r\n}\r\ngetX(E); // 이넘 E의 X는 숫자이기 때문에 정상 동작\r\n-----\r\nQuiz. \r\ngetX(E)값을 변수에 넣어서 출력한다면, 얼마나 나올까?\r\n```\r\n\r\n### 4-5. 컴파일 시점에서의 이넘 특징\r\n\r\n```tsx\r\nenum LogLevel {\r\n  ERROR, WARN, INFO, DEBUG\r\n}\r\n\r\n// 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\r\ntype LogLevelStrings = keyof typeof LogLevel;\r\n\r\nfunction printImportant(key: LogLevelStrings, message: string) {\r\n    const num = LogLevel[key];\r\n    if (num <= LogLevel.WARN) {\r\n       console.log('Log level key is: ', key);\r\n       console.log('Log level value is: ', num);\r\n       console.log('Log level message is: ', message);\r\n    }\r\n}\r\nprintImportant('ERROR', 'This is a message');\r\n\r\n-------\r\n[LOG]: \"Log level key is: \",  \"ERROR\" \r\n[LOG]: \"Log level value is: \",  0 \r\n[LOG]: \"Log level message is: \",  \"This is a message\"\r\n```\r\n\r\n### 4-6. Typescript enum을 사용하는 이유\r\n\r\nEnum은 추상화의 수단이다.\r\n\r\n다국어 코드 (Language Code)를 할당한다고 생각해보자\r\n\r\n```tsx\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\n\r\nconst code: LanguageCode = 'ko'\r\n\r\nconsole.log(code) // [LOG]: \"ko\"\r\n\r\n하지만 \r\ncost code: LanguageCode = 'hahahaha'\r\n와 같이 코드를 짜면 typescript에서 에러로 표시해준다.\r\n```\r\n\r\n이것도 좋지만 데이터 양이 많아지면 가독성이 많이 떨어진다.\r\n\r\n우리가 원하는 것은 korean을 검색하면 'ko'라는 코드가 나왔으면 하는 것이고 기존 방식으로는 다음과 같이 두 가지 방법이 있다.\r\n\r\n```tsx\r\n// 이렇게 하면 언어 코드가 위아래에 중복되고\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nlet code: LanguageCode = english\r\nconsole.log(code) // \"en\"\r\n```\r\n\r\n```tsx\r\n// 이렇게 하면 코드가 너무 길어집니다\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = typeof korean | typeof english | typeof japanese | typeof chinese | typeof spanish\r\nlet code: LanguageCode = spanish\r\nconsole.log(code) // \"es\"\r\n```\r\n\r\n이러한 이유 때문에 리터럴의 타입과 값에 이름을 붙인 `enum`을 활용하면 가독성을 크게 높일 수 있습니다.\r\n\r\n```tsx\r\nenum LanguageCode {\r\n  korean = 'ko',\r\n  english = 'en',\r\n  japanese = 'ja',\r\n  chinese = 'zh',\r\n  spanish = 'es',\r\n}\r\n// 여기서 \r\n// LanguageCode.korean === 'ko'\r\n// (의미상) LanguageCode === 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nconst code: LanguageCode = LanguageCode.korean\r\nconsole.log(code) // \"ko\"\r\n```\r\n\r\n### 4-7. Typescript enum을 사용하지 않는 이유\r\n\r\n### Tree-shaking은 무엇인가요?\r\n\r\nTree-shaking이란 간단하게 말해 사용하지 않는 코드를 삭제하는 기능을 말합니다. 나무를 흔들면 죽은 잎사귀들이 떨어지는 모습에 착안해 Tree-shaking이라고 부릅니다. Tree-shaking을 통해 export했지만 아무 데서도 import하지 않은 모듈이나 사용하지 않는 코드를 삭제해서 번들 크기를 줄여 페이지가 표시되는 시간을 단축할 수 있습니다.\r\n\r\n하지만 enum을 사용하게 되면 Tree-shaking이 되지 않습니다.\r\n\r\n결론적으로  Tree-shaking 관점에서 보았을 때 아래와 같은 순서로 사용하시길 추천하며 글을 마치겠습니다.\r\n\r\n> Union Types > const enum > enum\r\n\r\n**정리**\r\n\r\n- 같은 ‘종류’를 나타내는 여러 개의 숫자 혹은 문자열을 다뤄야 하는데, \r\n각각 적당한 이름을 붙여서 코드의 가독성을 높이고 싶다면 enum을 사용!\r\n\r\n## 5. 연산자를 이용한 타입 정의\r\n\r\n### 5-1. Union Type ( | )\r\n\r\n유니온 타입(Union Type)이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입\r\n\r\n```tsx\r\nfunction logText(text: string | number) {\r\n  // ...\r\n}\r\n```\r\n\r\n- text는 string이거나 (OR || ) number이다. 즉, 둘 다 올 수 있다는 뜻.\r\n- 이처럼 `|` 연산자를 이용하여 타입을 여러 개 연결하는 방식을 `유니온 타입 정의 방식` 이라 부른다.\r\n\r\n```tsx\r\nfunction getAge(age: number | string) {\r\n  if (typeof age === 'number') {\r\n    age.toFixed(); // 정상 동작, age의 타입이 `number`로 추론되기 때문에 숫자 관련된 API를 쉽게 자동완성 할 수 있다.\r\n    return age;\r\n  }\r\n  if (typeof age === 'string') {\r\n    return age;\r\n  }\r\n  return new TypeError('age must be number or string');\r\n}\r\nconsole.log(getAge(10))\r\nconsole.log(getAge('Hello World'))\r\nconsole.log(getAge(true))\r\n--- 출력 ---\r\n[LOG]: 10 \r\n[LOG]: \"Hello World\" \r\n[LOG]: age must be number or string\r\n```\r\n\r\n### 5-2. Intersection Type ( & )\r\n\r\n여러 타입을 모두 만족하는 하나의 타입을 의미.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: number;\r\n}\r\ntype Capt = Person & Developer;\r\n```\r\n\r\n```tsx\r\n// Capt의 타입은\r\n\r\n{\r\n  name: string;\r\n  age: number;\r\n  skill: string;\r\n}\r\n```\r\n\r\n![Intersection Type](https://joshua1988.github.io/ts/assets/img/intersection-diagram.01f4fdfe.png)\r\n\r\n### 5-3. Union Type을 쓸 때 주의할 점\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: string;\r\n}\r\nfunction introduce(someone: Person | Developer) {\r\n  someone.name; // O 정상 동작\r\n  someone.age; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n  someone.skill; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n}\r\n```\r\n\r\n유니온 타입은 A도 될 수 있고 B도 될 수 있는 타입이지라고 생각하면 파라미터의 타입이 Person도 되고 Developer도 될테니까 함수 안에서 당연히 이 인터페이스들이 제공하는 속성들인 age나 skill를 사용할 수 있겠지라고 생각할 수 있습니다. \r\n\r\n하지만, 타입스크립트 관점에서는 introduce() 함수를 호출하는 시점에 Person 타입이 올지 Developer 타입이 올지 알 수가 없기 때문에 어느 타입이 들어오든 간에 오류가 안 나는 방향으로 타입을 추론하게 됩니다.\r\n\r\n따라서 위의 예시 같은 경우에는 의도와는 달리 [someone.name](http://someone.name) 만 정상적으로 작동하게 됩니다.\r\n\r\n## 6. Class\r\n\r\n### 6-1. Readonly\r\n\r\n```tsx\r\nclass Developer {\r\n    readonly name: string;\r\n    constructor(theName: string) {\r\n        this.name = theName;\r\n    }\r\n}\r\nlet john = new Developer(\"John\");\r\njohn.name = \"John\"; // error! name is readonly.\r\nconsole.log(john)\r\n--- 출력 ---\r\n[LOG]: Developer: {\r\n  \"name\": \"John\"\r\n}\r\n```\r\n\r\n### 6-2. Accessor\r\n\r\n타입스크립트는 객체의 특정 속성의 접근과 할당에 대해 제어할 수 있습니다. 이를 위해선 해당 객체가 클래스로 생성한 객체여야 합니다. 아래의 간단한 예제를 봅시다.\r\n\r\n```tsx\r\nclass Developer {\r\n  name: string;\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton';\r\n```\r\n\r\n위 코드는 클래스로 생성한 객체의 `name` 속성에 `Josh Bolton`이라는 값을 대입한 코드입니다. 이제 `josh`라는 객체의 `name` 속성은 `Josh Bolton`이라는 값을 갖겠죠.\r\n\r\n여기서 만약 `name` 속성에 제약 사항을 추가하고 싶다면 아래와 같이 `get`과 `set`을 활용합니다.\r\n\r\n```tsx\r\nclass Developer {\r\n  private name: string;\r\n  \r\n  get name(): string {\r\n    return this.name;\r\n  }\r\n\r\n  set name(newValue: string) {\r\n    if (newValue && newValue.length > 5) {\r\n      throw new Error('이름이 너무 깁니다');\r\n    }\r\n    this.name = newValue;\r\n  }\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton'; // Error\r\njosh.name = 'Josh';\r\n```\r\n\r\nTIP!\r\nget만 선언하고 set을 선언하지 않는 경우에는 자동으로 readonly로 인식됩니다.\r\n\r\n### 6-3. Abstract Class\r\n\r\n추상 클래스(Abstract Class)는 인터페이스와 비슷한 역할을 하면서도 조금 다른 특징을 갖고 있습니다. 추상 클래스는 특정 클래스의 상속 대상이 되는 클래스이며 좀 더 상위 레벨에서 속성, 메서드의 모양을 정의합니다.\r\n\r\n```tsx\r\nabstract class Developer {\r\n  abstract coding(): void; // 'abstract'가 붙으면 상속 받은 클래스에서 무조건 구현해야 함\r\n  drink(): void {\r\n    console.log('drink sth');\r\n  }\r\n}\r\n\r\nclass FrontEndDeveloper extends Developer {\r\n  coding(): void {\r\n    // Developer 클래스를 상속 받은 클래스에서 무조건 정의해야 하는 메서드\r\n    console.log('develop web');\r\n  }\r\n  design(): void {\r\n    console.log('design web');\r\n  }\r\n}\r\nconst dev = new Developer(); // error: cannot create an instance of an abstract class\r\nconst josh = new FrontEndDeveloper();\r\njosh.coding(); // develop web\r\njosh.drink(); // drink sth\r\njosh.design(); // design web\r\n```\r\n\r\n\r\n\r\n\r\n---\r\nReferences\r\nhttps://joshua1988.github.io/ts/\r\n\r\n[TypeScript enum을 사용하는 이유](https://medium.com/@seungha_kim_IT/typescript-enum을-사용하는-이유-3b3ccd8e5552)\r\n\r\n[TypeScript enum을 사용하지 않는 게 좋은 이유](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/)\r\n\r\n[C언어 Enum](https://dojang.io/mod/page/view.php?id=480)");

/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS90eXBlc2NyaXB0LzIwMjEtMDQtMTQtVHlwZXNjcmlwdC3si5zsnpHtlZjquLAubWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLCtEQUFlLDZOQUE2TixpRUFBaUUsb0NBQW9DLHNGQUFzRixpQkFBaUIsd0NBQXdDLHlIQUF5SCxnREFBZ0QsbURBQW1ELGtGQUFrRixzQkFBc0IsdUNBQXVDLDBCQUEwQixvREFBb0QsNkZBQTZGLHNCQUFzQixrQ0FBa0MsOENBQThDLGtJQUFrSSw2QkFBNkIseUJBQXlCLEtBQUssc0hBQXNILG9CQUFvQixXQUFXLEtBQUssZ0RBQWdELGlDQUFpQyxLQUFLLCtKQUErSixtQkFBbUIsS0FBSywrSUFBK0ksbUJBQW1CLEtBQUssZ0JBQWdCLDBCQUEwQiwwQ0FBMEMscUtBQXFLLG1CQUFtQixLQUFLLGdCQUFnQiwwQkFBMEIsMENBQTBDLHdJQUF3SSxtQkFBbUIsS0FBSyw2RkFBNkYsbUJBQW1CLEtBQUssdUJBQXVCLDJCQUEyQiwwQ0FBMEMsNk9BQTZPLHlCQUF5Qiw4QkFBOEIsY0FBYyxHQUFHLDJCQUEyQixXQUFXLG1CQUFtQixvREFBb0Qsa0JBQWtCLEtBQUsseUNBQXlDLDJCQUEyQixLQUFLLGtCQUFrQix5QkFBeUIsbUJBQW1CLHdIQUF3SCxtQkFBbUIsbUJBQW1CLE9BQU8sc0JBQXNCLDBCQUEwQix3Q0FBd0MsNkJBQTZCLGVBQWUscUJBQXFCLG1HQUFtRyw2QkFBNkIsS0FBSyxpQ0FBaUMsaUNBQWlDLHNDQUFzQyxzS0FBc0ssb0JBQW9CLHlCQUF5QiwwQkFBMEIsZ0NBQWdDLCtFQUErRSxxQkFBcUIsS0FBSyw0Q0FBNEMsZ0JBQWdCLGNBQWMsa0JBQWtCLEVBQUUsaUZBQWlGLGtCQUFrQixFQUFFLGtDQUFrQyxpR0FBaUcsb0RBQW9ELEtBQUssNkJBQTZCLGtFQUFrRSw4QkFBOEIsa0JBQWtCLEtBQUssaUtBQWlLLHVCQUF1QixtQ0FBbUMsS0FBSywyQ0FBMkMseUNBQXlDLDJCQUEyQiwwQkFBMEIsT0FBTyxzQkFBc0IsS0FBSyxzRUFBc0UsbUJBQW1CLEtBQUssdUJBQXVCLG9CQUFvQixLQUFLLHdDQUF3QyxvQkFBb0IsS0FBSyxlQUFlLGNBQWMscUJBQXFCLDRCQUE0QixzQkFBc0IsaUVBQWlFLGVBQWUsaUtBQWlLLG1EQUFtRCxvWkFBb1osZ0RBQWdELGdJQUFnSSxnQ0FBZ0Msc0VBQXNFLDBDQUEwQyxrREFBa0QsMExBQTBMLG1HQUFtRyxtSUFBbUksMENBQTBDLDRIQUE0SCxrQkFBa0IsNEJBQTRCLFlBQVksR0FBRyxtQkFBbUIsS0FBSyxZQUFZLDJKQUEySixtQ0FBbUMsK0NBQStDLGlEQUFpRCx3RUFBd0Usa0NBQWtDLG1DQUFtQyxrREFBa0Qsb0RBQW9ELDBEQUEwRCxTQUFTLEtBQUssaURBQWlELDgyQ0FBODJDLDhHQUE4RyxnN0JBQWc3QixpQkFBaUIsOExBQThMLG9DQUFvQyxzQkFBc0IscUZBQXFGLE9BQU8sb0NBQW9DLG1CQUFtQixPQUFPLDJEQUEyRCxLQUFLLGlUQUFpVCxtQkFBbUIsa0JBQWtCLEtBQUsseUJBQXlCLG1CQUFtQixvQkFBb0IsS0FBSyxtQ0FBbUMsOENBQThDLG1CQUFtQixrQkFBa0Isb0JBQW9CLEtBQUssMkxBQTJMLG1CQUFtQixrQkFBa0IsS0FBSyx5QkFBeUIsbUJBQW1CLG9CQUFvQixLQUFLLHFEQUFxRCxtQkFBbUIsNkJBQTZCLHFEQUFxRCxzQ0FBc0MsNmNBQTZjLDhCQUE4QixzQ0FBc0MsZ0NBQWdDLFNBQVMsS0FBSyx1Q0FBdUMseUJBQXlCLHNGQUFzRiw2QkFBNkIsc0tBQXNLLG1CQUFtQixLQUFLLGlDQUFpQyw4QkFBOEIsdU9BQXVPLDJCQUEyQixnQ0FBZ0MseUJBQXlCLE9BQU8sc0NBQXNDLDhDQUE4Qyx3Q0FBd0MsU0FBUyw2QkFBNkIsT0FBTyxLQUFLLGlDQUFpQyw4QkFBOEIsZ0NBQWdDLHlSQUF5Uiw4QkFBOEIsK0RBQStELGlDQUFpQyxPQUFPLEtBQUssbURBQW1ELHNCQUFzQix3RkFBd0YsT0FBTyxzQkFBc0Isa0NBQWtDLE9BQU8sS0FBSyxnQ0FBZ0Msa0dBQWtHLGtCQUFrQixnQ0FBZ0MsK0JBQStCLDJYQUEyWCxFIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3BhZ2VzL19hcHAuM2E3MTlmMTBlMGVmYzBjYzlkMzkuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJUeXBlc2NyaXB0IOyLnOyeke2VmOq4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wNC4xNFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gdHlwZXNjcmlwdFxcclxcbiAgLSDtg4DsnoXsiqTtgazrpr3tirhcXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIO2DgOyeheyKpO2BrOumve2KuCBmdW5kYW1lbnRhbHMgLSDtg4DsnoUsIO2VqOyImCwg7J247YSw7Y6Y7J207IqkLCBlbnVtLCDtgbTrnpjsiqRcXHJcXG5cXHJcXG5cXHJcXG4jIyAxLiDquLDrs7jtg4DsnoVcXHJcXG5cXHJcXG7rs4DsiJjshKDslrjrsKnsi50g67OA7IiY66qFIDog7YOA7J6FID0g6rCSO1xcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBzdHI6IHN0cmluZyA9ICdoaSdcXHJcXG5sZXQgbnVtOiBudW1iZXIgPSAxMDtcXHJcXG5sZXQgaXNMb2dnZWRJbjogYm9vbGVhbiA9IGZhbHNlO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyBBcnJheVxcclxcblxcclxcbuyalOyGjOydmCDsp5HtlalcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgYXJyOiBudW1iZXJbXSA9IFsxLCAyLCAzXTtcXHJcXG5hcnJbMl0gPSAxMDA7XFxyXFxuXFxyXFxuLy8g7YOA7J6F7J20IOuLpOultOuvgOuhnCDsl5Drn6xcXHJcXG5hcnJbMl0gPSAnaGknO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyBUdXBsZVxcclxcblxcclxcbioq6ri47J206rCAIOqzoOyglSoq65CY6rOgIOyalOyGjCAqKu2DgOyeheydtCDsp4DsoJUqKuuQnCDrsLDsl7RcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgdHVwbGU6IFtzdHJpbmcsIG51bWJlcl0gPSBbJ2hpJywgMTBdO1xcclxcblxcclxcbi8v6ri47J206rCAIOqzoOygleuQmOq4sOuVjOusuOyXkCDsl5Drn6zrnLhcXHJcXG50dXBsZVs1XSA9ICdoZWxsbyc7XFxyXFxuLy8gbnVtYmVy7YOA7J6F7JeQIHN0cmluZyDtlaDri7kgeCDsl5Drn6xcXHJcXG50dXBsZVsxXSA9ICdoaSc7XFxyXFxuXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIEVudW1cXHJcXG5cXHJcXG4qKuyDgeyImCoq65Ok7J2YIOynke2VqeydtOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIEF2ZW5nZXJzIHsgQ2FwdCwgSXJvbk1hbiwgVGhvciB9XFxyXFxubGV0IGhlcm86IEF2ZW5nZXJzID0gQXZlbmdlcnMuQ2FwdDtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhoZXJvKTsgLy8gMFxcclxcblxcclxcbi8v7J296riw7KCE7Jqp7J2065287IScIO2VoOuLueu2iOqwgCDsl5Drn6xcXHJcXG5BdmVuZ2Vycy5DYXB0ID0gMztcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgQW55XFxyXFxuXFxyXFxu7J6Q67CU7Iqk7YGs66a97Yq47J2YIOuzgOyImOuekSDrmJHqsJnri6QuIOutkOuToCDtlaDri7kg6rCA64qlXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IHN0cjogYW55ID0gJ2hpJztcXHJcXG5sZXQgbnVtOiBhbnkgPSAxMDtcXHJcXG5sZXQgYXJyOiBhbnkgPSBbJ2EnLCAyLCB0cnVlXTtcXHJcXG5cXHJcXG4vL2FueeudvOyEnCBudW3sl5AgJ2hpJyDtlaDri7kg6rCA64qlXFxyXFxubnVtID0gJ2hpJztcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgVm9pZFxcclxcblxcclxcbnVuZGVmaW5lZOyZgCBudWxs66eMIO2VoOuLueqwgOuKpe2VmOuLpC4g7J2867CY7KCB7Jy866GcIOuwmO2ZmO2VmOyngCDslYrripQgKirtlajsiJgqKuyXkOyEnCDsgqzsmqlcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgdW51c2VmdWw6IHZvaWQgPSB1bmRlZmluZWQ7XFxyXFxuZnVuY3Rpb24gbm90dXNlKCk6IHZvaWQge1xcclxcbiAgY29uc29sZS5sb2coJ3N0aCcpO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgbmV2ZXJcXHJcXG5cXHJcXG7sl5Drn6zrpbwgdGhyb3cg7ZWY6rGw64KYIOygiOuMgCDrsJjtmZjtlZjsp4Ag7JWK64qUIO2VqOyImCjrrLTtlZzro6jtlITsnbzrlYwg7JOw7J2064Sk7JqUKVxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIG5ldmVyRW5kKCk6IG5ldmVyIHtcXHJcXG4gIHdoaWxlICh0cnVlKSB7XFxyXFxuXFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2U6IHN0cmluZyk6IG5ldmVyIHtcXHJcXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyAyLiDtlajsiJhcXHJcXG5cXHJcXG4jIyMg7ZWo7IiY7J2YIOq4sOuzuOyggeyduCDtg4DsnoUg7ISg7Ja4XFxyXFxuXFxyXFxu7J6Q67CU7Iqk7YGs66a97Yq47JmA7J2YIOywqOydtOygkOydgCAqKuunpOqwnCDrs4DsiJgqKuyZgCAqKuuwmO2ZmCDqsJIqKuyXkCDtg4DsnoUg67aA7JesXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gc3VtKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcXHJcXG5cXHRyZXR1cm4gYSArIGI7XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiMjIyDtlajsiJjsnZgg7J247J6QXFxyXFxuXFxyXFxu7KCE64usIOyduOyekOydmCDsiJjqsIAg642UIOunjuqxsOuCmCDsoIHqsbDrgpgg7ZWY66m0IOuLueyXsO2eiCDslYjrkJjqsqDso6A/IOuLueyXsO2eiCDtg4DsnoXrj4Qg64uk66W066m0IOyViOuQmOyalFxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIHN1bShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XFxyXFxuICByZXR1cm4gYSArIGI7XFxyXFxufVxcclxcbnN1bSgxMCwgMjApOyAvLyAzMFxcclxcbnN1bSgxMCwgMjAsIDMwKTsgLy8gZXJyb3IsIHRvbyBtYW55IHBhcmFtZXRlcnNcXHJcXG5zdW0oMTApOyAvLyBlcnJvciwgdG9vIGZldyBwYXJhbWV0ZXJzXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIOyEoO2DneyggSDrp6TqsJzrs4DsiJhcXHJcXG5cXHJcXG7tlZjsp4Drp4wg66ek6rCc67OA7IiY7JeQID/rpbwg64us7JWE7KO866m0IOq3uCDsoITri6zsnbjsnpDrpbwg64SY6riw7KeAIOyViuyVhOuPhCDrkKnri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gc3VtKGE6IG51bWJlciwgYj86IG51bWJlcik6IG51bWJlciB7XFxyXFxuICByZXR1cm4gYSArIGI7XFxyXFxufVxcclxcbnN1bSgxMCwgMjApOyAvLyAzMFxcclxcbnN1bSgxMCwgMjAsIDMwKTsgLy8gZXJyb3IsIHRvbyBtYW55IHBhcmFtZXRlcnNcXHJcXG5zdW0oMTApOyAvLyAxMFxcclxcbmBgYFxcclxcblxcclxcbmBgYHRzeFxcclxcbi8vIGVycm9yIO2VhOyImCDrp6TqsJzrs4DsiJjqsIAg7ISg7YOd7KCBIOunpOqwnOuzgOyImCBcXHJcXG4vLyDshKDtg53soIEg66ek6rCc67OA7IiY6rCAIOyVnuyXkCDsnojsnLzrqbQg7JWI65Cp64uI64ukLlxcclxcbmZ1bmN0aW9uIHN1bShhPzogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xcclxcbiAgcmV0dXJuIGEgKyBiO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7quLDrs7jqsJLrj4Qg7ISk7KCV7ZW0IOykhCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIHN1bShhOiBudW1iZXIsIGIgPSAxMDApOiBudW1iZXIge1xcclxcbiAgcmV0dXJuIGEgKyBiO1xcclxcbn1cXHJcXG5zdW0oMTAsIHVuZGVmaW5lZCk7IC8vIDExMFxcclxcbnN1bSgxMCwgMjAsIDMwKTsgLy8gZXJyb3IsIHRvbyBtYW55IHBhcmFtZXRlcnNcXHJcXG5zdW0oMTApOyAvLyAxMTBcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7J247YSw7Y6Y7J207IqkXFxyXFxuXFxyXFxu7J247YSw7Y6Y7J207Iqk64qUIOyDge2YuOqwhOydmCDsoJXsnZjtlZwg7JW97IaN7J2064KYIOq3nOy5meydhCDsnZjrr7jtlZzri6QuXFxyXFxuXFxyXFxu6rCd7LK07J2YIOyGjeyEseqzvCDsho3shLHtg4DsnoVcXHJcXG5cXHJcXG7tlajsiJjsnZgg66ek6rCc67OA7IiY64KYIOuwmO2ZmO2DgOyehVxcclxcblxcclxcbuuwsOyXtOqzvCDqsJ3ssrTrpbwg7KCR6re87ZWY64qUIOuwqeyLnVxcclxcblxcclxcbu2BtOuemOyKpFxcclxcblxcclxcbmxvZ0FnZSDrqZTshozrk5zripQgYWdl652864qUIOyGjeyEseydhCDqsJbqs6AgbnVtYmVy7YOA7J6F7J2EIOqwluuKlCDqsJ3ssrTrpbwg67Cb64qU6rKD7J2EIOyVveyGje2WiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgcGVyc29uID0geyBuYW1lOiAnQ2FwdCcsIGFnZTogMjggfTtcXHJcXG5cXHJcXG5mdW5jdGlvbiBsb2dBZ2Uob2JqOiB7IGFnZTogbnVtYmVyIH0pIHtcXHJcXG4gIGNvbnNvbGUubG9nKG9iai5hZ2UpOyAvLyAyOFxcclxcbn1cXHJcXG5sb2dBZ2UocGVyc29uKTsgLy8gMjhcXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgcGVyc29uQWdlIHtcXHJcXG4gIGFnZTogbnVtYmVyO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBsb2dBZ2Uob2JqOiBwZXJzb25BZ2UpIHtcXHJcXG4gIGNvbnNvbGUubG9nKG9iai5hZ2UpO1xcclxcbn1cXHJcXG5sZXQgcGVyc29uID0geyBuYW1lOiAnQ2FwdCcsIGFnZTogMjggfTtcXHJcXG5sb2dBZ2UocGVyc29uKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7Ji17IWY7IaN7ISxXFxyXFxuXFxyXFxu7JWE6rmMIOunpOqwnOuzgOyImOuVjOyZgCDrp4jssKzqsIDsp4DroZwgP+ulvCDrtpntmIDso7zrqbQg6re4IOyGjeyEseydhCDrqqjrkZAg64ukIOq8rSDsgqzsmqntlZjsp4Ag7JWK7JWE64+EIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgQ3JhZnRCZWVyIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIGhvcD86IG51bWJlcjsgIFxcclxcbn1cXHJcXG5cXHJcXG5sZXQgbXlCZWVyID0ge1xcclxcbiAgbmFtZTogJ1NhcG9ybydcXHJcXG59O1xcclxcbmZ1bmN0aW9uIGJyZXdCZWVyKGJlZXI6IENyYWZ0QmVlcikge1xcclxcbiAgY29uc29sZS5sb2coYmVlci5uYW1lKTsgLy8gU2Fwb3JvXFxyXFxufVxcclxcbmJyZXdCZWVyKG15QmVlcik7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIOydveq4sCDsoITsmqkg7IaN7ISxXFxyXFxuXFxyXFxucmVhZG9ubHnqsIAg67aZ7J2AIOyGjeyEseydgCDsnb3ripTqsoPrp4wg65Cc64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBDcmFmdEJlZXIge1xcclxcbiAgcmVhZG9ubHkgYnJhbmQ6IHN0cmluZztcXHJcXG59XFxyXFxuXFxyXFxubGV0IG15QmVlcjogQ3JhZnRCZWVyID0ge1xcclxcbiAgYnJhbmQ6ICdCZWxnaWFuIE1vbmsnXFxyXFxufTtcXHJcXG5teUJlZXIuYnJhbmQgPSAnS29yZWFuIENhcnBlbnRlcic7IC8vIGVycm9yIVxcclxcbmBgYFxcclxcblxcclxcbiMjIyDsnb3quLAg7KCE7JqpIOuwsOyXtFxcclxcblxcclxcblJlYWRvbmx5QXJyYXnroZwg7ISg7Ja47ZWY66m0IOuwsOyXtCDrgrTsmqkg67OA6rK9IOu2iOqwgFJlYWRvbmx5QXJyYXnroZwg7ISg7Ja47ZWY66m0IOuwsOyXtCDrgrTsmqkg67OA6rK9IOu2iOqwgFxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBhcnI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiA9IFsxLDIsM107XFxyXFxuYXJyLnNwbGljZSgwLDEpOyAvLyBlcnJvclxcclxcbmFyci5wdXNoKDQpOyAvLyBlcnJvclxcclxcbmFyclswXSA9IDEwMDsgLy8gZXJyb3JcXHJcXG5hcnIgPSBbMTAsIDIwLCAzMF07IC8vIGVycm9yXFxyXFxuYGBgXFxyXFxuXFxyXFxu6rCd7LK0IOyEoOyWuOqzvCDqtIDroKjrkJwg7YOA7J6FIOyytO2CuVxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBDcmFmdEJlZXIge1xcclxcbiAgYnJhbmQ/OiBzdHJpbmc7XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGJyZXdCZWVyKGJlZXI6IENyYWZ0QmVlcikge1xcclxcbiAgLy8gLi5cXHJcXG59XFxyXFxuYnJld0JlZXIoeyBicmFuZG9uOiAnd2hhdCcgfSk7IC8vIOyGjeyEseydtCDri6TrpbTri4gg7JeQ65+s65y564uI64ukLlxcclxcbmBgYFxcclxcblxcclxcbuydtOufrOuptCDtg4DsnoUg7LK07YGs66W8IOustOyLnO2VnOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgbXlCZWVyID0geyBicmFuZG9uOiAnd2hhdCcgfSc7XFxyXFxuYnJld0JlZXIobXlCZWVyIGFzIENyYWZ0QmVlcik7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIO2VqOyImCDtg4DsnoVcXHJcXG5cXHJcXG7tlajsiJgg66ek6rCc67OA7IiY7JmAIOuwmO2ZmO2DgOyeheuPhCDsnbjthLDtjpjsnbTsiqQg7KCV7J2Y6rCAIOqwgOuKpe2VmOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgbG9naW4ge1xcclxcbiAgKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBib29sZWFuO1xcclxcbn1cXHJcXG5cXHJcXG5sZXQgbG9naW5Vc2VyOiBsb2dpbjsgLy8g7ZWo7IiYIOyggOyepe2VoCDrs4DsiJgg7ISg7Ja4XFxyXFxubG9naW5Vc2VyID0gZnVuY3Rpb24oaWQ6IHN0cmluZywgcHc6IHN0cmluZykge1xcclxcbiAgY29uc29sZS5sb2coJ+uhnOq3uOyduCDtlojsirXri4jri6QnKTtcXHJcXG4gIHJldHVybiB0cnVlO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7tgbTrnpjsiqQg7YOA7J6FXFxyXFxuXFxyXFxu7J6Q67CU7J2YIOyduO2EsO2OmOydtOyKpOyZgCDrqqnsoIHsnbQg67mE7Iq37ZWc642wXFxyXFxuXFxyXFxu7Ja065akIOyduO2EsO2OmOydtOyKpOulvCBpbXBsZW1lbnRz7ZWcIO2BtOuemOyKpOqwgCDsnojri6TrqbRcXHJcXG5cXHJcXG7snbjthLDtjpjsnbTsiqTsnZgg66mU7IaM65Oc7JmAIOuzgOyImOqwgCDsnojri6TripQg6rKD7J2EIOuztOyepe2VnOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgQ3JhZnRCZWVyIHtcXHJcXG4gIGJlZXJOYW1lOiBzdHJpbmc7XFxyXFxuICBuYW1lQmVlcihiZWVyOiBzdHJpbmcpOiB2b2lkO1xcclxcbn1cXHJcXG5cXHJcXG5jbGFzcyBteUJlZXIgaW1wbGVtZW50cyBDcmFmdEJlZXIge1xcclxcbiAgYmVlck5hbWU6IHN0cmluZyA9ICdCYWJ5IEd1aW5uZXNzJztcXHJcXG4gIG5hbWVCZWVyKGI6IHN0cmluZykge1xcclxcbiAgICB0aGlzLmJlZXJOYW1lID0gYjtcXHJcXG4gIH1cXHJcXG4gIGNvbnN0cnVjdG9yKCkge31cXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu7J247YSw7Y6Y7J207IqkIOuBvOumrCDsg4Hsho3rj4Qg6rCA64ql7ZWp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBQZXJzb24ge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbn1cXHJcXG5pbnRlcmZhY2UgRHJpbmtlciB7XFxyXFxuICBkcmluazogc3RyaW5nO1xcclxcbn1cXHJcXG5pbnRlcmZhY2UgRGV2ZWxvcGVyIGV4dGVuZHMgUGVyc29uIHtcXHJcXG4gIHNraWxsOiBzdHJpbmc7XFxyXFxufVxcclxcbmxldCBmZSA9IHt9IGFzIERldmVsb3BlcjtcXHJcXG5mZS5uYW1lID0gJ2pvc2gnO1xcclxcbmZlLnNraWxsID0gJ1R5cGVTY3JpcHQnO1xcclxcbmZlLmRyaW5rID0gJ0JlZXInO1xcclxcbmBgYFxcclxcblxcclxcbiMjIDQuIEVudW1cXHJcXG5cXHJcXG4+IO2KueyglSDqsJLrk6TsnZggKirsp5HtlakqKuydhCDsnZjrr7jtlZjripQg7J6Q66OM7ZiV7Jy866GcIO2BrOqyjCB77Iir7J6Q7ZiVIOydtOuEmCwg66y47J6Q7ZiVIOydtOuEmH0g65GQIOqwgOyngOqwgCDsnojri6RcXHJcXG5cXHJcXG4tIEVudW3snbTrnbzripQg6rCc64WQ7J2EIOydtO2VtO2VmOq4sCDslrTroKTsm6DrjZgg7J207Jyg64qULCBqYXZhc2NyaXB07JeQ64qUIGVudW3snbQg7JeG7JeI6riwIOuVjOusuOydtOuLpC4gKO2VmOyngOunjCDqsoDsg4ntlbTrs7Tri4ggQ+yWuOyWtOyXkOyEnOuKlCDsoJzqs7XtlZjripQg6rKDIOqwmeydjC4pXFxyXFxuXFxyXFxuIyMjIDQtMS4g7Iir7J6Q7ZiVIOydtOuEmFxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gRGlyZWN0aW9uIHtcXHJcXG4gIFVwID0gMSxcXHJcXG4gIERvd24sXFxyXFxuICBMZWZ0LFxcclxcbiAgUmlnaHRcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu7Yq57J207ZWcIOqyg+ydgCDsnbTroIfqsowg7ISg7Ja47ZWY66m0ICDslpHrsKntlqXsnLzroZwg7Zi47Lac7ZWgIOyImCDsnojripQg7Yq57J207ZWcIOyekOujjOq1rOyhsOqwgCDrkJzri6TripQg6rKD7J2064ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmNvbnNvbGUubG9nKERpcmVjdGlvblsxXSkgICAgLy8gXFxcIlVwXFxcIlxcclxcbmNvbnNvbGUubG9nKERpcmVjdGlvbltcXFwiVXBcXFwiXSkgLy8gMVxcclxcbmNvbnNvbGUubG9nKERpcmVjdGlvblszXSkgICAgLy8gXFxcIkxlZnRcXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J207JmAIOqwmeydtCDsiKvsnpDtmJUgRW51beyXkOyEnCBEaXJlY3Rpb24uVXAg7Jy866GcIDHqsJLsnYQg7Ja76rGw64KYIOuwmOuMgOuhnCBEaXJlY3Rpb25bMV3roZwgXFxcIlVwXFxcIuqwkuydhCDslrvripQg6rKD7J2EICoqYOumrOuyhOyKpCDrp6TtlZFgKiog7J2065286rOgIO2VnOuLpC5cXHJcXG5cXHJcXG7snbTroIfqsowg7LSI6riw6rCS7J2EIOyEoOyWuO2VtOyjvOuptCAxLCAyLCAzLCA0IOydmCDsiJzshJzroZwgMeyUqSDspp3qsIDtlZjrqbAg7ZWg64u565Cc64ukLiDrp4zslb0sXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBEaXJlY3Rpb24ge1xcclxcblxcdFVwLCBcXHJcXG5cXHREb3duLFxcclxcblxcdExlZnQsXFxyXFxuXFx0UmlnaHRcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu7Jy866GcIOyEoOyWuOuQmOyXiOuLpOuptCBVcCAtIDAgLCBEb3duIC0gMSwgTGVmdCAtIDIsIFJpZ2h0IC0gM+ydtCDrkJzri6QuXFxyXFxuXFxyXFxuIyMjIDQtMiDsiKvsnpDtmJUgZW51bSDsgqzsmqlcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIFJlc3BvbnNlIHtcXHJcXG4gIE5vID0gMCxcXHJcXG4gIFllcyA9IDEsXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHJlc3BvbmQocmVjaXBpZW50OiBzdHJpbmcsIG1lc3NhZ2U6IFJlc3BvbnNlKTogdm9pZCB7XFxyXFxuICBjb25zb2xlLmxvZyhyZWNpcGllbnQsIG1lc3NhZ2UpXFxyXFxufVxcclxcblxcclxcbnJlc3BvbmQoXFxcIkNhcHRhaW4gUGFuZ3lvXFxcIiwgUmVzcG9uc2UuWWVzKTtcXHJcXG5cXHJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcbltMT0ddOiBcXFwiQ2FwdGFpbiBQYW5neW9cXFwiLCAgMVxcclxcbmBgYFxcclxcblxcclxcbiMjIyA0LTMuIOusuOyekO2YlSBlbnVtXFxyXFxuXFxyXFxuPiDrrLjsnpDtmJUg7J2064SY7J2AIOydtOuEmCDqsJIg7KCE67aAIOuLpCDtirnsoJUg66y47J6QIOuYkOuKlCDri6Trpbgg7J2064SYIOqwkuycvOuhnCDstIjquLDtmZQg7ZW07KSY7JW8IO2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIERpcmVjdGlvbiB7XFxyXFxuICAgIFVwID0gXFxcIlVQXFxcIixcXHJcXG4gICAgRG93biA9IFxcXCJET1dOXFxcIixcXHJcXG4gICAgTGVmdCA9IFxcXCJMRUZUXFxcIixcXHJcXG4gICAgUmlnaHQgPSBcXFwiUklHSFRcXFwiLFxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4qKiDrs7XtlakgZW51bXMgKipcXHJcXG5cXHJcXG7rrLjsnpDsmYAg7Iir7J6Q66W8IO2YvO2Vqe2VmOyXrCBlbnVt7J2EIOyDneyEse2VoCDsiJgg7J6I7Jy864KYLCDqtozsnqXtlZjsp4Ag7JWK64qUIOuwqeyLnSFcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIEJvb2xlYW5MaWtlSGV0ZXJvZ2VuZW91c0VudW0ge1xcclxcbiAgICBObyA9IDAsXFxyXFxuICAgIFllcyA9IFxcXCJZRVNcXFwiLFxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNC00LiDrn7Dtg4DsnoQg7Iuc7KCQ7JeQ7ISc7J2YIOydtOuEmCDtirnsp5VcXHJcXG5cXHJcXG7snbTrhJjsnYAg65+w7YOA7J6E7Iuc7JeQIOyLpOygnCDqsJ3ssrQg7ZiV7YOc66GcIOyhtOyerO2VqeuLiOuLpC4g7JiI66W8IOuTpOyWtCDslYTrnpjsmYAg6rCZ7J2AIOydtOuEmCDsvZTrk5zqsIAg7J6I7J2EIOuVjFxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gRSB7XFxyXFxuICBYLCBZLCBaXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGdldFgob2JqOiB7IFg6IG51bWJlciB9KSB7XFxyXFxuICByZXR1cm4gb2JqLlg7XFxyXFxufVxcclxcbmdldFgoRSk7IC8vIOydtOuEmCBF7J2YIFjripQg7Iir7J6Q7J206riwIOuVjOusuOyXkCDsoJXsg4Eg64+Z7J6RXFxyXFxuLS0tLS1cXHJcXG5RdWl6LiBcXHJcXG5nZXRYKEUp6rCS7J2EIOuzgOyImOyXkCDrhKPslrTshJwg7Lac66Cl7ZWc64uk66m0LCDslrzrp4jrgpgg64KY7Jis6rmMP1xcclxcbmBgYFxcclxcblxcclxcbiMjIyA0LTUuIOy7tO2MjOydvCDsi5zsoJDsl5DshJzsnZgg7J2064SYIO2KueynlVxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gTG9nTGV2ZWwge1xcclxcbiAgRVJST1IsIFdBUk4sIElORk8sIERFQlVHXFxyXFxufVxcclxcblxcclxcbi8vICdFUlJPUicgfCAnV0FSTicgfCAnSU5GTycgfCAnREVCVUcnO1xcclxcbnR5cGUgTG9nTGV2ZWxTdHJpbmdzID0ga2V5b2YgdHlwZW9mIExvZ0xldmVsO1xcclxcblxcclxcbmZ1bmN0aW9uIHByaW50SW1wb3J0YW50KGtleTogTG9nTGV2ZWxTdHJpbmdzLCBtZXNzYWdlOiBzdHJpbmcpIHtcXHJcXG4gICAgY29uc3QgbnVtID0gTG9nTGV2ZWxba2V5XTtcXHJcXG4gICAgaWYgKG51bSA8PSBMb2dMZXZlbC5XQVJOKSB7XFxyXFxuICAgICAgIGNvbnNvbGUubG9nKCdMb2cgbGV2ZWwga2V5IGlzOiAnLCBrZXkpO1xcclxcbiAgICAgICBjb25zb2xlLmxvZygnTG9nIGxldmVsIHZhbHVlIGlzOiAnLCBudW0pO1xcclxcbiAgICAgICBjb25zb2xlLmxvZygnTG9nIGxldmVsIG1lc3NhZ2UgaXM6ICcsIG1lc3NhZ2UpO1xcclxcbiAgICB9XFxyXFxufVxcclxcbnByaW50SW1wb3J0YW50KCdFUlJPUicsICdUaGlzIGlzIGEgbWVzc2FnZScpO1xcclxcblxcclxcbi0tLS0tLS1cXHJcXG5bTE9HXTogXFxcIkxvZyBsZXZlbCBrZXkgaXM6IFxcXCIsICBcXFwiRVJST1JcXFwiIFxcclxcbltMT0ddOiBcXFwiTG9nIGxldmVsIHZhbHVlIGlzOiBcXFwiLCAgMCBcXHJcXG5bTE9HXTogXFxcIkxvZyBsZXZlbCBtZXNzYWdlIGlzOiBcXFwiLCAgXFxcIlRoaXMgaXMgYSBtZXNzYWdlXFxcIlxcclxcbmBgYFxcclxcblxcclxcbiMjIyA0LTYuIFR5cGVzY3JpcHQgZW51beydhCDsgqzsmqntlZjripQg7J207JygXFxyXFxuXFxyXFxuRW51beydgCDstpTsg4HtmZTsnZgg7IiY64uo7J2064ukLlxcclxcblxcclxcbuuLpOq1reyWtCDsvZTrk5wgKExhbmd1YWdlIENvZGUp66W8IO2VoOuLue2VnOuLpOqzoCDsg53qsIHtlbTrs7TsnpBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG50eXBlIExhbmd1YWdlQ29kZSA9ICdrbycgfCAnZW4nIHwgJ2phJyB8ICd6aCcgfCAnZXMnXFxyXFxuXFxyXFxuY29uc3QgY29kZTogTGFuZ3VhZ2VDb2RlID0gJ2tvJ1xcclxcblxcclxcbmNvbnNvbGUubG9nKGNvZGUpIC8vIFtMT0ddOiBcXFwia29cXFwiXFxyXFxuXFxyXFxu7ZWY7KeA66eMIFxcclxcbmNvc3QgY29kZTogTGFuZ3VhZ2VDb2RlID0gJ2hhaGFoYWhhJ1xcclxcbuyZgCDqsJnsnbQg7L2U65Oc66W8IOynnOuptCB0eXBlc2NyaXB07JeQ7IScIOyXkOufrOuhnCDtkZzsi5ztlbTspIDri6QuXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J206rKD64+EIOyii+yngOunjCDrjbDsnbTthLAg7JaR7J20IOunjuyVhOyngOuptCDqsIDrj4XshLHsnbQg66eO7J20IOuWqOyWtOynhOuLpC5cXHJcXG5cXHJcXG7smrDrpqzqsIAg7JuQ7ZWY64qUIOqyg+ydgCBrb3JlYW7snYQg6rKA7IOJ7ZWY66m0ICdrbyfrnbzripQg7L2U65Oc6rCAIOuCmOyZlOycvOuptCDtlZjripQg6rKD7J206rOgIOq4sOyhtCDrsKnsi53snLzroZzripQg64uk7J2M6rO8IOqwmeydtCDrkZAg6rCA7KeAIOuwqeuyleydtCDsnojri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuLy8g7J2066CH6rKMIO2VmOuptCDslrjslrQg7L2U65Oc6rCAIOychOyVhOuemOyXkCDspJHrs7XrkJjqs6BcXHJcXG5jb25zdCBrb3JlYW4gPSAna28nXFxyXFxuY29uc3QgZW5nbGlzaCA9ICdlbidcXHJcXG5jb25zdCBqYXBhbmVzZSA9ICdqYSdcXHJcXG5jb25zdCBjaGluZXNlID0gJ3poJ1xcclxcbmNvbnN0IHNwYW5pc2ggPSAnZXMnXFxyXFxudHlwZSBMYW5ndWFnZUNvZGUgPSAna28nIHwgJ2VuJyB8ICdqYScgfCAnemgnIHwgJ2VzJ1xcclxcbmxldCBjb2RlOiBMYW5ndWFnZUNvZGUgPSBlbmdsaXNoXFxyXFxuY29uc29sZS5sb2coY29kZSkgLy8gXFxcImVuXFxcIlxcclxcbmBgYFxcclxcblxcclxcbmBgYHRzeFxcclxcbi8vIOydtOugh+qyjCDtlZjrqbQg7L2U65Oc6rCAIOuEiOustCDquLjslrTsp5Hri4jri6RcXHJcXG5jb25zdCBrb3JlYW4gPSAna28nXFxyXFxuY29uc3QgZW5nbGlzaCA9ICdlbidcXHJcXG5jb25zdCBqYXBhbmVzZSA9ICdqYSdcXHJcXG5jb25zdCBjaGluZXNlID0gJ3poJ1xcclxcbmNvbnN0IHNwYW5pc2ggPSAnZXMnXFxyXFxudHlwZSBMYW5ndWFnZUNvZGUgPSB0eXBlb2Yga29yZWFuIHwgdHlwZW9mIGVuZ2xpc2ggfCB0eXBlb2YgamFwYW5lc2UgfCB0eXBlb2YgY2hpbmVzZSB8IHR5cGVvZiBzcGFuaXNoXFxyXFxubGV0IGNvZGU6IExhbmd1YWdlQ29kZSA9IHNwYW5pc2hcXHJcXG5jb25zb2xlLmxvZyhjb2RlKSAvLyBcXFwiZXNcXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J2065+s7ZWcIOydtOycoCDrlYzrrLjsl5Ag66as7YSw65+07J2YIO2DgOyeheqzvCDqsJLsl5Ag7J2066aE7J2EIOu2meyduCBgZW51bWDsnYQg7Zmc7Jqp7ZWY66m0IOqwgOuPheyEseydhCDtgazqsowg64aS7J28IOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBMYW5ndWFnZUNvZGUge1xcclxcbiAga29yZWFuID0gJ2tvJyxcXHJcXG4gIGVuZ2xpc2ggPSAnZW4nLFxcclxcbiAgamFwYW5lc2UgPSAnamEnLFxcclxcbiAgY2hpbmVzZSA9ICd6aCcsXFxyXFxuICBzcGFuaXNoID0gJ2VzJyxcXHJcXG59XFxyXFxuLy8g7Jes6riw7IScIFxcclxcbi8vIExhbmd1YWdlQ29kZS5rb3JlYW4gPT09ICdrbydcXHJcXG4vLyAo7J2Y66+47IOBKSBMYW5ndWFnZUNvZGUgPT09ICdrbycgfCAnZW4nIHwgJ2phJyB8ICd6aCcgfCAnZXMnXFxyXFxuY29uc3QgY29kZTogTGFuZ3VhZ2VDb2RlID0gTGFuZ3VhZ2VDb2RlLmtvcmVhblxcclxcbmNvbnNvbGUubG9nKGNvZGUpIC8vIFxcXCJrb1xcXCJcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNC03LiBUeXBlc2NyaXB0IGVudW3snYQg7IKs7Jqp7ZWY7KeAIOyViuuKlCDsnbTsnKBcXHJcXG5cXHJcXG4jIyMgVHJlZS1zaGFraW5n7J2AIOustOyXh+yduOqwgOyalD9cXHJcXG5cXHJcXG5UcmVlLXNoYWtpbmfsnbTrnoAg6rCE64uo7ZWY6rKMIOunkO2VtCDsgqzsmqntlZjsp4Ag7JWK64qUIOy9lOuTnOulvCDsgq3soJztlZjripQg6riw64ql7J2EIOunkO2VqeuLiOuLpC4g64KY66y066W8IO2dlOuTpOuptCDso73snYAg7J6O7IKs6reA65Ok7J20IOuWqOyWtOyngOuKlCDrqqjsirXsl5Ag7LCp7JWI7ZW0IFRyZWUtc2hha2luZ+ydtOudvOqzoCDrtoDrpoXri4jri6QuIFRyZWUtc2hha2luZ+ydhCDthrXtlbQgZXhwb3J07ZaI7KeA66eMIOyVhOustCDrjbDshJzrj4QgaW1wb3J07ZWY7KeAIOyViuydgCDrqqjrk4jsnbTrgpgg7IKs7Jqp7ZWY7KeAIOyViuuKlCDsvZTrk5zrpbwg7IKt7KCc7ZW07IScIOuyiOuTpCDtgazquLDrpbwg7KSE7JesIO2OmOydtOyngOqwgCDtkZzsi5zrkJjripQg7Iuc6rCE7J2EIOuLqOy2le2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbu2VmOyngOunjCBlbnVt7J2EIOyCrOyaqe2VmOqyjCDrkJjrqbQgVHJlZS1zaGFraW5n7J20IOuQmOyngCDslYrsirXri4jri6QuXFxyXFxuXFxyXFxu6rKw66Gg7KCB7Jy866GcICBUcmVlLXNoYWtpbmcg6rSA7KCQ7JeQ7IScIOuztOyVmOydhCDrlYwg7JWE656Y7JmAIOqwmeydgCDsiJzshJzroZwg7IKs7Jqp7ZWY7Iuc6ri4IOy2lOyynO2VmOupsCDquIDsnYQg66eI7LmY6rKg7Iq164uI64ukLlxcclxcblxcclxcbj4gVW5pb24gVHlwZXMgPiBjb25zdCBlbnVtID4gZW51bVxcclxcblxcclxcbioq7KCV66asKipcXHJcXG5cXHJcXG4tIOqwmeydgCDigJjsooXrpZjigJnrpbwg64KY7YOA64K064qUIOyXrOufrCDqsJzsnZgg7Iir7J6QIO2YueydgCDrrLjsnpDsl7TsnYQg64uk66SE7JW8IO2VmOuKlOuNsCwgXFxyXFxu6rCB6rCBIOyggeuLue2VnCDsnbTrpoTsnYQg67aZ7Jes7IScIOy9lOuTnOydmCDqsIDrj4XshLHsnYQg64aS7J206rOgIOyLtuuLpOuptCBlbnVt7J2EIOyCrOyaqSFcXHJcXG5cXHJcXG4jIyA1LiDsl7DsgrDsnpDrpbwg7J207Jqp7ZWcIO2DgOyehSDsoJXsnZhcXHJcXG5cXHJcXG4jIyMgNS0xLiBVbmlvbiBUeXBlICggfCApXFxyXFxuXFxyXFxu7Jyg64uI7JioIO2DgOyehShVbmlvbiBUeXBlKeydtOuegCDsnpDrsJTsiqTtgazrpr3tirjsnZggT1Ig7Jew7IKw7J6QKHx8KeyZgCDqsJnsnbQgQeydtOqxsOuCmCBC7J2064ukIOudvOuKlCDsnZjrr7jsnZgg7YOA7J6FXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gbG9nVGV4dCh0ZXh0OiBzdHJpbmcgfCBudW1iZXIpIHtcXHJcXG4gIC8vIC4uLlxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4tIHRleHTripQgc3RyaW5n7J206rGw64KYIChPUiB8fCApIG51bWJlcuydtOuLpC4g7KaJLCDrkZgg64ukIOyYrCDsiJgg7J6I64uk64qUIOucuy5cXHJcXG4tIOydtOyymOufvCBgfGAg7Jew7IKw7J6Q66W8IOydtOyaqe2VmOyXrCDtg4DsnoXsnYQg7Jes65+sIOqwnCDsl7DqsrDtlZjripQg67Cp7Iud7J2EIGDsnKDri4jsmKgg7YOA7J6FIOygleydmCDrsKnsi51gIOydtOudvCDrtoDrpbjri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZnVuY3Rpb24gZ2V0QWdlKGFnZTogbnVtYmVyIHwgc3RyaW5nKSB7XFxyXFxuICBpZiAodHlwZW9mIGFnZSA9PT0gJ251bWJlcicpIHtcXHJcXG4gICAgYWdlLnRvRml4ZWQoKTsgLy8g7KCV7IOBIOuPmeyekSwgYWdl7J2YIO2DgOyeheydtCBgbnVtYmVyYOuhnCDstpTroaDrkJjquLAg65WM66y47JeQIOyIq+yekCDqtIDroKjrkJwgQVBJ66W8IOyJveqyjCDsnpDrj5nsmYTshLEg7ZWgIOyImCDsnojri6QuXFxyXFxuICAgIHJldHVybiBhZ2U7XFxyXFxuICB9XFxyXFxuICBpZiAodHlwZW9mIGFnZSA9PT0gJ3N0cmluZycpIHtcXHJcXG4gICAgcmV0dXJuIGFnZTtcXHJcXG4gIH1cXHJcXG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdhZ2UgbXVzdCBiZSBudW1iZXIgb3Igc3RyaW5nJyk7XFxyXFxufVxcclxcbmNvbnNvbGUubG9nKGdldEFnZSgxMCkpXFxyXFxuY29uc29sZS5sb2coZ2V0QWdlKCdIZWxsbyBXb3JsZCcpKVxcclxcbmNvbnNvbGUubG9nKGdldEFnZSh0cnVlKSlcXHJcXG4tLS0g7Lac66ClIC0tLVxcclxcbltMT0ddOiAxMCBcXHJcXG5bTE9HXTogXFxcIkhlbGxvIFdvcmxkXFxcIiBcXHJcXG5bTE9HXTogYWdlIG11c3QgYmUgbnVtYmVyIG9yIHN0cmluZ1xcclxcbmBgYFxcclxcblxcclxcbiMjIyA1LTIuIEludGVyc2VjdGlvbiBUeXBlICggJiApXFxyXFxuXFxyXFxu7Jes65+sIO2DgOyeheydhCDrqqjrkZAg66eM7KGx7ZWY64qUIO2VmOuCmOydmCDtg4DsnoXsnYQg7J2Y66+4LlxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBQZXJzb24ge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgYWdlOiBudW1iZXI7XFxyXFxufVxcclxcbmludGVyZmFjZSBEZXZlbG9wZXIge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgc2tpbGw6IG51bWJlcjtcXHJcXG59XFxyXFxudHlwZSBDYXB0ID0gUGVyc29uICYgRGV2ZWxvcGVyO1xcclxcbmBgYFxcclxcblxcclxcbmBgYHRzeFxcclxcbi8vIENhcHTsnZgg7YOA7J6F7J2AXFxyXFxuXFxyXFxue1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgYWdlOiBudW1iZXI7XFxyXFxuICBza2lsbDogc3RyaW5nO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4hW0ludGVyc2VjdGlvbiBUeXBlXShodHRwczovL2pvc2h1YTE5ODguZ2l0aHViLmlvL3RzL2Fzc2V0cy9pbWcvaW50ZXJzZWN0aW9uLWRpYWdyYW0uMDFmNGZkZmUucG5nKVxcclxcblxcclxcbiMjIyA1LTMuIFVuaW9uIFR5cGXsnYQg7JO4IOuVjCDso7zsnZjtlaAg7KCQXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIFBlcnNvbiB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBhZ2U6IG51bWJlcjtcXHJcXG59XFxyXFxuaW50ZXJmYWNlIERldmVsb3BlciB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBza2lsbDogc3RyaW5nO1xcclxcbn1cXHJcXG5mdW5jdGlvbiBpbnRyb2R1Y2Uoc29tZW9uZTogUGVyc29uIHwgRGV2ZWxvcGVyKSB7XFxyXFxuICBzb21lb25lLm5hbWU7IC8vIE8g7KCV7IOBIOuPmeyekVxcclxcbiAgc29tZW9uZS5hZ2U7IC8vIFgg7YOA7J6FIOyYpOulmCAtPiDtg4DsnoXsiqTtgazrpr3tirjsl5DshJwg67mo6rCE7KSE66GcIO2RnOyLnO2VtOykjFxcclxcbiAgc29tZW9uZS5za2lsbDsgLy8gWCDtg4DsnoUg7Jik66WYIC0+IO2DgOyeheyKpO2BrOumve2KuOyXkOyEnCDruajqsITspITroZwg7ZGc7Iuc7ZW07KSMXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbuycoOuLiOyYqCDtg4DsnoXsnYAgQeuPhCDrkKAg7IiYIOyeiOqzoCBC64+EIOuQoCDsiJgg7J6I64qUIO2DgOyeheydtOyngOudvOqzoCDsg53qsIHtlZjrqbQg7YyM652866+47YSw7J2YIO2DgOyeheydtCBQZXJzb27rj4Qg65CY6rOgIERldmVsb3BlcuuPhCDrkKDthYzri4jquYwg7ZWo7IiYIOyViOyXkOyEnCDri7nsl7Dtnogg7J20IOyduO2EsO2OmOydtOyKpOuTpOydtCDsoJzqs7XtlZjripQg7IaN7ISx65Ok7J24IGFnZeuCmCBza2lsbOulvCDsgqzsmqntlaAg7IiYIOyeiOqyoOyngOudvOqzoCDsg53qsIHtlaAg7IiYIOyeiOyKteuLiOuLpC4gXFxyXFxuXFxyXFxu7ZWY7KeA66eMLCDtg4DsnoXsiqTtgazrpr3tirgg6rSA7KCQ7JeQ7ISc64qUIGludHJvZHVjZSgpIO2VqOyImOulvCDtmLjstpztlZjripQg7Iuc7KCQ7JeQIFBlcnNvbiDtg4DsnoXsnbQg7Jis7KeAIERldmVsb3BlciDtg4DsnoXsnbQg7Jis7KeAIOyVjCDsiJjqsIAg7JeG6riwIOuVjOusuOyXkCDslrTripAg7YOA7J6F7J20IOuTpOyWtOyYpOuToCDqsITsl5Ag7Jik66WY6rCAIOyViCDrgpjripQg67Cp7Zal7Jy866GcIO2DgOyeheydhCDstpTroaDtlZjqsowg65Cp64uI64ukLlxcclxcblxcclxcbuuUsOudvOyEnCDsnITsnZgg7JiI7IucIOqwmeydgCDqsr3smrDsl5DripQg7J2Y64+E7JmA64qUIOuLrOumrCBbc29tZW9uZS5uYW1lXShodHRwOi8vc29tZW9uZS5uYW1lKSDrp4wg7KCV7IOB7KCB7Jy866GcIOyekeuPme2VmOqyjCDrkKnri4jri6QuXFxyXFxuXFxyXFxuIyMgNi4gQ2xhc3NcXHJcXG5cXHJcXG4jIyMgNi0xLiBSZWFkb25seVxcclxcblxcclxcbmBgYHRzeFxcclxcbmNsYXNzIERldmVsb3BlciB7XFxyXFxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcXHJcXG4gICAgY29uc3RydWN0b3IodGhlTmFtZTogc3RyaW5nKSB7XFxyXFxuICAgICAgICB0aGlzLm5hbWUgPSB0aGVOYW1lO1xcclxcbiAgICB9XFxyXFxufVxcclxcbmxldCBqb2huID0gbmV3IERldmVsb3BlcihcXFwiSm9oblxcXCIpO1xcclxcbmpvaG4ubmFtZSA9IFxcXCJKb2huXFxcIjsgLy8gZXJyb3IhIG5hbWUgaXMgcmVhZG9ubHkuXFxyXFxuY29uc29sZS5sb2coam9obilcXHJcXG4tLS0g7Lac66ClIC0tLVxcclxcbltMT0ddOiBEZXZlbG9wZXI6IHtcXHJcXG4gIFxcXCJuYW1lXFxcIjogXFxcIkpvaG5cXFwiXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbiMjIyA2LTIuIEFjY2Vzc29yXFxyXFxuXFxyXFxu7YOA7J6F7Iqk7YGs66a97Yq464qUIOqwneyytOydmCDtirnsoJUg7IaN7ISx7J2YIOygkeq3vOqzvCDtlaDri7nsl5Ag64yA7ZW0IOygnOyWtO2VoCDsiJgg7J6I7Iq164uI64ukLiDsnbTrpbwg7JyE7ZW07ISgIO2VtOuLuSDqsJ3ssrTqsIAg7YG0656Y7Iqk66GcIOyDneyEse2VnCDqsJ3ssrTsl6zslbwg7ZWp64uI64ukLiDslYTrnpjsnZgg6rCE64uo7ZWcIOyYiOygnOulvCDrtIXsi5zri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuY2xhc3MgRGV2ZWxvcGVyIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG59XFxyXFxuY29uc3Qgam9zaCA9IG5ldyBEZXZlbG9wZXIoKTtcXHJcXG5qb3NoLm5hbWUgPSAnSm9zaCBCb2x0b24nO1xcclxcbmBgYFxcclxcblxcclxcbuychCDsvZTrk5zripQg7YG0656Y7Iqk66GcIOyDneyEse2VnCDqsJ3ssrTsnZggYG5hbWVgIOyGjeyEseyXkCBgSm9zaCBCb2x0b25g7J20652864qUIOqwkuydhCDrjIDsnoXtlZwg7L2U65Oc7J6F64uI64ukLiDsnbTsoJwgYGpvc2hg652864qUIOqwneyytOydmCBgbmFtZWAg7IaN7ISx7J2AIGBKb3NoIEJvbHRvbmDsnbTrnbzripQg6rCS7J2EIOqwluqyoOyjoC5cXHJcXG5cXHJcXG7sl6zquLDshJwg66eM7JW9IGBuYW1lYCDsho3shLHsl5Ag7KCc7JW9IOyCrO2VreydhCDstpTqsIDtlZjqs6Ag7Iu264uk66m0IOyVhOuemOyZgCDqsJnsnbQgYGdldGDqs7wgYHNldGDsnYQg7Zmc7Jqp7ZWp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmNsYXNzIERldmVsb3BlciB7XFxyXFxuICBwcml2YXRlIG5hbWU6IHN0cmluZztcXHJcXG4gIFxcclxcbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcXHJcXG4gICAgcmV0dXJuIHRoaXMubmFtZTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHNldCBuYW1lKG5ld1ZhbHVlOiBzdHJpbmcpIHtcXHJcXG4gICAgaWYgKG5ld1ZhbHVlICYmIG5ld1ZhbHVlLmxlbmd0aCA+IDUpIHtcXHJcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ+ydtOumhOydtCDrhIjrrLQg6rmB64uI64ukJyk7XFxyXFxuICAgIH1cXHJcXG4gICAgdGhpcy5uYW1lID0gbmV3VmFsdWU7XFxyXFxuICB9XFxyXFxufVxcclxcbmNvbnN0IGpvc2ggPSBuZXcgRGV2ZWxvcGVyKCk7XFxyXFxuam9zaC5uYW1lID0gJ0pvc2ggQm9sdG9uJzsgLy8gRXJyb3JcXHJcXG5qb3NoLm5hbWUgPSAnSm9zaCc7XFxyXFxuYGBgXFxyXFxuXFxyXFxuVElQIVxcclxcbmdldOunjCDshKDslrjtlZjqs6Agc2V07J2EIOyEoOyWuO2VmOyngCDslYrripQg6rK97Jqw7JeQ64qUIOyekOuPmeycvOuhnCByZWFkb25seeuhnCDsnbjsi53rkKnri4jri6QuXFxyXFxuXFxyXFxuIyMjIDYtMy4gQWJzdHJhY3QgQ2xhc3NcXHJcXG5cXHJcXG7stpTsg4Eg7YG0656Y7IqkKEFic3RyYWN0IENsYXNzKeuKlCDsnbjthLDtjpjsnbTsiqTsmYAg67mE7Iq37ZWcIOyXre2VoOydhCDtlZjrqbTshJzrj4Qg7KGw6riIIOuLpOuluCDtirnsp5XsnYQg6rCW6rOgIOyeiOyKteuLiOuLpC4g7LaU7IOBIO2BtOuemOyKpOuKlCDtirnsoJUg7YG0656Y7Iqk7J2YIOyDgeyGjSDrjIDsg4HsnbQg65CY64qUIO2BtOuemOyKpOydtOupsCDsooAg642UIOyDgeychCDroIjrsqjsl5DshJwg7IaN7ISxLCDrqZTshJzrk5zsnZgg66qo7JaR7J2EIOygleydmO2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5hYnN0cmFjdCBjbGFzcyBEZXZlbG9wZXIge1xcclxcbiAgYWJzdHJhY3QgY29kaW5nKCk6IHZvaWQ7IC8vICdhYnN0cmFjdCfqsIAg67aZ7Jy866m0IOyDgeyGjSDrsJvsnYAg7YG0656Y7Iqk7JeQ7IScIOustOyhsOqxtCDqtaztmITtlbTslbwg7ZWoXFxyXFxuICBkcmluaygpOiB2b2lkIHtcXHJcXG4gICAgY29uc29sZS5sb2coJ2RyaW5rIHN0aCcpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5jbGFzcyBGcm9udEVuZERldmVsb3BlciBleHRlbmRzIERldmVsb3BlciB7XFxyXFxuICBjb2RpbmcoKTogdm9pZCB7XFxyXFxuICAgIC8vIERldmVsb3BlciDtgbTrnpjsiqTrpbwg7IOB7IaNIOuwm+ydgCDtgbTrnpjsiqTsl5DshJwg66y07KGw6rG0IOygleydmO2VtOyVvCDtlZjripQg66mU7ISc65OcXFxyXFxuICAgIGNvbnNvbGUubG9nKCdkZXZlbG9wIHdlYicpO1xcclxcbiAgfVxcclxcbiAgZGVzaWduKCk6IHZvaWQge1xcclxcbiAgICBjb25zb2xlLmxvZygnZGVzaWduIHdlYicpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5jb25zdCBkZXYgPSBuZXcgRGV2ZWxvcGVyKCk7IC8vIGVycm9yOiBjYW5ub3QgY3JlYXRlIGFuIGluc3RhbmNlIG9mIGFuIGFic3RyYWN0IGNsYXNzXFxyXFxuY29uc3Qgam9zaCA9IG5ldyBGcm9udEVuZERldmVsb3BlcigpO1xcclxcbmpvc2guY29kaW5nKCk7IC8vIGRldmVsb3Agd2ViXFxyXFxuam9zaC5kcmluaygpOyAvLyBkcmluayBzdGhcXHJcXG5qb3NoLmRlc2lnbigpOyAvLyBkZXNpZ24gd2ViXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLS0tXFxyXFxuUmVmZXJlbmNlc1xcclxcbmh0dHBzOi8vam9zaHVhMTk4OC5naXRodWIuaW8vdHMvXFxyXFxuXFxyXFxuW1R5cGVTY3JpcHQgZW51beydhCDsgqzsmqntlZjripQg7J207JygXShodHRwczovL21lZGl1bS5jb20vQHNldW5naGFfa2ltX0lUL3R5cGVzY3JpcHQtZW51beydhC3sgqzsmqntlZjripQt7J207JygLTNiM2NjZDhlNTU1MilcXHJcXG5cXHJcXG5bVHlwZVNjcmlwdCBlbnVt7J2EIOyCrOyaqe2VmOyngCDslYrripQg6rKMIOyii+ydgCDsnbTsnKBdKGh0dHBzOi8vZW5naW5lZXJpbmcubGluZWNvcnAuY29tL2tvL2Jsb2cvdHlwZXNjcmlwdC1lbnVtLXRyZWUtc2hha2luZy8pXFxyXFxuXFxyXFxuW0PslrjslrQgRW51bV0oaHR0cHM6Ly9kb2phbmcuaW8vbW9kL3BhZ2Uvdmlldy5waHA/aWQ9NDgwKVwiOyJdLCJzb3VyY2VSb290IjoiIn0=