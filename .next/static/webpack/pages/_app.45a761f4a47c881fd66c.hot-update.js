self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md":
/*!************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Javascript 자주쓰는 내장 함수 복습하기\"\r\ndate: \"2021.03.31\"\r\ntags: \r\n  - javascript\r\n  - es6\r\n---\r\n\r\n\r\n\r\n# 자주쓰는 JS 내장함수 :map, find, findIndex, filter, indexOf, splice, slice, shift & pop, join, reduce\r\n\r\n## 1. map\r\n\r\nmap은 배열 안의 각 원소를 변환 할 때 사용 되며, 이 과정에서 새로운 배열이 만들어집니다. 배열.map()\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconst square = n => n**2\r\nconst squared = array.map(square)\r\nconsole.log(squared)\r\n\r\n// [1,  4,  9, 16, 25, 36, 49, 64]\r\n```\r\n\r\n- map안에 들어가는 square같은 함수를 `변화함수`라고 한다.\r\n- 변화함수를 쓰지 않고 바로 해도 된다\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconst squared = array.map(n => n**2)\r\nconsole.log(squared)\r\n// 결과는 같다. [1,  4,  9, 16, 25, 36, 49, 64]\r\n```\r\n\r\n## 2. indexOf\r\n\r\nindexOf 는 원하는 항목이 배열 내 몇번째 원소인지 찾아주는 함수입니다.\r\n\r\n```jsx\r\nconst superheroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지']\r\nconst index = superheroes.indexOf('토르')\r\nconsole.log(index)\r\n// 2\r\n```\r\n\r\n## 3. findIndex - 찾아낸 값의 index를 반환\r\n\r\n배열 안에 있는 값이 객체이거나, 배열이라면 indexOf 로 찾을 수 없습니다. 이럴 때 findIndex를 사용합니다.\r\n\r\n```jsx\r\n// todos에서 id가 3인 객체가 몇 번째 인지 찾기\r\n\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst index = todos.findIndex(todo => todo.id === 3);\r\nconsole.log(index);\r\n\r\n// 2\r\n```\r\n\r\n## 4. find - 찾아낸 값 자체를 반환\r\n\r\n```jsx\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst todo = todos.find(todo => todo.id === 3);\r\nconsole.log(todo);\r\n\r\n// {id: 3, text: \"객체와 배열 배우기\", done: true}\r\n```\r\n\r\n## 5. filter\r\n\r\n특정 조건을 만족하는 값들만 따로 추출하여 새로운 배열을 만듭니다.\r\n\r\n```jsx\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst tasksNotDone = todos.filter(todo => todo.done === false);\r\nconsole.log(tasksNotDone);\r\n/* \r\ntodo.done이 false인 {id: 4, text: '배열 내장함수 배우기', done: false} \r\n객체만 새로운 배열(taskNotDone) 안에 들어간다.\r\n[ { id: 4, text: '배열 내장함수 배우기', done: false } ]\r\n\r\n*/\r\n\r\n//  이렇게 표현할 수도 있다.\r\nconst tasksNotDone = todos.filter(todo => !todo.done);\r\n```\r\n\r\n## 6. splice\r\n\r\n배열에서 특정 항목을 제거할 때 사용된다. 인덱스 값으로 지우는 것이기 때문에 인덱스를 먼저 구하고 해당 인덱스로부터 몇 개나 지울 것인지 선택하여 여러값을 한 번에 지울 수 있다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst index = numbers.indexOf(30);\r\nnumbers.splice(index, 1);\r\nconsole.log(numbers);\r\n\r\n// 30의 index = 2이고 2번째 인덱스로부터 한 개의 값을 지우므로 30만 지워진다.\r\n// [10, 20, 40]\r\n```\r\n\r\n## 7. slice\r\n\r\n기존 배열에 변화를 일으키지 않고 슬라이싱 하여 새로운 배열을 생성한다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst sliced = numbers.slice(0, 2); // 0부터 시작해서 2전까지\r\n\r\nconsole.log(sliced); // [10, 20]\r\nconsole.log(numbers); // [10, 20, 30, 40]\r\n```\r\n\r\n## 8. shift & pop\r\n\r\nshift는 배열의 첫 번째 값을 뽑아내고, pop은 맨 뒤의 값을 뽑아낸다. python과 비교하면 shift = pop(0), pop은 똑같다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst value = numbers.shift();\r\nconsole.log(value); // 10\r\nconst value2 = numbers.pop();\r\nconsole.log(value2); // 40\r\nconsole.log(numbers); //[20, 30]\r\n```\r\n\r\n## 9. join\r\n\r\n배열 안의 값들을 문자열 형태로 합쳐줍니다.\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5];\r\nconsole.log(array.join()); // 1,2,3,4,5\r\nconsole.log(array.join(' ')); // 1 2 3 4 5\r\nconsole.log(array.join(', ')); // 1, 2, 3, 4, 5\r\n```\r\n\r\n## 10. reduce\r\n\r\n배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다. 앞의 문장만 읽어서는 이해하기 어려운데, 내가 지정해준 함수를 실행 후 나온 결과값을 다시 파라미터로 사용하도록 합니다. 아래 예를 통해 이해해봅시다.\r\n\r\n```jsx\r\n// 기존 방식\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\nlet sum = 0;\r\nnumbers.forEach(n => {\r\n  sum += n;\r\n});\r\nconsole.log(sum);  //15\r\n\r\n//reduce를 사용하는 방식\r\nconst numbers = [1, 2, 3, 4, 5];\r\nlet sum = array.reduce((accumulator, current) => accumulator + current, 0);\r\n\r\nconsole.log(sum);  //15\r\nconst numbers = [1, 2, 3, 4, 5];\r\nlet sum = numbers.reduce((accumulator, current) => {\r\n  console.log({ accumulator, current });\r\n  return accumulator + current;\r\n}, 0);\r\n\r\nconsole.log(sum);\r\n\r\n// 결과\r\n{ accumulator: 0, current: 1 }\r\n{ accumulator: 1, current: 2 }\r\n{ accumulator: 3, current: 3 }\r\n{ accumulator: 6, current: 4 }\r\n{ accumulator: 10, current: 5 }\r\n15\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n**references**\r\n\r\n[LearnJS GitBook](https://learnjs.vlpt.us/basics/09-array-functions.html)");

/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDMtMzEtSmF2YXNjcmlwdC3snpDso7zsk7DripQt64K07J6lLe2VqOyImC3rs7XsirXtlZjquLAubWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLCtEQUFlLGtYQUFrWCwyUUFBMlEsOGhCQUE4aEIsaUVBQWlFLFFBQVEsOERBQThELFFBQVEsa0VBQWtFLFFBQVEsb0VBQW9FLE1BQU0sNkRBQTZELHVCQUF1Qiw0RkFBNEYsaUVBQWlFLFFBQVEsOERBQThELFFBQVEsa0VBQWtFLFFBQVEsb0VBQW9FLE1BQU0sdURBQXVELHNCQUFzQixZQUFZLHdDQUF3QyxnSEFBZ0gsaUVBQWlFLFFBQVEsOERBQThELFFBQVEsa0VBQWtFLFFBQVEsb0VBQW9FLE1BQU0sdUVBQXVFLDhCQUE4Qiw4QkFBOEIsd0NBQXdDLDRDQUE0QywwQ0FBMEMsZ0dBQWdHLDJMQUEyTCxzQ0FBc0MsNkJBQTZCLHlCQUF5Qiw0TUFBNE0sdUNBQXVDLDZDQUE2QyxxQ0FBcUMsaU1BQWlNLGtDQUFrQyx1QkFBdUIsdUNBQXVDLHdCQUF3QiwrQkFBK0Isb0hBQW9ILDhCQUE4Qiw4Q0FBOEMsK0NBQStDLCtQQUErUCxvQkFBb0IsMEJBQTBCLGVBQWUsS0FBSyxFQUFFLHFCQUFxQixtRUFBbUUsK0VBQStFLHlCQUF5QiwwQ0FBMEMsd0RBQXdELG1CQUFtQix1QkFBdUIsRUFBRSxtQ0FBbUMsS0FBSyxLQUFLLHlCQUF5QixrQkFBa0IsNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssOEJBQThCLHdJQUF3SSxFIiwiZmlsZSI6InN0YXRpYy93ZWJwYWNrL3BhZ2VzL19hcHAuNDVhNzYxZjRhNDdjODgxZmQ2NmMuaG90LXVwZGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJKYXZhc2NyaXB0IOyekOyjvOyTsOuKlCDrgrTsnqUg7ZWo7IiYIOuzteyKte2VmOq4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wMy4zMVxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gamF2YXNjcmlwdFxcclxcbiAgLSBlczZcXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIOyekOyjvOyTsOuKlCBKUyDrgrTsnqXtlajsiJggOm1hcCwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXIsIGluZGV4T2YsIHNwbGljZSwgc2xpY2UsIHNoaWZ0ICYgcG9wLCBqb2luLCByZWR1Y2VcXHJcXG5cXHJcXG4jIyAxLiBtYXBcXHJcXG5cXHJcXG5tYXDsnYAg67Cw7Je0IOyViOydmCDqsIEg7JuQ7IaM66W8IOuzgO2ZmCDtlaAg65WMIOyCrOyaqSDrkJjrqbAsIOydtCDqs7zsoJXsl5DshJwg7IOI66Gc7Jq0IOuwsOyXtOydtCDrp4zrk6TslrTsp5Hri4jri6QuIOuwsOyXtC5tYXAoKVxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xcclxcbmNvbnN0IHNxdWFyZSA9IG4gPT4gbioqMlxcclxcbmNvbnN0IHNxdWFyZWQgPSBhcnJheS5tYXAoc3F1YXJlKVxcclxcbmNvbnNvbGUubG9nKHNxdWFyZWQpXFxyXFxuXFxyXFxuLy8gWzEsICA0LCAgOSwgMTYsIDI1LCAzNiwgNDksIDY0XVxcclxcbmBgYFxcclxcblxcclxcbi0gbWFw7JWI7JeQIOuTpOyWtOqwgOuKlCBzcXVhcmXqsJnsnYAg7ZWo7IiY66W8IGDrs4DtmZTtlajsiJhg65286rOgIO2VnOuLpC5cXHJcXG4tIOuzgO2ZlO2VqOyImOulvCDsk7Dsp4Ag7JWK6rOgIOuwlOuhnCDtlbTrj4Qg65Cc64ukXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgYXJyYXkgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XFxyXFxuY29uc3Qgc3F1YXJlZCA9IGFycmF5Lm1hcChuID0+IG4qKjIpXFxyXFxuY29uc29sZS5sb2coc3F1YXJlZClcXHJcXG4vLyDqsrDqs7zripQg6rCZ64ukLiBbMSwgIDQsICA5LCAxNiwgMjUsIDM2LCA0OSwgNjRdXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgMi4gaW5kZXhPZlxcclxcblxcclxcbmluZGV4T2Yg64qUIOybkO2VmOuKlCDtla3rqqnsnbQg67Cw7Je0IOuCtCDrqofrsojsp7gg7JuQ7IaM7J247KeAIOywvuyVhOyjvOuKlCDtlajsiJjsnoXri4jri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3Qgc3VwZXJoZXJvZXMgPSBbJ+yVhOydtOyWuOunqCcsICfsuqHti7Qg7JWE66mU66as7Lm0JywgJ+2GoOultCcsICfri6XthLAg7Iqk7Yq466CI7J247KeAJ11cXHJcXG5jb25zdCBpbmRleCA9IHN1cGVyaGVyb2VzLmluZGV4T2YoJ+2GoOultCcpXFxyXFxuY29uc29sZS5sb2coaW5kZXgpXFxyXFxuLy8gMlxcclxcbmBgYFxcclxcblxcclxcbiMjIDMuIGZpbmRJbmRleCAtIOywvuyVhOuCuCDqsJLsnZggaW5kZXjrpbwg67CY7ZmYXFxyXFxuXFxyXFxu67Cw7Je0IOyViOyXkCDsnojripQg6rCS7J20IOqwneyytOydtOqxsOuCmCwg67Cw7Je07J20652866m0IGluZGV4T2Yg66GcIOywvuydhCDsiJgg7JeG7Iq164uI64ukLiDsnbTrn7Qg65WMIGZpbmRJbmRleOulvCDsgqzsmqntlanri4jri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8gdG9kb3Psl5DshJwgaWTqsIAgM+yduCDqsJ3ssrTqsIAg66qHIOuyiOynuCDsnbjsp4Ag7LC+6riwXFxyXFxuXFxyXFxuY29uc3QgdG9kb3MgPSBbXFxyXFxuICB7XFxyXFxuICAgIGlkOiAxLFxcclxcbiAgICB0ZXh0OiAn7J6Q67CU7Iqk7YGs66a97Yq4IOyeheusuCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAyLFxcclxcbiAgICB0ZXh0OiAn7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAzLFxcclxcbiAgICB0ZXh0OiAn6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogNCxcXHJcXG4gICAgdGV4dDogJ+uwsOyXtCDrgrTsnqXtlajsiJgg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogZmFsc2VcXHJcXG4gIH1cXHJcXG5dO1xcclxcblxcclxcbmNvbnN0IGluZGV4ID0gdG9kb3MuZmluZEluZGV4KHRvZG8gPT4gdG9kby5pZCA9PT0gMyk7XFxyXFxuY29uc29sZS5sb2coaW5kZXgpO1xcclxcblxcclxcbi8vIDJcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA0LiBmaW5kIC0g7LC+7JWE64K4IOqwkiDsnpDssrTrpbwg67CY7ZmYXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgdG9kb3MgPSBbXFxyXFxuICB7XFxyXFxuICAgIGlkOiAxLFxcclxcbiAgICB0ZXh0OiAn7J6Q67CU7Iqk7YGs66a97Yq4IOyeheusuCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAyLFxcclxcbiAgICB0ZXh0OiAn7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAzLFxcclxcbiAgICB0ZXh0OiAn6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogNCxcXHJcXG4gICAgdGV4dDogJ+uwsOyXtCDrgrTsnqXtlajsiJgg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogZmFsc2VcXHJcXG4gIH1cXHJcXG5dO1xcclxcblxcclxcbmNvbnN0IHRvZG8gPSB0b2Rvcy5maW5kKHRvZG8gPT4gdG9kby5pZCA9PT0gMyk7XFxyXFxuY29uc29sZS5sb2codG9kbyk7XFxyXFxuXFxyXFxuLy8ge2lkOiAzLCB0ZXh0OiBcXFwi6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLBcXFwiLCBkb25lOiB0cnVlfVxcclxcbmBgYFxcclxcblxcclxcbiMjIDUuIGZpbHRlclxcclxcblxcclxcbu2KueyglSDsobDqsbTsnYQg66eM7KGx7ZWY64qUIOqwkuuTpOunjCDrlLDroZwg7LaU7Lac7ZWY7JesIOyDiOuhnOyatCDrsLDsl7TsnYQg66eM65Ot64uI64ukLlxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IHRvZG9zID0gW1xcclxcbiAge1xcclxcbiAgICBpZDogMSxcXHJcXG4gICAgdGV4dDogJ+yekOuwlOyKpO2BrOumve2KuCDsnoXrrLgnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogMixcXHJcXG4gICAgdGV4dDogJ+2VqOyImCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogMyxcXHJcXG4gICAgdGV4dDogJ+qwneyytOyZgCDrsLDsl7Qg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogdHJ1ZVxcclxcbiAgfSxcXHJcXG4gIHtcXHJcXG4gICAgaWQ6IDQsXFxyXFxuICAgIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IGZhbHNlXFxyXFxuICB9XFxyXFxuXTtcXHJcXG5cXHJcXG5jb25zdCB0YXNrc05vdERvbmUgPSB0b2Rvcy5maWx0ZXIodG9kbyA9PiB0b2RvLmRvbmUgPT09IGZhbHNlKTtcXHJcXG5jb25zb2xlLmxvZyh0YXNrc05vdERvbmUpO1xcclxcbi8qIFxcclxcbnRvZG8uZG9uZeydtCBmYWxzZeyduCB7aWQ6IDQsIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsIGRvbmU6IGZhbHNlfSBcXHJcXG7qsJ3ssrTrp4wg7IOI66Gc7Jq0IOuwsOyXtCh0YXNrTm90RG9uZSkg7JWI7JeQIOuTpOyWtOqwhOuLpC5cXHJcXG5bIHsgaWQ6IDQsIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsIGRvbmU6IGZhbHNlIH0gXVxcclxcblxcclxcbiovXFxyXFxuXFxyXFxuLy8gIOydtOugh+qyjCDtkZztmITtlaAg7IiY64+EIOyeiOuLpC5cXHJcXG5jb25zdCB0YXNrc05vdERvbmUgPSB0b2Rvcy5maWx0ZXIodG9kbyA9PiAhdG9kby5kb25lKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA2LiBzcGxpY2VcXHJcXG5cXHJcXG7rsLDsl7Tsl5DshJwg7Yq57KCVIO2VreuqqeydhCDsoJzqsbDtlaAg65WMIOyCrOyaqeuQnOuLpC4g7J24642x7IqkIOqwkuycvOuhnCDsp4DsmrDripQg6rKD7J206riwIOuVjOusuOyXkCDsnbjrjbHsiqTrpbwg66i87KCAIOq1rO2VmOqzoCDtlbTri7kg7J24642x7Iqk66Gc67aA7YSwIOuqhyDqsJzrgpgg7KeA7Jq4IOqyg+yduOyngCDshKDtg53tlZjsl6wg7Jes65+s6rCS7J2EIO2VnCDrsojsl5Ag7KeA7Jq4IOyImCDsnojri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgbnVtYmVycyA9IFsxMCwgMjAsIDMwLCA0MF07XFxyXFxuY29uc3QgaW5kZXggPSBudW1iZXJzLmluZGV4T2YoMzApO1xcclxcbm51bWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcXHJcXG5jb25zb2xlLmxvZyhudW1iZXJzKTtcXHJcXG5cXHJcXG4vLyAzMOydmCBpbmRleCA9IDLsnbTqs6AgMuuyiOynuCDsnbjrjbHsiqTroZzrtoDthLAg7ZWcIOqwnOydmCDqsJLsnYQg7KeA7Jqw66+A66GcIDMw66eMIOyngOybjOynhOuLpC5cXHJcXG4vLyBbMTAsIDIwLCA0MF1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA3LiBzbGljZVxcclxcblxcclxcbuq4sOyhtCDrsLDsl7Tsl5Ag67OA7ZmU66W8IOydvOycvO2CpOyngCDslYrqs6Ag7Iqs65287J207IuxIO2VmOyXrCDsg4jroZzsmrQg67Cw7Je07J2EIOyDneyEse2VnOuLpC5cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5jb25zdCBudW1iZXJzID0gWzEwLCAyMCwgMzAsIDQwXTtcXHJcXG5jb25zdCBzbGljZWQgPSBudW1iZXJzLnNsaWNlKDAsIDIpOyAvLyAw67aA7YSwIOyLnOyeke2VtOyEnCAy7KCE6rmM7KeAXFxyXFxuXFxyXFxuY29uc29sZS5sb2coc2xpY2VkKTsgLy8gWzEwLCAyMF1cXHJcXG5jb25zb2xlLmxvZyhudW1iZXJzKTsgLy8gWzEwLCAyMCwgMzAsIDQwXVxcclxcbmBgYFxcclxcblxcclxcbiMjIDguIHNoaWZ0ICYgcG9wXFxyXFxuXFxyXFxuc2hpZnTripQg67Cw7Je07J2YIOyyqyDrsojsp7gg6rCS7J2EIOu9keyVhOuCtOqzoCwgcG9w7J2AIOunqCDrkqTsnZgg6rCS7J2EIOu9keyVhOuCuOuLpC4gcHl0aG9u6rO8IOu5hOq1kO2VmOuptCBzaGlmdCA9IHBvcCgwKSwgcG9w7J2AIOuYkeqwmeuLpC5cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5jb25zdCBudW1iZXJzID0gWzEwLCAyMCwgMzAsIDQwXTtcXHJcXG5jb25zdCB2YWx1ZSA9IG51bWJlcnMuc2hpZnQoKTtcXHJcXG5jb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDEwXFxyXFxuY29uc3QgdmFsdWUyID0gbnVtYmVycy5wb3AoKTtcXHJcXG5jb25zb2xlLmxvZyh2YWx1ZTIpOyAvLyA0MFxcclxcbmNvbnNvbGUubG9nKG51bWJlcnMpOyAvL1syMCwgMzBdXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgOS4gam9pblxcclxcblxcclxcbuuwsOyXtCDslYjsnZgg6rCS65Ok7J2EIOusuOyekOyXtCDtmJXtg5zroZwg7ZWp7LOQ7KSN64uI64ukLlxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDQsIDVdO1xcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oKSk7IC8vIDEsMiwzLDQsNVxcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oJyAnKSk7IC8vIDEgMiAzIDQgNVxcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oJywgJykpOyAvLyAxLCAyLCAzLCA0LCA1XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgMTAuIHJlZHVjZVxcclxcblxcclxcbuuwsOyXtOydmCDqsIEg7JqU7IaM7JeQIOuMgO2VtCDso7zslrTsp4Qg66as65OA7IScKHJlZHVjZXIpIO2VqOyImOulvCDsi6TtlontlZjqs6AsIO2VmOuCmOydmCDqsrDqs7zqsJLsnYQg67CY7ZmY7ZWp64uI64ukLiDslZ7snZgg66y47J6l66eMIOydveyWtOyEnOuKlCDsnbTtlbTtlZjquLAg7Ja066Ck7Jq0642wLCDrgrTqsIAg7KeA7KCV7ZW07KSAIO2VqOyImOulvCDsi6Ttlokg7ZuEIOuCmOyYqCDqsrDqs7zqsJLsnYQg64uk7IucIO2MjOudvOuvuO2EsOuhnCDsgqzsmqntlZjrj4TroZ0g7ZWp64uI64ukLiDslYTrnpgg7JiI66W8IO2Gte2VtCDsnbTtlbTtlbTrtIXsi5zri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8g6riw7KG0IOuwqeyLnVxcclxcbmNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV07XFxyXFxuXFxyXFxubGV0IHN1bSA9IDA7XFxyXFxubnVtYmVycy5mb3JFYWNoKG4gPT4ge1xcclxcbiAgc3VtICs9IG47XFxyXFxufSk7XFxyXFxuY29uc29sZS5sb2coc3VtKTsgIC8vMTVcXHJcXG5cXHJcXG4vL3JlZHVjZeulvCDsgqzsmqntlZjripQg67Cp7IudXFxyXFxuY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XTtcXHJcXG5sZXQgc3VtID0gYXJyYXkucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50LCAwKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhzdW0pOyAgLy8xNVxcclxcbmNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV07XFxyXFxubGV0IHN1bSA9IG51bWJlcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4ge1xcclxcbiAgY29uc29sZS5sb2coeyBhY2N1bXVsYXRvciwgY3VycmVudCB9KTtcXHJcXG4gIHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnQ7XFxyXFxufSwgMCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coc3VtKTtcXHJcXG5cXHJcXG4vLyDqsrDqs7xcXHJcXG57IGFjY3VtdWxhdG9yOiAwLCBjdXJyZW50OiAxIH1cXHJcXG57IGFjY3VtdWxhdG9yOiAxLCBjdXJyZW50OiAyIH1cXHJcXG57IGFjY3VtdWxhdG9yOiAzLCBjdXJyZW50OiAzIH1cXHJcXG57IGFjY3VtdWxhdG9yOiA2LCBjdXJyZW50OiA0IH1cXHJcXG57IGFjY3VtdWxhdG9yOiAxMCwgY3VycmVudDogNSB9XFxyXFxuMTVcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4qKnJlZmVyZW5jZXMqKlxcclxcblxcclxcbltMZWFybkpTIEdpdEJvb2tdKGh0dHBzOi8vbGVhcm5qcy52bHB0LnVzL2Jhc2ljcy8wOS1hcnJheS1mdW5jdGlvbnMuaHRtbClcIjsiXSwic291cmNlUm9vdCI6IiJ9