(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/link.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/link.js ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$();

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/router/router.js");

var _router2 = __webpack_require__(/*! ./router */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/router.js");

var _useIntersection = __webpack_require__(/*! ./use-intersection */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/use-intersection.js");

var prefetched = {};

function prefetch(router, href, as, options) {
  if ( false || !router) return;
  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)
  // We need to handle a prefetch error here since we may be
  // loading with priority which can reject but we don't
  // want to force navigation since this is only a prefetch

  router.prefetch(href, as, options)["catch"](function (err) {
    if (true) {
      // rethrow to show invalid URL errors
      throw err;
    }
  });
  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character

  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;
}

function isModifiedEvent(event) {
  var target = event.currentTarget.target;
  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download
  event.nativeEvent && event.nativeEvent.which === 2;
}

function linkClicked(e, router, href, as, replace, shallow, scroll, locale) {
  var nodeName = e.currentTarget.nodeName;

  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {
    // ignore click for browser’s default behavior
    return;
  }

  e.preventDefault(); //  avoid scroll for urls with anchor refs

  if (scroll == null && as.indexOf('#') >= 0) {
    scroll = false;
  } // replace state instead of push if prop is present


  router[replace ? 'replace' : 'push'](href, as, {
    shallow: shallow,
    locale: locale,
    scroll: scroll
  });
}

function Link(props) {
  _s();

  if (true) {
    var createPropError = function createPropError(args) {
      return new Error("Failed prop type: The prop `".concat(args.key, "` expects a ").concat(args.expected, " in `<Link>`, but got `").concat(args.actual, "` instead.") + ( true ? "\nOpen your browser's console to view the Component stack trace." : 0));
    }; // TypeScript trick for type-guarding:


    var requiredPropsGuard = {
      href: true
    };
    var requiredProps = Object.keys(requiredPropsGuard);
    requiredProps.forEach(function (key) {
      if (key === 'href') {
        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: props[key] === null ? 'null' : typeof props[key]
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // TypeScript trick for type-guarding:

    var optionalPropsGuard = {
      as: true,
      replace: true,
      scroll: true,
      shallow: true,
      passHref: true,
      prefetch: true,
      locale: true
    };
    var optionalProps = Object.keys(optionalPropsGuard);
    optionalProps.forEach(function (key) {
      var valType = typeof props[key];

      if (key === 'as') {
        if (props[key] && valType !== 'string' && valType !== 'object') {
          throw createPropError({
            key: key,
            expected: '`string` or `object`',
            actual: valType
          });
        }
      } else if (key === 'locale') {
        if (props[key] && valType !== 'string') {
          throw createPropError({
            key: key,
            expected: '`string`',
            actual: valType
          });
        }
      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {
        if (props[key] != null && valType !== 'boolean') {
          throw createPropError({
            key: key,
            expected: '`boolean`',
            actual: valType
          });
        }
      } else {
        // TypeScript trick for type-guarding:
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var _ = key;
      }
    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    var hasWarned = _react["default"].useRef(false);

    if (props.prefetch && !hasWarned.current) {
      hasWarned.current = true;
      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');
    }
  }

  var p = props.prefetch !== false;
  var router = (0, _router2.useRouter)();

  var _react$default$useMem = _react["default"].useMemo(function () {
    var _ref = (0, _router.resolveHref)(router, props.href, true),
        _ref2 = _slicedToArray(_ref, 2),
        resolvedHref = _ref2[0],
        resolvedAs = _ref2[1];

    return {
      href: resolvedHref,
      as: props.as ? (0, _router.resolveHref)(router, props.as) : resolvedAs || resolvedHref
    };
  }, [router, props.href, props.as]),
      href = _react$default$useMem.href,
      as = _react$default$useMem.as;

  var children = props.children,
      replace = props.replace,
      shallow = props.shallow,
      scroll = props.scroll,
      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag

  if (typeof children === 'string') {
    children = /*#__PURE__*/_react["default"].createElement("a", null, children);
  } // This will return the first child, if multiple are provided it will throw an error


  var child;

  if (true) {
    try {
      child = _react.Children.only(children);
    } catch (err) {
      throw new Error("Multiple children were passed to <Link> with `href` of `".concat(props.href, "` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children") + ( true ? "\nOpen your browser's console to view the Component stack trace." : 0));
    }
  } else {}

  var childRef = child && typeof child === 'object' && child.ref;

  var _ref3 = (0, _useIntersection.useIntersection)({
    rootMargin: '200px'
  }),
      _ref4 = _slicedToArray(_ref3, 2),
      setIntersectionRef = _ref4[0],
      isVisible = _ref4[1];

  var setRef = _react["default"].useCallback(function (el) {
    setIntersectionRef(el);

    if (childRef) {
      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {
        childRef.current = el;
      }
    }
  }, [childRef, setIntersectionRef]);

  (0, _react.useEffect)(function () {
    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;
    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];

    if (shouldPrefetch && !isPrefetched) {
      prefetch(router, href, as, {
        locale: curLocale
      });
    }
  }, [as, href, isVisible, locale, p, router]);
  var childProps = {
    ref: setRef,
    onClick: function onClick(e) {
      if (child.props && typeof child.props.onClick === 'function') {
        child.props.onClick(e);
      }

      if (!e.defaultPrevented) {
        linkClicked(e, router, href, as, replace, shallow, scroll, locale);
      }
    }
  };

  childProps.onMouseEnter = function (e) {
    if (!(0, _router.isLocalURL)(href)) return;

    if (child.props && typeof child.props.onMouseEnter === 'function') {
      child.props.onMouseEnter(e);
    }

    prefetch(router, href, as, {
      priority: true
    });
  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
  // defined, we specify the current 'href', so that repetition is not needed by the user


  if (props.passHref || child.type === 'a' && !('href' in child.props)) {
    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale
    // so that locale links are still visitable in development/preview envs

    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);
    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));
  }

  return /*#__PURE__*/_react["default"].cloneElement(child, childProps);
}

_s(Link, "7cX92ILFgstKFyzTMH+g73G4t5k=");

_c = Link;
var _default = Link;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Link");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/use-intersection.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/use-intersection.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _slicedToArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.useIntersection = useIntersection;

var _react = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/request-idle-callback.js");

var hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';

function useIntersection(_ref) {
  var rootMargin = _ref.rootMargin,
      disabled = _ref.disabled;
  var isDisabled = disabled || !hasIntersectionObserver;
  var unobserve = (0, _react.useRef)();

  var _ref2 = (0, _react.useState)(false),
      _ref3 = _slicedToArray(_ref2, 2),
      visible = _ref3[0],
      setVisible = _ref3[1];

  var setRef = (0, _react.useCallback)(function (el) {
    if (unobserve.current) {
      unobserve.current();
      unobserve.current = undefined;
    }

    if (isDisabled || visible) return;

    if (el && el.tagName) {
      unobserve.current = observe(el, function (isVisible) {
        return isVisible && setVisible(isVisible);
      }, {
        rootMargin: rootMargin
      });
    }
  }, [isDisabled, rootMargin, visible]);
  (0, _react.useEffect)(function () {
    if (!hasIntersectionObserver) {
      if (!visible) {
        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {
          return setVisible(true);
        });
        return function () {
          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);
        };
      }
    }
  }, [visible]);
  return [setRef, visible];
}

function observe(element, callback, options) {
  var _createObserver = createObserver(options),
      id = _createObserver.id,
      observer = _createObserver.observer,
      elements = _createObserver.elements;

  elements.set(element, callback);
  observer.observe(element);
  return function unobserve() {
    elements["delete"](element);
    observer.unobserve(element); // Destroy observer when there's nothing left to watch:

    if (elements.size === 0) {
      observer.disconnect();
      observers["delete"](id);
    }
  };
}

var observers = new Map();

function createObserver(options) {
  var id = options.rootMargin || '';
  var instance = observers.get(id);

  if (instance) {
    return instance;
  }

  var elements = new Map();
  var observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      var callback = elements.get(entry.target);
      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;

      if (callback && isVisible) {
        callback(isVisible);
      }
    });
  }, options);
  observers.set(id, instance = {
    id: id,
    observer: observer,
    elements: elements
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp-context.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = /*#__PURE__*/_react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp.js ***!
  \***************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/head.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/head.js ***!
  \****************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _defineProperty = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/defineProperty.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports.default = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;
    var hasKey = false;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      hasKey = true;
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return /*#__PURE__*/_react["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, _react.useContext)(_ampContext.AmpStateContext);
  var headManager = (0, _react.useContext)(_headManagerContext.HeadManagerContext);
  return /*#__PURE__*/_react["default"].createElement(_sideEffect["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, _amp.isInAmpMode)(ampState)
  }, children);
}

_c = Head;
var _default = Head;
exports.default = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/side-effect.js":
/*!***********************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);


var _toConsumableArray = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/toConsumableArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _classCallCheck = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/assertThisInitialized */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/inherits */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/possibleConstructorReturn */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/getPrototypeOf */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports.default = void 0;

var _react = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");

var isServer = false;

var _default = /*#__PURE__*/function (_react$Component) {
  _inherits(_default, _react$Component);

  var _super = _createSuper(_default);

  function _default(props) {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.call(this, props);
    _this._hasHeadManager = void 0;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(_toConsumableArray(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  _createClass(_default, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances.add(this);
      }

      this.emitChange();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.emitChange();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._hasHeadManager) {
        this.props.headManager.mountedInstances["delete"](this);
      }

      this.emitChange();
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return _default;
}(_react.Component);

exports.default = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/head */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/router */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _src_contexts_theme__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @src/contexts/theme */ "./src/contexts/theme/index.ts");
/* harmony import */ var _src_contexts_app__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @src/contexts/app */ "./src/contexts/app/index.tsx");
/* harmony import */ var _src_helpers_gtag__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @src/helpers/gtag */ "./src/helpers/gtag.ts");
/* harmony import */ var _src_services_post_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @src/services/post.service */ "./src/services/post.service.ts");
/* harmony import */ var _src_layouts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @src/layouts */ "./src/layouts/index.ts");
/* harmony import */ var _src_styles_global_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @src/styles/global.css */ "./src/styles/global.css");
/* harmony import */ var _src_styles_global_css__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_src_styles_global_css__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _src_styles_post_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @src/styles/post.css */ "./src/styles/post.css");
/* harmony import */ var _src_styles_post_css__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_src_styles_post_css__WEBPACK_IMPORTED_MODULE_13__);
/* module decorator */ module = __webpack_require__.hmd(module);






var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\pages\\_app.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }












function MyApp(_ref) {
  _s();

  var Component = _ref.Component,
      pageProps = _ref.pageProps,
      posts = _ref.posts;
  var router = (0,next_router__WEBPACK_IMPORTED_MODULE_5__.useRouter)();
  (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(function () {
    var handleRouteChange = function handleRouteChange(url) {
      var title = window.document.title;
      var href = window.location.href;
      _src_helpers_gtag__WEBPACK_IMPORTED_MODULE_9__.pageview({
        url: url,
        title: title,
        href: href
      });
    };

    router.events.on("routeChangeComplete", handleRouteChange);
    return function () {
      router.events.off("routeChangeComplete", handleRouteChange);
    };
  }, [router.events]);
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_4___default()), {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("title", {
        children: "Frontend Dev | likelionSungGuk Blog"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("meta", {
        name: "description",
        content: "Frontend Dev likelionSungGuk Blog"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 42,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("link", {
        rel: "icon",
        href: "/favicon.ico"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(_src_contexts_theme__WEBPACK_IMPORTED_MODULE_7__.ThemeContextProvider, {
      defaultTheme: "dark",
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(_src_contexts_app__WEBPACK_IMPORTED_MODULE_8__.AppContextProvider, {
        posts: posts,
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(_src_layouts__WEBPACK_IMPORTED_MODULE_11__.BlogLayout, {
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(Component, _objectSpread({}, pageProps), void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 48,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 47,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 46,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}

_s(MyApp, "vQduR7x+OPXj6PSmJyFnf+hU7bg=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_5__.useRouter];
});

_c = MyApp;
MyApp.getInitialProps = /*#__PURE__*/(0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__.default)( /*#__PURE__*/C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().mark(function _callee() {
  var posts;
  return C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default().wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return _src_services_post_service__WEBPACK_IMPORTED_MODULE_10__.default.getPosts();

        case 2:
          posts = _context.sent;
          return _context.abrupt("return", {
            posts: posts
          });

        case 4:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
}));
/* harmony default export */ __webpack_exports__["default"] = (MyApp);

var _c;

$RefreshReg$(_c, "MyApp");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/account.tsx":
/*!**************************************!*\
  !*** ./src/assets/icons/account.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\account.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function AccountIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      d: "M16 7.992C16 3.58 12.416 0 8 0S0 3.58 0 7.992c0 2.43 1.104 4.62 2.832 6.09.016.016.032.016.032.032.144.112.288.224.448.336.08.048.144.111.224.175A7.98 7.98 0 0 0 8.016 16a7.98 7.98 0 0 0 4.48-1.375c.08-.048.144-.111.224-.16.144-.111.304-.223.448-.335.016-.016.032-.016.032-.032 1.696-1.487 2.8-3.676 2.8-6.106zm-8 7.001c-1.504 0-2.88-.48-4.016-1.279.016-.128.048-.255.08-.383a4.17 4.17 0 0 1 .416-.991c.176-.304.384-.576.64-.816.24-.24.528-.463.816-.639.304-.176.624-.304.976-.4A4.15 4.15 0 0 1 8 10.342a4.185 4.185 0 0 1 2.928 1.166c.368.368.656.8.864 1.295.112.288.192.592.24.911A7.03 7.03 0 0 1 8 14.993zm-2.448-7.4a2.49 2.49 0 0 1-.208-1.024c0-.351.064-.703.208-1.023.144-.32.336-.607.576-.847.24-.24.528-.431.848-.575.32-.144.672-.208 1.024-.208.368 0 .704.064 1.024.208.32.144.608.336.848.575.24.24.432.528.576.847.144.32.208.672.208 1.023 0 .368-.064.704-.208 1.023a2.84 2.84 0 0 1-.576.848 2.84 2.84 0 0 1-.848.575 2.715 2.715 0 0 1-2.064 0 2.84 2.84 0 0 1-.848-.575 2.526 2.526 0 0 1-.56-.848zm7.424 5.306c0-.032-.016-.048-.016-.08a5.22 5.22 0 0 0-.688-1.406 4.883 4.883 0 0 0-1.088-1.135 5.207 5.207 0 0 0-1.04-.608 2.82 2.82 0 0 0 .464-.383 4.2 4.2 0 0 0 .624-.784 3.624 3.624 0 0 0 .528-1.934 3.71 3.71 0 0 0-.288-1.47 3.799 3.799 0 0 0-.816-1.199 3.845 3.845 0 0 0-1.2-.8 3.72 3.72 0 0 0-1.472-.287 3.72 3.72 0 0 0-1.472.288 3.631 3.631 0 0 0-1.2.815 3.84 3.84 0 0 0-.8 1.199 3.71 3.71 0 0 0-.288 1.47c0 .352.048.688.144 1.007.096.336.224.64.4.927.16.288.384.544.624.784.144.144.304.271.48.383a5.12 5.12 0 0 0-1.04.624c-.416.32-.784.703-1.088 1.119a4.999 4.999 0 0 0-.688 1.406c-.016.032-.016.064-.016.08C1.776 11.636.992 9.91.992 7.992.992 4.14 4.144.991 8 .991s7.008 3.149 7.008 7.001a6.96 6.96 0 0 1-2.032 4.907z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(AccountIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = AccountIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(AccountIcon));

var _c, _c2;

$RefreshReg$(_c, "AccountIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/chevron/down.tsx":
/*!*******************************************!*\
  !*** ./src/assets/icons/chevron/down.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\chevron\\down.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function ChevronDownIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M7.976 10.072l4.357-4.357.62.618L8.284 11h-.618L3 6.333l.619-.618 4.357 4.357z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, this);
}

_s(ChevronDownIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = ChevronDownIcon;
/* harmony default export */ __webpack_exports__["default"] = (ChevronDownIcon);

var _c;

$RefreshReg$(_c, "ChevronDownIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/chevron/index.ts":
/*!*******************************************!*\
  !*** ./src/assets/icons/chevron/index.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChevronUpIcon": function() { return /* reexport safe */ _up__WEBPACK_IMPORTED_MODULE_0__.default; },
/* harmony export */   "ChevronDownIcon": function() { return /* reexport safe */ _down__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "ChevronLeftIcon": function() { return /* reexport safe */ _left__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "ChevronRightIcon": function() { return /* reexport safe */ _right__WEBPACK_IMPORTED_MODULE_3__.default; }
/* harmony export */ });
/* harmony import */ var _up__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./up */ "./src/assets/icons/chevron/up.tsx");
/* harmony import */ var _down__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./down */ "./src/assets/icons/chevron/down.tsx");
/* harmony import */ var _left__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./left */ "./src/assets/icons/chevron/left.tsx");
/* harmony import */ var _right__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./right */ "./src/assets/icons/chevron/right.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);





;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/chevron/left.tsx":
/*!*******************************************!*\
  !*** ./src/assets/icons/chevron/left.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\chevron\\left.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function ChevronLeftIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5.928 7.976l4.357 4.357-.618.62L5 8.284v-.618L9.667 3l.618.619-4.357 4.357z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, this);
}

_s(ChevronLeftIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = ChevronLeftIcon;
/* harmony default export */ __webpack_exports__["default"] = (ChevronLeftIcon);

var _c;

$RefreshReg$(_c, "ChevronLeftIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/chevron/right.tsx":
/*!********************************************!*\
  !*** ./src/assets/icons/chevron/right.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\chevron\\right.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function ChevronUpIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10.072 8.024L5.715 3.667l.618-.62L11 7.716v.618L6.333 13l-.618-.619 4.357-4.357z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, this);
}

_s(ChevronUpIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = ChevronUpIcon;
/* harmony default export */ __webpack_exports__["default"] = (ChevronUpIcon);

var _c;

$RefreshReg$(_c, "ChevronUpIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/chevron/up.tsx":
/*!*****************************************!*\
  !*** ./src/assets/icons/chevron/up.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\chevron\\up.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function ChevronUpIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8.024 5.928l-4.357 4.357-.62-.618L7.716 5h.618L13 9.667l-.619.618-4.357-4.357z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 8,
    columnNumber: 5
  }, this);
}

_s(ChevronUpIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = ChevronUpIcon;
/* harmony default export */ __webpack_exports__["default"] = (ChevronUpIcon);

var _c;

$RefreshReg$(_c, "ChevronUpIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/close.tsx":
/*!************************************!*\
  !*** ./src/assets/icons/close.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\close.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function CloseIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill,
      onClick = _ref.onClick,
      className = _ref.className;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    className: className,
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    onClick: onClick,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M8 8.707l3.646 3.647.708-.707L8.707 8l3.647-3.646-.707-.708L8 7.293 4.354 3.646l-.707.708L7.293 8l-3.646 3.646.707.708L8 8.707z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, this);
}

_s(CloseIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = CloseIcon;
/* harmony default export */ __webpack_exports__["default"] = (CloseIcon);

var _c;

$RefreshReg$(_c, "CloseIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/ellipsis.tsx":
/*!***************************************!*\
  !*** ./src/assets/icons/ellipsis.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\ellipsis.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function EllipsisIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.6rem",
      height: "1.6rem"
    }, style),
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      d: "M4 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm5 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 8,
    columnNumber: 5
  }, this);
}

_s(EllipsisIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_2__.useTheme];
});

_c = EllipsisIcon;
/* harmony default export */ __webpack_exports__["default"] = (EllipsisIcon);

var _c;

$RefreshReg$(_c, "EllipsisIcon");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/extensions.tsx":
/*!*****************************************!*\
  !*** ./src/assets/icons/extensions.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\extensions.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function ExtensionsIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M13.5 1.5L15 0h7.5L24 1.5V9l-1.5 1.5H15L13.5 9V1.5zm1.5 0V9h7.5V1.5H15zM0 15V6l1.5-1.5H9L10.5 6v7.5H18l1.5 1.5v7.5L18 24H1.5L0 22.5V15zm9-1.5V6H1.5v7.5H9zM9 15H1.5v7.5H9V15zm1.5 7.5H18V15h-7.5v7.5z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(ExtensionsIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = ExtensionsIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(ExtensionsIcon));

var _c, _c2;

$RefreshReg$(_c, "ExtensionsIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/files.tsx":
/*!************************************!*\
  !*** ./src/assets/icons/files.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\files.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function FilesIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M13.71 4.29l-3-3L10 1H4L3 2v12l1 1h9l1-1V5l-.29-.71zM13 14H4V2h5v4h4v8zm-3-9V2l3 3h-3z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(FilesIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = FilesIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(FilesIcon));

var _c, _c2;

$RefreshReg$(_c, "FilesIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/index.ts":
/*!***********************************!*\
  !*** ./src/assets/icons/index.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AccountIcon": function() { return /* reexport safe */ _account__WEBPACK_IMPORTED_MODULE_1__.default; },
/* harmony export */   "CloseIcon": function() { return /* reexport safe */ _close__WEBPACK_IMPORTED_MODULE_2__.default; },
/* harmony export */   "EllipsisIcon": function() { return /* reexport safe */ _ellipsis__WEBPACK_IMPORTED_MODULE_3__.default; },
/* harmony export */   "ExtensionsIcon": function() { return /* reexport safe */ _extensions__WEBPACK_IMPORTED_MODULE_4__.default; },
/* harmony export */   "FilesIcon": function() { return /* reexport safe */ _files__WEBPACK_IMPORTED_MODULE_5__.default; },
/* harmony export */   "RunAndDebugIcon": function() { return /* reexport safe */ _run_n_debug__WEBPACK_IMPORTED_MODULE_6__.default; },
/* harmony export */   "SearchIcon": function() { return /* reexport safe */ _search__WEBPACK_IMPORTED_MODULE_7__.default; },
/* harmony export */   "SettingsGearIcon": function() { return /* reexport safe */ _settings_gear__WEBPACK_IMPORTED_MODULE_8__.default; },
/* harmony export */   "SourceControlIcon": function() { return /* reexport safe */ _source_control__WEBPACK_IMPORTED_MODULE_9__.default; }
/* harmony export */ });
/* harmony import */ var _chevron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chevron */ "./src/assets/icons/chevron/index.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _chevron__WEBPACK_IMPORTED_MODULE_0__) if(["default","AccountIcon","CloseIcon","EllipsisIcon","ExtensionsIcon","FilesIcon","RunAndDebugIcon","SearchIcon","SettingsGearIcon","SourceControlIcon"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _chevron__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _account__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./account */ "./src/assets/icons/account.tsx");
/* harmony import */ var _close__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./close */ "./src/assets/icons/close.tsx");
/* harmony import */ var _ellipsis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipsis */ "./src/assets/icons/ellipsis.tsx");
/* harmony import */ var _extensions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extensions */ "./src/assets/icons/extensions.tsx");
/* harmony import */ var _files__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./files */ "./src/assets/icons/files.tsx");
/* harmony import */ var _run_n_debug__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./run-n-debug */ "./src/assets/icons/run-n-debug.tsx");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./search */ "./src/assets/icons/search.tsx");
/* harmony import */ var _settings_gear__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./settings-gear */ "./src/assets/icons/settings-gear.tsx");
/* harmony import */ var _source_control__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source-control */ "./src/assets/icons/source-control.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);
/**
 * Activity Bar Icons
 */











;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/run-n-debug.tsx":
/*!******************************************!*\
  !*** ./src/assets/icons/run-n-debug.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\run-n-debug.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function RunAndDebugIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      d: "M10.94 13.5l-1.32 1.32a3.73 3.73 0 0 0-7.24 0L1.06 13.5 0 14.56l1.72 1.72-.22.22V18H0v1.5h1.5v.08c.077.489.214.966.41 1.42L0 22.94 1.06 24l1.65-1.65A4.308 4.308 0 0 0 6 24a4.31 4.31 0 0 0 3.29-1.65L10.94 24 12 22.94 10.09 21c.198-.464.336-.951.41-1.45v-.1H12V18h-1.5v-1.5l-.22-.22L12 14.56l-1.06-1.06zM6 13.5a2.25 2.25 0 0 1 2.25 2.25h-4.5A2.25 2.25 0 0 1 6 13.5zm3 6a3.33 3.33 0 0 1-3 3 3.33 3.33 0 0 1-3-3v-2.25h6v2.25zm14.76-9.9v1.26L13.5 17.37V15.6l8.5-5.37L9 2v9.46a5.07 5.07 0 0 0-1.5-.72V.63L8.64 0l15.12 9.6z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(RunAndDebugIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = RunAndDebugIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(RunAndDebugIcon));

var _c, _c2;

$RefreshReg$(_c, "RunAndDebugIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/search.tsx":
/*!*************************************!*\
  !*** ./src/assets/icons/search.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\search.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function SearchIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      d: "M15.25 0a8.25 8.25 0 0 0-6.18 13.72L1 22.88l1.12 1 8.05-9.12A8.251 8.251 0 1 0 15.25.01V0zm0 15a6.75 6.75 0 1 1 0-13.5 6.75 6.75 0 0 1 0 13.5z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(SearchIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = SearchIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(SearchIcon));

var _c, _c2;

$RefreshReg$(_c, "SearchIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/settings-gear.tsx":
/*!********************************************!*\
  !*** ./src/assets/icons/settings-gear.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\settings-gear.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function SettingsGearIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M19.85 8.75l4.15.83v4.84l-4.15.83 2.35 3.52-3.43 3.43-3.52-2.35-.83 4.15H9.58l-.83-4.15-3.52 2.35-3.43-3.43 2.35-3.52L0 14.42V9.58l4.15-.83L1.8 5.23 5.23 1.8l3.52 2.35L9.58 0h4.84l.83 4.15 3.52-2.35 3.43 3.43-2.35 3.52zm-1.57 5.07l4-.81v-2l-4-.81-.54-1.3 2.29-3.43-1.43-1.43-3.43 2.29-1.3-.54-.81-4h-2l-.81 4-1.3.54-3.43-2.29-1.43 1.43L6.38 8.9l-.54 1.3-4 .81v2l4 .81.54 1.3-2.29 3.43 1.43 1.43 3.43-2.29 1.3.54.81 4h2l.81-4 1.3-.54 3.43 2.29 1.43-1.43-2.29-3.43.54-1.3zm-8.186-4.672A3.43 3.43 0 0 1 12 8.57 3.44 3.44 0 0 1 15.43 12a3.43 3.43 0 1 1-5.336-2.852zm.956 4.274c.281.188.612.288.95.288A1.7 1.7 0 0 0 13.71 12a1.71 1.71 0 1 0-2.66 1.422z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(SettingsGearIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = SettingsGearIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(SettingsGearIcon));

var _c, _c2;

$RefreshReg$(_c, "SettingsGearIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/assets/icons/source-control.tsx":
/*!*********************************************!*\
  !*** ./src/assets/icons/source-control.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\assets\\icons\\source-control.tsx",
    _s = $RefreshSig$();

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




function SourceControlIcon(_ref) {
  _s();

  var style = _ref.style,
      fill = _ref.fill;

  var _useTheme = (0,styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme)(),
      colors = _useTheme.colors;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("svg", {
    style: _objectSpread({
      width: "1.4rem",
      height: "1.4rem"
    }, style),
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    fill: fill || colors.scheme.$white,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("path", {
      d: "M21.007 8.222A3.738 3.738 0 0 0 15.045 5.2a3.737 3.737 0 0 0 1.156 6.583 2.988 2.988 0 0 1-2.668 1.67h-2.99a4.456 4.456 0 0 0-2.989 1.165V7.4a3.737 3.737 0 1 0-1.494 0v9.117a3.776 3.776 0 1 0 1.816.099 2.99 2.99 0 0 1 2.668-1.667h2.99a4.484 4.484 0 0 0 4.223-3.039 3.736 3.736 0 0 0 3.25-3.687zM4.565 3.738a2.242 2.242 0 1 1 4.484 0 2.242 2.242 0 0 1-4.484 0zm4.484 16.441a2.242 2.242 0 1 1-4.484 0 2.242 2.242 0 0 1 4.484 0zm8.221-9.715a2.242 2.242 0 1 1 0-4.485 2.242 2.242 0 0 1 0 4.485z"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 10,
    columnNumber: 5
  }, this);
}

_s(SourceControlIcon, "/Q6cdUHzgkoetCTF1QsQ9YmUzs0=", false, function () {
  return [styled_components__WEBPACK_IMPORTED_MODULE_3__.useTheme];
});

_c = SourceControlIcon;
/* harmony default export */ __webpack_exports__["default"] = (_c2 = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().memo(SourceControlIcon));

var _c, _c2;

$RefreshReg$(_c, "SourceControlIcon");
$RefreshReg$(_c2, "%default%");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/components/common/accordion-section/index.tsx":
/*!***********************************************************!*\
  !*** ./src/components/common/accordion-section/index.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ AccordionSection; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/assets/icons */ "./src/assets/icons/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);




var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\components\\common\\accordion-section\\index.tsx",
    _s = $RefreshSig$();

function _templateObject4() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  overflow-x: hidden;\n  overflow-y: auto;\n\n  ", "\n  ", ";\n\n  transition: all 0.3s ease-out;\n\n  ", "\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  &::-webkit-scrollbar {\n    /* Chrome, Safari and Opera */\n    display: none;\n  }\n\n  -ms-overflow-style: none; /* IE and Edge */\n  scrollbar-width: none; /* Firefox */\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  font-size: 0.8rem;\n  font-weight: 700;\n\n  padding-left: 0.4rem;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  padding: 0.4rem 0.2rem;\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




function AccordionSection(_ref) {
  _s();

  var title = _ref.title,
      children = _ref.children,
      defaultExpanded = _ref.defaultExpanded,
      hasLine = _ref.hasLine,
      height = _ref.height,
      maxHeight = _ref.maxHeight;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(!!defaultExpanded),
      isExpanded = _useState[0],
      setIsExpanded = _useState[1];

  var handleHeaderClick = function handleHeaderClick() {
    setIsExpanded(!isExpanded);
  };

  var ChevronIcon = isExpanded ? _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.ChevronDownIcon : _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.ChevronRightIcon;
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Header, {
      onClick: handleHeaderClick,
      hasLine: hasLine,
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(ChevronIcon, {
        style: {
          width: "1rem",
          height: "1rem"
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
        children: title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Content, {
      isExpanded: isExpanded,
      height: height,
      maxHeight: maxHeight,
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}

_s(AccordionSection, "Mxng1bsVhNIiltJavW+YKmr3gRo=");

_c = AccordionSection;
var Header = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject(), function (_ref2) {
  var hasLine = _ref2.hasLine;
  return hasLine && "border-top:1px solid rgba(204, 204, 204, 0.2);";
});
_c2 = Header;
var Title = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.b(_templateObject2());
_c3 = Title;
var hideScrollbar = (0,styled_components__WEBPACK_IMPORTED_MODULE_4__.css)(_templateObject3());
var Content = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject4(), function (_ref3) {
  var isExpanded = _ref3.isExpanded,
      height = _ref3.height;
  return height ? "height:".concat(isExpanded ? height : 0, ";") : "flex:".concat(isExpanded ? 1 : 0, ";");
}, function (_ref4) {
  var maxHeight = _ref4.maxHeight;
  return maxHeight ? "max-height: ".concat(maxHeight, ";") : "";
}, hideScrollbar);
_c4 = Content;

var _c, _c2, _c3, _c4;

$RefreshReg$(_c, "AccordionSection");
$RefreshReg$(_c2, "Header");
$RefreshReg$(_c3, "Title");
$RefreshReg$(_c4, "Content");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/components/common/scroll-pagenation/index.tsx":
/*!***********************************************************!*\
  !*** ./src/components/common/scroll-pagenation/index.tsx ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* module decorator */ module = __webpack_require__.hmd(module);




var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\components\\common\\scroll-pagenation\\index.tsx",
    _s = $RefreshSig$();

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  width: 100%;\n  height: 2rem;\n  background-color: black;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n\n  overflow-y: auto;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}



var DEFAULT_PAGE_SIZE = 20;

function ScrollPagenation(_ref) {
  _s();

  var initialData = _ref.data,
      _ref$pageSize = _ref.pageSize,
      pageSize = _ref$pageSize === void 0 ? DEFAULT_PAGE_SIZE : _ref$pageSize,
      renderItem = _ref.renderItem,
      onClick = _ref.onClick;
  var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(initialData.slice(0, pageSize)),
      data = _useState[0],
      setData = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(true),
      hasMore = _useState2[0],
      setHasMore = _useState2[1];

  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    setData(initialData.slice(0, pageSize));
  }, [initialData, pageSize]);

  var handleScroll = function handleScroll() {
    if (!wrapperRef.current) {
      return;
    }

    var _wrapperRef$current = wrapperRef.current,
        scrollTop = _wrapperRef$current.scrollTop,
        clientHeight = _wrapperRef$current.clientHeight,
        scrollHeight = _wrapperRef$current.scrollHeight;
    var scrollBottom = scrollTop + clientHeight; // 모든 스크롤을 내렸을 때

    if (scrollBottom >= scrollHeight) {
      loadMore();
    }
  };

  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    if (!wrapperRef.current) {
      return;
    }

    wrapperRef.current.addEventListener("scroll", handleScroll); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [wrapperRef]);

  var getNextData = function getNextData(_ref2) {
    var offset = _ref2.offset,
        limit = _ref2.limit;
    return initialData.slice(offset, offset + limit);
  };

  var loadMore = function loadMore() {
    if (hasMore) {
      setData(function (prevData) {
        var nextData = getNextData({
          offset: prevData.length,
          limit: pageSize
        });

        if (nextData.length < pageSize) {
          var _wrapperRef$current2;

          setHasMore(false);
          (_wrapperRef$current2 = wrapperRef.current) === null || _wrapperRef$current2 === void 0 ? void 0 : _wrapperRef$current2.removeEventListener("scroll", handleScroll);
        }

        return [].concat((0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__.default)(prevData), (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__.default)(nextData));
      });
    }
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    ref: wrapperRef,
    onClick: onClick,
    children: data.map(function (item, i) {
      return renderItem(item, i === 0 ? null : data[i - 1]);
    })
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 77,
    columnNumber: 5
  }, this);
}

_s(ScrollPagenation, "qQHMWFx30wDrGfVBGjIRi/eg2Ac=");

_c = ScrollPagenation;
/* harmony default export */ __webpack_exports__["default"] = (ScrollPagenation);
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.ul(_templateObject());
_c2 = Wrapper;
var More = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject2());

var _c, _c2;

$RefreshReg$(_c, "ScrollPagenation");
$RefreshReg$(_c2, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/components/common/tag/index.tsx":
/*!*********************************************!*\
  !*** ./src/components/common/tag/index.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Tag; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/link */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_4__);
/* module decorator */ module = __webpack_require__.hmd(module);




var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\components\\common\\tag\\index.tsx";

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  margin-left: 0.4rem;\n\n  color: ", ";\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  margin: 0 0.8rem 0.8rem 0;\n  padding: 0.2rem 0.6rem;\n  border-radius: 0.8rem;\n\n  font-size: 1.2rem;\n  color: ", ";;\n  background-color: ", ";\n\n  ", "\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



function Tag(_ref) {
  var children = _ref.children,
      count = _ref.count,
      _ref$clickable = _ref.clickable,
      clickable = _ref$clickable === void 0 ? true : _ref$clickable,
      href = _ref.href,
      props = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__.default)(_ref, ["children", "count", "clickable", "href"]);

  var tagDefault = /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(Wrapper, _objectSpread(_objectSpread({}, props), {}, {
    clickable: clickable,
    children: [children, count != null && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(Count, {
      children: count
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 25
    }, this)]
  }), void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 20,
    columnNumber: 5
  }, this);

  return href ? /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_4___default()), {
    href: href,
    passHref: true,
    children: tagDefault
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 27,
    columnNumber: 5
  }, this) : tagDefault;
}
_c = Tag;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_5__.default.a(_templateObject(), function (_ref2) {
  var theme = _ref2.theme;
  return theme.colors.scheme.$tagFontColor;
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.colors.scheme.$gray300;
}, function (p) {
  return p.clickable && "\n    cursor: pointer;\n    &:hover {\n      background-color: ".concat(p.theme.colors.scheme.$gray400, ";\n    }\n  ");
});
_c2 = Wrapper;
var Count = styled_components__WEBPACK_IMPORTED_MODULE_5__.default.span(_templateObject2(), function (_ref4) {
  var theme = _ref4.theme;
  return theme.colors.scheme.$gray100;
});
_c3 = Count;

var _c, _c2, _c3;

$RefreshReg$(_c, "Tag");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Count");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/components/common/theme-switcher/index.tsx":
/*!********************************************************!*\
  !*** ./src/components/common/theme-switcher/index.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ThemeSwitcher; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* harmony import */ var _src_contexts_theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/contexts/theme */ "./src/contexts/theme/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\components\\common\\theme-switcher\\index.tsx",
    _s = $RefreshSig$();

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: absolute;\n  ", ";\n\n  width: 1.2rem;\n  height: 1.2rem;\n\n  border-radius: 50%;\n\n  background-color: ", ";\n\n  transition: all 0.2s;\n\n  user-select: auto;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: relative;\n\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: space-between;\n\n  width: 1.2rem;\n  height: 2.8rem;\n  border-radius: 0.6rem;\n\n  background-color: ", ";\n\n  outline: 2px solid ", ";\n\n  &:focus {\n    outline: 2px solid ", ";\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




function ThemeSwitcher() {
  _s();

  var _useThemeContext = (0,_src_contexts_theme__WEBPACK_IMPORTED_MODULE_3__.useThemeContext)(),
      theme = _useThemeContext.state.theme,
      toggleTheme = _useThemeContext.action.toggleTheme;

  var handleClick = function handleClick() {
    toggleTheme();
  };

  var handleKeyDown = function handleKeyDown(e) {
    if (["Enter", " "].includes(e.key)) {
      handleClick();
    }
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    tabIndex: 0,
    onClick: handleClick,
    onKeyDown: handleKeyDown,
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("span", {
      children: "\uD83C\uDF1D"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)("span", {
      children: "\uD83C\uDF1E"
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Circle, {
      mode: theme
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 25,
    columnNumber: 5
  }, this);
}

_s(ThemeSwitcher, "+zbbDHBSVZfoEA3uC1lRedoBaEM=", false, function () {
  return [_src_contexts_theme__WEBPACK_IMPORTED_MODULE_3__.useThemeContext];
});

_c = ThemeSwitcher;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject(), _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.BLACK, _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.BLACK, _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.WHITE);
_c2 = Wrapper;
var Circle = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject2(), function (_ref) {
  var mode = _ref.mode;
  return mode === "light" ? "top: 0;" : "bottom: 0;";
}, _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.WHITE);
_c3 = Circle;

var _c, _c2, _c3;

$RefreshReg$(_c, "ThemeSwitcher");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Circle");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/constants/palette.ts":
/*!**********************************!*\
  !*** ./src/constants/palette.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WHITE": function() { return /* binding */ WHITE; },
/* harmony export */   "BLACK": function() { return /* binding */ BLACK; },
/* harmony export */   "DRACULAR_BACKGROUND_LIGHT_DARK": function() { return /* binding */ DRACULAR_BACKGROUND_LIGHT_DARK; },
/* harmony export */   "DRACULAR_BACKGROUND_DEEP_DARK": function() { return /* binding */ DRACULAR_BACKGROUND_DEEP_DARK; },
/* harmony export */   "YELLOW": function() { return /* binding */ YELLOW; },
/* harmony export */   "BLUE": function() { return /* binding */ BLUE; },
/* harmony export */   "PINK": function() { return /* binding */ PINK; },
/* harmony export */   "ORANGE": function() { return /* binding */ ORANGE; },
/* harmony export */   "GREEN": function() { return /* binding */ GREEN; },
/* harmony export */   "PURPLE": function() { return /* binding */ PURPLE; },
/* harmony export */   "PURPLE_DARK": function() { return /* binding */ PURPLE_DARK; },
/* harmony export */   "GRAY_100": function() { return /* binding */ GRAY_100; },
/* harmony export */   "GRAY_200": function() { return /* binding */ GRAY_200; },
/* harmony export */   "GRAY_300": function() { return /* binding */ GRAY_300; },
/* harmony export */   "GRAY_400": function() { return /* binding */ GRAY_400; },
/* harmony export */   "GRAY_500": function() { return /* binding */ GRAY_500; },
/* harmony export */   "GRAY_600": function() { return /* binding */ GRAY_600; },
/* harmony export */   "LIGHT_GRAY_100": function() { return /* binding */ LIGHT_GRAY_100; },
/* harmony export */   "LIGHT_GRAY_200": function() { return /* binding */ LIGHT_GRAY_200; },
/* harmony export */   "LIGHT_GRAY_300": function() { return /* binding */ LIGHT_GRAY_300; },
/* harmony export */   "LIGHT_GRAY_400": function() { return /* binding */ LIGHT_GRAY_400; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
var WHITE = "#FFF";
var BLACK = "#000";
var DRACULAR_BACKGROUND_LIGHT_DARK = "#383a59";
var DRACULAR_BACKGROUND_DEEP_DARK = "#282a36";
var YELLOW = "#F1FA8C";
var BLUE = "#8BE9FD";
var PINK = "#FF79C6";
var ORANGE = "#FFB86C";
var GREEN = "#3ee668";
var PURPLE = "#BD93F9";
var PURPLE_DARK = "#25253A";
var GRAY_100 = "#7a7a7a";
var GRAY_200 = "#505050";
var GRAY_300 = "#3c3c3c";
var GRAY_400 = "#333333";
var GRAY_500 = "#252526";
var GRAY_600 = "#1e1e1e";
var LIGHT_GRAY_100 = "#F3F3F3";
var LIGHT_GRAY_200 = "#EAEAEA";
var LIGHT_GRAY_300 = "#E1E1E1";
var LIGHT_GRAY_400 = "#D6D6D6";

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/contexts/app/index.tsx":
/*!************************************!*\
  !*** ./src/contexts/app/index.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppContextProvider": function() { return /* binding */ AppContextProvider; },
/* harmony export */   "useAppContext": function() { return /* binding */ useAppContext; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\contexts\\app\\index.tsx",
    _s = $RefreshSig$(),
    _this = undefined,
    _s2 = $RefreshSig$();



var AppContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)(undefined);

var useAppContext = function useAppContext() {
  _s();

  return (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(AppContext);
};

_s(useAppContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var AppContextProvider = function AppContextProvider(_ref) {
  _s2();

  var children = _ref.children,
      posts = _ref.posts;
  var router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      openPosts = _useState[0],
      setOpenPosts = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(),
      currentPostId = _useState2[0],
      setCurrentPostId = _useState2[1];

  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    if (currentPostId === undefined) {
      return;
    }

    router.push(currentPostId ? "/blog/".concat(currentPostId) : "/blog"); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentPostId]);

  var selectPost = function selectPost(id) {
    setCurrentPostId(id);

    if (openPosts.find(function (post) {
      return post.id === id;
    }) !== undefined) {
      return;
    }

    var targetPost = posts.find(function (post) {
      return post.id === id;
    });
    targetPost && setOpenPosts([].concat((0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(openPosts), [targetPost]));
  };

  var closePost = function closePost(id) {
    var newOpenPosts = openPosts.filter(function (post) {
      return post.id !== id;
    });
    setOpenPosts(newOpenPosts);

    if (newOpenPosts.length === 0) {
      setCurrentPostId(null);
      return;
    }

    if (id === currentPostId) {
      setCurrentPostId(newOpenPosts[newOpenPosts.length - 1].id);
    }
  };

  var appStore = {
    state: {
      posts: posts,
      openPosts: openPosts,
      currentPostId: currentPostId
    },
    action: {
      selectPost: selectPost,
      closePost: closePost
    }
  };
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {
    value: appStore,
    children: children
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 68,
    columnNumber: 10
  }, _this);
};

_s2(AppContextProvider, "UlCu0OW1TFG6D2PMDsWnLrIIDLk=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter];
});

_c = AppContextProvider;


var _c;

$RefreshReg$(_c, "AppContextProvider");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/contexts/theme/context.ts":
/*!***************************************!*\
  !*** ./src/contexts/theme/context.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThemeContext": function() { return /* binding */ ThemeContext; },
/* harmony export */   "useThemeContext": function() { return /* binding */ useThemeContext; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();


var ThemeContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);
var useThemeContext = function useThemeContext() {
  _s();

  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);
};

_s(useThemeContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/contexts/theme/index.ts":
/*!*************************************!*\
  !*** ./src/contexts/theme/index.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThemeContextProvider": function() { return /* reexport safe */ _provider__WEBPACK_IMPORTED_MODULE_1__.default; }
/* harmony export */ });
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context */ "./src/contexts/theme/context.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _context__WEBPACK_IMPORTED_MODULE_0__) if(["default","ThemeContextProvider"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _context__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./provider */ "./src/contexts/theme/provider.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/contexts/theme/provider.tsx":
/*!*****************************************!*\
  !*** ./src/contexts/theme/provider.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ThemeContextProvider; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_themes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/themes */ "./src/themes/index.ts");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ "./src/contexts/theme/context.ts");
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\contexts\\theme\\provider.tsx",
    _s = $RefreshSig$();





function ThemeContextProvider(_ref) {
  _s();

  var defaultTheme = _ref.defaultTheme,
      children = _ref.children;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(defaultTheme),
      theme = _useState[0],
      setTheme = _useState[1];

  var toggleTheme = function toggleTheme() {
    setTheme(theme === "light" ? "dark" : "light");
  };

  var themeStore = {
    state: {
      theme: theme
    },
    action: {
      toggleTheme: toggleTheme
    }
  };
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(styled_components__WEBPACK_IMPORTED_MODULE_4__.ThemeProvider, {
    theme: {
      colors: theme === "light" ? _src_themes__WEBPACK_IMPORTED_MODULE_2__.light : _src_themes__WEBPACK_IMPORTED_MODULE_2__.dark
    },
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context__WEBPACK_IMPORTED_MODULE_3__.ThemeContext.Provider, {
      value: themeStore,
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 33,
    columnNumber: 5
  }, this);
}

_s(ThemeContextProvider, "FHn34gXH9qfbNc0YwENDsTaP8hM=");

_c = ThemeContextProvider;

var _c;

$RefreshReg$(_c, "ThemeContextProvider");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/helpers/gtag.ts":
/*!*****************************!*\
  !*** ./src/helpers/gtag.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GA_TRACKING_ID": function() { return /* binding */ GA_TRACKING_ID; },
/* harmony export */   "pageview": function() { return /* binding */ pageview; },
/* harmony export */   "event": function() { return /* binding */ event; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
/* provided dependency */ var process = __webpack_require__(/*! process */ "./.yarn/cache/process-npm-0.11.10-aeb3b641ae-bfcce49814.zip/node_modules/process/browser.js");
var GA_TRACKING_ID = process.env.GA_MEASUREMENT_ID || "";
// https://developers.google.com/analytics/devguides/collection/gtagjs/pages
var pageview = function pageview(_ref) {
  var url = _ref.url,
      title = _ref.title,
      href = _ref.href;
   false && 0;
};
// https://developers.google.com/analytics/devguides/collection/gtagjs/events
var event = function event(_ref2) {
  var action = _ref2.action,
      category = _ref2.category,
      label = _ref2.label,
      value = _ref2.value;
   false && 0;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/helpers/index.ts":
/*!******************************!*\
  !*** ./src/helpers/index.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _markdown_helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./markdown.helper */ "./src/helpers/markdown.helper.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _markdown_helper__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _markdown_helper__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* module decorator */ module = __webpack_require__.hmd(module);


;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/helpers/markdown.helper.ts":
/*!****************************************!*\
  !*** ./src/helpers/markdown.helper.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseMarkdown": function() { return /* binding */ parseMarkdown; }
/* harmony export */ });
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! marked */ "./.yarn/cache/marked-npm-2.0.6-d375c0da85-f9088d33f8.zip/node_modules/marked/lib/marked.js");
/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(marked__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismjs */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/prism.js");
/* harmony import */ var prismjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prismjs_components_prism_markup_templating__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prismjs/components/prism-markup-templating */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-markup-templating.js");
/* harmony import */ var prismjs_components_prism_markup_templating__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_markup_templating__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var prismjs_components_prism_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prismjs/components/prism-css */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-css.js");
/* harmony import */ var prismjs_components_prism_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var prismjs_components_prism_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prismjs/components/prism-json */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-json.js");
/* harmony import */ var prismjs_components_prism_json__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_json__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var prismjs_components_prism_javascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prismjs/components/prism-javascript */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-javascript.js");
/* harmony import */ var prismjs_components_prism_javascript__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_javascript__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var prismjs_components_prism_typescript__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prismjs/components/prism-typescript */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-typescript.js");
/* harmony import */ var prismjs_components_prism_typescript__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_typescript__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var prismjs_components_prism_jsx__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prismjs/components/prism-jsx */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-jsx.js");
/* harmony import */ var prismjs_components_prism_jsx__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_jsx__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var prismjs_components_prism_tsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prismjs/components/prism-tsx */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-tsx.js");
/* harmony import */ var prismjs_components_prism_tsx__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_tsx__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var prismjs_components_prism_bash__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prismjs/components/prism-bash */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-bash.js");
/* harmony import */ var prismjs_components_prism_bash__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_bash__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var prismjs_components_prism_yaml__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prismjs/components/prism-yaml */ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-yaml.js");
/* harmony import */ var prismjs_components_prism_yaml__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(prismjs_components_prism_yaml__WEBPACK_IMPORTED_MODULE_10__);
/* module decorator */ module = __webpack_require__.hmd(module);











marked__WEBPACK_IMPORTED_MODULE_0___default().setOptions({
  highlight: function highlight(code, lang) {
    if ((prismjs__WEBPACK_IMPORTED_MODULE_1___default().languages)[lang]) {
      return prismjs__WEBPACK_IMPORTED_MODULE_1___default().highlight(code, (prismjs__WEBPACK_IMPORTED_MODULE_1___default().languages)[lang], lang);
    } else {
      return code;
    }
  }
});
var parseMarkdown = function parseMarkdown(text) {
  return marked__WEBPACK_IMPORTED_MODULE_0___default().parse(text);
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/hooks/index.ts":
/*!****************************!*\
  !*** ./src/hooks/index.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _useCanvasContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useCanvasContext */ "./src/hooks/useCanvasContext.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _useCanvasContext__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _useCanvasContext__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _useDrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useDrag */ "./src/hooks/useDrag.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _useDrag__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _useDrag__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _useResizeDetector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useResizeDetector */ "./src/hooks/useResizeDetector.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _useResizeDetector__WEBPACK_IMPORTED_MODULE_2__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _useResizeDetector__WEBPACK_IMPORTED_MODULE_2__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* module decorator */ module = __webpack_require__.hmd(module);




;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/hooks/useCanvasContext.ts":
/*!***************************************!*\
  !*** ./src/hooks/useCanvasContext.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useCanvasContext": function() { return /* binding */ useCanvasContext; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();


var useCanvasContext = function useCanvasContext() {
  _s();

  var canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(),
      context = _useState[0],
      setContext = _useState[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    if (!canvasRef.current) return;
    var ctx = canvasRef.current.getContext("2d");
    if (!ctx) return;
    setContext(ctx);
  }, [canvasRef]);
  return {
    canvasRef: canvasRef,
    context: context
  };
};

_s(useCanvasContext, "WwcNrdMzup7J9mI1SWI2cUL5zG8=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/hooks/useDrag.ts":
/*!******************************!*\
  !*** ./src/hooks/useDrag.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useDrag": function() { return /* binding */ useDrag; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();


var useDrag = function useDrag(onDrag) {
  _s();

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),
      isDragging = _useState[0],
      setIsDragging = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    x: 0,
    y: 0
  }),
      start = _useState2[0],
      setStart = _useState2[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var handleMouseMove = function handleMouseMove(e) {
      if (isDragging) {
        onDrag({
          x: e.clientX - start.x,
          y: e.clientY - start.y
        });
      }
    };

    var handleMouseUp = function handleMouseUp() {
      setIsDragging(false);
      setStart({
        x: 0,
        y: 0
      });
    };

    if (isDragging) {
      window.addEventListener("mousemove", handleMouseMove);
      window.addEventListener("mouseup", handleMouseUp);
    }

    return function () {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    }; // 주의 : onDrag가 dependencies 배열에 들어가면 오작동한다.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isDragging, start]);

  var startDrag = function startDrag(e) {
    setIsDragging(true);
    setStart({
      x: e.clientX,
      y: e.clientY
    });
  };

  return {
    isDragging: isDragging,
    startDrag: startDrag
  };
};

_s(useDrag, "eaRk/ekjgbBbFJb+WA4cILIqhoY=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/hooks/useResizeDetector.ts":
/*!****************************************!*\
  !*** ./src/hooks/useResizeDetector.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useResizeDetector": function() { return /* binding */ useResizeDetector; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();


var useResizeDetector = function useResizeDetector() {
  _s();

  var ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    width: undefined,
    height: undefined
  }),
      size = _useState[0],
      setSize = _useState[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {
    var callback = function callback(entries) {
      entries.forEach(function (entry) {
        var _ref = entry && entry.contentRect || {},
            width = _ref.width,
            height = _ref.height;

        setSize({
          width: width,
          height: height
        });
      });
    };

    var resizeObserver = new ResizeObserver(callback);
    ref.current && resizeObserver.observe(ref.current);
    return function () {
      return resizeObserver.disconnect();
    };
  }, []);
  return {
    width: size.width,
    height: size.height,
    ref: ref
  };
};

_s(useResizeDetector, "ZjWeBxW+gy/h0fcRcGKmAzpYBFU=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/activity-bar/action-item/index.tsx":
/*!********************************************************************!*\
  !*** ./src/layouts/blog-layout/activity-bar/action-item/index.tsx ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\activity-bar\\action-item\\index.tsx",
    _this = undefined;

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  width: 3rem;\n  height: 3rem;\n  ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




var ActionItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(_c = function _c(_ref, ref) {
  var Icon = _ref.Icon,
      _ref$isSelected = _ref.isSelected,
      isSelected = _ref$isSelected === void 0 ? false : _ref$isSelected,
      onClick = _ref.onClick,
      _ref$onKeyDown = _ref.onKeyDown,
      onKeyDown = _ref$onKeyDown === void 0 ? function () {
    return null;
  } : _ref$onKeyDown;
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    ref: ref,
    tabIndex: 0,
    onClick: onClick,
    onKeyDown: onKeyDown,
    isSelected: isSelected,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Icon, {
      style: {
        width: "1.4rem",
        heigth: "1.4rem"
      },
      fill: isSelected ? _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__.WHITE : _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__.GRAY_100
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 9
    }, _this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 24,
    columnNumber: 7
  }, _this);
});
_c2 = ActionItem;
/* harmony default export */ __webpack_exports__["default"] = (ActionItem);
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.li(_templateObject(), function (_ref2) {
  var isSelected = _ref2.isSelected;
  return "border-left: 0.16rem solid ".concat(isSelected ? _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__.WHITE : "transparent");
});
_c3 = Wrapper;

var _c, _c2, _c3;

$RefreshReg$(_c, "ActionItem$React.forwardRef");
$RefreshReg$(_c2, "ActionItem");
$RefreshReg$(_c3, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/activity-bar/index.tsx":
/*!********************************************************!*\
  !*** ./src/layouts/blog-layout/activity-bar/index.tsx ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ACTIVITY_BAR_WIDTH": function() { return /* binding */ ACTIVITY_BAR_WIDTH; },
/* harmony export */   "ACTION_ITEMS": function() { return /* binding */ ACTION_ITEMS; },
/* harmony export */   "default": function() { return /* binding */ ActivityBar; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/assets/icons */ "./src/assets/icons/index.ts");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* harmony import */ var _src_components_common_theme_switcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @src/components/common/theme-switcher */ "./src/components/common/theme-switcher/index.tsx");
/* harmony import */ var _explorer_section__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../explorer-section */ "./src/layouts/blog-layout/explorer-section/index.tsx");
/* harmony import */ var _log_section__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../log-section */ "./src/layouts/blog-layout/log-section/index.tsx");
/* harmony import */ var _search_section__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../search-section */ "./src/layouts/blog-layout/search-section/index.tsx");
/* harmony import */ var _action_item__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./action-item */ "./src/layouts/blog-layout/activity-bar/action-item/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\activity-bar\\index.tsx",
    _s = $RefreshSig$();

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n\n  > :not(:last-child) {\n    margin-bottom: 0.4rem;\n  }\n\n  > li {\n    &:hover {\n      cursor: pointer;\n    }\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n\n  width: ", ";\n\n  background-color: ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}










var GITHUB_URL = "https://github.com/likelionSungGuk";
var ACTIVITY_BAR_WIDTH = "3rem";
var ACTION_ITEMS = [{
  label: "EXPLORER",
  Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.FilesIcon,
  content: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_explorer_section__WEBPACK_IMPORTED_MODULE_6__.default, {}, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 37,
    columnNumber: 14
  }, undefined)
}, {
  label: "SEARCH",
  Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.SearchIcon,
  content: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_search_section__WEBPACK_IMPORTED_MODULE_8__.default, {}, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 42,
    columnNumber: 14
  }, undefined)
}, {
  label: "POSTING LOG",
  Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.SourceControlIcon,
  content: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_log_section__WEBPACK_IMPORTED_MODULE_7__.default, {}, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 47,
    columnNumber: 14
  }, undefined)
}, {
  label: "RUN AND DEBUG",
  Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.RunAndDebugIcon,
  content: "RUN AND DEBUG"
}, {
  label: "EXTENSIONS",
  Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.ExtensionsIcon,
  content: "EXTENSIONS"
}];
function ActivityBar(_ref) {
  _s();

  var _this = this;

  var currentActionItem = _ref.currentActionItem,
      onCurrentActionItemChange = _ref.onCurrentActionItemChange,
      onKeyDown = _ref.onKeyDown;
  var itemsRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)([]);

  var handleItemClick = function handleItemClick(index) {
    return function () {
      onCurrentActionItemChange(index === currentActionItem ? null : index);
    };
  };

  var setFocusToPreviousItem = function setFocusToPreviousItem(index) {
    var _itemsRef$current$pre;

    var prevItemIdx = index === 0 ? ACTION_ITEMS.length - 1 : (index - 1) % ACTION_ITEMS.length;
    (_itemsRef$current$pre = itemsRef.current[prevItemIdx]) === null || _itemsRef$current$pre === void 0 ? void 0 : _itemsRef$current$pre.focus();
  };

  var setFocusToNextItem = function setFocusToNextItem(index) {
    var _itemsRef$current$nex;

    var nextItenIdx = (index + 1) % ACTION_ITEMS.length;
    (_itemsRef$current$nex = itemsRef.current[nextItenIdx]) === null || _itemsRef$current$nex === void 0 ? void 0 : _itemsRef$current$nex.focus();
  };

  var handleItemKeyDown = function handleItemKeyDown(index) {
    return function (e) {
      switch (e.key) {
        case " ":
        case "Enter":
          handleItemClick(index)();
          return;

        case "Up":
        case "ArrowUp":
          setFocusToPreviousItem(index);
          return;

        case "Down":
        case "ArrowDown":
          setFocusToNextItem(index);
          return;
      }
    };
  };

  var openGithubLink = function openGithubLink() {
    window.open(GITHUB_URL, "_blank");
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    onKeyDown: onKeyDown,
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Ul, {
      children: ACTION_ITEMS.map(function (_ref2, index) {
        var label = _ref2.label,
            Icon = _ref2.Icon;
        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_action_item__WEBPACK_IMPORTED_MODULE_9__.default, {
          ref: function ref(el) {
            return itemsRef.current[index] = el;
          },
          Icon: Icon,
          isSelected: index === currentActionItem,
          onClick: handleItemClick(index),
          onKeyDown: handleItemKeyDown(index)
        }, label, false, {
          fileName: _jsxFileName,
          lineNumber: 114,
          columnNumber: 11
        }, _this);
      })
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 112,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Ul, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_components_common_theme_switcher__WEBPACK_IMPORTED_MODULE_5__.default, {}, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 125,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_action_item__WEBPACK_IMPORTED_MODULE_9__.default, {
        Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.AccountIcon,
        onClick: openGithubLink
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 126,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_action_item__WEBPACK_IMPORTED_MODULE_9__.default, {
        Icon: _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.SettingsGearIcon,
        onClick: function onClick() {
          return null;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 127,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 124,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 111,
    columnNumber: 5
  }, this);
}

_s(ActivityBar, "3N1LDnRuOjrm6Bp4vMvsoKEhn+E=");

_c = ActivityBar;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_10__.default.nav(_templateObject(), ACTIVITY_BAR_WIDTH, _src_constants_palette__WEBPACK_IMPORTED_MODULE_4__.DRACULAR_BACKGROUND_LIGHT_DARK);
_c2 = Wrapper;
var Ul = styled_components__WEBPACK_IMPORTED_MODULE_10__.default.ul(_templateObject2());
_c3 = Ul;

var _c, _c2, _c3;

$RefreshReg$(_c, "ActivityBar");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Ul");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeItem.class.ts":
/*!**************************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeItem.class.ts ***!
  \**************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeItem": function() { return /* binding */ TreeItem; },
/* harmony export */   "File": function() { return /* binding */ File; },
/* harmony export */   "Folder": function() { return /* binding */ Folder; },
/* harmony export */   "isFolder": function() { return /* binding */ isFolder; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/inherits */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/getPrototypeOf */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* module decorator */ module = __webpack_require__.hmd(module);








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var TreeItem = /*#__PURE__*/function () {
  function TreeItem() {
    var _path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

    var _data = arguments.length > 1 ? arguments[1] : undefined;

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__.default)(this, TreeItem);

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(this, "_name", void 0);

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(this, "_path", void 0);

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)(this, "_data", void 0);

    this._name = _path.split("/").reverse()[0];
    this._path = _path;
    this._data = _data;
  }

  (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__.default)(TreeItem, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "path",
    get: function get() {
      return this._path;
    }
  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
  }]);

  return TreeItem;
}();
var File = /*#__PURE__*/function (_TreeItem) {
  (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__.default)(File, _TreeItem);

  var _super = _createSuper(File);

  function File() {
    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__.default)(this, File);

    return _super.apply(this, arguments);
  }

  return File;
}(TreeItem);
var Folder = /*#__PURE__*/function (_TreeItem2) {
  (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_1__.default)(Folder, _TreeItem2);

  var _super2 = _createSuper(Folder);

  function Folder() {
    var _this;

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__.default)(this, Folder);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super2.call.apply(_super2, [this].concat(args));

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__.default)((0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_0__.default)(_this), "_children", []);

    return _this;
  }

  (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__.default)(Folder, [{
    key: "add",
    value: function add(treeItem) {
      this._children.push(treeItem);

      return this;
    }
  }, {
    key: "find",
    value: function find(path) {
      return this._children.find(function (v) {
        return v.path === path;
      });
    }
  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
  }]);

  return Folder;
}(TreeItem);
var isFolder = function isFolder(item) {
  return item.children !== undefined;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeView.class.ts":
/*!**************************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeView.class.ts ***!
  \**************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TreeView; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _TreeItem_class__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TreeItem.class */ "./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeItem.class.ts");
/* module decorator */ module = __webpack_require__.hmd(module);





var TreeView = /*#__PURE__*/function () {
  function TreeView(data, mapFilePath) {
    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__.default)(this, TreeView);

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "root", new _TreeItem_class__WEBPACK_IMPORTED_MODULE_3__.Folder("root"));

    (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__.default)(this, "mapFilePath", void 0);

    this.mapFilePath = mapFilePath;
    this.createTree(data);
  }

  (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__.default)(TreeView, [{
    key: "createTree",
    value: function createTree(data) {
      var _this = this;

      data.map(function (v) {
        return _this.mapFilePath ? _this.addFile(_this.mapFilePath(v), v) : _this.addFile(v);
      });
    }
  }, {
    key: "splitPath",
    value: function splitPath(path) {
      return path.split("/").filter(function (v) {
        return !!v;
      });
    }
  }, {
    key: "addFile",
    value: function addFile(path, data) {
      var paths = this.splitPath(path);
      var leafFolderPath = paths.slice(0, paths.length - 1).join("/");
      this.accessToFolder(leafFolderPath).add(new _TreeItem_class__WEBPACK_IMPORTED_MODULE_3__.File(path, data));
      return this;
    }
  }, {
    key: "accessToFolder",
    value: function accessToFolder(path) {
      if (!path || path === "/") {
        return this.root;
      }

      var paths = this.splitPath(path);
      return paths.reduce(function (currentRoot, _, i) {
        var currentPath = paths.slice(0, i + 1).join("/");
        var currentFoler = currentRoot.find(currentPath);
        return currentFoler == null ? currentRoot.add(new _TreeItem_class__WEBPACK_IMPORTED_MODULE_3__.Folder(currentPath)).find(currentPath) : currentFoler;
      }, this.root);
    }
  }]);

  return TreeView;
}();



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/file-tree/classes/index.ts":
/*!*****************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/file-tree/classes/index.ts ***!
  \*****************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TreeView": function() { return /* reexport safe */ _TreeView_class__WEBPACK_IMPORTED_MODULE_0__.default; }
/* harmony export */ });
/* harmony import */ var _TreeView_class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeView.class */ "./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeView.class.ts");
/* harmony import */ var _TreeItem_class__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TreeItem.class */ "./src/layouts/blog-layout/explorer-section/file-tree/classes/TreeItem.class.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _TreeItem_class__WEBPACK_IMPORTED_MODULE_1__) if(["default","TreeView"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _TreeItem_class__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* module decorator */ module = __webpack_require__.hmd(module);



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/file-tree/file-tree-item/index.tsx":
/*!*************************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/file-tree/file-tree-item/index.tsx ***!
  \*************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FileTreeItem; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/assets/icons */ "./src/assets/icons/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\explorer-section\\file-tree\\file-tree-item\\index.tsx",
    _s = $RefreshSig$();

function _templateObject4() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  margin-left: 0.6rem;\n  ", ";\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  font-size: 0.8rem;\n  font-weight: 700;\n\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  align-items: center;\n\n  padding: 0.4rem 0.2rem;\n  ", ";\n\n  ", "\n  ", ";\n\n  &:hover {\n    cursor: pointer;\n  }\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




function FileTreeItem(_ref) {
  _s();

  var title = _ref.title,
      children = _ref.children,
      isSelected = _ref.isSelected,
      defaultExpanded = _ref.defaultExpanded,
      onClick = _ref.onClick;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(!!defaultExpanded),
      isExpanded = _useState[0],
      setIsExpanded = _useState[1];

  if (!children) {
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Li, {
      isSelected: isSelected,
      onClick: onClick,
      isFile: true,
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
        children: ["\uD83D\uDCDD ", title]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 7
    }, this);
  }

  var toggleExpand = function toggleExpand() {
    setIsExpanded(!isExpanded);
  };

  var ChevronIcon = isExpanded ? _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.ChevronDownIcon : _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.ChevronRightIcon;
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Li, {
      onClick: toggleExpand,
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(ChevronIcon, {
        style: {
          width: "1rem",
          height: "1rem"
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
        children: ["\uD83D\uDCC2 ", title]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 41,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 39,
      columnNumber: 7
    }, this), isExpanded && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Ul, {
      children: children
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 22
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 38,
    columnNumber: 5
  }, this);
}

_s(FileTreeItem, "Mxng1bsVhNIiltJavW+YKmr3gRo=");

_c = FileTreeItem;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.li(_templateObject());
_c2 = Wrapper;
var Li = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.li(_templateObject2(), function (_ref2) {
  var isFile = _ref2.isFile;
  return isFile ? "padding-left: 1.4rem;" : "";
}, function (_ref3) {
  var theme = _ref3.theme;
  return "&:hover { \n          background-color: ".concat(theme.colors.scheme.$gray300, ";\n       }");
}, function (_ref4) {
  var isSelected = _ref4.isSelected,
      theme = _ref4.theme;
  return isSelected ? "background-color: ".concat(theme.colors.scheme.$gray200, ";") : "";
});
_c3 = Li;
var Title = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.p(_templateObject3());
_c4 = Title;
var Ul = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.ul(_templateObject4(), function (_ref5) {
  var theme = _ref5.theme;
  return "border-left: 0.4px solid ".concat(theme.colors.scheme.$gray200);
});
_c5 = Ul;

var _c, _c2, _c3, _c4, _c5;

$RefreshReg$(_c, "FileTreeItem");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Li");
$RefreshReg$(_c4, "Title");
$RefreshReg$(_c5, "Ul");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/file-tree/index.tsx":
/*!**********************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/file-tree/index.tsx ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ FileTree; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _file_tree_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./file-tree-item */ "./src/layouts/blog-layout/explorer-section/file-tree/file-tree-item/index.tsx");
/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes */ "./src/layouts/blog-layout/explorer-section/file-tree/classes/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\explorer-section\\file-tree\\index.tsx";

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  margin-left: 0.6rem;\n  ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




function FileTree(_ref) {
  var _this = this;

  var posts = _ref.posts,
      _ref$currentPostId = _ref.currentPostId,
      currentPostId = _ref$currentPostId === void 0 ? null : _ref$currentPostId,
      selectPost = _ref.selectPost;
  var root = new _classes__WEBPACK_IMPORTED_MODULE_3__.TreeView(posts, function (post) {
    return post.id;
  }).root;

  var sortChildren = function sortChildren(children) {
    return children.sort(function (a, b) {
      return (0,_classes__WEBPACK_IMPORTED_MODULE_3__.isFolder)(a) && !(0,_classes__WEBPACK_IMPORTED_MODULE_3__.isFolder)(b) ? -1 : 0;
    });
  };

  var renderChildren = function renderChildren(children) {
    return sortChildren(children).map(function (item) {
      var _item$data$meta$title, _item$data;

      if ((0,_classes__WEBPACK_IMPORTED_MODULE_3__.isFolder)(item)) {
        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_file_tree_item__WEBPACK_IMPORTED_MODULE_2__.default, {
          title: item.name,
          children: renderChildren(item.children)
        }, item.name, false, {
          fileName: _jsxFileName,
          lineNumber: 29,
          columnNumber: 11
        }, _this);
      }

      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_file_tree_item__WEBPACK_IMPORTED_MODULE_2__.default, {
        title: (_item$data$meta$title = (_item$data = item.data) === null || _item$data === void 0 ? void 0 : _item$data.meta.title) !== null && _item$data$meta$title !== void 0 ? _item$data$meta$title : "",
        isSelected: item.path === currentPostId,
        onClick: function onClick() {
          return selectPost(item.path);
        }
      }, item.name, false, {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 9
      }, _this);
    });
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    children: renderChildren(root.children)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 45,
    columnNumber: 10
  }, this);
}
_c = FileTree;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.div(_templateObject(), function (_ref2) {
  var theme = _ref2.theme;
  return "border-left: 0.4px solid ".concat(theme.colors.scheme.$gray200);
});
_c2 = Wrapper;

var _c, _c2;

$RefreshReg$(_c, "FileTree");
$RefreshReg$(_c2, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/index.tsx":
/*!************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/index.tsx ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ExplorerSection; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_components_common_accordion_section__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/components/common/accordion-section */ "./src/components/common/accordion-section/index.tsx");
/* harmony import */ var _src_contexts_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/contexts/app */ "./src/contexts/app/index.tsx");
/* harmony import */ var _open_post_list_open_post_list_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./open-post-list/open-post-list-item */ "./src/layouts/blog-layout/explorer-section/open-post-list/open-post-list-item/index.tsx");
/* harmony import */ var _open_post_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./open-post-list */ "./src/layouts/blog-layout/explorer-section/open-post-list/index.tsx");
/* harmony import */ var _file_tree__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./file-tree */ "./src/layouts/blog-layout/explorer-section/file-tree/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\explorer-section\\index.tsx",
    _s = $RefreshSig$();

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}







var MAX_VISIBLE_ITEM = 4;
function ExplorerSection() {
  _s();

  var _useAppContext = (0,_src_contexts_app__WEBPACK_IMPORTED_MODULE_3__.useAppContext)(),
      _useAppContext$state = _useAppContext.state,
      posts = _useAppContext$state.posts,
      openPosts = _useAppContext$state.openPosts,
      currentPostId = _useAppContext$state.currentPostId,
      _useAppContext$action = _useAppContext.action,
      selectPost = _useAppContext$action.selectPost,
      closePost = _useAppContext$action.closePost;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_components_common_accordion_section__WEBPACK_IMPORTED_MODULE_2__.default, {
      title: "OPEN POSTS",
      height: "calc(".concat(_open_post_list_open_post_list_item__WEBPACK_IMPORTED_MODULE_4__.OPEN_POST_LIST_ITEM_HEIGHT, " * ").concat(openPosts.length, ")"),
      maxHeight: "calc(".concat(_open_post_list_open_post_list_item__WEBPACK_IMPORTED_MODULE_4__.OPEN_POST_LIST_ITEM_HEIGHT, " * ").concat(MAX_VISIBLE_ITEM, ")"),
      defaultExpanded: true,
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_open_post_list__WEBPACK_IMPORTED_MODULE_5__.default, {
        openPosts: openPosts,
        currentPostId: currentPostId,
        selectPost: selectPost,
        closePost: closePost
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 26,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_components_common_accordion_section__WEBPACK_IMPORTED_MODULE_2__.default, {
      title: "BLOG POSTS",
      defaultExpanded: true,
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_file_tree__WEBPACK_IMPORTED_MODULE_6__.default, {
        posts: posts,
        currentPostId: currentPostId,
        selectPost: selectPost
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 19,
    columnNumber: 5
  }, this);
}

_s(ExplorerSection, "H+AIWUNhIrl2KY4rbUtV3V0F34M=", false, function () {
  return [_src_contexts_app__WEBPACK_IMPORTED_MODULE_3__.useAppContext];
});

_c = ExplorerSection;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_7__.default.div(_templateObject());
_c2 = Wrapper;

var _c, _c2;

$RefreshReg$(_c, "ExplorerSection");
$RefreshReg$(_c2, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/open-post-list/index.tsx":
/*!***************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/open-post-list/index.tsx ***!
  \***************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ OpenPostList; }
/* harmony export */ });
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _open_post_list_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./open-post-list-item */ "./src/layouts/blog-layout/explorer-section/open-post-list/open-post-list-item/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);

var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\explorer-section\\open-post-list\\index.tsx";

function OpenPostList(props) {
  var _this = this;

  var openPosts = props.openPosts,
      currentPostId = props.currentPostId,
      selectPost = props.selectPost,
      closePost = props.closePost;
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("ul", {
    style: {
      whiteSpace: "nowrap"
    },
    children: openPosts.map(function (_ref) {
      var id = _ref.id,
          meta = _ref.meta;
      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_open_post_list_item__WEBPACK_IMPORTED_MODULE_1__.default, {
        title: meta.title,
        isSelected: currentPostId === id,
        onClick: function onClick() {
          return selectPost(id);
        },
        onClose: function onClose() {
          return closePost(id);
        },
        showCloseButton: true
      }, id, false, {
        fileName: _jsxFileName,
        lineNumber: 18,
        columnNumber: 9
      }, _this);
    })
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 16,
    columnNumber: 5
  }, this);
}
_c = OpenPostList;

var _c;

$RefreshReg$(_c, "OpenPostList");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/explorer-section/open-post-list/open-post-list-item/index.tsx":
/*!***********************************************************************************************!*\
  !*** ./src/layouts/blog-layout/explorer-section/open-post-list/open-post-list-item/index.tsx ***!
  \***********************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OPEN_POST_LIST_ITEM_HEIGHT": function() { return /* binding */ OPEN_POST_LIST_ITEM_HEIGHT; },
/* harmony export */   "default": function() { return /* binding */ OpenPostListItem; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/assets/icons */ "./src/assets/icons/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\explorer-section\\open-post-list\\open-post-list-item\\index.tsx",
    _s = $RefreshSig$();

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  padding-left: 0.4rem;\n  font-size: 0.8rem;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  ", "\n  &:hover {\n    cursor: pointer;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




var OPEN_POST_LIST_ITEM_HEIGHT = "2rem";
function OpenPostListItem(_ref) {
  _s();

  var _ref$emoji = _ref.emoji,
      emoji = _ref$emoji === void 0 ? "📝" : _ref$emoji,
      title = _ref.title,
      _ref$isSelected = _ref.isSelected,
      isSelected = _ref$isSelected === void 0 ? false : _ref$isSelected,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === void 0 ? function () {
    return null;
  } : _ref$onClick,
      _ref$onClose = _ref.onClose,
      onClose = _ref$onClose === void 0 ? function () {
    return null;
  } : _ref$onClose,
      _ref$showCloseButton = _ref.showCloseButton,
      showCloseButton = _ref$showCloseButton === void 0 ? false : _ref$showCloseButton;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false),
      isHovered = _useState[0],
      setIsHovered = _useState[1];

  var isCloseVisible = showCloseButton && (isSelected || isHovered);

  var handleCloseClick = function handleCloseClick(e) {
    e.stopPropagation();
    onClose();
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    height: OPEN_POST_LIST_ITEM_HEIGHT,
    isSelected: isSelected,
    onClick: onClick,
    onMouseOver: function onMouseOver() {
      return setIsHovered(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setIsHovered(false);
    },
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.CloseIcon, {
      style: {
        minWidth: "1rem",
        width: "1rem",
        height: "1rem",
        visibility: isCloseVisible ? "visible" : "hidden"
      },
      onClick: handleCloseClick
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
      children: [emoji, " ", title]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 35,
    columnNumber: 5
  }, this);
}

_s(OpenPostListItem, "FPQn8a98tPjpohC7NUYORQR8GJE=");

_c = OpenPostListItem;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.li(_templateObject(), function (_ref2) {
  var height = _ref2.height,
      isSelected = _ref2.isSelected,
      theme = _ref2.theme;
  return "\n    display: flex;\n    flex-direction: Row;\n    align-items: center;\n\n    height: ".concat(height, ";\n    padding: 0 1.2rem;\n\n    ").concat(isSelected ? "background-color: ".concat(theme.colors.scheme.$gray200, ";") : "&:hover { \n              background-color: ".concat(theme.colors.scheme.$gray300, ";\n          }"), "\n  ");
});
_c2 = Wrapper;
var Title = styled_components__WEBPACK_IMPORTED_MODULE_4__.default.p(_templateObject2());
_c3 = Title;

var _c, _c2, _c3;

$RefreshReg$(_c, "OpenPostListItem");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Title");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/index.tsx":
/*!*******************************************!*\
  !*** ./src/layouts/blog-layout/index.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BlogLayout; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* harmony import */ var _activity_bar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activity-bar */ "./src/layouts/blog-layout/activity-bar/index.tsx");
/* harmony import */ var _side_bar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./side-bar */ "./src/layouts/blog-layout/side-bar/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\index.tsx",
    _s = $RefreshSig$();

function _templateObject5() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  height: 1.6rem;\n  background-color: ", ";\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex: 1;\n\n  overflow-x: hidden;\n  overflow-y: hidden;\n\n  background-color: ", ";\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex: 1;\n\n  display: flex;\n  flex-direction: row;\n\n  overflow: hidden;\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  height: 1.6rem;\n  background-color: ", ";\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n\n  width: 100vw;\n  height: 100vh;\n\n  background-color: ", ";\n  color: ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}






function BlogLayout(_ref) {
  _s();

  var children = _ref.children;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null),
      currentActionItem = _useState[0],
      setCurrentActionItem = _useState[1];

  var sideBarRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);

  var handleActivityBarKeyDown = function handleActivityBarKeyDown(e) {
    if (["ArrowRight", "Right"].includes(e.key)) {
      var _sideBarRef$current;

      (_sideBarRef$current = sideBarRef.current) === null || _sideBarRef$current === void 0 ? void 0 : _sideBarRef$current.focus();
    }
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Header, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Row, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_activity_bar__WEBPACK_IMPORTED_MODULE_4__.default, {
        currentActionItem: currentActionItem,
        onCurrentActionItemChange: setCurrentActionItem,
        onKeyDown: handleActivityBarKeyDown
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 9
      }, this), currentActionItem != null && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_side_bar__WEBPACK_IMPORTED_MODULE_5__.default, {
        ref: sideBarRef,
        label: _activity_bar__WEBPACK_IMPORTED_MODULE_4__.ACTION_ITEMS[currentActionItem].label,
        content: _activity_bar__WEBPACK_IMPORTED_MODULE_4__.ACTION_ITEMS[currentActionItem].content,
        onClose: function onClose() {
          return setCurrentActionItem(null);
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 36,
        columnNumber: 11
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Main, {
        children: children
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Footer, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 27,
    columnNumber: 5
  }, this);
}

_s(BlogLayout, "S+JxIVNYT3kuO7onATTJW4cImyk=");

_c = BlogLayout;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_6__.default.div(_templateObject(), function (_ref2) {
  var theme = _ref2.theme;
  return theme.colors.semanticScheme.mainBg;
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.colors.scheme.$white;
});
_c2 = Wrapper;
var Header = styled_components__WEBPACK_IMPORTED_MODULE_6__.default.header(_templateObject2(), _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__.GRAY_300);
_c3 = Header;
var Row = styled_components__WEBPACK_IMPORTED_MODULE_6__.default.div(_templateObject3());
_c4 = Row;
var Main = styled_components__WEBPACK_IMPORTED_MODULE_6__.default.main(_templateObject4(), function (_ref4) {
  var theme = _ref4.theme;
  return theme.colors.semanticScheme.mainBg;
});
_c5 = Main;
var Footer = styled_components__WEBPACK_IMPORTED_MODULE_6__.default.footer(_templateObject5(), _src_constants_palette__WEBPACK_IMPORTED_MODULE_3__.GRAY_600);
_c6 = Footer;

var _c, _c2, _c3, _c4, _c5, _c6;

$RefreshReg$(_c, "BlogLayout");
$RefreshReg$(_c2, "Wrapper");
$RefreshReg$(_c3, "Header");
$RefreshReg$(_c4, "Row");
$RefreshReg$(_c5, "Main");
$RefreshReg$(_c6, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/log-section/index.tsx":
/*!*******************************************************!*\
  !*** ./src/layouts/blog-layout/log-section/index.tsx ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _src_contexts_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/contexts/app */ "./src/contexts/app/index.tsx");
/* harmony import */ var _src_components_common_scroll_pagenation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/components/common/scroll-pagenation */ "./src/components/common/scroll-pagenation/index.tsx");
/* harmony import */ var _log_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log-item */ "./src/layouts/blog-layout/log-section/log-item.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\log-section\\index.tsx",
    _s = $RefreshSig$();






function LogSection() {
  _s();

  var _this = this;

  var _useAppContext = (0,_src_contexts_app__WEBPACK_IMPORTED_MODULE_3__.useAppContext)(),
      posts = _useAppContext.state.posts,
      selectPost = _useAppContext.action.selectPost;

  var sortedPosts = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(function () {
    // 최신순 정렬
    return (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(posts).sort(function (a, b) {
      return b.meta.date.localeCompare(a.meta.date);
    });
  }, [posts]);

  var handleClick = function handleClick(e) {
    var itemElem = e.target.closest(".logItem");

    if (itemElem && itemElem.dataset.id) {
      selectPost(itemElem.dataset.id);
    }
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_components_common_scroll_pagenation__WEBPACK_IMPORTED_MODULE_4__.default, {
    data: sortedPosts,
    renderItem: function renderItem(curr, prev) {
      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_log_item__WEBPACK_IMPORTED_MODULE_5__.default, {
        currPost: curr,
        prevPost: prev
      }, curr.id, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, _this);
    },
    onClick: handleClick
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 31,
    columnNumber: 5
  }, this);
}

_s(LogSection, "JWmeI/DKQJb2SBIM709MeTWOZTE=", false, function () {
  return [_src_contexts_app__WEBPACK_IMPORTED_MODULE_3__.useAppContext];
});

_c = LogSection;
/* harmony default export */ __webpack_exports__["default"] = (LogSection);

var _c;

$RefreshReg$(_c, "LogSection");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/log-section/log-item.tsx":
/*!**********************************************************!*\
  !*** ./src/layouts/blog-layout/log-section/log-item.tsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\log-section\\log-item.tsx";

function _templateObject9() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate3d(-50%, -50%, 0);\n\n  width: 0.6rem;\n  height: 0.6rem;\n  border-radius: 50%;\n\n  background-color: ", ";\n"]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: absolute;\n  left: 50%;\n  transform: translateX(-50%);\n\n  width: 0.1rem;\n  height: 100%;\n\n  background-color: ", ";\n"]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: relative;\n\n  flex-shrink: 0;\n  width: 1.6rem;\n  height: 100%;\n"]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex: 1;\n\n  margin-left: 0.8rem;\n\n  font-size: 0.8rem;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n  width: 1.4rem;\n\n  font-size: 0.8rem;\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n  width: 3rem;\n\n  font-size: 1.2rem;\n  font-weight: bold;\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n\n  width: 100%;\n  height: 2rem;\n\n  padding: 0 0.8rem;\n\n  &:hover {\n    background-color: ", ";\n  }\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  font-size: 1.4rem;\n  font-weight: bold;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  width: 100%;\n\n  padding: 0 0.8rem;\n  margin-bottom: 0.4rem;\n\n  ", ";\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}




function LogItem(_ref) {
  var _this = this;

  var currPost = _ref.currPost,
      prevPost = _ref.prevPost;
  var currDate = new Date(currPost.meta.date);
  var prevDate = prevPost ? new Date(prevPost.meta.date) : null;
  var showYear = (prevDate === null || prevDate === void 0 ? void 0 : prevDate.getFullYear()) !== currDate.getFullYear();
  var showMonth = (prevDate === null || prevDate === void 0 ? void 0 : prevDate.getMonth()) !== currDate.getMonth();
  var showDate = (prevDate === null || prevDate === void 0 ? void 0 : prevDate.getDate()) !== currDate.getDate();

  var getMonthText = function getMonthText() {
    return currDate.toLocaleString("default", {
      month: "short"
    });
  };

  var renderYear = function renderYear() {
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(YearWrapper, {
      isFirst: !prevPost,
      children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Year, {
        children: currDate.getFullYear()
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 7
      }, _this)
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 5
    }, _this);
  };

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {
    children: [showYear && renderYear(), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
      className: "logItem",
      "data-id": currPost.id,
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Month, {
        children: showMonth ? getMonthText() : ""
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 33,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_Date, {
        children: showDate ? currDate.getDate() : ""
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 34,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Pin, {
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Line, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 36,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Dot, {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 37,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
        children: currPost.meta.title
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 32,
      columnNumber: 7
    }, this)]
  }, void 0, true);
}

_c = LogItem;
/* harmony default export */ __webpack_exports__["default"] = (LogItem);
var YearWrapper = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.li(_templateObject(), function (_ref2) {
  var isFirst = _ref2.isFirst;
  return !isFirst && "margin-top: 0.8rem;";
});
_c2 = YearWrapper;
var Year = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.b(_templateObject2());
_c3 = Year;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.li(_templateObject3(), function (_ref3) {
  var theme = _ref3.theme;
  return "".concat(theme.colors.scheme.$gray300);
});
_c4 = Wrapper;
var Month = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.b(_templateObject4());
_c5 = Month;

var _Date = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.span(_templateObject5());

var Title = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.span(_templateObject6());
_c6 = Title;
var Pin = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.div(_templateObject7());
_c7 = Pin;
var Line = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.div(_templateObject8(), _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.GREEN);
_c8 = Line;
var Dot = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.div(_templateObject9(), _src_constants_palette__WEBPACK_IMPORTED_MODULE_2__.GREEN);
_c9 = Dot;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9;

$RefreshReg$(_c, "LogItem");
$RefreshReg$(_c2, "YearWrapper");
$RefreshReg$(_c3, "Year");
$RefreshReg$(_c4, "Wrapper");
$RefreshReg$(_c5, "Month");
$RefreshReg$(_c6, "Title");
$RefreshReg$(_c7, "Pin");
$RefreshReg$(_c8, "Line");
$RefreshReg$(_c9, "Dot");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/search-section/index.tsx":
/*!**********************************************************!*\
  !*** ./src/layouts/blog-layout/search-section/index.tsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ SearchSection; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _tags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tags */ "./src/layouts/blog-layout/search-section/tags/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);


var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\search-section\\index.tsx";

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}



function SearchSection() {
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_tags__WEBPACK_IMPORTED_MODULE_2__.default, {}, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 8,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 7,
    columnNumber: 5
  }, this);
}
_c = SearchSection;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_3__.default.div(_templateObject());
_c2 = Wrapper;

var _c, _c2;

$RefreshReg$(_c, "SearchSection");
$RefreshReg$(_c2, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/search-section/tags/index.tsx":
/*!***************************************************************!*\
  !*** ./src/layouts/blog-layout/search-section/tags/index.tsx ***!
  \***************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TagsSection; }
/* harmony export */ });
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_components_common_accordion_section__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/components/common/accordion-section */ "./src/components/common/accordion-section/index.tsx");
/* harmony import */ var _src_components_common_tag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @src/components/common/tag */ "./src/components/common/tag/index.tsx");
/* harmony import */ var _src_contexts_app__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @src/contexts/app */ "./src/contexts/app/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);




var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\search-section\\tags\\index.tsx",
    _s = $RefreshSig$();

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  padding: 0.8rem;\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}






function TagsSection() {
  _s();

  var _this = this;

  var _useAppContext = (0,_src_contexts_app__WEBPACK_IMPORTED_MODULE_6__.useAppContext)(),
      posts = _useAppContext.state.posts;

  var tags = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(function () {
    return posts.reduce(function (acc, _ref) {
      var tags = _ref.meta.tags;
      tags === null || tags === void 0 ? void 0 : tags.forEach(function (tag) {
        if (acc[tag] == null) {
          acc[tag] = 0;
        }

        acc[tag] += 1;
      });
      return acc;
    }, {});
  }, [posts]);
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_components_common_accordion_section__WEBPACK_IMPORTED_MODULE_4__.default, {
    title: "Tags",
    defaultExpanded: true,
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
      children: Object.entries(tags).map(function (_ref2) {
        var _ref3 = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.default)(_ref2, 2),
            key = _ref3[0],
            value = _ref3[1];

        return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_src_components_common_tag__WEBPACK_IMPORTED_MODULE_5__.default, {
          count: value,
          href: "/posts?tag=".concat(key),
          children: key
        }, key, false, {
          fileName: _jsxFileName,
          lineNumber: 29,
          columnNumber: 11
        }, _this);
      })
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 26,
    columnNumber: 5
  }, this);
}

_s(TagsSection, "MH00hHYSOiah1J+6BFczD0ABXNY=", false, function () {
  return [_src_contexts_app__WEBPACK_IMPORTED_MODULE_6__.useAppContext];
});

_c = TagsSection;
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_7__.default.div(_templateObject());
_c2 = Wrapper;

var _c, _c2;

$RefreshReg$(_c, "TagsSection");
$RefreshReg$(_c2, "Wrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/blog-layout/side-bar/index.tsx":
/*!****************************************************!*\
  !*** ./src/layouts/blog-layout/side-bar/index.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! styled-components */ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js");
/* harmony import */ var _src_assets_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @src/assets/icons */ "./src/assets/icons/index.ts");
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* harmony import */ var _src_hooks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @src/hooks */ "./src/hooks/index.ts");
/* harmony import */ var _src_styles_theme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @src/styles/theme */ "./src/styles/theme.ts");
/* harmony import */ var _activity_bar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../activity-bar */ "./src/layouts/blog-layout/activity-bar/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "C:\\Users\\sungkook\\Documents\\dev\\vscode-theme\\src\\layouts\\blog-layout\\side-bar\\index.tsx",
    _this = undefined,
    _s = $RefreshSig$();

function _templateObject6() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: absolute;\n  top: 0;\n  right: 0;\n\n  width: 0.2rem;\n  height: 100%;\n\n  background-color: ", ";\n\n  &:hover {\n    cursor: col-resize;\n  }\n"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex: 1;\n\n  overflow: hidden;\n"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  display: none;\n\n  ", " {\n    display: block;\n  }\n"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  font-size: 0.8rem;\n  font-weight: 400;\n  color: ", ";\n"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  flex-shrink: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n\n  height: 2.4rem;\n  padding: 0 0.8rem;\n"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__.default)(["\n  position: relative;\n\n  flex-shrink: 0;\n\n  display: flex;\n  flex-direction: column;\n\n  width: ", "px;\n  background-color: ", ";\n\n  ", " {\n    width: calc(100% - ", ");\n    z-index: 1;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}








var INITIAL_WIDTH = 320;
var MIN_WIDTH = 80;
var SideBar = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_2__.forwardRef)(_c = _s(function (_ref, ref) {
  _s();

  var label = _ref.label,
      content = _ref.content,
      onClose = _ref.onClose;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(INITIAL_WIDTH),
      width = _useState[0],
      setWidth = _useState[1];

  var _useDrag = (0,_src_hooks__WEBPACK_IMPORTED_MODULE_5__.useDrag)(function (movement) {
    var nextWidth = width + movement.x;

    if (nextWidth <= MIN_WIDTH) {
      onClose();
      setWidth(INITIAL_WIDTH);
      return;
    }

    setWidth(nextWidth);
  }),
      isDragging = _useDrag.isDragging,
      startDrag = _useDrag.startDrag;

  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Wrapper, {
    ref: ref,
    tabIndex: 0,
    width: width,
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(TitleWrapper, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Title, {
        children: label
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 39,
        columnNumber: 11
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(CloseIcon, {
        onClick: onClose
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 11
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 9
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(ContentWrapper, {
      children: content
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 9
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(DraggableLine, {
      onMouseDown: startDrag,
      isVisible: isDragging
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 9
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 37,
    columnNumber: 7
  }, _this);
}, "ARXW+8rVLEbzybAkYA9hwBpcjoY=", false, function () {
  return [_src_hooks__WEBPACK_IMPORTED_MODULE_5__.useDrag];
}));
_c2 = SideBar;
/* harmony default export */ __webpack_exports__["default"] = (SideBar);
var Wrapper = styled_components__WEBPACK_IMPORTED_MODULE_8__.default.section(_templateObject(), function (props) {
  return props.width;
}, function (_ref2) {
  var theme = _ref2.theme;
  return theme.colors.semanticScheme.sideBarBg;
}, _src_styles_theme__WEBPACK_IMPORTED_MODULE_6__.breakpoints.small, _activity_bar__WEBPACK_IMPORTED_MODULE_7__.ACTIVITY_BAR_WIDTH);
_c3 = Wrapper;
var TitleWrapper = styled_components__WEBPACK_IMPORTED_MODULE_8__.default.div(_templateObject2());
_c4 = TitleWrapper;
var Title = styled_components__WEBPACK_IMPORTED_MODULE_8__.default.h2(_templateObject3(), function (_ref3) {
  var theme = _ref3.theme;
  return theme.colors.scheme.$gray100;
});
_c5 = Title;
var CloseIcon = (0,styled_components__WEBPACK_IMPORTED_MODULE_8__.default)(_src_assets_icons__WEBPACK_IMPORTED_MODULE_3__.CloseIcon).attrs({
  style: {
    width: "1.2rem",
    height: "1.2rem"
  }
})(_templateObject4(), _src_styles_theme__WEBPACK_IMPORTED_MODULE_6__.breakpoints.small);
_c6 = CloseIcon;
var ContentWrapper = styled_components__WEBPACK_IMPORTED_MODULE_8__.default.div(_templateObject5());
_c7 = ContentWrapper;
var DraggableLine = styled_components__WEBPACK_IMPORTED_MODULE_8__.default.div(_templateObject6(), function (_ref4) {
  var isVisible = _ref4.isVisible;
  return isVisible ? _src_constants_palette__WEBPACK_IMPORTED_MODULE_4__.BLUE : "transparent";
});
_c8 = DraggableLine;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8;

$RefreshReg$(_c, "SideBar$forwardRef");
$RefreshReg$(_c2, "SideBar");
$RefreshReg$(_c3, "Wrapper");
$RefreshReg$(_c4, "TitleWrapper");
$RefreshReg$(_c5, "Title");
$RefreshReg$(_c6, "CloseIcon");
$RefreshReg$(_c7, "ContentWrapper");
$RefreshReg$(_c8, "DraggableLine");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/layouts/index.ts":
/*!******************************!*\
  !*** ./src/layouts/index.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlogLayout": function() { return /* reexport safe */ _blog_layout__WEBPACK_IMPORTED_MODULE_0__.default; }
/* harmony export */ });
/* harmony import */ var _blog_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blog-layout */ "./src/layouts/blog-layout/index.tsx");
/* module decorator */ module = __webpack_require__.hmd(module);


;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/services/post.service.ts":
/*!**************************************!*\
  !*** ./src/services/post.service.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var gray_matter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gray-matter */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/index.js");
/* harmony import */ var gray_matter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gray_matter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers */ "./src/helpers/index.ts");
/* module decorator */ module = __webpack_require__.hmd(module);




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }




var filterPosts = function filterPosts(posts, filter) {
  if (!filter) {
    return posts;
  }

  var tag = filter.tag;
  var filteredPosts = posts;

  if (tag) {
    filteredPosts = filteredPosts.filter(function (post) {
      var _post$meta$tags;

      return (_post$meta$tags = post.meta.tags) === null || _post$meta$tags === void 0 ? void 0 : _post$meta$tags.includes(tag);
    });
  }

  return filteredPosts;
};

var getPosts = /*#__PURE__*/function () {
  var _ref = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(filter) {
    var context, posts;
    return C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            // request only markdown files which is ending with .md
            context = __webpack_require__("./contents/blog sync recursive ^\\.\\/.*$");
            posts = [];
            _context2.next = 4;
            return Promise.all(context.keys().map( /*#__PURE__*/function () {
              var _ref2 = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(key) {
                var path, post;
                return C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        path = key.slice(2); // 맨 앞 './' 문자열 제거

                        _context.next = 3;
                        return getPost(path);

                      case 3:
                        post = _context.sent;
                        posts.push(post);

                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x2) {
                return _ref2.apply(this, arguments);
              };
            }()));

          case 4:
            return _context2.abrupt("return", filter ? filterPosts(posts, filter) : posts);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getPosts(_x) {
    return _ref.apply(this, arguments);
  };
}();

var getPost = /*#__PURE__*/function () {
  var _ref3 = (0,C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__.default)( /*#__PURE__*/C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3(id) {
    var _data$description;

    var _yield$import, markdown, _matter, data, content;

    return C_Users_sungkook_Documents_dev_vscode_theme_yarn_cache_babel_runtime_npm_7_12_5_b3edb8ee8e_64964a0fd1_zip_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return __webpack_require__("./contents/blog lazy recursive ^\\.\\/.*$")("./".concat(id));

          case 2:
            _yield$import = _context3.sent;
            markdown = _yield$import["default"];
            _matter = gray_matter__WEBPACK_IMPORTED_MODULE_3___default()(markdown), data = _matter.data, content = _matter.content;
            return _context3.abrupt("return", {
              id: id,
              meta: _objectSpread(_objectSpread({}, data), {}, {
                description: (_data$description = data.description) !== null && _data$description !== void 0 ? _data$description : content.split("\n").slice(0, 4).join(" ")
              }),
              html: (0,_helpers__WEBPACK_IMPORTED_MODULE_4__.parseMarkdown)(content)
            });

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function getPost(_x3) {
    return _ref3.apply(this, arguments);
  };
}();

var PostService = {
  getPosts: getPosts,
  getPost: getPost
};
/* harmony default export */ __webpack_exports__["default"] = (PostService);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/styles/theme.ts":
/*!*****************************!*\
  !*** ./src/styles/theme.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "breakpoints": function() { return /* binding */ breakpoints; }
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
var breakpoints = {
  small: "@media (max-width: 600px)",
  medium: "@media (max-width: 768px)",
  large: "@media (min-width: 769px)"
};


;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/themes/dark.ts":
/*!****************************!*\
  !*** ./src/themes/dark.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dark": function() { return /* binding */ dark; }
/* harmony export */ });
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* module decorator */ module = __webpack_require__.hmd(module);

var dark = Object.freeze({
  scheme: {
    $white: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.WHITE,
    $gray100: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_100,
    $gray200: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_200,
    $gray300: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_300,
    $gray400: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_400,
    $gray500: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_500,
    $gray600: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_600,
    $tagFontColor: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GREEN
  },
  semanticScheme: {
    sideBarBg: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.PURPLE_DARK,
    mainBg: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.DRACULAR_BACKGROUND_DEEP_DARK
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/themes/index.ts":
/*!*****************************!*\
  !*** ./src/themes/index.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _light__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./light */ "./src/themes/light.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _light__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _light__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _dark__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dark */ "./src/themes/dark.ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _dark__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _dark__WEBPACK_IMPORTED_MODULE_1__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* module decorator */ module = __webpack_require__.hmd(module);



;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./src/themes/light.ts":
/*!*****************************!*\
  !*** ./src/themes/light.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "light": function() { return /* binding */ light; }
/* harmony export */ });
/* harmony import */ var _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @src/constants/palette */ "./src/constants/palette.ts");
/* module decorator */ module = __webpack_require__.hmd(module);

var light = Object.freeze({
  scheme: {
    $white: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_600,
    $gray100: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.GRAY_100,
    $gray200: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.LIGHT_GRAY_400,
    $gray300: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.LIGHT_GRAY_300,
    $gray400: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.LIGHT_GRAY_200,
    $gray500: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.LIGHT_GRAY_100,
    $gray600: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.WHITE,
    $tagFontColor: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.PURPLE_DARK
  },
  semanticScheme: {
    sideBarBg: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.LIGHT_GRAY_100,
    mainBg: _src_constants_palette__WEBPACK_IMPORTED_MODULE_0__.WHITE
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!":
/*!*******************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx! ***!
  \*******************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/_app",
      function () {
        return __webpack_require__(/*! private-next-pages/_app.tsx */ "./pages/_app.tsx");
      }
    ]);
  

/***/ }),

/***/ "./src/styles/global.css":
/*!*******************************!*\
  !*** ./src/styles/global.css ***!
  \*******************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./global.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/global.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./global.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/global.css",
      function () {
        content = __webpack_require__(/*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./global.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/global.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./src/styles/post.css":
/*!*****************************!*\
  !*** ./src/styles/post.css ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./post.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/post.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element){// These elements should always exist. If they do not,
// this code should fail.
var anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>
// Each style tag should be placed right before our
// anchor. By inserting before and not after, we do not
// need to track the last inserted element.
parentNode.insertBefore(element,anchorElement);};
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue
continue;}if(!a[p]){return false;}}return true;};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./post.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/post.css",
      function () {
        content = __webpack_require__(/*! !!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./post.css */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/post.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \********************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks
// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
// Tests for existence of standard globals is to allow style-loader
// to operate correctly into non-standard environments
// @see https://github.com/webpack-contrib/style-loader/issues/177
memo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself
if(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked
// due to cross-origin restrictions
styleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next
styleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=id+' '+count.toString();idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier:identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef
 true?__webpack_require__.nc:0;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(function(key){style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if
if(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?'@media '+obj.media+' {'+obj.css+'}':obj.css;// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+='\n/*# sourceMappingURL=data:application/json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))+' */';}// For old IE
/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=function(){removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=function(list,options){options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
if(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};
//# sourceMappingURL=injectStylesIntoStyleTag.js.map

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(module) {

var __dirname = "/";
module.exports=function(){"use strict";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return"@media ".concat(t[2]," {").concat(r,"}")}return r}).join("")};t.i=function(n,r,o){if(typeof n==="string"){n=[[null,n,""]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]="".concat(r," and ").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||"";var o=n[3];if(!o){return r}if(t&&typeof btoa==="function"){var e=toComment(o);var a=o.sources.map(function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")});return[r].concat(a).concat([e]).join("\n")}return[r].join("\n")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(t);return"/*# ".concat(r," */")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(762)}();

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/global.css":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/global.css ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, "html {\r\n  font-family: \"Spoqa Han Sans Neo\", \"sans-serif\";\r\n  font-size: 16px;\r\n}\r\n\r\nhtml,\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\nbody {\r\n  font-size: 1rem;\r\n}\r\n\r\n*,\r\n::after,\r\n::before {\r\n  box-sizing: border-box;\r\n}\r\n\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6,\r\np,\r\nul,\r\nol,\r\nli {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nul,\r\nol {\r\n  list-style-type: none;\r\n}\r\n\r\na {\r\n  text-decoration: none;\r\n  color: inherit;\r\n}\r\n\r\ninput {\r\n  -webkit-appearance: none;\r\n  -webkit-border-radius: 0;\r\n}\r\n\r\n@media (max-width: 600px) {\r\n  html {\r\n    font-size: 15px;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://src/styles/global.css"],"names":[],"mappings":"AAAA;EACE,+CAA+C;EAC/C,eAAe;AACjB;;AAEA;;EAEE,SAAS;EACT,UAAU;EACV,WAAW;EACX,YAAY;AACd;;AAEA;EACE,eAAe;AACjB;;AAEA;;;EAKE,sBAAsB;AACxB;;AAEA;;;;;;;;;;EAUE,SAAS;EACT,UAAU;AACZ;;AAEA;;EAEE,qBAAqB;AACvB;;AAEA;EACE,qBAAqB;EACrB,cAAc;AAChB;;AAEA;EACE,wBAAwB;EACxB,wBAAwB;AAC1B;;AAEA;EACE;IACE,eAAe;EACjB;AACF","sourcesContent":["html {\r\n  font-family: \"Spoqa Han Sans Neo\", \"sans-serif\";\r\n  font-size: 16px;\r\n}\r\n\r\nhtml,\r\nbody {\r\n  margin: 0;\r\n  padding: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\nbody {\r\n  font-size: 1rem;\r\n}\r\n\r\n*,\r\n::after,\r\n::before {\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n}\r\n\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6,\r\np,\r\nul,\r\nol,\r\nli {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\nul,\r\nol {\r\n  list-style-type: none;\r\n}\r\n\r\na {\r\n  text-decoration: none;\r\n  color: inherit;\r\n}\r\n\r\ninput {\r\n  -webkit-appearance: none;\r\n  -webkit-border-radius: 0;\r\n}\r\n\r\n@media (max-width: 600px) {\r\n  html {\r\n    font-size: 15px;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/post.css":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[1]!./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[2].oneOf[6].use[2]!./src/styles/post.css ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/compiled/css-loader/api.js");
/* harmony import */ var _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _yarn_virtual_next_virtual_77d0572bfd_0_cache_next_npm_11_0_1_c40bc7f380_c6b4747f1a_zip_node_modules_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".postContents {\r\n  line-height: 1.7;\r\n  font-size: 1rem;\r\n}\r\n\r\n.postContents h1,\r\n.postContents h2,\r\n.postContents h3,\r\n.postContents h4,\r\n.postContents h5,\r\n.postContents h6 {\r\n  margin-top: 2rem;\r\n  margin-bottom: 1rem;\r\n\r\n  font-weight: 700;\r\n  line-height: 1.5;\r\n}\r\n\r\n.postContents h1 {\r\n  font-size: 2.2rem;\r\n}\r\n.postContents h2 {\r\n  font-size: 1.8rem;\r\n}\r\n.postContents h3 {\r\n  font-size: 1.6rem;\r\n}\r\n.postContents h4 {\r\n  font-size: 1.3rem;\r\n}\r\n.postContents h5 {\r\n  font-size: 1.2rem;\r\n}\r\n.postContents h6 {\r\n  font-size: 1.1rem;\r\n}\r\n.postContents p {\r\n  margin: 1rem 0;\r\n  white-space: pre-line;\r\n  overflow-wrap: anywhere;\r\n}\r\n\r\n.postContents strong,\r\n.postContents b {\r\n  font-weight: normal;\r\n}\r\n\r\n.postContents code:not([class*=\"language\"]),\r\n.postContents strong,\r\n.postContents b {\r\n  margin: 0 0.2rem;\r\n  padding: 0 0.2rem;\r\n  border-radius: 0.2rem;\r\n}\r\n\r\n.postContents a {\r\n  color: #007fd4;\r\n}\r\n\r\n.postContents ul,\r\n.postContents ol {\r\n  margin: 1rem 0;\r\n  padding-left: 2.4rem;\r\n}\r\n\r\n.postContents ul {\r\n  list-style-type: disc;\r\n}\r\n.postContents ol {\r\n  list-style-type: decimal;\r\n}\r\n.postContents ul ul,\r\n.postContents ol ul {\r\n  list-style-type: circle;\r\n  margin-top: 0.4rem;\r\n}\r\n.postContents ol ol,\r\n.postContents ul ol {\r\n  list-style-type: lower-latin;\r\n  margin-top: 0.4rem;\r\n}\r\n\r\n.postContents li {\r\n  margin-bottom: 0.4rem;\r\n}\r\n\r\n.postContents img {\r\n  max-width: 100%;\r\n}\r\n\r\n.postContents hr {\r\n  margin: 2rem 0;\r\n}\r\n\r\n.postContents pre {\r\n  background-color: #333333;\r\n\r\n  margin: 1rem 0;\r\n  padding: 1rem;\r\n  border-radius: 0.8rem;\r\n\r\n  overflow-x: auto;\r\n}\r\n\r\n.postContents .table-wrapper {\r\n  width: 100%;\r\n  overflow-x: auto;\r\n}\r\n\r\n.postContents table {\r\n  border-collapse: collapse;\r\n}\r\n", "",{"version":3,"sources":["webpack://src/styles/post.css"],"names":[],"mappings":"AAAA;EACE,gBAAgB;EAChB,eAAe;AACjB;;AAEA;;;;;;EAME,gBAAgB;EAChB,mBAAmB;;EAEnB,gBAAgB;EAChB,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,cAAc;EACd,qBAAqB;EACrB,uBAAuB;AACzB;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;;;EAGE,gBAAgB;EAChB,iBAAiB;EACjB,qBAAqB;AACvB;;AAEA;EACE,cAAc;AAChB;;AAEA;;EAEE,cAAc;EACd,oBAAoB;AACtB;;AAEA;EACE,qBAAqB;AACvB;AACA;EACE,wBAAwB;AAC1B;AACA;;EAEE,uBAAuB;EACvB,kBAAkB;AACpB;AACA;;EAEE,4BAA4B;EAC5B,kBAAkB;AACpB;;AAEA;EACE,qBAAqB;AACvB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,yBAAyB;;EAEzB,cAAc;EACd,aAAa;EACb,qBAAqB;;EAErB,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,yBAAyB;AAC3B","sourcesContent":[".postContents {\r\n  line-height: 1.7;\r\n  font-size: 1rem;\r\n}\r\n\r\n.postContents h1,\r\n.postContents h2,\r\n.postContents h3,\r\n.postContents h4,\r\n.postContents h5,\r\n.postContents h6 {\r\n  margin-top: 2rem;\r\n  margin-bottom: 1rem;\r\n\r\n  font-weight: 700;\r\n  line-height: 1.5;\r\n}\r\n\r\n.postContents h1 {\r\n  font-size: 2.2rem;\r\n}\r\n.postContents h2 {\r\n  font-size: 1.8rem;\r\n}\r\n.postContents h3 {\r\n  font-size: 1.6rem;\r\n}\r\n.postContents h4 {\r\n  font-size: 1.3rem;\r\n}\r\n.postContents h5 {\r\n  font-size: 1.2rem;\r\n}\r\n.postContents h6 {\r\n  font-size: 1.1rem;\r\n}\r\n.postContents p {\r\n  margin: 1rem 0;\r\n  white-space: pre-line;\r\n  overflow-wrap: anywhere;\r\n}\r\n\r\n.postContents strong,\r\n.postContents b {\r\n  font-weight: normal;\r\n}\r\n\r\n.postContents code:not([class*=\"language\"]),\r\n.postContents strong,\r\n.postContents b {\r\n  margin: 0 0.2rem;\r\n  padding: 0 0.2rem;\r\n  border-radius: 0.2rem;\r\n}\r\n\r\n.postContents a {\r\n  color: #007fd4;\r\n}\r\n\r\n.postContents ul,\r\n.postContents ol {\r\n  margin: 1rem 0;\r\n  padding-left: 2.4rem;\r\n}\r\n\r\n.postContents ul {\r\n  list-style-type: disc;\r\n}\r\n.postContents ol {\r\n  list-style-type: decimal;\r\n}\r\n.postContents ul ul,\r\n.postContents ol ul {\r\n  list-style-type: circle;\r\n  margin-top: 0.4rem;\r\n}\r\n.postContents ol ol,\r\n.postContents ul ol {\r\n  list-style-type: lower-latin;\r\n  margin-top: 0.4rem;\r\n}\r\n\r\n.postContents li {\r\n  margin-bottom: 0.4rem;\r\n}\r\n\r\n.postContents img {\r\n  max-width: 100%;\r\n}\r\n\r\n.postContents hr {\r\n  margin: 2rem 0;\r\n}\r\n\r\n.postContents pre {\r\n  background-color: #333333;\r\n\r\n  margin: 1rem 0;\r\n  padding: 1rem;\r\n  border-radius: 0.8rem;\r\n\r\n  overflow-x: auto;\r\n}\r\n\r\n.postContents .table-wrapper {\r\n  width: 100%;\r\n  overflow-x: auto;\r\n}\r\n\r\n.postContents table {\r\n  border-collapse: collapse;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__["default"] = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/head.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/head.js ***!
  \*******************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/next-server/lib/head */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/next-server/lib/head.js")


/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/link.js":
/*!*******************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/link.js ***!
  \*******************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./contents/blog/aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md":
/*!**************************************************************!*\
  !*** ./contents/blog/aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"AWS EC2 한글 도메인 연결하기\"\r\ndate: \"2021-05-28\"\r\ntags: \r\n  - AWS\r\n  - EC2\r\n  - route53\r\n---\r\n\r\n# AWS EC2 한글 도메인 연결하기\r\n\r\nAWS EC2와 ROUTE53으로 도메인 연결에 관해서는 많은 정보가 있다. \r\n\r\n하지만 한글 도메인을 연결해보다가 뜻밖에 문제상황에 부딪혔던 경험이 있어 이를 공유하려 한다.\r\n\r\n![20210528_212411](../../../assets/img/20210528_212411.png)\r\n\r\n위 이미지와 같이 도메인 이름에 한글도메인을 넣으면 `지원되지 않는 문자가 있습니다.`라며 거부한다.\r\n\r\n하지만 나는 이미 한글 도메인을 구매해놨다면...?\r\n\r\n이때 활용할 수 있는 것이 바로 `**퓨니코드**` 이다.\r\n\r\n\r\n\r\n### 퓨니코드\r\n\r\n> **한글 도메인을 사용하실 경우에 DNS가 한글을 처리하기 위하여 영어, 숫자, 하이픈(-)으로 이루어진 퓨니코드(Punycode)의 형태로 변환된 후, DNS 서버에 전달, 저장돱니다. 따라서 서비스에 도메인을 등록하실 경우 퓨니코드 변환기를 통하여 \"xn--\"로 시작하는 퓨니코드로 변환된 값을 등록하셔야만 합니다**\r\n\r\n\r\n\r\n퓨니코드 변환기는 구글에 검색하면 쏟아져 나오니 골라서 쓰면 된다. \r\n\r\n나는 아래 사이트를 활용하였다.\r\n\r\n[KISA 퓨니코드 변환 사이트](https://xn--c79as89aj0e29b77z.xn--3e0b707e/idnconv/idnconv.do)\r\n\r\n![20210528_212418](../../..//assets/img/20210528_212418.png)\r\n\r\n![20210528_212456](../../..//assets/img/20210528_212456.png)\r\n\r\n사이트 입력창에서 도메인 이름을 작성하고 `**변환**`버튼을 누르면 아래 OUTPUT이 나온다.\r\n\r\n`xn--bj0b ~~~` 이 값이 변환된 값이다.\r\n\r\nAWS ROUTE53에서 다시 이 OUTPUT을 입력해준다.\r\n\r\n![20210528_213117](../../..//assets/img/20210528_213117.png)\r\n\r\n오류가 나지 않는다.\r\n\r\n\r\n\r\n끝.\r\n");

/***/ }),

/***/ "./contents/blog/ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md":
/*!***************************************************************!*\
  !*** ./contents/blog/ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"CI/CD 개념에 대해 알아보자\"\r\ndate: \"2021-08-30\"\r\ntags: \r\n  - javascript\r\n  - iterable\r\n  - iterator\r\n  - ES6\r\n---\r\n\r\n# CI/CD 개념을 빠르게 알아보자!\r\n\r\n유튜브 채널 `드림코딩 by 엘리` 에 업로드된 내용을 정리해보았습니다. 링크는 하단에 있으니 직접 보시는걸 추천드립니다.\r\n\r\n## CI/CD란? \r\n\r\n> CI: Continuous Integration \r\n> CD: Continuous Delivery ( or Deployment)\r\n\r\nCI/CD란 시장과 고객의 요구에 빠르게 맞춰 개발 배포 프로세스를 빠르게 할 수 있도록 통합적이고(Continuous ntegration) 지속적인 개발 - 배포 프로세스(CD)를 말합니다.\r\n\r\n\r\n\r\n### CI 지속적인 통합\r\n\r\n새로운 기능을 개발하고 git repository (Github, Gitlab, Bitbucket 등)에 push되면, `build` -> `merge` -> `test` 되는 과정을 말합니다.\r\n\r\n![Grady Booch](https://image.slideserve.com/845909/grady-booch-pronounced-bootch-l.jpg)\r\n\r\nExtreme Programming의 Grady Booch는 CI의 두 가지 포인트를 제시했다\r\n\r\n1. 코드 변경사항을 **<u>주기적</u>**으로 **<u>빈번하게 머지</u>**해야 한다.\r\n2.  통합을 위한 단계 (`빌드` -`테스트` - `머지`)의 **<u>자동화</u>**\r\n\r\n\r\n\r\n1번의 주기적이고 빈번한 머지는, 개발자들이 오랜 기간 개발을 하고 나서 한참 뒤에 서로의 코드를 머지하려고 하면 실제로 코어 기능을 개발하는 중요한 것보다는 merge conflict를 해결하는 부수적인 일에 훨씬 더 시간을 많이 쓰는 단점을 막기 위한 방법이라고 합니다.\r\n\r\n2번의 자동화 단계에서 중요한 점은 주기적으로 merge된 코드가 build 상에 문제는 없었는지 자동으로 체크해야 한다는 점입니다. Build가 문제없이 진행되었다면 그 다음에는 이 코드가 정상적으로 작동하는지를 자동으로 테스트하는 것까지가 CI의 중요한 점이라고 강조했습니다.\r\n\r\n\r\n\r\nCI 프로세스를 통해 얻을 수 있는 장점은 다음과 같습니다.\r\n\r\n1. 개발 생산성 향상\r\n2. 문제점 빠르게 발견\r\n3. 버그 수정 용이\r\n4. 코드 퀄리티 향상\r\n\r\nCI를 자동화 하기 위해서는 개발자들이 모두 유닛테스트를 포함해야 하기 때문에 자연스레 코드의 퀄리티 향상까지 기대할 수 있습니다.\r\n\r\n\r\n\r\n### CD 지속적인 제공/배포\r\n\r\n어떻게 하면 자동화해서 서비스를 배포할 수 있을까?\r\n\r\n![Continuous Delivery](/assets/img/cd1.png)\r\n\r\n![Continuous Deployment](/assets/img/cd2.png)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\nRef.\r\n\r\n[CI/CD 5분 개념 정리 (현업에서 쓰는 개발 프로세스) - 드림코딩 by 엘리](https://www.youtube.com/watch?v=0Emq5FypiMM)\r\n");

/***/ }),

/***/ "./contents/blog/etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md":
/*!**********************************************************************!*\
  !*** ./contents/blog/etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"윈도우 듀얼모니터 가상드세크탑 & 멀티모니터 맥처럼 따로 따로 사용하기\"\r\ndate: \"2021.08.07\"\r\ntags: \r\n  - windows 듀얼모니터\r\n  - 가상데스크톱 화면고정\r\n---\r\n\r\n# 윈도우 가상 데스크톱과 듀얼모니터 활용 극대화하기\r\n\r\n\r\n> 윈도우 OS에서 듀얼모니터 이상 사용할 때 해당 모니터별로 따로 구분해서 한 쪽은 고정화면을 띄워놓고 다른 쪽만 변경하며 사용하고 싶었으나 방법을 모르셨다면 아래 내용을 확인해보시길 추천드립니다.\r\n\r\n검색해보니 유료 추가 앱을 이용하지 않고도 윈도우 자체기능으로도 이 문제를 해결할 수 있어 공유드립니다.\r\n\r\n\r\n\r\n## **💀 나의 문제상황**\r\n\r\n- 듀얼 모니터 사용\r\n- 왼쪽면은 고정화면을 띄워놓고 계속 보고 싶음\r\n- 오른쪽면은 잦은 화면 변환을 하고 싶음.\r\n\r\n<video src=\"/assets/img/vdektop_vid_1.mp4\" width=\"100%\" autoplay controls loop></video>\r\n\r\n\r\n\r\n맥북을 사용할때는 가상환경에 따라 트랙패드를 좌우로 휙휙 쓸면서 모니터별로 따로 사용할 수 있어서 좋았었는데 윈도우로 작업을 하다보니 그때처럼 하려고 단축키 `Ctrl+Win+방향키(<- or ->)` 를 쓰면 좌우 모든 화면이 같이 돌아가서 해당 가상데스크탑을 모든 모니터가 공유해버리는 문제가 있었습니다.\r\n\r\n\r\n\r\n## **💡 어느 정도 해결할 방법을 찾았습니다.**\r\n\r\n원리는 가상화면 자체를 모니터별로 분화하는 것은 아니고, 똑같은 창을 모든 가상 데스크톱에 고정적으로 띄워놓는 방법입니다.\r\n\r\n(아쉽지만 맥북처럼 가상 데스크탑 자체를 모니터별로 분화해서 사용하는 방법은 아닙니다. 이런 기능을 제공하는 써드파티 앱이 있는데 유료라는 것 같고 데모버전을 테스트해보려 해도 이것저것 입력한 뒤 사용요청을 보내라고 해서 귀찮아서 그냥 안했습니다.)\r\n\r\n### **1. Win + Tab 키로 여러 화면을 한 번에 띄웁니다.**\r\n\r\n![vdektop1.png](/assets/img/vdesktop1.png)\r\n\r\n### **2. 계속 고정하려는 창 마우스 우클릭 > \"모든 바탕 화면에 이 창 표시\" 클**\r\n\r\n![vdesktop2.png](/assets/img/vdesktop2.png)\r\n\r\n크롬창을 우클릭하고 스샷찍으려 했는데 Win+Tab상황에서 스샷찍기가 쉽지가 않아서 좀 어긋났습니다 ;;\r\n\r\n> 참고로 (1)모든 바탕화면에 이 창 표시 하고 (2)모든 바탕화면에 이 앱창 표시는 조금 다릅니다.\r\n\r\n같은 크롬창이어도 여러개로 나누어져 있으면  (1)의 경우 설정한 하나의 크롬창만을 고정합니다. 하지만 (2)의 경우 여러개의 크롬창을 모두 \"크롬\"이라는 하나의 앱으로 인식하여 예상과는 다른 결과가 나올 수 있으므로 **\"(1) 모든 바탕화면에 이 창 표시\"**를 추천합니다.\r\n\r\n\r\n\r\n### **3. 나머지 변환하며 사용하고 싶은 앱들은 각각의 가상 데스크탑1, 2, 3으로 나눠서 분배**\r\n\r\n예를 들어 크롬창을 계속 띄워놓고 싶다면 `크롬창 우클릭 > \"모든 바탕 화면에 이 창 표시\"` 클릭\r\n\r\n이러면 이 크롬창이 데스크탑 1, 2, 3 등에 모두 복사가 되고 한 쪽 면을 차지하게 됩니다.\r\n\r\nCtrl+Win+방향키 단축키를 활용해 데스크탑을 넘나 들어도 한 쪽면에 고정된 크롬창은 그 자리를 그대로 지키고 있습니다.\r\n\r\n## 😎 적용 후 모습\r\n\r\n<video src=\"/assets/img/vdektop_vid_2.mp4\" width=\"100%\" autoplay controls loop></video>\r\n\r\n\r\n\r\n가상 데스크탑에서 알탭 누르거나 그러면 좀 앱들이 복잡해지고 해서 맥만큼의 깔끔함은 아니지만 원하던 기능을 쓸 수 있어 저는 매우 만족합니다. 모니터가 많아지더라도 잘 활용하면 꽤 유용할 것 같습니다.\r\n\r\n감사합니다 :)\r\n\r\n");

/***/ }),

/***/ "./contents/blog/etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md":
/*!*************************************************************************************!*\
  !*** ./contents/blog/etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"jekyll 구글애널리틱스(GA) 다는 방법 초간단 알아보기\"\r\ndate: \"2021.08.18\"\r\ntags: \r\n  - jekyll\r\n  - google analytics\r\n  - GA\r\n  - 구글애널리틱스\r\n  - UX\r\n  - 사용자패턴\r\n---\r\n\r\n# 구글 애널리틱스로 jekyll로 만든 내 블로그 방문자 행동패턴 알아보는 방법\r\n\r\n## 1. 구글 애널리틱스 가입하기 \r\n\r\n그새 예전에 할 때랑 좀 달라져 있네요.\r\n\r\n\r\n\r\n![ga_1](/assets/img/ga_1.png)\r\n\r\n구글 애널리틱스 검색 후 접속\r\n\r\n\r\n\r\n![ga_2](/assets/img/ga_2.png)\r\n\r\n[Start Measuring] 버튼 클릭\r\n\r\n![ga_3](/assets/img/ga_3.png)\r\n\r\n계정 설정 후 나머지 설정은 알아서 체크 후 Next!\r\n\r\n![ga_4](/assets/img/ga_4.png)\r\n\r\n카테고리, business size 등 알아서 체크 후 Create\r\n\r\n![ga_5](/assets/img/ga_5.png)\r\n\r\n마지막으로 Agreement 에 동의 후 Accept하면 구글 애널리틱스 생성완료\r\n\r\n\r\n\r\n## 2. GA 트랙코드 jekyll에 심기\r\n\r\n![GA추적코드](https://rextarx.github.io/assets/2017-02-03-Applying_Google_Analytics_to_a_blog_using_Jekyll/4.png)\r\n\r\n만약 이 관리 페이지에 들어오지 못하셨다면 왼쪽 하단에 **[관리] ** 버튼을 클릭해보세요.\r\n\r\n![ga_6](/assets/img/ga_6.png)\r\n\r\n\r\n\r\n![ga_7](/assets/img/ga_7.png)\r\n\r\n### (접속 경로)_includes > _third_party > analytics > google-analytics.html\r\n\r\n위 경로로 들어와서 구글 애널리틱스 페이지에 있던 추적코드를 심어줍니다.\r\n\r\n\r\n\r\n## 3. _config.yml 에 추적ID 추가해주기\r\n\r\n![ga_8](/assets/img/ga_8.png)\r\n\r\n`_config.yml ` 파일에서 google_analytics를 찾아서 **UA-OOOOOOOO-1** 과 같은 추적 ID를 추가해줍니다.\r\n\r\n\r\n\r\n여기까지 완료되었으면 끝!\r\n\r\n\r\n\r\n## 4. 완성된 모습\r\n\r\n![ga_9](/assets/img/ga_9.png)\r\n\r\n![ga_10](/assets/img/ga_10.png)\r\n\r\n시간이 조금 지나고나면...WOW! \r\n\r\n드디어 얼마나 많은 사용자들이 방문-이탈했는지 한 눈에 볼 수 있는 대시보드가 보입니다!\r\n\r\n그밖에도 실시간 사용자에 대한 정보, 잠재고객층에 대한 정보도 살펴볼 수 있고 어떤 페이지에 얼마나 많은 방문횟수가 나왔는지 등에 대한 다양한 정보를 알 수 있습니다.\r\n\r\nGA와 함께 더욱 효과적으로 블로그를 잘 꾸며나가시길 바랍니다. \r\n\r\n감사합니다.");

/***/ }),

/***/ "./contents/blog/frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md":
/*!***********************************************************************!*\
  !*** ./contents/blog/frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"개발자를 괴롭히지만 없어서는 안되는 CORS\"\r\ndate: \"2020.12.16\"\r\ntags:\r\n  - http\r\n  - 웹개발\r\n  - CORS\r\n  - SOP\r\n  - 네트워크\r\n---\r\n\r\n\r\n\r\n# Cross-Origin Resource Sharing, CORS\r\n\r\n> 이 포스팅은 같이 스터디 했던 팀원 신상훈님의 포스팅을 기반으로 약간의 편집만을 더했습니다.\r\n\r\n\r\n\r\n## 0. CORS를 이해하기 위한 배경\r\n\r\n**CORS는 웹 개발자라면 한 번쯤은 마주하게 될 정책입니다.**\r\n\r\nMozilla의 MDN 에서는 CORS를 아래와 같이 설명하고 있습니다.\r\n\r\n> `교차 출처 리소스 공유`는 추가 `HTTP 헤더`를 사용하여, 한 `출처`에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다.\r\n>\r\n> 쉽게 말해 교차 출처 자원 공유는 웹 페이지 상의 제한된 리소스를 최초 자원이 서비스된 도메인 밖의 다른 도메인으로부터 요청할 수 있게 허용하는 구조입니다. CORS는 교차 출처 요청을 허용하는 것이 안전한지 아닌지를 판별하기 위해 브라우저와 서버가 상호 통신하는 하나의 방법을 정의합니다.\r\n\r\n### 0.1 시작 전 집고 넘어갈 점\r\n\r\n- CORS를 직역하니 `Cross-Origin` 을 `교차 출처` 로 해석되었는데 `\"다른 출처\"` 로 생각하는게 이해에 도움이 된다.\r\n- 즉 CORS 는 `다른 출처간의 리소스 공유` 라는 의미 !\r\n\r\n---\r\n\r\n\r\n\r\n## 1. 같은 출처, 다른 출처는 무엇을 기준으로 나뉘는가?\r\n\r\n### 1.1 출처(Origin)\r\n\r\n\r\n **서버의 위치를 의미하는 URL은 여러 개의 구성 요소로 이루어져 있습니다.**\r\n\r\n![](/assets/img/sources.JPG)\r\n\r\n- 출처는 위 그림과 같이 `Protocol` 과 `Host` 등, 그리고 그림에 없는 `:443` 과 같은 포트 번호까지 모두 합친 것을 의미합니다. 즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것이죠\r\n\r\n- 출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 `HTTP`, `HTTPS` 프로토콜의 기본 포트 번호가 정해져 있기 때문입니다. (지난 포스팅에도 언급했듯이 기본적으로 80포트를 쓰고 이때는 생략 가능함.)\r\n- 그러나, 만약 `https://google.com:443` 과 같이 출처에 포트 번호가 명시적으로 포함된다면, 이 포트 번호까지 모두 일치해야 같은 출처라고 인정됩니다.\r\n  - (그런데 이 케이스에 대한 명확한 정의가 표준으로 정해진 것은 아니어서, 어떤 경우에는 다른 출처로 판단될 수도 있다는게 함정)\r\n\r\n---\r\n\r\n\r\n\r\n### 1.2 SOP(Same-Origin Policy) 동일출처 정책\r\n\r\n\r\n\r\n**웹 세계에서 다른 출처로의 리소스 요청을 제한하는 것과 관련된 정책은 두 가지인데, 한 가지는 앞서 소개한 CORS, 나머지 한 가지가 `SOP` 입니다.**\r\n\r\n**SOP의 의미 : \"같은 출처에서만 리소스를 공유할 수 있다\" 인데,** 즉 이 동일 출처 정책은 한 도메인의 JavaScript 코드를 불러오면 해당 코드 안에서 다른 도메인의 데이터를 요청할 수 없다는 것을 의미합니다. \r\n\r\n**따라서 CORS와는 반대되는 의미로 보이지만 기본적으로 CORS또한 SOP의 일환으로 `적어도 이정도는 지키면서 교차출처 요청을 해라!` 이해하시면 됩니다.**\r\n\r\n대표적으로 `XMLHttpRequest`와 [Fetch API](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API)는 동일출처정책(SOP)을 따릅니다.\r\n\r\n여기서 `XMLHttpRequest` 는 비동기 웹 기술에 관련된 객체이고(대표적으로 ajax 요청),`fetch`란 쉽게 말해 웹 리소스를 가져오는 고수준 api를 뜻합니다. html의 img태그나 scipt 태그, javascript,css 의 리소스 접근에 관한 일부 api도 Fetch의 구현체입니다.\r\n\r\n**하지만 최근에는 웹이라는 오픈된 환경에서 ajax가 대중화되고, OPEN API 등 <u>다른 출처에 있는 리소스를 가져와 활용하는 일은 매우 흔한 일</u>로 무작정 막을 수는 없습니다. 그래서 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 다른 출처라도 허용하기로 했는데, 그 중 하나가 `CORS 정책을 지킨 리소스 요청` 이죠.**\r\n\r\n\r\n\r\n- 왜 이러한 정책이 만들어 졌을까 ?\r\n\r\n>  출처가 다른 두 개의 어플리케이션이 제약없이 소통할 수 있는 환경이 위험하기 때문이다. 특히 웹 어플리케이션의 경우 브라우저의 개발자 도구만 열어도 어떤 서버와 통신하는지, 리소스의 출처는 어디인지와 같은 각종 정보들을 아무런 제재없이 열람할 수 있다. \r\n>\r\n> (최근에는 자바스크립트 소스 코드를 난독화해 읽기 어렵다고는 하지만  난독화는 암호화가 아니므로, 소스 코드를 직접 볼 수 있다는 것 자체가 보안적으로 상당히 취약하다. 다시 복호화하는 사이트도 있음. 상당히 쉽게 파훼가 가능함.)\r\n\r\n이런 환경에서 아무런 제약이 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 쓱 구경한 후 [CSRF(Cross-Site Request Forgery)](https://ko.wikipedia.org/wiki/사이트_간_요청_위조)나 [XSS(Cross-Site Scripting)](https://ko.wikipedia.org/wiki/사이트_간_스크립팅)와 같은 방법을 사용하여 사용자의 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나도 쉬워지는 문제가 생길 수 있습니다.\r\n\r\n\r\n\r\n- 즉, 우리가 다른 출처로 리소스를 요청하면 SOP 정책을 위반하는 것이고, SOP의 예외 조항인 CORS 정책까지 위반한다면 아예 다른 출처의 리소스를 사용할 수 없게 되는 것이다.\r\n\r\n**결론적으로, 다른 출처로 리소스를 요청하기 위해서는 SOP에서 정의된 예외 조항과 CORS를 사용할 수 있는 케이스를 따라야 한다는 것이다.**\r\n\r\n---\r\n\r\n\r\n\r\n### 1.3 같은 출처와 다른 출처의 구분\r\n\r\n결론부터 말하자면, 두 URL의 구성 요소 중 `Scheme`, `Host`, `Port` 이 3가지만 동일하면 두 개의 출처가 서로 같습니다.\r\n\r\n`https://mensan-sanghun.github.io:80` 이라는 출처로 예를 들자면 `https://` 이라는 스킴에 `mensan-sanghun.github.io` 호스트를 가지고 `:80` 번 포트를 사용하고 있다는 것만 같다면, 나머지는 전부 다르더라도 같은 출처로 판단됩니다.\r\n\r\n\r\n\r\n- 예시(출처가 https://mensan-sanghun.github.io 일 때)\r\n\r\n| URL                                            | 같은 출처 여부 | 이유                        |\r\n| ---------------------------------------------- | -------------- | --------------------------- |\r\n| https://mensan-sanghun.github.io/about         | O              | 스킴, 호스트, 포트가 동일   |\r\n| https://mensan-sanghun.github.io/about?q=상훈  | O              | 스킴, 호스트, 포트가 동일   |\r\n| https://user:password@mensan-sanghun.github.io | O              | 스킴, 호스트, 포트가 동일   |\r\n| http://mensan-sanghun.github.io                | X              | 스킴이 다름                 |\r\n| https://api.github.io                          | X              | 호스트가 다름               |\r\n| https://mensan-sanghun.naver.com               | X              | 호스트가 다름               |\r\n| https://mensan-sanghun.github.io:8000          | ?              | 브라우저의 구현에 따라 다름 |\r\n\r\n맨 마지막 케이스의 경우, 만약 출처에 `https://mensan-sanghun.github.io:80` 처럼 포트 번호가 명시되어 있다면 다른 출처이지만, 예시로 든 출처의 경우 포트 번호가 포함되지 않아 판단하기 애매합니다.\r\n\r\n이런 경우에는 각 브라우저들의 독자적인 출처 비교 로직을 따라갑니다.\r\n\r\n**여기서 중요한 점은, 이렇게 출처를 비교하는 로직이 <u>서버에 구현된게 아니라 브라우저에 구현</u>되어 있는 점입니다.**\r\n\r\n**!그렇기 때문에, 우리가 CORS 정책을 위반하는 리소스 요청을 해도, 해당 서버가 같은 출처에서 보낸 요청만 받는 로직을 가진 경우가 아니라면, 서버는 정상적으로 응답을 하고 이후 브라우저에서는 이 응답을 분석해 CORS 정책 위반이라고 판단하고 그 응답을 사용하지 않고 버립니다. **\r\n\r\n-> 따라서 서버 로그에는 `200 ok `가 뜨지만 브라우저 개발자 도구에는 \"CORS 오류\"가 떠있습니다.\r\n\r\n**즉, CORS는 브라우저의 구현 스펙에 포함되는 정책이기 때문에, 브라우저를 통하지 않고 서버 간 통신을 할 때는 이 정책이 적용되지 않습니다. 또한 CORS 정책을 위반하는 리소스 요청 에러가 발생해도, 서버 쪽 로그에는 정상적으로 응답을 했다는 로그가 남아 혼란을 야기할 수 있습니다.**\r\n\r\n---\r\n\r\n\r\n\r\n## 2. CORS의 동작\r\n\r\n기본적으로 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 `Origin` 이라는 필드에 요청을 보내는 출처를 함께 담습니다\r\n\r\n```http\r\n# http\r\nOrigin: https://mensan-sanghun.github.io\r\n```\r\n\r\n이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 `Access-Control-Allow-Origin`이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 `Origin`과 서버가 보내준 응답의 `Access-Control-Allow-Origin`을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정합니다.\r\n\r\n기본적 흐름은 이와 같고, CORS가 동작하는 방식은 세 가지의 시나리오가 있습니다.\r\n\r\n---\r\n\r\n### 2.1 CORS의 시나리오\r\n\r\n> 1. simple request\r\n> 2. preflight request\r\n> 3. credentialed request\r\n\r\n\r\n\r\n#### Simple Request 시나리오를 들어가기 전에\r\n\r\n이 시나리오 케이스에 대한 정식 명칭은 없지만, MDN의 CORS 문서에서는 이 시나리오를 [Simple Request](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS#접근_제어_시나리오_예제)라고 부르고 있습니다.\r\n\r\nSimple Request의 정의에 앞서 CORS Preflight 에 대해 먼저 집고 넘어가는게 이해하기에 좋습니다. \r\n\r\n---\r\n\r\n#### Preflight Request(예비 요청 시나리오)\r\n\r\n`프리플라이트(Preflight)` 방식은 일반적으로 우리가 웹 어플리케이션을 개발할 때 가장 자주 마주치는 시나리오입니다. 이 시나리오에 해당하는 상황일 때 브라우저는 요청을 한번에 보내지 않고 **예비 요청과 본 요청으로 나누어서 서버로 전송**합니다.\r\n\r\n이때 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 Preflight라고 부르는 것이며, 이 예비 요청에는 HTTP 메소드 중 `OPTIONS` 메소드가 사용됩니다. 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것입니다.\r\n\r\n자바스크립트를 예를 들어 이 과정을 간단한 플로우 차트로 나타내보면 다음과 같습니다.\r\n\r\n![preflight](/assets/img/Preflight.JPG)\r\n\r\n> 브라우저는 본 요청을 보내기 전 예비 요청을 먼저 보내고, 요청의 유효성을 검사한다.\r\n\r\n자바스크립트의 `fetch API`를 사용하여 브라우저에게 리소스를 받아오라는 명령을 내리면 브라우저는 서버에 예비 요청을 먼저 보내고, 서버는 이 예비 요청에 대한 응답으로 현재 자신이 어떤 것들을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답 헤더에 담아 브라우저에게 다시 보내주게 됩니다.\r\n\r\n>  이후 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교한 후, 이 요청을 보내는 것이 안전하다고 판단되면 같은 엔드포인트로 다시 본 요청을 보내게 된다. 이후 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.\r\n\r\n\r\n\r\n---\r\n\r\n아래 플로우는 다른 개발자가 재현한 예제를 통해 공부해보았다.\r\n\r\n출처: [CORS는 왜 이렇게 우리를 힘들게 하는걸까?](https://evan-moon.github.io/2020/05/21/about-cors/)\r\n\r\n---\r\n\r\n- 예제\r\n\r\n개발자의 블로그 환경에서 개발자의 티스토리 블로그의 RSS 파일 리소스에 요청을 보내면 브라우저가 본 요청을 보내기 전에 `OPTIONS` 메소드를 사용하여 예비 요청을 보내는 것을 확인할 수 있습니다.\r\n\r\n![preflight_1](/assets/img/Preflight_1.JPG)\r\n\r\n실제로 브라우저가 보낸 요청을 보면, 단순히 `Origin`에 대한 정보 뿐만 아니라 자신이 예비 요청 이후에 보낼 본 요청에 대한 다른 정보들도 함께 포함되어 있는 것을 볼 수 있습니다.\r\n\r\n위 예비 요청에서 브라우저는 `Access-Control-Request-Headers`를 사용하여 자신이 본 요청에서 `Content-Type` 헤더를 사용할 것을 알려주거나, `Access-Control-Request-Method`를 사용하여 이후 `GET` 메소드를 사용할 것을 서버에게 미리 알려주고 있습니다.\r\n\r\n이후, 티스토리 서버는 예비 요청에 대한 응답을 보내줍니다.\r\n\r\n![preflight_2](/assets/img/Preflight_2.JPG)\r\n\r\n여기서 중요하게 볼 것은 `Access-Control-Allow-Origin: https://evanmoon.tistory.com`라는 값입니다.\r\n\r\n티스토리 서버는 이 리소스에 접근이 가능한 출처는 오직 `https://evanmoon.tistory.com` 뿐이라고 브라우저에게 이야기해준 것이고, 개발자가 이 요청을 보낸 출처는 `https://evan-moon.github.io`이므로 **<u>서버가 허용해준 출처와는 다른 출처</u>**입니다.\r\n\r\n결국 브라우저는 이 요청이 CORS 정책을 위반했다고 판단하고 다음과 같은 에러를 보유줍니다.\r\n\r\n![preflight_3](/assets/img/Preflight_3.JPG)\r\n\r\n앞에서 얘기했듯, 위 예비 요청에 대한 응답에서 에러가 발생하지 않고 `200` 이 정상적으로 응답되었는데, 콘솔 창에서는 에러가 표시되는 부분이 많은 개발자를 헷갈리게 합니다.  따라서 중요한 것은 예비 요청의 성공/실패 여부가 아니라 “응답 헤더에 유효한 `Access-Control-Allow-Origin` 값이 존재하는가”입니다. 만약 예비 요청이 실패해서 `200`이 아닌 상태 코드가 내려오더라도 헤더에 저 값이 제대로 들어가있다면 CORS 정책 위반이 아닌 것이죠.\r\n\r\n---\r\n\r\n#### Simple Request(단순 요청 시나리오)\r\n\r\n대부분의 경우 Preflight Request 방식을 사용해 예비 요청과 본 여청을 나누어 보내지만, 예비 요청없이 본 요청만으로 CORS 정책 위반 여부를 검사하기도 합니다.\r\n\r\n이 시나리오는 Preflight Request 시나리오와 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다릅니다.\r\n\r\n예비 요청을 보내지 않고 바로 서버에게 본 요청을 보낸 후, 서버가 이에 대한 응답의 헤더에 `Access-Control-Allow-Origin`과 같은 값을 보내주면 그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식입니다.\r\n\r\n![simple](/assets/img/simple.JPG)\r\n\r\n> 단순 요청은 예비 요청없이 바로 본 요청을 보낸다.\r\n\r\n다만 단순 요청은 특정 조건을 만족하는 경우에만 가능하고, 이 조건은 까다로운 편이라 거의 경험하기 힘든 편이다.\r\n\r\n1. 요청의 메소드는 `GET`, `HEAD`, `POST` 중 하나여야 함.\r\n2. `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`, `DPR`, `Downlink`, `Save-Data`, `Viewport-Width`, `Width`를 제외한 헤더를 사용하면 안됨\r\n3. 만약 `Content-Type`를 사용하는 경우에는 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`만 허용\r\n\r\n2번 조건에 명시된 헤더는 매우 기본적인 헤더들이고, `Authorization` 헤더 조차 저 조건에는 포함되지 않습니다. 또한, 대부분의 HTTP API는 `text/xml`이나 `application/json` 컨텐츠 타입을 가지도록 설계되기 때문에 3번 조건을 만족시키기도 매우 어렵습니다.\r\n\r\n---\r\n\r\n#### Credentialed Request(인증된 요청 시나리오)\r\n\r\n이번 시나리오는 CORS의 기본적 방식이라기 보다 **다른 출처 간 통신에서 보안을 좀 더 강화하고 싶을 때 사용하는 방법**입니다.\r\n\r\n기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 `XMLHttpRequest` 객체나 `fetch API`는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않습니다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 `credentials` 옵션입니다.\r\n\r\n이 옵션에 사용할 수 있는 값과 의미는 다음과 같습니다.\r\n\r\n| 옵션 값              | 설명                                            |\r\n| -------------------- | ----------------------------------------------- |\r\n| same-origin (기본값) | 같은 출처 간 요청에만 인증 정보를 담을 수 있다. |\r\n| include              | 모든 요청에 인증 정보를 담을 수 있다.           |\r\n| omit                 | 모든 요청에 인증 정보를 담지 않는다.            |\r\n\r\n만약 `same-origin`이나 `include`와 같은 옵션을 사용하여 리소스 요청에 인증 정보가 포함된다면, 브라우저는 다른 출처의 리소스를 요청할 때 단순히 `Access-Control-Allow-Origin`만 확인하는 것이 아니라 좀 더 빡빡한 검사 조건을 추가하게 됩니다.\r\n\r\n---\r\n\r\n- 예제\r\n\r\n앞선 예제의 개발자의 로컬환경과 블로그를 호스팅하고 있는 Github 서버와의 통신을 통해, 어떤 제약이 추가되었는지 보여주는 예제\r\n\r\n\r\n\r\n개발자의 블로그는 `Allow-Control-Allow-Origin` 값으로 모든 출처를 허용한다는 의미인 `*`가 설정되어있기 때문에, 다른 출처에서 개발자의 블로그로 리소스를 요청할 때 CORS 정책 위반으로 인한 제약을 받지 않습니다.\r\n\r\n그래서 `http://localhost:8000`과 같은 로컬의 개발 환경에서도 `fetch API`를 사용하여 마음대로 리소스를 요청하고, 또 받아올 수 있습니다.\r\n\r\n![credential1](/assets/img/Credentialed_1.JPG)\r\n\r\n구글 크롬 브라우저의 `credentials` 기본 값은 같은 출처 내에서만 인증 정보를 사용하겠다는 `same-origin`이기 때문에, 로컬 환경에서 `https://evan-moon.github.io`로 보내는 리소스 요청에는 당연히 브라우저의 쿠키와 같은 인증 정보가 포함되어 있지 않습니다.\r\n\r\n그렇기 때문에 브라우저는 단순히 `Access-Control-Allow-Origin: *`이라는 값을 보고 “이 요청은 안전하다”라는 결론을 내리는 것이다. 그러나 `credentials` 옵션을 모든 요청에 인증 정보를 포함하겠다는 의미를 가진 `include`로 변경하고 같은 요청을 보내면 이번에는 상황이 조금 달라지게 됩니다.\r\n\r\n![credential2](/assets/img/Credentialed_2.JPG)\r\n\r\n블로그를 호스팅하고 있는 Github 서버는 이번에도 동일한 응답을 보내주었지만, 브라우저의 반응은 다르죠.\r\n\r\n![credential3](/assets/img/Credentialed_3.JPG)\r\n\r\n브라우저는 인증 모드가 `include`일 경우, 모든 요청을 허용한다는 의미의 `*`를 `Access-Control-Allow-Origin` 헤더에 사용하면 안된다고 이야기하고 있습니다.\r\n\r\n이처럼 요청에 인증 정보가 담겨있는 상태에서 다른 출처의 리소스를 요청하게 되면 브라우저는 CORS 정책 위반 여부를 검사하는 룰에 다음 두 가지를 추가하게 됩니다.\r\n\r\n1. `Access-Control-Allow-Origin`에는 `*`를 사용할 수 없으며, 명시적인 URL이어야한다.\r\n\r\n2. 응답 헤더에는 반드시 `Allow-Control-Allow-Credentials: true`가 존재해야한다.\r\n\r\n---\r\n\r\n\r\n\r\n## 3. CORS를 해결할 수 있는 방법\r\n\r\n그렇다면 이 복잡한 정책 CORS를 위반하지 않으려면 어떻게 해야하는건가?\r\n\r\n\r\n\r\n### 3.1 Access-Control-Allow-Origin 세팅하기\r\n\r\nCORS 정책 위반으로 인한 문제를 해결하는 가장 대표적이고 정석적인 방법은, 그냥 서버에서 `Access-Control-Allow-Origin` 헤더에 알맞은 값을 세팅해주는 것입니다. (인터넷을 찾아보면 리버스 프록싱 등 몇 가지 꼼수가 있지만 로컬환경과 실제 서버 환경이 다른 경우 에러가 나기 쉽다. 그러므로 정석대로 하자)\r\n\r\n이때 와일드카드인 `*`을 사용하여 이 헤더를 세팅하게 되면 모든 출처에서 오는 요청을 허용한다는 의미이므로 **보안적으로 심각한 이슈가 발생할 수도 있습니다.**\r\n\r\n그러므로 `Access-Control-Allow-Origin: https://evan.github.io`와 같이 출처를 명시해주도록 합니다.\r\n\r\nSpring, Express, Django와 같이 이름있는 백엔드 프레임워크의 경우에는 모두 CORS 관련 설정을 위한 세팅이나 미들웨어 라이브러리를 제공하고 있으니 세팅 자체가 어렵지는 않을 것입니다.\r\n\r\n\r\n\r\n#### EX)장고에서 적용하기\r\n\r\n먼저 장고 패키지를 설치한다.\r\n\r\n```bash\r\n>>> pip install django-cors-headers\r\n```\r\n\r\n설치가 완료되면, `settings.py`의 `INSTALLED_APP`과 `MIDDLEWARE`에 코드를 입력한다.\r\n\r\n```django\r\nINSTALLED_APPS = [\r\n\t'corsheaders',\r\n]\r\n\r\nMIDDLEWARE = [\r\n\t'corsheaders.middleware.CorsMiddleware',\r\n]\r\n```\r\n\r\n마지막으로 `settings.py`에 아래와 같은 코드를 입력하면 된다. 아래 설정에서 CORS_ORIGIN_ALLOW_ALL=False를 하고 CORS_ORIGIN_WHITELIST를 지운다면 모든 요청을 허용하는 환경(테스트환경으로나 가능)\r\n\r\n```django\r\n##CORS\r\nCORS_ORIGIN_ALLOW_ALL=False\r\nCORS_ORIGIN_WHITELIST = [\r\n\t'google.com',\r\n\t'localhost:8000',\r\n\t'127.0.0.1:9000',\r\n\t'hostname.example.com',\r\n]\r\nCORS_ALLOW_CREDENTIALS = True\r\n\r\nCORS_ALLOW_METHODS = (\r\n    'DELETE',\r\n    'GET',\r\n    'OPTIONS',\r\n    'PATCH',\r\n    'POST',\r\n    'PUT',\r\n)\r\n\r\nCORS_ALLOW_HEADERS = (\r\n    'accept',\r\n    'accept-encoding',\r\n    'authorization',\r\n    'content-type',\r\n    'dnt',\r\n    'origin',\r\n    'user-agent',\r\n    'x-csrftoken',\r\n    'x-requested-with',\r\n)\r\n```\r\n\r\n---\r\n\r\n\r\n\r\nCORS 정책 위반은 브라우저의 구현에서 발생하기 때문에, 프론트엔드 개발자가 이로 인한 문제를 겪는다. 하지만 문제 해결을 위해서는 백엔드 개발자가 서버 어플리케이션의 응답 헤더에 올바른 `Acccess-Control-Allow-Origin`이 내려올 수 있도록 세팅해줘야 합니다.\r\n\r\n그러므로 프론트엔드 개발자로서든, 백엔드 개발자로서든 이 정책위반 문제해결에 대한 지식을 가지고, 꼭 한 번 쯤은 경험해볼 필요가 있다고 생각합니다.\r\n\r\n---\r\n\r\n#### References\r\n\r\n[교차 출처 리소스 공유 MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)\r\n\r\n[Fetch API](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API)\r\n\r\n[CORS는 왜 이렇게 우리를 힘들게 하는걸까?](https://evan-moon.github.io/2020/05/21/about-cors/)\r\n\r\n[Django-내 로컬 서버에서 외부접속 허용하기](https://velog.io/@devmin/Django-CORS-Setting-basic)\r\n\r\n[Django CORS 설정과 API 연동](https://blog.thereis.xyz/41)\r\n\r\n[교차 출처 리소스 공유 위키피디아](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A8_%EC%B6%9C%EC%B2%98_%EB%A6%AC%EC%86%8C%EC%8A%A4_%EA%B3%B5%EC%9C%A0#cite_note-6)");

/***/ }),

/***/ "./contents/blog/frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md":
/*!**********************************************************************!*\
  !*** ./contents/blog/frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"우리가 항상 쓰는 HTTP 프로토콜이 뭘까\"\r\ndate: \"2020.12.16\"\r\ntags:\r\n- http\r\n- 웹개발\r\n- CORS\r\n- SOP\r\n- 프로토콜\r\n- 네트워크\r\n---\r\n\r\n## HTTP의 정의\r\n\r\n> **하이퍼텍스트 전송 프로토콜(HTTP)**은 HTML과 같은 하이퍼미디어 문서를 전송하기위한 [애플리케이션 레이어](https://en.wikipedia.org/wiki/Application_Layer) 프로토콜입니다.\r\n>\r\n> 일반적으로 안정적인 [전송 레이어](https://en.wikipedia.org/wiki/Transport_Layer)로 UDP와 달리 메세지를 잃지 않는 프로토콜인 TCP/IP 레이어를 기반으로 사용 합니다.\r\n>\r\n> 웹 브라우저와 웹 서버간의 커뮤니케이션을위해 디자인되었지만, 다른 목적으로도 사용될 수 있습니다.\r\n>\r\n> [URI](https://developer.mozilla.org/ko/docs/Glossary/URI)의 일부로, \"http://\" 는 \"schema\" 라고도 불리며, 일반적으로 주소의 시작 부분에 위치합니다. 일례로 \"https://developer.mozilla.org\" 라는 주소는 HTTP 프로토콜을 사용하여 문서를 요청하도록 브라우저에 명시한다는 것을 의미합니다. 이 경우 https는 HTTP 프로토콜의 보안 버전인 [SSL](https://developer.mozilla.org/ko/docs/Glossary/SSL) 를 나타냅니다 (TLS라고도 부르죠).\r\n>\r\n> HTTP 텍스트 기반 (모든 통신은 일반 텍스트로 수행됩니다) 이며 stateless (이전의 통신을 인식하지 않습니다) 입니다. 이 속성은 www 상에서 인간이 문서(웹 사이트) 를 읽는 것을 이상적으로 수행할 수 있도록 합니다. 그뿐만 아니라, HTTP 는 서버 간 웹 서비스 [REST](https://developer.mozilla.org/ko/docs/Glossary/REST) 또는 웹 사이트 내의 요청 [AJAX](https://developer.mozilla.org/ko/docs/Glossary/AJAX) 에 대한 기초로도 사용할 수 있습니다. - 출처 MDN\r\n>\r\n> 요청을보내고(request)응답을받는(response)과정이며, 연결당 하나의 트랜잭션을 수행한다.\r\n\r\n### HTTP 연결\r\n\r\nHTTP와 같은 클라이언트-서버 프로토콜에서, 세션은 다음의 세 가지 과정으로 이루어집니다:\r\n\r\n1. 클라이언트가 TCP 연결을 수립합니다(또는 전송 계층이 TCP가 아닌 다른 적당한 연결로).\r\n2. 클라이언트는 요청을 전송한 뒤 응답을 기다립니다.\r\n3. 서버는 요청에 대해 처리하고 그에 대한 응답을 상태 코드 그리고 요청에 부합하는 데이터와 함께 돌려보냅니다.\r\n\r\nTCP를 이용할 경우, 컴퓨터 상의 HTTP 서버를 위한 **기본 포트는 80**인데, **8000 혹은 8080**처럼 다른 포트들도 자주 사용되곤 합니다. 요청을 위한 페이지 URL은 도메인 이름과 포트 번호 둘 다 포함하는데, **포트 번호가 80일 경우 생략 가능**합니다.\r\n\r\n## HTTP MESSAGE REQUEST & RESPONSE\r\n\r\n#### 1. 클라이언트 요청 전송 (REQUEST)\r\n\r\n1. 첫번째 줄은 파라메터가 따르는 요청 메서드를 포함합니다:\r\n\r\n   The first line contains a request method followed by its parameters:\r\n\r\n   - 문서의 경로, 즉 프로토콜과 도메인 이름을 제외한 절대 URL\r\n   - 사용중인 HTTP 프로토콜 버전\r\n\r\n2. 바로 다음 줄들은 각각 특정 헤더를 나타내는데, 데이터의 종류가 적합한지(예를 들어, 언어는 무엇인지, MIME 타입은 무엇인지 등) 혹은 서버의 동작을 수정하는 몇 가지 데이터(예를 들어, 이미 캐시되어 있는 경우 응답을 전송하지 않는다든지 하는) 등에 관한 몇 가지 정보를 서버에게 제공합니다. 이런 HTTP 헤더들은 빈 줄로 끝나는 블록을 형성합니다.\r\n\r\n3. 마지막 블록은 부가적인 데이터 블록으로, 더 많은 데이터를 포함하며 주로 POST 메서드에 의해 사용됩니다.\r\n\r\n```markdown\r\nGET / HTTP/1.1\r\nHost: developer.mozilla.org\r\nAccept-Language: fr\r\n```\r\n\r\n**다양한 http request methods**\r\n\r\n- HTTP는 주어진 자원에 대해 실행되길 바라는 동작을 가리키는 요청 메소드 집합으로, 대표적으로 `GET`, `POST`방식이 있습니다. \r\n- 좀 더 자세한 내용은 아래 MDN 링크를 통해 확인해보세요.\r\n\r\n[다양한 HTTP request methods](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)\r\n\r\n\r\n\r\n#### 2. 서버 응답의 구조 (RESPONSE)\r\n\r\n연결된 에이전트가 자신의 요청을 전송하고 난 뒤에, 웹 서버가 그것을 처리하고 최종적으로 응답을 돌려보내게 됩니다. 클라이언트 요청과 유사하게, 서버 응답은 세 개의 다른 블록으로 나누어진, CRLF로 구분된 텍스트 지시자들로 형성됩니다\r\n\r\n1. 상태 줄인 `첫번째 줄`은 `상태 요청`(그리고 인간이 읽을 수 있는 텍스트 내에서의 의미)이 따르도록 사용된 HTTP 버전의 acknowledgment로 구성됩니다.\r\n2. 다음 줄들은 각각 `특정 HTTP 헤더`를 나타는데, 전송되는 데이터에 관한 정보(이를테면, 타입, 데이터 크기, 사용된 압축 알고리즘, 캐시에 대한 힌트 등)를 클라이언트에게 제공합니다. 클라이언트의 요청에 대한 HTTP 헤더 블록과 유사하게, 이 HTTP 헤더들은 빈 줄로 끝나는 블록을 형성합니다.\r\n3. 마지막 블록은 데이터 블록으로 (존재한다면) 데이터를 포함합니다.\r\n\r\n\r\n\r\n> 서로 유사한 형태의 REQUESTS와 RESPONSES\r\n\r\n![HTTPMsgStructure2](https://media.prod.mdn.mozit.cloud/attachments/2016/08/31/13827/2737306def7d994b1785d5879f0f5704/HTTPMsgStructure2.png)\r\n\r\n웹 페이지의 성공적인 수신:\r\n\r\n```markdown\r\nHTTP/1.1 200 OK\r\nDate: Sat, 09 Oct 2010 14:28:02 GMT\r\nServer: Apache\r\nLast-Modified: Tue, 01 Dec 2009 20:18:22 GMT\r\nETag: \"51142bc1-7449-479b075b2891b\"\r\nAccept-Ranges: bytes\r\nContent-Length: 29769\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)\r\n\r\n```\r\n\r\n요청된 자원이 존재하지 않는다는 내용의 알림\r\n\r\n```markdown\r\nHTTP/1.1 404 Not Found\r\nDate: Sat, 09 Oct 2010 14:33:02 GMT\r\nServer: Apache\r\nLast-Modified: Tue, 01 May 2007 14:24:39 GMT\r\nETag: \"499fd34e-29ec-42f695ca96761;48fe7523cfcc1\"\r\nAccept-Ranges: bytes\r\nContent-Length: 10732\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE html... (contains a site-customized page helping the user to find the missing resource)\r\n```\r\n\r\n**HTTP REQUEST STATUS CODE 응답 상세 코드**\r\n\r\nHTTP 응답 상태 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 알려줍니다. 응답은 5개의 그룹으로 나누어집니다\r\n\r\n정보를 제공하는 응답, 성공적인 응답, 리다이렉트, 클라이언트 에러, 그리고 서버 에러.\r\n\r\n가장 대표적인 것은 200, 400, 500 번대의 에러입니다.\r\n\r\n| STATUS CODE                  | DESCRIPTION                                                  |\r\n| ---------------------------- | ------------------------------------------------------------ |\r\n| `200`: OK                    | 가장 반가운 상태입니다. 요청이 성공적으로 되었습니다. 성공의 의미는 HTTP 메소드에 따라 달라집니다: GET: 리소스를 불러와서 메시지 바디에 전송되었습니다. HEAD: 개체 해더가 메시지 바디에 있습니다. PUT 또는 POST: 수행 결과에 대한 리소스가 메시지 바디에 전송되었습니다. TRACE: 메시지 바디는 서버에서 수신한 요청 메시지를 포함하고 있습니다. |\r\n| `400`: Bad Request           | 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다.<br />401: unauthorized - 인증되지 않은 요청 (주로 login 되지 않은 경우 발생)<br />403: Forbidden - 콘텐츠에 접근할 권리를 가지고 있지 않는 요청. (주로 권한이 없는 유저가 요청하여 발생)<br />404: Not found - 서버는 요청받은 리소스를 찾을 수 없습니다. (주로 잘못된 링크를 작성하여 발생하거나 예전에 있던 페이지가 없어져서 발생) |\r\n| `500`: Interner server Error | 이 응답은 클라이언트 요청에서는 문제가 없었으나 요청에 대한 처리를 해주는 서버쪽에 문제가 생겼을 때의 상태코드입니다.<br />일명 `서버가 터졌다`는 상황이 많습니다. |\r\n\r\n`HTTP REQUEST STATUS 코드`에 대한 더욱 자세한 내용은 아래 링크를 통해 확인해주세요.\r\n\r\n[HTTP 요청 STATUS CODE](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)\r\n\r\n---\r\n\r\n다음은 `개발자를 괴롭히지만 없어서는 안되는 CORS와 SOP`에 대한 포스팅을 해보겠습니다.\r\n\r\n---\r\n\r\nCopyright - likelionSungGuk\r\n\r\n");

/***/ }),

/***/ "./contents/blog/frontend/2021-01-01-WAS와 웹서버.md":
/*!*******************************************************!*\
  !*** ./contents/blog/frontend/2021-01-01-WAS와 웹서버.md ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"WAS와 웹서버는 뭐가 다른거지?\"\r\ndate: \"2021.01.01\"\r\ntags: \r\n  - WAS\r\n  - 웹서버\r\n  - NGINX\r\n  - Apache\r\n  - Tomcat\r\n---\r\n\r\n# [헷갈리는 개념 비교] \r\n\r\n## 1. Web 서버란\r\n\r\n- 클라이언트가 서버에 페이지 요청을 하면 요청을 받아` 정적 컨텐츠(.html, .png, .css등)`를 제공하는 서버\r\n- WEB서버는 클라이언트에서 요청이 올 때 가장 앞에서 요청에 대한 처리를 진행합니다.\r\n- 작동 Process\r\n  - 1. 클라이언트 콘텐츠 요청\r\n    2. 만약 정적 콘텐츠 요청이면, 웹서버에서 정정 콘텐츠 클라이언트에게 전달\r\n       만약 동적 콘텐츠 요청이면, 웹서버에서 처리하기 버거움. -> WAS에게 요청\r\n    3. 끝.\r\n- 대표적인 웹서버: Apache, nginx\r\n\r\n![web_server](/assets/img/web_server.png)\r\n\r\n\r\n\r\n## 2. WAS란\r\n\r\n![20200819_000733](/assets/img/middle_ware.png)\r\n\r\n- DB조회 혹은 로직처리가 요구되는 `동적 콘텐츠`를 제공하기 위해 만들어진 **Web Application Server**입니다. \r\n- 좀 더 구체적으로는 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산환경에서 사용되는 미들웨어입니다.\r\n- 클라이언트에서 DB서버로 데이터를 직접 요청하는 것에 여러 문제가 있었다. 첫 번째는 보안 문제, 두 번째는 클라이언트와 DB의 갯수가 많아지면서 로직이 복잡해진다는 것이다.  따라서, 미들웨어라는 새로운 개념이 생겼는데, 클라이언트는 이 미들웨어에 자신의 요청을 모두 전송하고 이 미들웨어는 가운데에서 이를 db서버에 전달하고 response를 받아 다시 클라이언트에 전달하는 역할을 수행합니다. \r\n- JSP, Servlet이 구동할 수 있는 환경을 제공합니다.\r\n- 컨테이너, 웹컨테이너 혹인 서블릿 컨테이너라고도 부릅니다.\r\n\r\n- 동작 프로세스\r\n\r\n  1. 웹서버로부터 요청이 오면 컨테이너가 받아서 처리\r\n\r\n  2. 컨테이너는 web.xml을 참조하여 해당 서블릿에 대한 쓰레드 생성하고 httpServletRequest와 httpServletResponse 객체를 생성하여 전달한다.\r\n\r\n  3. 컨테이너는 서블릿을 호출한다.\r\n\r\n  4. 호출된 서블릿의 작업을 담당하게 된 쓰레드(2번에서 만든 쓰레드)는 doPost()또는 doGet()을 호출한다.\r\n\r\n  5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response객체에 담아 컨테이너에 전달한다.\r\n\r\n  6. 컨테이너는 전달받은 Response객체를 HTTPResponse형태로 바꿔 웹서버에 전달하고 생성되었던 쓰레드를 종료하고 httpServletRequest, httpServletResponse 객체를 소멸시킨다.\r\n\r\n- 대표 : Tomcat, Jeus, JBoss\r\n\r\n![](/assets/img/WAS.png)\r\n\r\n\r\n\r\n## 3. 웹서버와 WAS 구조\r\n\r\n![](/assets/img/web-service-architecture.png)\r\n\r\n웹서버는 다양한 구조를 가질 수 있습니다.\r\n\r\n- Client -> Web Server -> DB\r\n- Client -> WAS -> DB\r\n- Client -> Web Server -> WAS -> DB\r\n\r\n이 중에서 가장 마지막 구조인 `Client -> Web Server -> WAS -> DB`가 위의 도식화된 형태이고, 이렇게 가장 많이 구분되어 있는 구조가 좋다고 평가받고 있습니다. 그 이유는 아래 상세히 설명하겠습니다.\r\n\r\n\r\n\r\n## 4. 웹서버와 WAS 구분 이유\r\n\r\n- 일단 WAS는 웹서버의 역할도 맡을 수 있습니다.\r\n- 이전에는 **정적콘텐츠까지 WAS에서 하기에는 서버에 부하를 많이 줘 비효율적**이어서 나눴었습니다. 하지만 최근에는 WAS의 성능이 더 올라갔기 때문에 굳이 성능상의 이유 때문에 둘을 나누지는 않는다고 합니다. \r\n- 그럼에도 불구하고 이 두 가지를 구분해서 쓰고 있는데 이유는 다음과 같습니다.\r\n  1.  물리적 분리로 인한 보안 강화 \r\n     - WAS는 db서버를 호출하는 역할을 맡는데, 이 db서버에는 회원정보와 같이 가장 중요한 정보들이 들어있습니다. 따라서 클라이언트와 가장 가까이 있는 웹서버의 보안이 뚫려도, WAS에서 db에 접근하는 한 단계가 더 생기므로 보안에 상대적으로 용이합니다. 반면, 웹서버와 WAS를 구분하지 않는 경우 한 번에 다 뚫리기 때문에 보안에 취약하다고 볼 수 있습니다. \r\n  2. 여러 WAS를 연결할 수 있음\r\n     - java서버, C서버, php서버 등 하나의 웹서버를 통해 여러 서비스가 가능하다.\r\n  3. ***장애 극복*** - 만약 WAS에 오류가 났을 경우, 웹서버에서 이를 인지하고 사용자가 오류가 난 WAS에 접근하지 못하도록 막고 WAS를 재시작합니다. 이때, 이 사용자가 WAS를 호출하는 요청을 하기 전까지는 웹서버에서 정적콘텐츠(html, png) 등을 보여주고 있기 때문에 오류상황을 인지하지 못할 수 있습니다. \r\n- 특히나 서비스의 규모가 커질수록 WAS와 웹서버를 더욱 필수적으로 분리합니다.\r\n- Web Server를 WAS 앞에 두고 필요한 WAS들을 Web Server에 플러그인 형태로 설정하면 더욱 효율적인 분산 처리가 가능하다.\r\n\r\n\r\n\r\n---\r\n\r\n출처 Refs.\r\n\r\nhttps://gmlwjd9405.github.io/2018/10/29/web-application-structure.html\r\n\r\nhttps://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html\r\n\r\nhttps://jeong-pro.tistory.com/84\r\n\r\nhttps://okky.kr/article/243427\r\n\r\n");

/***/ }),

/***/ "./contents/blog/frontend/2022-02-22-요것이웹팩이다.md":
/*!******************************************************!*\
  !*** ./contents/blog/frontend/2022-02-22-요것이웹팩이다.md ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"요것이 웹팩이다!\"\ndate: \"2022-02-22\"\ntags:\n  - webpack\n---\n\n\n\n이 글은 [프론트엔드 개발 환경의 이해](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html#5-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8)를 메인으로 해서 간단한 html, css, js를 활용한 프로젝트를 만들어보며 제가 이해한 대로 웹팩을 설명해 놓은 글입니다.\n\n\n\n# 요것이 웹팩 (Webpack)이다!\n\n## 1. 웹팩이란?\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다.png)\n\n오픈 소스 자바스크립트 **모듈 번들러**로써 여러개로 나누어져 있는 파일들을 **하나의 자바스크립트 코드로 압축하고 최적화하는 라이브러리**입니다.\n\n이러한 Bundler의 가장 대표적인 것이 `웹팩`이고, `Parcel`, `Rollup`등이 더 있습니다.\n\n![과거 일반적인 모습의 html, css, js 구조\n각각의 파일들을 따로 받아오는 것은 네트워크 낭비가 크다.](/assets/img/요것이웹팩이다%201.png)\n\n과거 일반적인 모습의 html, css, js 구조\n각각의 파일들을 따로 받아오는 것은 네트워크 낭비가 크다.\n\n### 1.1 웹팩을 사용하는 이유?\n\n1. **여러 파일의 자바스크립트 코드를 압축하여 최적화** 할 수 있기 때문에 **로딩에 대한 네트워크 비용을 줄일 수 있습니다. \n⇒ 로딩 속도를 높일 수 있습니다.**\n2. **모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽습니다.**\n    - 예를 들어, 기능별로 나눈다고 하면 Create.js, Read.js, Update.js, Delete.js 스크립트를 각각 만들어서 해당 기능에 필요한 코드들끼리 모아두고 다른 것들끼리는 분리해서  javascript 파일을 용도별로 구분해서 작성하는 것이 개발자 입장에서는 편리합니다. 어차피 따로 만들어도 Webpack으로 Build(Bundling)을 하면 **하나의 JS 파일**로 만들어 주니까요.\n3. **최신 자바스크립트 문법을 지원하지 않는 브라우저에서 사용할 수 있는 코드로 쉽게 변환시켜 줍니다.**\n    - 브라우저의 종류에 따라, 브라우저 버전에 따라서 최신 Javascript문법을 지원하지 않을 수도 있습니다. Webpack을 사용해서 빌드하면 최신 Javascript 문법을 사용한 코드를 이전 버전에서도 호환이 가능하도록 변경해줍니다.\n4. **JS 모듈화 이슈**\n    - Javascript를 각각 불러오도록 하면 불러오는 순서에 따라 영향을 받는 이슈.\n    - 스코프가 같은 위치에 동일 변수가 있으면 변수가 원하는 대로 작동하지 않습니다.\n    - Code Example\n      \n        ```html\n        # index.html\n        <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n          <meta charset=\"UTF-8\">\n          <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n          <title>Document</title>\n        </head>\n        <body>\n          <h1 id=\"title\">Hello world!</h1>\n        \n          <script src=\"./js/A.js\"></script>\n          <script src=\"./js/B.js\"></script>\n          <script src=\"./js/C.js\"></script>\n            \n        </body>\n        </html>\n        ```\n        \n        ```jsx\n        // A.js\n        const text = \"AAAAA\";\n        let target = document.getElementById(\"title\")\n        target.innerText = text\n        ```\n        \n        ```jsx\n        // B.js\n        const text = \"BBBBB\";\n        let target = document.getElementById(\"title\")\n        target.innerText = text\n        ```\n        \n        ```jsx\n        // C.js\n        const text = \"CCCCC\";\n        let target = document.getElementById(\"title\")\n        target.innerText = text\n        ```\n        \n        - 이 경우 H1태그에는 어떤 텍스트가 들어갈까요?\n            - 정답\n              \n                AAAAA\n            \n            - 이유\n              - A/B/C 모두 글로벌 영역에서 text 변수를 const 로 지정하고 있습니다. 동일 영역에서 const로의 변수 선언은 가장 먼저 불린 A.js의 `const text = \"AAAAA\"`가 선언됩니다.\n\n## 2. 웹팩의 구성\n\n### **2.1. entry** ➡️\n\n> entry 속성은 웹팩에서 웹 자원을 변환하는 데 필요한 진입점이자 자바스크립트 파일 경로입니다.\n> \n\nentry 속성에서 번들링하고 싶은 파일들을 선언합니다.\n\n웹팩은 엔트리를 통해서 필요한 모듈들을 로딩하고, 하나의 파일로 묶는 과정을 진행합니다.\n\n### **2.2. output 🎯**\n\n> output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미합니다.\n> \n\n번들된 결과물을 처리할 위치를 output에 기록합니다.\n\n### **2.3. loader 🚩**\n\n> 웹팩이 웹 애플리케이션을 해석할 때 JS 파일이 아닌 HTML, CSS, IMG, 폰트 등을 변환할 수 있도록 도와주는 속성입니다.\n> \n\n웹팩은 모든 파일을 모듈로 관리하지만 JS 만 알고 있어서 **다른 파일들을 웹팩이 이해할 수 있도록 변경해주는 것이 로더의 역할**입니다.\n\n### **2.4. plugin 🔗**\n\n> 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성입니다.\n> \n\n로더랑 비교하면 **로더는 파일을 해석하고 변환하는 과정에 해당**하고 **플러그인은 해당 결과물의 형태를 바꾸는 과정에 해당**합니다.\n\n## 3. Webpack 실습으로 알아보기\n\n```bash\n$ npm i webpack webpack-cli --save-dev\n```\n\n[💡github 바로가기](https://github.com/likelionSungGuk/webpack/tree/2aa56fbf4f0166f5082c2d43d9e6a3a181404e55)\n\n### 3.1 `webpack.config.js` 파일 직접 작성\n\n```jsx\n// webpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n\n  entry: {\n    main: './js/A.js',\n  },\n\n  output: {\n    filename: '[name].js',  // entry의 이름을 뜻합니다. (여기서는 main)\n    path: path.resolve('./dist'), // .resolve 를 이용해서 절대 경로를 작성 (OS)\n\t\t\t\t\t\t\t\t\t\t\t\t\t// 기본적으로 dist로 설정되어있으나 웹에서는 public으로 많이 함\n  },\n};\n```\n\n- mode:  `'production' | 'development' | 'none'` 중 하나를 선택.\n    - production\n        - DefinePlugin 의 process.env.NODE_ENV 를 production 으로 설정합니다.\n        - `최적화를 가장 중점적`으로 두고 빌드하는 속성\n          - production 모드에서는 코드가 가장 짧고 간결하게 빌드됩니다.\n    - development\n        - DefinePlugin 의 process.env.NODE_ENV 를 development 로 설정합니다.\n        - `빠른 빌드`를 중심으로 두고 빌드하는 속성\n          - development 모드에서 실제로 빌드를 해보면 수 많은 주석이 함께 작성됩니다.\n          - 개발자가 개발하면서 진행상황을 최대한 알아볼 수 있도록 지원합니다.\n    - none\n        - 기본 최적화 옵션으로 설정합니다.\n    \n- entry: 엔트리는 애플리케이션 번들링을 시작할 지점을 의미합니다. 즉, 어떤 파일들을 bundling할 것인가에 대한 경로입니다.\n  \n    entry의 이름이 main이고, 이 main은 `./js/A.js` 입니다. 즉, build를 하면 dist 폴더 아래에 main이라는 이름으로 A.js가 bundling됩니다.\n    \n    - SPA와 MPA Entry차이\n      \n        ```\n        module.exports = {\n          // SPA\n          entry: './index.js'\n        \n          // MPA\n          entry: {\n            main: './main.js',\n            contact: './contact.js'\n          }\n        }\n        ```\n        \n\n💡[웹팩으로 번들링 했을 때와 안했을 때의 차이](https://github.com/likelionSungGuk/webpack/tree/654efb034e021cd4d45cc3d736810824673c9d6d)\n\n```html\n# Bundling 전 index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <h1 id=\"title\">Hello world!</h1>\n  <h3 id=\"B\"></h3>\n  <h3 id=\"C\"></h3>\n\n  <script src=\"./js/A.js\"></script>\n    \n</body>\n</html>\n```\n\n- 돌발QUIZ: 예상되는 화면은?\n  \n    ![요것이웹팩이다](/assets/img/요것이웹팩이다%202.png)\n    \n\n```html\n# Bundling 후\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <h1 id=\"title\">Hello world!</h1>\n  <h3 id=\"B\"></h3>\n  <h3 id=\"C\"></h3>\n\n  <script src=\"./main.js\"></script>\n    \n</body>\n</html>\n```\n\n- 돌발QUIZ: 예상되는 화면은?\n  \n    ![요것이웹팩이다](/assets/img/요것이웹팩이다%203.png)\n    \n\n⇒ 번들링을 하면 Import로 연결되어있는 Javascript 파일들을 모두 하나(`main.js`)로 모아주기 때문에 B.js와 C.js에 있는 BBB와 CCC가 모두 화면에 나옵니다.\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%204.png)\n\n### 3.2 loader & plugin\n\n위에서 언급했듯이 로더는 자바스크립트가 아닌 파일들을 번들링해주는 기능을 합니다.\n\n대표적인 것이 html, css, img파일 등이 있죠.\n\n로더는 아래와 같은 규칙으로 작성됩니다.\n\n[💡커스텀 로더 코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/c522b7b520103488528b1bedbf0e839ee1bd1b80)\n\n```jsx\nmodule : {\n\trules: {\n\t\ttest: '가지고올 파일 형식 정규식',\n\t\tuse: [\n\t\t\t{\n\t\t\t\tloader: '사용할 로더 이름',\n\t\t\t\toptions: { 사용할 로더 옵션 }\n\t\t\t}\n\t\t]\n\t}\n}\n```\n\n커스텀 로더를 하나 만들어 보겠습니다.\n\n```jsx\n// customLoader.js\nmodule.exports = function customLoader(content) {\n  console.log(\"customLoader 동작!\")\n  return content\n}\n```\n\n단순히 로그를 찍은 뒤 content를 그대로 반환하는 간단한 로더입니다.\n\n```jsx\n// webpack.config.js\nmodule: {\n  rules: [{\n    test: /\\.js$/, // .js 확장자로 끝나는 모든 파일\n    use: [path.resolve('./customLoader.js')] // 방금 만든 로더를 적용한다\n  }]\n}\n```\n\njs로 끝나는 모든 확장자는 이 로더를 한 번씩 돌리도록 하는 설정입니다.\n\n- 돌발 QUIZ: build를  때 “customLoader 동작!”이라는 로그는 몇 번 나올까요?\n  \n    ![요것이웹팩이다](/assets/img/요것이웹팩이다%205.png)\n    \n\n앞서 언급했듯이 로더는 주로 Javascript가 아닌 파일들을 위해 만들어져있는데 예시를 자바스크립트로 만들어 버렸네요. 자주쓰이는 Loader들을 살펴보며 실제로는 어떻게 활용되는지 알아보겠습니다.\n\n## 4. 자주쓰이는 Loader\n\n### 4.1 css-loader\n\n[💡css-loader 코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/231957299996bad792a750638e4f72d0c43a9e3b)\n\n```bash\n$ npm install -D css-loader\n```\n\n- 돌발QUIZ: `-D`는 무슨 뜻일까요?\n  \n    D, --save-dev (Package will appear in your `devDependencies`)\n    \n    개발의존성 모드.\n    \n    개발할 때만 필요한 패키지가 있습니다. 이런 경우에는 -D를 붙여서 설치하면 \n    \n    런타임에도 필요한 패키지가 있을 경우에는 -D를 생략하면 됩니다.\n    \n    dev에서만 필요하고 prod에서는 필요하지 않은 패키지의 경우 이렇게 설치하여 사용합니다.\n    \n    - `npm install {패키지}` == `npm install --save {패키지}`\n    - `npm install -D {패키지}` == `npm install --save-dev {패키지}`\n    \n    ![요것이웹팩이다](/assets/img/요것이웹팩이다%206.png)\n    \n\n설치를 하고 `webpack.config.js` 에 로더 설정을 추가해줍니다.\n\n```jsx\nmodule: {\n    rules: [\n      {\n        test: /\\.css$/, \n        use: [\"css-loader\"], // css-loader를 적용한다\n      },\n    ],\n  }\n```\n\nbuild후 main.js\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%207.png)\n\n- `style.css`파일이 같이 빌드되어있는 것을 확인할 수 있습니다.\n\n그렇다면 배경이 초록색으로 변경되었을까요?\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%208.png)\n\nNO. ???\n\nstyle-loader에서 알아봅시다.\n\n### 4.2 **style-loader**\n\n[💡style-loader코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/06209b896af27a128ccd0a05012b3bdb3e1f1fe3)\n\n모듈로 변경된 스타일 시트는 돔에 추가되어야만 브라우저가 해석할 수 있습니다. `css-loader`로 처리하면 CSS가 자바스크립트 코드로 변경만 되었을 뿐 돔에 적용되지는 않은 상황이다. 때문에 스타일이 적용되지 않은 것입니다.\n\nstyle-loader는 javascript로 변경된 스타일을 돔에 추가하는 로더입니다.\n\n❕그러므로 css-loader와 style-loader는 대부분 함께 사용됩니다.\n\n```bash\n$ npm install -D css-loader\n```\n\n설치 후 webpack.config.js 추가\n\n```jsx\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/, // .css 확장자로 끝나는 모든 파일\n      use: [\"style-loader\", \"css-loader\"], // style-loader를 앞에 추가한다\n    },\n  ],\n}\n```\n\n특이한 점은 뒤에 설치된 style-loader를 use 배열의 앞쪽에 적었다는 점입니다. 이 배열은 뒤에서 부터 읽어들여 로더를 실행한다고 합니다. 따라서 css를 js로 바꾸는 css-loader먼저 실행하고 그 뒤에 style-loader를 실행해야 하므로 위와 같은 순서대로 작성해줘야 합니다.\n\n```jsx\n$ npm run build\n```\n\n![드디어 못생긴 초록색 배경 스타일(background: green)이 적용되었네요.](/assets/img/요것이웹팩이다%209.png)\n\n드디어 못생긴 초록색 배경 스타일(background: green)이 적용되었네요.\n\n이 외에 file-loader, url-loader, babel-loader들이 자주 사용되는 로더라고 합니다.\n\n## 5. 플러그인\n\n로더가 “파일” 단위로 처리한다면 플러그인은 “번들된 결과물”을 처리합니다.\n\n특징점인 것은 플러그인 배열에는 생성자를 사용해서 만들어줘야 한다는 점입니다.\n\n```jsx\n// webpack.config.js \nvar webpack = require('webpack'); \nvar HtmlWebpackPlugin = require('html-webpack-plugin'); \nmodule.exports = {\n  mode : '', \n\tentry : {}, \n\toutput : {}, \n\tmodule : {},\n plugins : [ \n\tnew HtmlWebpackPlugin(), \n\tnew webpack.ProgressPlugin(), \n\tnew webpack.optimize.UglifyJsPlugin()\n\t // ... ] \n}\n\n```\n\n[💡플러그인 바로가기](https://github.com/likelionSungGuk/webpack/tree/47df871e7cb317e490948627b9cc3165a2829c23)\n\n가장 이해하기 편한 `HtmlWebpackPlugin`의 사용 사례를 살펴보겠습니다.\n\n```bash\n$ npm install --save-dev html-webpack-plugin\n```\n\n`HtmlWebpackPlugin` 은 번들링 했을 때 최종적으로 완성된 Html을 같이 export해주는 기능을 제공합니다.\n\n플러그인은 각각의 플러그인별로 사용법이 많이 차이가 난다고 합니다. 따라서 webpack 공식 사이트에서 제공해주는 Guide를 따라 가며 진행할 것을 권장드립니다.\n\n[HtmlWebpackPlugin | webpack](https://webpack.js.org/plugins/html-webpack-plugin)\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%2010.png)\n\n상단에 require, 하단에 생성자 생성을 진행해줍니다.\n\n```jsx\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n\n  entry: {\n    main: './src/js/A.js',\n  },\n  output: {\n    filename: '[name].js',\n    path: path.resolve('./dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/, // .css 확장자로 끝나는 모든 파일\n        use: [\"style-loader\", \"css-loader\"], // style-loader를 앞에 추가한다\n      },\n    ],\n  },\n  plugins: [new HtmlWebpackPlugin()]\n};\n```\n\n이후 `npm run build`\n\n```html\n// index.html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Webpack App</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><script defer src=\"main.js\"></script></head>\n  <body>\n  </body>\n</html>\n```\n\n기존에는 따로 만들어줬던 index.html 이었지만 이번에는 플러그인이 직접 index.html을 생성해주었습니다. index.html을 브라우저로 열어보겠습니다.\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%2011.png)\n\n이상하게도 스타일은 그대로 적용이 되었는데, 기존 h1태그 들이 사라져 있습니다.\n\n우리가 원하는 것은 기본 index.html을 템플릿으로 해서 새롭게 빌드해주는 것이었는데 그렇게 동작하지 않았네요.\n\n이것을 가능하게 하려면 템플릿을 지정하는 설정을 추가해줘야 합니다.\n\n`webpack.config.js`\n\n```jsx\nplugins: [new HtmlWebpackPlugin({\n  template: './index.html', // 템플릿이 될 html path를 지정\n  filename: './output.html' // 빌드될 html의 이름/path 지정\n}\n```\n\n의도적으로 이름을 `output.html` 로 지어봤습니다.\n\n![요것이웹팩이다](/assets/img/요것이웹팩이다%2012.png)\n\n`output.html`\n\n```jsx\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n<script defer src=\"main.js\"></script></head>\n<body>\n  <h1 id=\"title\">Hello world!</h1>\n  <h3 id=\"B\"></h3>\n  <h3 id=\"C\"></h3>\n\n  <script src=\"./js/A.js\"></script>\n    \n</body>\n</html>\n```\n\n우리가 원하던 대로 index.html 템플릿을 그대로 가져왔네요.\n\n—-END—-\n\n---\n\n참고자료\n\n[npm-install | npm Docs](https://docs.npmjs.com/cli/v8/commands/npm-install)\n\n[npm install (plugin) --save와 --save-dev 차이점](https://ithub.tistory.com/165)\n\n[개발(Development) 모드는 어떻게 작동할까?](https://ui.toast.com/weekly-pick/ko_20191212)\n\n[프론트엔드 개발환경의 이해: 웹팩(기본)](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html#5-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8)\n\n[Writing a Plugin | webpack](https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture)");

/***/ }),

/***/ "./contents/blog/frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md":
/*!***********************************************************************!*\
  !*** ./contents/blog/frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"똑똑하게 ASSETS관리하는 EIMA 라이브러리 추천합니다!\"\ndate: \"2022.10.12\"\ntags:\n- 리액트\n- 이미지\n- EIMA\n- 라이브러리\n---\n\n\n\n## 1. Intro\n\n개발을 하다보면 png, svg 파일 등의 Assets들을 import해와서 써야 하는 경우가 빈번하게 발생합니다. 이 과정을 반복하다보면 크게 두 가지 귀찮은 상황이 발생하는데 하나는 import문이 길어진다는 것이고 또 다른 하나는 다양한 곳에서 활용되는 assets은 A, B, C… 등 n개의 여러 파일에 걸쳐서 계속 import 되고 쓰여야 한다는 것이죠. 그때마다 해당 소스의 path를 상대경로로 가지고 오는 것도 꽤나 귀찮은 반복작업입니다.\n\n### EIMA 라이브러리 소개\n\n이런 불편한 점을 개선할 수 있도록 도와주는 좋은 라이브러리를 찾아 공유합니다.\n\n[https://github.com/Jonghakseo/EimaJS](https://github.com/Jonghakseo/EimaJS)\n\nEIMA라이브러리는 하나의 디렉토리 안에 있는 assets들을 [상위dir _ 하위dir _ 이름]으로 구분지어 쉽게 import하고 이름을 검색할 수 있도록 만들어주는 똑똑한 기능을 제공합니다.\n\n예를들어 `img/abc/def/sky.png` 라는 이미지가 있으면 `ABC_DEF_SKY_PNG` 라는 이름으로 해당 path를 불러올 수 있도록 도와줍니다.\n\n```\n// assets.js\nimport ABC_DEF_SKY_PNG from \"img/abc/def/sky.png\";\n\nconst ASSETS = {\n  ABC_DEF_SKY_PNG\n}\nexport default ASSETS\n```\n\n또 해당 디렉토리를 watch하고 있다가 새로운 리소스가 들어오면 그 리소스에 대한 이름과 path도 바로 만들어서 assets.js에 추가해주어 리소스를 추가한 뒤 또 assets.js에 추가해야되는 번거로움을 없애주었습니다.\n\neima를 설치하고 `eima init` 명령어를 입력하면 기본적으로 생기는 것이 eima.json입니다.\n\n```tsx\n// eima.json\n{\n\t\"target\":\"es6\",\n\t\"hideSize\":false,\n\t\"lintPath\":\"src\",\n\t\"paths\":[{\"assets\":\"src/img\",\"out\":\"src/assets.js\",\"vName\":\"ASSETS\"}]\n}\n```\n\n- target은 ECMASCRIPT 문법을 뜻하며 es6로 할 경우 익숙한 import from 으로 변환시켜 줍니다.\n- 여기서 중요하게 봐야할 것은 paths인데, paths내부의 **assets은 타겟 디렉토리의 path**를 넣어주고 out은 어떤 위치에 assets를 import하여 이름과 path를 반환해주는 js파일의 path와 name, 확장자까지 적어줍니다. vName은 export할 대표 닉네임이라 보시면 됩니다.\n- 위와 같이 설정하면 eima.json은 디렉토리 최상단, assets.js라는 이름의 파일은 src 아래 생기고 닉네임은 ASSETS로 설정됩니다.\n- 이 설정파일을 완료한 뒤 `eima start` 명령어를 입력하면 assets.js 가 생기면서 ASSETS의 이름과 path가 생성됩니다.\n\n> 💡주의: eima를 리액트 프로젝트 내부에 설치하면 eima 명령어가 제대로 동작하지 않습니다. \n> npm i eima -g 명령어로 글로벌로 설치하시면 eima의 명령어를 실행할 수 있습니다.\n\n\n\n## 2. SVG 파일을 ReactComponent로 사용하기\n\n기존에는 SVG 파일을 리액트 컴포넌트로 사용하기 위해 다음과 같은 문법을 활용하였습니다.\n\n```tsx\nimport { ReactComponent as FileUpload } from '../src/img/icon/file_upload.svg';\n```\n\n하지만 새롭게 EIMA 라이브러리를 쓰게 되면서 import 자체를 ReactComponent로 해오기는 어려웠습니다. 이를 해결하기 위해서 svg의 ASSETS src 를 전달하면 ReactComponent를 만들어 주는 컴포넌트를 만들었습니다.\n\n```tsx\nimport React from 'react'\nimport styled from 'styled-components';\n\ninterface SvgComponentProps {\n  src: string;\n  className: string;\n  disabled?: boolean;\n}\n\nconst SvgComponent = (props: SvgComponentProps) => <StyledObject type=\"image/svg+xml\" data={props.src} className={props.className} disabled={props.disabled} />;\n\nexport default SvgComponent;\n\ninterface StyledObjectProps {\n  disabled?: boolean;\n}\n\nconst StyledObject = styled.object<StyledObjectProps>`\n  filter: ${(props) => (props.disabled ? `invert(50%) sepia(0%) saturate(50%) hue-rotate(0deg) brightness(100%) contrast(100%)` : ``)};\n`;\n```\n\n여기서 특이한 점은 object를 썼다는 점인데요, svg를 사용하는 다양한 방식이 있었지만 svg의 색상을 제어해야했던 상황에서 object 태그가 그나마 유용하다고 여겨졌습니다.\n\n[웹에서 SVG 사용하기](https://svgontheweb.com/ko/)\n\n\n\n### 2-1. Object태그 에러 핸들링\n\nobject태그로 disabled가 props로 왔을 때 색상 변경까지 진행할 수 있어서 이제 다 되었구나 생각하고 있었을 때 예상치 못한 상황이 하나 펼쳐졌습니다. 마우스 커서를 보면 아이콘 바로 위에 위치했을 때는 포인터 커서가 아닌 일반커서형태로 나오고 클릭도 되지 않습니다. 해당 아이콘 영역을 벗어나면 다시 일반 버튼과 동일하게 동작하게 되는 것이죠.\n\n<video src=\"/assets/img/object태그이슈.mp4\" width=\"100%\" autoplay controls loop></video>\n\n바로 svg가 상위의 버튼 컴포넌트의 클릭 이벤트를 막고 있었습니다.\n\n따라서 css에 `pointer-events: none;` 을 추가해주고 나서야 드디어 정상적으로 동작할 수 있게 되었습니다.\n\n[How to bind click event to object tag?](https://stackoverflow.com/questions/25916403/how-to-bind-click-event-to-object-tag#:~:text=1.%20Issue%3A%20Event%20handling)\n\n\n\n### 2-2. 아이콘마다 색상이 다른 이슈\n\nSvgComponent로 아이콘을 래핑해서 ReactComponent화 해주어도 문제가 되는 것은 색상 이슈였습니다. 아이콘의 색상이 원하던 색이 그대로 나오지 않는 상황이었는데 원인은 크게 두 가지가 있었습니다.\n\n1. svg는 기존 class에 선언된 css 영향을 받지 않는다.\n2. svg 파일별로 각각의 색상값이 존재하고 그 값이 다르다.\n\n```tsx\n// ex: file_download.svg\n<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 0 24 24\" width=\"24px\" fill=\"#000000\"> ...\n\n// ex2: ic-cal-area.svg\n<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">...\n```\n\n예를 들어 file_download.svg 파일은 기본적으로 검정색 색상이 fill로 적용되어있고 이와는 달리 ic-cal-area 파일은 fill 색상이 따로 지정되어있지 않는 특성을 가지고 있습니다.\n\n따라서 각각의 svg파일에 기본 색상값 #CCC를 넣어주고 해당 값이 변해야 하는 상황(예를 들어 disabled)에서는 filter 어트리뷰트를 사용하여 색상값을 변경해주었습니다.\n\n<aside>\n💡 SVGR 라이브러리를 활용하면 SVG 파일을 ReactComponent로 변경하여 사용할 수 있게 됩니다. 하지만 개인적으로 EIMA 라이브러리를 설치한데다가 SVGR까지 두 개를 설치하는게 좀 꺼려졌고, 좀 더 원했던것은 각각의 SVG파일이 ReactComponent가 되는 것이 아니라 SVG의 Path만으로 쉽게 ReactComponent를 만들고 싶어서 이번에는 위와 같이 작업하였습니다.\n</aside>\n```javascript\n<img className=\"loading-img\" src={ASSETS.ICON_LOADING_PNG} alt=\"loading-img\" />\n```\n\n\n이런식으로 기존 svg의 경로를 찾아서 src에 직접 넣는 것보다 vsCode와 EIMA의 도움을 받아 내가 추가한 assets의 경로와 이름으로 손쉽게 찾아올 수 있다는 점이 상당히 편리해졌다는 것입니다. 또한 여러개의 페이지에 동일한 이미지 assets들이 import 되고 있는데 이런 부분들은 추후 assets의 경로나 파일이 변경되면 번거롭게 모두 수정해주어야 하고 그에 따라 버그 발생확률도 올라갈 수 있다는 단점이 있습니다. 하지만 이렇게 동일한 asset에 대해 같은 이름을 사용한다면 변경사항이 있더라도 모두 동일하게 적용될 수 있습니다.\n\n이와 같은 과정을 반복하면서 기존 Assets들을 대체해줍니다.\n\n### 3-2. ReactComponent로 import해서 사용하던 SVG 파일 수정 예시\n\n```tsx\n// 기존\nimport { ReactComponent as DoubleArrowRight } from \"./img/icon/double_arrow_right.svg\"\n<DoubleArrowRight className=\"icon\" />\n```\n\n<video src=\"/assets/img/ReactComponent-eima.mp4\" width=\"100%\" autoplay controls loop></video>\n\n```tsx\n// 변환\nimport SvgComponent from './components/SvgComponent';\nimport ASSETS from './assets';\n\n<SvgComponent className=\"icon\" src={ASSETS.ICON_DOUBLE_ARROW_RIGHT_SVG} disabled={this.state.endPageNum - 10 < this.props.curPage || this.state.endPageNum === this.props.curPage} />\n```\n\n이렇게 SVG의 src path를 SvgComponent에 props으로 내려주는 방식으로 아이콘을 쉽게 ReactComponent화 해서 활용할 수 있습니다.\n\n\n\n## 4. 사용법\n\nEima를 도입하고자 한다면 다음과 같이 쓸 수 있습니다.\n\n터미널을 두  개 이상 켭니다.\n\n그래서 하나는 로컬 서버로 사용하고 또 다른 하나는 eima를 사용합니다. (저는 git용으로 3개씩 켜서 쓰고 있습니다.)\n\n![eima사용법.png](/assets/img/eima사용법.png)\n\n이렇게 되면 assets가 바라보고 있는 디렉토리에 새로운 assets이 추가될 때마다 assets.js 에 해당 assets의 패스와 이름이 자동으로 추가되어 손쉽게 사용할 수 있게 됩니다.\n\n제가 한 번 써보고 괜찮으면 저희 팀에도 소개하려고 했는데 개인적으로 상당히 만족하고 있어서 팀에 소개 후 도입하려고 합니다.\n\n좋은 라이브러리를 만들어주신 [서종학](https://nookpi.tistory.com/97?category=906072) 님께 다시 한 번 감사드립니다 🙇\n");

/***/ }),

/***/ "./contents/blog/frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md":
/*!***************************************************************************!*\
  !*** ./contents/blog/frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"FEconf 2022 Rescript같이해요\"\ndate: \"2022.10.14\"\ntags:\n- feconf\n- rescript\n- 그린랩스\n---\n\n\n\n# 2022 FEconf Track A - Rescript같이해요\n\n2022년부터 코로나 규제가 서서히 풀리면서 컨퍼런스들이 오프라인으로 진행이 되고 있습니다. 올해 처음 시작한 인프콘도 있었고 Feconf도 10월에 열렸습니다.\n\nFEconf는 그 인기가 대단해서 마치 무슨 BTS 콘서트 티켓팅 하듯이 순식간에 마무리가 되었더라구요. 올해 꼭 오프라인 컨퍼런스를 참여해보고 싶었는데 올해는 쉽지 않을 것 같아 아쉽네요. 내년에는 꼭 참석하고 싶습니다. 집구석에서 온라인으로 컨퍼런스 내용을 정리해보며 스스로 마음을 달래봅니다.\n\n\n\nTrack A 목차\n\n1. **Rescript같이해요**\n\n2. @webtoon/psd 라이브러리 개발기\n\n3. 프론트엔드 DDD를 만나다 \n\n4. 텍스트 에디터? 그게 뭘 만드는건데? \n\n5. Edge 컴퓨팅으로 프론트엔드 포텐셜 끌어올리기 \n\n\n\n## Rescript같이해요\n\n- 발표자: 그린랩스 정미량\n\n- 예상 청자: 프론트엔드 비기너, 타입언어 사용해보고 싶은분, 함수형 프로그래밍에 관심있으신 분 등\n- 발표 내용 요약: Rescript라는 순수함수를 지향하는 함수형 프로그래밍 정적 타입언어를 소개하는 세션이었으며 그린랩스에서 왜 Rescript를 쓰고 있고 그 장점이 무엇인지 알려주셨습니다.\n\n\n\n## Rescript의 특징\n\n- 불변성을 유지하기 위해 변수값을 변경할 수 없다.\n- let만 있다 (재할당이 안되서 const와 오히려 유사)\n- return 이 없다. (마지막 라인이 암묵적 반환됨)\n- import export가 없다. (모든 모듈은 내보내진다.)\n- TS처럼 JS의 superset인가? NO\n  - JS의 기능 중 특별히 선정된 기능만을 다루고 있는 새로운 언어\n\n\n\n## Rescirpt의 소소한 장점\n\n- 모든 JS 라이브러리를 Rescript와 함께 사용 가능하다. (npm, yarn, package.json 모두 사용 가능)\n\n- 파이프 연산자를 통해 한 방향으로 코드를 읽기 편하게 도와준다 (좌 -> 우, 위 -> 아래) \n\n  - JS문법이 달라졌다기 보다 문법적 설탕(Syntactic Sugar)으로 보면 된다.\n\n  - ```javascript\n    // 기존 js\n    A(B(C(...args)))\n    \n    // rescript\n    A -> B -> C\n    ```\n\n- 모든 모듈이 내보내지기 때문에 import, export문이 길어지지 않는다.\n\n\n\n## Rescript의 큰 장점\n\n### 타입추론\n\n- 타입어노테이션 없이 모든 표현식의 타입을 힌들리-밀너 타입으로 추론 가능하다\n\n- ```javascript\n  let add (a, b) => a+b     --- (int, int) => int\n  let add2 (a, b) => a++b  --- (str, str) => str\n  let add3 (a, b) => a+.b  --- (float, float) => float\n  ```\n\n- 이게 가능한 이유는 각 타입별로 연산자를 다르게 사용하는 Rescript의 특징때문이다.\n\n- 이 뿐만 아니고 실제로 타입을 선언한 뒤 비슷한 객체를 새롭게 생성하면 Rescript는 스스로 가장 적합해 보이는 타입을 추론한다.\n\n- variant 타입\n\n  - ```javascript\n    type result = Pending | Success({ data: string }) | Fail\n    ```\n\n  - 위와 같이 Variant 생성자는 타입에 추가 값을 가질 수가 있다.\n\n- 패턴매칭\n\n  - 위 variant 타입을 활용하면 패턴 매칭에 유리하다\n\n  - ```javascript\n    let data = (true, false) // 튜플\n    let component = switch data {\n        | (true, true) => \"tt\"\n        | (true, false) => \"tf\"\n        | (false, true) => \"ft\"\n    }\n    ```\n\n  - 위와 같이 코드를 짜면 Rescript compile 당시 \"ff\" 쌍이 없다는 것을 찾아준다.\n\n- option 타입\n\n  - Rescript에는 nulll, undefined 개념이 없다. 이런 경우 option타입을 이용해서 값이 있는지 없는지를 체크할 수 있다.\n\n\n\n## Rescript를 쓰면서 아쉬웠던 점\n\n### 1. 바인딩\n\nRescript에서는 javascript함수를 사용하기 위해 바인딩을 해야 한다. 이것이 어렵고 귀찮다.\n\n> 바인딩이란?\n>\n> 현재 언어에서 다른 언어로 쓰인 코드를 호출하기 위한 인터페이스\n\n그린랩스에서는 next, nock, jest, react-hook-form, react-linkify 등 다양한 rescript-bindings 라이브러리를 제공합니다.\n\nNEXT 예시 링크: https://www.npmjs.com/package/@greenlabs/rescript-next\n\n\n\n### 2. 작은 커뮤니티\n\nStackoverflow에서 검색해도 나오는 것이 거의 없음 ㅠㅠ\n\n[rescript] 태그로 조회해보면 22년 10월 현재 69개 정도밖에 나오지 않을 정도로 글로벌 레벨에서도 사용빈도가 확실히 낮은 편에 속한다.\n\n\n\n## 느낀점\n\nRescript란 것을 처음 본 느낌은 뭔가 JS와 TS가 합쳐져서 하나의 언어로 다시 태어난 것 같다는 생각이 드네요.\n\n근데 현 프로젝트에 도입한다고 하면 좀 꺼려지는 생각이 우선 듭니다. 뭔가 벌써부터 꼰대가 된 느낌인데... 연사분께서 말씀하신 것처럼 러닝커브가 좀 있기도 하고 기존 JS/TS 조합으로 사용해도 어느 정도 만족하기 때문이 아닐까 싶기도하고 아직 스스로 느끼기에 'JS/TS도 완벽하게 못쓰는 놈이 한 눈 파나' 라는 생각이 들기도 합니다.\n\n그래도 Feconf에서 새로운 언어를 살펴보는 재미가 있었습니다.\n\n막상 써보면 또 다를 수도 있을 것 같아요.\n\n\n\n---\n\n출처: https://www.youtube.com/watch?v=jZNk-Ncez6E\n");

/***/ }),

/***/ "./contents/blog/jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md":
/*!******************************************************************************!*\
  !*** ./contents/blog/jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"jekyll Blog 만드는게 글쓰는 것보다 힘든 사람들에게\"\r\ndate: \"2020.12.17\"\r\ntags:\r\n   - jekyll\r\n   - jekyll theme\r\n   - ruby\r\n   - rails\r\n   - blog\r\n   - mac\r\n   - 지킬 테마\r\n---\r\n\r\n# [mac] Jekyll Blog 지킬 블로그 NeXT theme 따라하기\r\n\r\n## 1. 준비사항\r\n\r\n1. github pages 호스팅을 기본으로 합니다.\r\n\r\n   `username.github.io`라는 이름의 repository를 github에 만들어 줍니다.\r\n   \r\n2. `mac OS`에서 `ruby on rails`를 활용합니다. (windows는 좀 더 복잡한 것 같습니다... 추후 windows에서도 해보고 2탄을 올릴까 생각중입니다)\r\n   \r\n\r\nruby 를 설치하지 않고 jekyll 을 활용하고 싶으시다면  [쉽고 빠르게 수준 급의 GitHub 블로그 만들기 - jekyll remote theme으로](https://dreamgonfly.github.io/blog/jekyll-remote-theme/) 포스팅을 참고하세요. \r\n   저의 포스팅에서는 좀 더 custom이 가능한 `ruby on rails`를 활용하는 방법을 설명드리겠습니다.\r\n\r\n3. 마음에 드는 jekyll theme를 선택합니다. 아래 사이트 들을 돌아다니며 자신이 원하는 theme를 찾아보세요\r\n\r\n   - http://jekyllthemes.org/\r\n   - https://jekyllthemes.io/free\r\n   - http://themes.jekyllrc.org/\r\n   - https://github.com/topics/jekyll-theme\r\n\r\n   제 블로그에는 다음의 것들이 꼭 필요하다고 생각했습니다.\r\n\r\n   - 마크다운으로 글 작성\r\n\r\n   - 카테고리\r\n- tag기능 \r\n   - 검색기능\r\n- 포스트 댓글 기능 등\r\n  \r\n\r\n위의 요소들을 포함하는 테마 중에서 깔끔하다고 생각한[ `Next theme`](https://github.com/Simpleyyt/jekyll-theme-next)를 선택했습니다.\r\n\r\n개인적으로 깔끔한 테마를 추천하자면 [Tale](https://github.com/chesterhow/tale)테마도 추천합니다. `Next theme`과 Tale 사이에서 많이 고민했었습니다.\r\n\r\n\r\n\r\n선택한 theme의 github repository를 로컬 환경에 다운받습니다. 이후 username.github.io 에 git remote 를 연결해줍니다.\r\n\r\n```bash\r\n   $ git remote add origin https://github.com/username/username.github.io\r\n```\r\n\r\n3. .gitignore 를 추가해줍니다.\r\n   \r\n\r\n[jekyll gitignore](https://gist.github.com/bradonomics/cf5984b6799da7fdfafd) 페이지를 활용하시면 됩니다.\r\n\r\n5. Jekyll은 기본적으로 `ruby on rails` 의 정적 페이지 프로젝트입니다. 따라서 ruby 언어 설치가 필요합니다.\r\n   만약 mac OS를 쓰고 계시면 ruby가 기본적으로 설치되어 있을 수도 있습니다. \r\n   (아니면 homebrew를 통해 간단히 설치도 가능합니다.)\r\n   (만약 windows OS를 쓰고 계시다면[ `rubyinstaller`](https://rubyinstaller.org/)를 활용해 설치하시면 됩니다. )\r\n   저희는 이번에는 rvm 을 사용해서 ruby를 설치해보겠습니다.\r\n   ruby는 2.1.x 이상 버전으로 설치해주세요.\r\n\r\n6. 루비를 설치하기 전에 rvm을 설치하고 이후 ruby의 버전을 맞추어 설치해줍니다.\r\n\r\n   ```bash\r\n   $ \\curl -L https://get.rvm.io | bash -s stable\r\n   ```\r\n\r\n   rvm 설치 후  체크\r\n\r\n   ```bash\r\n   $ rvm list known\r\n   ```\r\n\r\n   ```bash\r\n   $ rvm install [ruby-version]\r\n   예: rvm install ruby-2.7.0\r\n   ```\r\n\r\n   ruby version확인\r\n\r\n   ```bash\r\n   $ ruby -v \r\n   또는\r\n   $ ruby --version\r\n   ```\r\n\r\n   \r\n\r\n## 2. Gem\r\n\r\n***만약 해당 과정 중  오류가 발생한다면  포스팅아래 3. errors & actions를 확인해주세요.***\r\n\r\n\r\n\r\n### 2-1. Gemfile 설치하기\r\n\r\n```ruby\r\nsource 'https://rubygems.org'\r\ngem 'github-pages', group: :jekyll_plugins\r\n#gem 'jekyll-admin', group: :jekyll_plugins\r\ngem 'bigdecimal', '1.3.5'\r\n```\r\n\r\n`Gemfile`을 아래와 같이 작성해주세요.\r\n\r\n- github-pages gem을 추가해주고, jekyll-admin 부분은 주석처리 합니다.\r\n- bigdecimal의 경우 mac OS 사용 시 `gem` 버전이 맞지 않아 버전까지 추가로 설정해주었습니다.\r\n\r\n### 2-2. rails, bundler 설치하기\r\n\r\n1. ruby의 프레임워크인 rails를 설치해줍니다.\r\n\r\n```bash\r\n$ gem install rails\r\n```\r\n\r\n2. 다음으로 라이브러리 관리를 도와주는 bundler를 설치해줍니다.\r\n\r\n```bash\r\n$ gem install bundler\r\n```\r\n\r\n3. 그리고 update를 실행해줍니다.\r\n\r\n(왜 처음 설치할 때부터 최신버전이 아닌지에 대해서는 정확히 모르겠지만, 아마 bundler뿐만 아니라 관련 gem 라이브러리들이 bundler 버전에 맞춰 업데이트 해줘야 하는 것 같습니다..;;)\r\n\r\n```bash\r\n$ bundle update --bundler\r\n```\r\n\r\n```bash\r\n$ bundle install\r\n```\r\n\r\n### 2-3. 로컬에서 제대로 돌아가는지 확인하기\r\n\r\n```bash\r\n$ bundle exec jekyll server\r\n```\r\n\r\n이 명령어를 입력하면 `http://127.0.0.1:4000` 에서 서버가 구동되는 것을 확인할 수 있습니다.\r\n\r\n일단 여기까지만 제대로 되면 아주 Nice한 상황입니다만...\r\n\r\n실제로 저는 이 화면을 띄우는데 꼬박 하루 걸렸던 것 같습니다.\r\n\r\n다음은 jekyll을 설치하고 실행시키면서 마주쳤던 오류 메시지들과 그에 대한 해결책들을 보여드리겠습니다.\r\n\r\n\r\n\r\n---\r\n\r\n## 3. errors & actions\r\n\r\n크게 4가지의 error들이 괴롭혔었는데요 하나씩 소개해드리겠습니다.\r\n\r\n### 3-1. [oh-my-zsh] permission error\r\n\r\n저는 terminal을 `oh-my-zsh`를 사용하고 있습니다. 여기서 계속 이런 오류가 발생합니다.\r\n\r\n![oh-my-zsh-permission](https://blog.kakaocdn.net/dn/bxXXV2/btqF00zWrWO/kZ0TIFBgWggC57LXO8MJBK/img.png)\r\n\r\n이 문제는 해당 directory의 ower가 현재 user와 다른 경우에 발생한다고 합니다.\r\n\r\n예를 들어, 맥에 2개의 계정이 있는데 서로 다른 계정을 사용하면서 생긴 문제라고 합니다. (하지만 저는 그렇지 않았던 것 같은데 계속 이 메시지가 떴습니다...;;)\r\n\r\n### 3-1. [oh-my-zsh] permission error actions 대응 방법\r\n\r\n해결 방법은 이미지의 마지막에서도 볼 수 있듯이 `ZSH_DISABLE_COMPFIX`를 true로 설정해주는 것입니다.\r\n\r\n```bash\r\n$ vi ~/.zshrc\r\n```\r\n\r\n명령어를 입력하여 vi editor 모드로 변경합니다.\r\n\r\n```bash\r\n...\r\nZSH_DISABLE_COMPFIX=\"true\"\r\n\r\nsource $ZSH/oh-my-zsh.sh\r\n...\r\n```\r\n\r\n**!주의!**\r\n\r\n여기서 가장 중요한 것은 위치입니다. 반드시 `source $ZSH/oh-my-zsh.sh`보다 위쪽에 `ZSH_DISABLE_COMPFIX=\"true\"`를 입력해주세요\r\n\r\n`source $ZSH/oh-my-zsh.sh` 는 위의 scripts 들을 적용하는 명령어인데 이것보다 뒤에 있으면 적용되지 않는다고 이해하시면 됩니다.\r\n\r\n`:wq`로 저장 후 vi editor를 빠져나옵니다.\r\n\r\n이 에러는 이렇게 해결할 수 있었습니다.\r\n\r\n\r\n\r\n### 3-2. undefined method `new' for BigDecimal:Class, Ruby 2.7\r\n\r\n```bash\r\nbundler: failed to load command: fastlane (/Users/REDACTED/.gem/ruby/2.7.0/bin/fastlane)\r\nNoMethodError: [!] undefined method `new' for BigDecimal:Class\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext/object/duplicable.rb:111:in `<class:BigDecimal>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext/object/duplicable.rb:106:in `<top (required)>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext/object.rb:3:in `require'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext/object.rb:3:in `<top (required)>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext.rb:2:in `require'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext.rb:2:in `block in <top (required)>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext.rb:1:in `each'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/activesupport-4.2.11.1/lib/active_support/core_ext.rb:1:in `<top (required)>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/slack-ruby-client-0.14.4/lib/slack-ruby-client.rb:39:in `require'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/slack-ruby-client-0.14.4/lib/slack-ruby-client.rb:39:in `<top (required)>'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/fastlane-2.146.1/fastlane/lib/fastlane/fastlane_require.rb:10:in `require'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/fastlane-2.146.1/fastlane/lib/fastlane/fastlane_require.rb:10:in `install_gem_if_needed'\r\n  /Users/REDACTED/.gem/ruby/2.7.0/gems/fastlane-2.146.1/fastlane/lib/fastlane/fast_file.rb:232:in `fastlane_require'\r\n  Fastfile:55:in `block in parsing_binding'\r\n```\r\n\r\n이 에러는 ruby 버전과 `BigDecimal` 이라는 gem의 버전 차이 문제로 발생한 것 같습니다.\r\n\r\nGemfile 내에 `gem 'bigdecimal', '1.3.5'` 로 버전까지 명확히 추가한 후 `bundle install` 하니 해결되었습니다.\r\n\r\n\r\n\r\n### 3-3. bundle / bundle install 이 안되는 에러\r\n\r\n이 에러도 꽤나 고생했던 에러였습니다.\r\n\r\n저는 `homebrew`를 사용하여 ruby 등 다양한 것들을 설치하고 했었는데 이게 mac OS 최신 버전인 Catalina와의 충돌 문제인건지, 아니면 rbenv와의 충돌인건지는 잘 모르겠습니다. \r\n\r\n### Actions 해결법 \r\n\r\n저는 아래와 같은 두 줄의 코드를 `vi ~/.zshrc`에 추가하여 해결했습니다.\r\n\r\n위와 같이 `source $ZSH/oh-my-zsh.sh` 보다 위쪽에 입력하고 저장하면 됩니다.\r\n\r\n```bash\r\n...\r\nexport PATH=\"$HOME/.rbenv/bin:$PATH\"\r\neval \"$(rbenv init -)\"\r\n\r\nsource $ZSH/oh-my-zsh.sh\r\n...\r\n```\r\n\r\n\r\n\r\n한 이틀 정도 지나고나서 작성하다보니 그새 에러와 대응법을 많이 잊었습니다.\r\n\r\n포스팅의 방법이 완벽하지 않을 수 있으니 사용에 주의해주시고, 혹시 잘못된 부분을 발견하신 분은 아래 댓글로 남겨주시면 정말 감사하겠습니다.\r\n\r\n이 외에도 여러가지 에러가 더 생각나거나 제보받으면 추가해보겠습니다.\r\n\r\nWindows 컴퓨터에서도 한 번 해보고 올려보도록 하겠습니다.\r\n\r\n\r\n\r\n감사합니다!\r\n\r\n---\r\n\r\nCopyright: likelionSungGuk 조성국\r\n\r\n\r\n\r\n");

/***/ }),

/***/ "./contents/blog/jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md":
/*!***********************************************************************!*\
  !*** ./contents/blog/jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"jekyll Blog에 포스팅 하는법-이미지넣기\"\r\ndate: \"2020.12.17\"\r\ntags: \r\n   - blog\r\n   - jekyll\r\n   - jekyll\r\n   - theme\r\n   - NexT theme\r\n   - 지킬 테마\r\n   - 지킬 블로그 포스팅\r\n   - GitHub Pages\r\n---\r\n\r\n## Jekyll Blog Posting Basic\r\n\r\n![image-20201217202444028](/assets/img/image-20201217202444028.png)\r\n\r\nblog posting은 `_post` 폴더 안에 `markdown`문서를 작성하면 됩니다.\r\n\r\n대신 이 때 지켜야할 형식이 있습니다.\r\n\r\n바로 `markdown`문서의 최상단에 아래와 같은 `Yaml` 방식의 코드를 삽입해주는 것입니다.\r\n\r\n아래는 이번 포스팅의 예시를 그대로 사용하였습니다.\r\n\r\n```yaml\r\n---\r\nlayout: post\r\ntitle: jekyll Blog에 포스팅 하는법-이미지넣기\r\ndate: 2020-12-17 17:32:09\r\ncategories: \r\n- jekyll\r\n- blog\r\ntags: [blog, jekyll, blog, jekyll theme, NexT theme, 지킬 테마, 지킬 블로그 포스팅, GitHub Pages]\r\n---- \r\n```\r\n\r\n하나 하나 살펴보면\r\n\r\n1. 위 아래를 세 개의 대시(-)로 막고 그 안에 내용을 작성합니다.\r\n2. `layout`: 레이아웃은 이 글이 어떤 형식인지를 명시합니다. Next theme에서는 archive, post, page, category, tag,  등의 레이아웃이 있습니다. \r\n   이 중에서 포스팅은 `post`를 사용합니다.\r\n3. `title`은 이 포스팅의 제목을 나타냅니다. (추후 자동적으로 해당 markdown 파일 자체의 이름이 됩니다.)\r\n4. `categories`는 이 글의 카테고리를 나타내는 것으로 이 글이 어떻게 분류 되었으면 하는지 희망하는 대로 작성하면 됩니다. 예시의 모습처럼 대시(-) 이후 한 칸 띄고 엔터치는 방식으로도 작성이 가능하고 아래 tags와 같이 배열 형태로 두 가지 형식 모두 작성 가능합니다.\r\n5. `tags`는 이 글에 여러개의 tag를 달아 추후 tag별 구분이 가능하도록 하고 검색엔진에 잘 잡히도록 `SEO`를 도와주기도 합니다. \r\n\r\n\r\n\r\n이 외에도 permalink, date 형식 변경 등 다양한 내용이 있습니다.\r\n\r\n더 자세한 내용은 [**jekyll 공식 사이트**](https://jekyllrb.com/docs/front-matter/)에서 확인하시고 하나씩 테스트해보시면 됩니다.\r\n\r\n\r\n\r\n이후 아래 부분에 평범한 markdown 형식으로 글을 작성하면 됩니다. 이후 Git Push 해주시면 몇 분 후 글이 포스팅 됩니다.\r\n\r\n**만약 온라인에 어떻게 포스팅 될 지 미리 확인해 보고 싶으시다면,**\r\n\r\n1. ``_draft` 폴더를 따로 만들어 온라인 상에서 확인하는 방법\r\n2. `Atom` 에디터를 활용하여 markdown 작성과 동시에 Web에서 보여지는 화면을 보면서 작성\r\n3. `bundle exec jekyll serve`로 로컬 서버로 먼저 돌려서 확인하는 방법\r\n\r\n등 이 있습니다.\r\n\r\n\r\n\r\n## 생각보다 난관인 이미지 넣기\r\n\r\n### 문제상황\r\n\r\n하지만 예전과 같이 `markdown`을 작성하시면서 글 중간 중간 이미지를 업로드 하실 경우, 웹상에서는 이미지가 제대로 뜨지 않는 오류가 심심찮게 발생합니다.\r\n\r\n저의 경우 `Markdown`파일을 `Typora`라는 에디터를 활용해서 작성하는데, 이때 이미지가 자동으로 한 폴더에 모이도록 하는 설정을 활용합니다.\r\n\r\n때문에 `포스팅과 똑같은 이름.assets`라는 폴더가 하나 더 생기게 되고 이때 상대경로로 이미지를 자동으로 찾아오기 때문에 막상 로컬에서는 제대로 동작하는 것처럼 보입니다.\r\n\r\n![image-20201217204513035](/assets/img/image-20201217204513035.png)\r\n\r\n\r\n\r\n그러나, 웹에서 해당 포스팅의 URL이 변경되면서 이 상대경로가 제대로 지정되지 않아 이미지가 불러와지지 않는 오류가 발생합니다.\r\n\r\n![image-20201217204655892](/assets/img/image-20201217204655892.png)\r\n\r\n아래 이미지에서 보듯이 URL에 보시면 `{날짜}`/`{title}`의 형식으로 되어 있는 것을 알 수 있습니다.\r\n\r\n\r\n\r\n### 해결\r\n\r\n이 문제를 해결하는 방법은 생각보다 **간단**하지만, **귀찮은 작업**이 될 수 있습니다.\r\n\r\n해결방법은 `절대경로`를 이용하는 것입니다.\r\n\r\n다시 파일트리를 살펴보면, `assets`폴더가 있습니다.\r\n\r\n![image-20201217205015321](/assets/img/image-20201217205015321.png)\r\n\r\n저의 경우 포스팅에 사용하는 이미지들은 모두 `img`라는 폴더에 넣어두고 해당이미지의 `절대주소`를 마크다운에 링크해두었습니다.\r\n\r\n정리하면, \r\n\r\n1. assets에 img폴더를 만든다\r\n\r\n2. 포스팅에 쓰인 img들을 모두 `/assets/img` 안에 넣는다. (복사 또는 이동)\r\n\r\n3. 포스팅 내에 이미지들의 링크를 모두 다음과 같이 변경한다.\r\n\r\n   ```markdown\r\n   ![Foo](/assets/imge/Foo.jpg)\r\n   ![Bar](/assets/imge/Bar.png)\r\n   ```\r\n\r\n   \r\n\r\n이렇게 처리한 뒤 `git push`해보면 이미지까지 제대로 포스팅 된 것을 확인하실 수 있습니다 :smile:\r\n\r\n\r\n\r\n혹시 참고하셔도 포스팅에 어려움을 겪으신 경우 댓글에 문의해주세요.\r\n\r\n---\r\n\r\nCopyright: likelionSungGuk 조성국");

/***/ }),

/***/ "./contents/blog/jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md":
/*!********************************************************************!*\
  !*** ./contents/blog/jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"jekyll Next 테마 자세히 알아보기\"\r\ndate: \"2020.12.17\"\r\ntags: [\r\n  - blog\r\n  - jekyll\r\n  - jekyll theme\r\n  - NexT theme\r\n  - 지킬 테마\r\n  - GitHub Pages\r\n---\r\n\r\n## _config.yml\r\n\r\n대부분의 Jekyll의 환경설정은 `_config.yml`에서 합니다.\r\n\r\n이번 포스팅에서는 `_config.yml`을 자세히 알아봅시다.\r\n\r\n\r\n\r\n## Site\r\n\r\n> Site 기본 설정입니다. 아래 이미지를 통해 어떤 내용이 어디에 뜨는지 확인해보세요.\r\n\r\n```yaml\r\ntitle: Blog 대문\r\nsubtitle: 개발자 조성국의 블로그입니다.\r\ndescription: Python, django, algorithm, Computer science, IT 트렌드\r\nauthor: likelionSungGuk 조성국\r\nSupport language: en, ko\r\nlanguage: en\r\ndate_format: '%Y-%m-%d'\r\n```\r\n\r\n![화면](/assets/img/IMG_0284.jpg)\r\n\r\n\r\n\r\n## URl\r\n\r\n```yaml\r\nurl: \"https://likelionSungGuk.github.io\"\r\nbaseurl: \"\"\r\npermalink: pretty\r\n```\r\n\r\n\r\n\r\n## Pagination\r\n\r\n> pagination은 게시글이 N개 이상일 경우 N+1개부터는 다음 페이지에서 보여주도록 하는 내용입니다. \r\n> paginate 10인 경우 게시물 10개까지는 한 페이지에 나오고 그 다음부터는 \"NEXT\"버튼 누르면 다시 10개가 노출되는 형식입니다.\r\n\r\n```yaml\r\npaginate: 10\r\npaginate_path: \"/page:num/\"\r\narchive:\r\n  paginate: 10\r\n  paginate_path: \"/page:num/\"\r\ncategory:\r\n  paginate: 10\r\n  paginate_path: \"/page:num/\"\r\ntag:\r\n  paginate: 10\r\n  paginate_path: \"/page:num/\"\r\n```\r\n\r\n\r\n\r\n## favicon\r\n\r\n> favicon은 chrom 탭의 맨 앞에 나오는 조그마한 icon입니다.\r\n> assets 폴더에 favicon을 넣으시면 해당 icon으로 favicon을 설정 가능합니다.\r\n\r\n```yaml\r\n# Put your favicon.ico into `assets/` directory.\r\nfavicon: /assets/favicon_terminal.ico\r\n```\r\n\r\n\r\n\r\n## index_with_subtitle\r\n\r\n> Home 화면에서 subtitle까지 보여주는 지 여부에 대한 내용입니다.\r\n> true로 설정하면 subtitle까지 나옵니다.\r\n\r\n```yaml\r\n# If true, will add site-subtitle to index page, added in jekyll config.\r\n# subtitle: Subtitle\r\nindex_with_subtitle: true\r\n```\r\n\r\n\r\n\r\n## menu\r\n\r\n>어떤 메뉴들을 활용하지 선택합니다.\r\n>Home, Category, About, Archive, Tags 들을 활성화시켰으며 sitemap, commonweal의 경우 비활성화 하였습니다.\r\n\r\n```yaml\r\n# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -> archives)\r\nmenu:\r\n  home: /\r\n  categories: /categories/\r\n  about: about/\r\n  archives: /archives/\r\n  tags: /tags/\r\n  #sitemap: /sitemap.xml\r\n  #commonweal: /404.html\r\n```\r\n\r\n\r\n\r\n## menu icons\r\n\r\n>  menu를 표현하는 icon들입니다.\r\n> fontawesome 의  아이콘 이름들을 적어주면 해당 icon들로 변경됩니다.\r\n\r\n```yaml\r\nmenu_icons:\r\n  enable: auto\r\n  # KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome\r\n  home: home\r\n  about: user\r\n  categories: th\r\n  schedule: calendar\r\n  tags: tags\r\n  archives: archive\r\n  sitemap: sitemap\r\n  commonweal: heartbeat\r\n```\r\n\r\n```html\r\n<i class=\"fas fa-home\"></i>\r\n```\r\n\r\n[fontawesome](https://fontawesome.com/icons/)사이트에서 위와 같이 `fa-`뒤에 나오는 이름들을 `_config.yml`에 넣어주면 됩니다.\r\n\r\n\r\n\r\n## scheme settings\r\n\r\n> Next theme중에서도 크게 3가지 디자인 형식이 있습니다.\r\n\r\n```yaml\r\n# Schemes\r\nscheme: Muse\r\n#scheme: Mist\r\n#scheme: Pisces\r\n```\r\n\r\nMist, Pisces 형식의 블로그를 보고 싶으시다면 [Mist 예시](https://blog.zzbd.org/) / [Pisces 예시](https://dandyxu.me/)를 통해 Demo를 확인해주세요.\r\n\r\n([Muse 형식의 ㅎㄷㄷ한 Custom CSS 적용 사례](https://acris.me/))\r\n\r\n\r\n\r\n## fonts\r\n\r\n>각 영역별로 font를 내가 원하는 것으로 변경할 수 있습니다.\r\n\r\n```yaml\r\n# ---------------------------------------------------------------\r\n# Font Settings\r\n# - Find fonts on Google Fonts (https://www.google.com/fonts)\r\n# - All fonts set here will have the following styles:\r\n#     light, light italic, normal, normal italic, bold, bold italic\r\n# - Be aware that setting too much fonts will cause site running slowly\r\n# - Introduce in 5.0.1\r\n# ---------------------------------------------------------------\r\nfont:\r\n  enable: true\r\n\r\n  # Uri of fonts host. E.g. //fonts.googleapis.com (Default)\r\n  host: {웹 폰트 주소 넣는 곳: 예) fonts.googleapis.com} \r\n\r\n  # Global font settings used on <body> element.\r\n  # Blog 전체의 글꼴 지정 (현 Lato)\r\n  global:\r\n    # external: true will load this font family from host.\r\n    external: true\r\n    family: Lato\r\n\r\n  # Font settings for Headlines (h1, h2, h3, h4, h5, h6)\r\n  # Fallback to `global` font settings.\r\n  # h1, h2, h3, h4, h5, h6태그만 font바꾸고 싶다면 설정\r\n  headings:\r\n    external: true\r\n    family:\r\n\r\n  # Font settings for posts\r\n  # Fallback to `global` font settings.\r\n  # posting 파트 font설정\r\n  posts:\r\n    external: true\r\n    family:\r\n\r\n  # Font settings for Logo\r\n  # Fallback to `global` font settings.\r\n  # The `size` option use `px` as unit\r\n  logo:\r\n    external: true\r\n    family:\r\n    size:\r\n\r\n  # Font settings for <code> and code blocks.\r\n  codes:\r\n    external: true\r\n    family:\r\n    size:\r\n```\r\n\r\n\r\n\r\n## search\r\n\r\n> 검색기능을 원하시는 경우 enable: true로 설정해주세요\r\n> trigger: manual의 경우 사용자가 search 아이콘을 클릭했을 때에만 나타나는 설정입니다.\r\n\r\n```yaml\r\n# Local search\r\nlocal_search:\r\n  enable: true\r\n  # if auto, trigger search by changing input\r\n  # if manual, trigger search by pressing enter key or search button\r\n  trigger: manual\r\n  # show top n results per article, show all results by setting to -1\r\n  top_n_per_article: 1\r\n```\r\n\r\n\r\n\r\n이 외에 더 다양한 설정들이 있지만 대부분 중국 관련 Social 링크들이거나 불필요하다고 생각하여 스킵하였습니다.\r\n\r\n추가로 궁금한 점이 있으시면 댓글 남겨주세요.\r\n\r\n---\r\n\r\nCopyright: likelionSungGuk 조성국");

/***/ }),

/***/ "./contents/blog/jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md":
/*!************************************************************************!*\
  !*** ./contents/blog/jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Jekyll 블로그 조회수 뱃지 달기 - HITS\"\r\ndate: \"2021.01.05\"\r\ntags: \r\n  - jekyll\r\n  - blog\r\n  - github pages\r\n  - 깃헙페이지\r\n  - 지킬 블로그\r\n  - hits\r\n---\r\n\r\n# 방문자에게 게시글 조회수 보여주는법\r\n\r\nJekyll과 같은 정적 블로그는 간편한 것이 장점입니다. 하지만 DB가 없기 때문에 누적 방문자 수를 체크하기가 어렵다는 단점이 있습니다.\r\n\r\n이것을 해결하기 위해서는 써드파티 앱인 **[HITS](https://github.com/dwyl/hits)**를 사용하면 간단하게 해결가능합니다.\r\n\r\n **[HITS](https://github.com/dwyl/hits)**는 github repository에 방문하는 사람들을 세기 위한 프로젝트로 만들어졌다고 합니다. 아래 이미지에 표시된 부분은 **[HITS](https://github.com/dwyl/hits)**의 github repository의 `README.md`의 모습입니다.\r\n\r\n![image-20210105103446971](/assets/img/image-20210105103446971.png)\r\n\r\n\r\n\r\n#### *! 주의 ! 현재 Hits가 디스크 메모리 문제로 정상적으로 작동하고 있지 않아 잠시 사용을 보류해두었습니다.* \r\n\r\n## jekyll blog에서 Hits 사용하기\r\n\r\nHits를  사용하기 위해서는 적절한 위치에 아래와 같은 코드를 삽입해야 합니다.\r\n\r\n```html\r\n<div style=\"text-align: center;\">\r\n    <a\r\n       href=\"http://hits.dwyl.com/{{ site.url | remove_first: 'https://' | remove_first: 'http://' }}{{ page.url }}\"\r\n       target=\"_blank\"\r\n     >\r\n     <img\r\n       src=\"http://hits.dwyl.com/{{ site.url | remove_first: 'https://' | remove_first: 'http://' }}{{ page.url }}.svg\"\r\n     />\r\n    </a>\r\n</div>\r\n```\r\n\r\n저는 제목과 본문이 시작하는 사이에 삽입해보았습니다. 적절한 위치를 찾기 위해 `크롬 개발자도구`를 활용해서 찾아보시면 됩니다.\r\n\r\n근데 그 위치를 내 blog코드 내에서 찾는 것이 생각보다 복잡합니다. 아래 이미지를 보시면서 파일 트리를 찾으시면 좋습니다.\r\n\r\n> '_includes' > '_macro' > 'post.html'\r\n\r\n![image-20210105102831674](/assets/img/image-20210105102831674.png)\r\n\r\n해당 위치에 삽입하면 아래 이미지와 같이 조회수가 표시됩니다.\r\n\r\n![11](/assets/img/11.png)\r\n\r\n---\r\n\r\nreferences\r\n\r\n[Hits 생성기](http://hits.dwyl.io/)\r\n\r\n[Hits Github repository](https://github.com/dwyl/hits)\r\n\r\n[HITS!를 이용하여 Jekyll 블로그에 조회수 배지 달기](https://ryanking13.github.io/2020/03/09/jekyll-views-count-badge.html)");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md":
/*!************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Javascript 자주쓰는 내장 함수 복습하기\"\r\ndate: \"2021.03.31\"\r\ntags: \r\n  - javascript\r\n  - js\r\n  - vanillaJS\r\n  - es6\r\n---\r\n\r\n\r\n\r\n# 자주쓰는 JS 내장함수 :map, find, findIndex, filter, indexOf, splice, slice, shift & pop, join, reduce\r\n\r\n## 1. map\r\n\r\nmap은 배열 안의 각 원소를 변환 할 때 사용 되며, 이 과정에서 새로운 배열이 만들어집니다. 배열.map()\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconst square = n => n**2\r\nconst squared = array.map(square)\r\nconsole.log(squared)\r\n\r\n// [1,  4,  9, 16, 25, 36, 49, 64]\r\n```\r\n\r\n- map안에 들어가는 square같은 함수를 `변화함수`라고 한다.\r\n- 변화함수를 쓰지 않고 바로 해도 된다\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconst squared = array.map(n => n**2)\r\nconsole.log(squared)\r\n// 결과는 같다. [1,  4,  9, 16, 25, 36, 49, 64]\r\n```\r\n\r\n## 2. indexOf\r\n\r\nindexOf 는 원하는 항목이 배열 내 몇번째 원소인지 찾아주는 함수입니다.\r\n\r\n```jsx\r\nconst superheroes = ['아이언맨', '캡틴 아메리카', '토르', '닥터 스트레인지']\r\nconst index = superheroes.indexOf('토르')\r\nconsole.log(index)\r\n// 2\r\n```\r\n\r\n## 3. findIndex - 찾아낸 값의 index를 반환\r\n\r\n배열 안에 있는 값이 객체이거나, 배열이라면 indexOf 로 찾을 수 없습니다. 이럴 때 findIndex를 사용합니다.\r\n\r\n```jsx\r\n// todos에서 id가 3인 객체가 몇 번째 인지 찾기\r\n\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst index = todos.findIndex(todo => todo.id === 3);\r\nconsole.log(index);\r\n\r\n// 2\r\n```\r\n\r\n## 4. find - 찾아낸 값 자체를 반환\r\n\r\n```jsx\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst todo = todos.find(todo => todo.id === 3);\r\nconsole.log(todo);\r\n\r\n// {id: 3, text: \"객체와 배열 배우기\", done: true}\r\n```\r\n\r\n## 5. filter\r\n\r\n특정 조건을 만족하는 값들만 따로 추출하여 새로운 배열을 만듭니다.\r\n\r\n```jsx\r\nconst todos = [\r\n  {\r\n    id: 1,\r\n    text: '자바스크립트 입문',\r\n    done: true\r\n  },\r\n  {\r\n    id: 2,\r\n    text: '함수 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 3,\r\n    text: '객체와 배열 배우기',\r\n    done: true\r\n  },\r\n  {\r\n    id: 4,\r\n    text: '배열 내장함수 배우기',\r\n    done: false\r\n  }\r\n];\r\n\r\nconst tasksNotDone = todos.filter(todo => todo.done === false);\r\nconsole.log(tasksNotDone);\r\n/* \r\ntodo.done이 false인 {id: 4, text: '배열 내장함수 배우기', done: false} \r\n객체만 새로운 배열(taskNotDone) 안에 들어간다.\r\n[ { id: 4, text: '배열 내장함수 배우기', done: false } ]\r\n\r\n*/\r\n\r\n//  이렇게 표현할 수도 있다.\r\nconst tasksNotDone = todos.filter(todo => !todo.done);\r\n```\r\n\r\n## 6. splice\r\n\r\n배열에서 특정 항목을 제거할 때 사용된다. 인덱스 값으로 지우는 것이기 때문에 인덱스를 먼저 구하고 해당 인덱스로부터 몇 개나 지울 것인지 선택하여 여러값을 한 번에 지울 수 있다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst index = numbers.indexOf(30);\r\nnumbers.splice(index, 1);\r\nconsole.log(numbers);\r\n\r\n// 30의 index = 2이고 2번째 인덱스로부터 한 개의 값을 지우므로 30만 지워진다.\r\n// [10, 20, 40]\r\n```\r\n\r\n## 7. slice\r\n\r\n기존 배열에 변화를 일으키지 않고 슬라이싱 하여 새로운 배열을 생성한다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst sliced = numbers.slice(0, 2); // 0부터 시작해서 2전까지\r\n\r\nconsole.log(sliced); // [10, 20]\r\nconsole.log(numbers); // [10, 20, 30, 40]\r\n```\r\n\r\n## 8. shift & pop\r\n\r\nshift는 배열의 첫 번째 값을 뽑아내고, pop은 맨 뒤의 값을 뽑아낸다. python과 비교하면 shift = pop(0), pop은 똑같다.\r\n\r\n```jsx\r\nconst numbers = [10, 20, 30, 40];\r\nconst value = numbers.shift();\r\nconsole.log(value); // 10\r\nconst value2 = numbers.pop();\r\nconsole.log(value2); // 40\r\nconsole.log(numbers); //[20, 30]\r\n```\r\n\r\n## 9. join\r\n\r\n배열 안의 값들을 문자열 형태로 합쳐줍니다.\r\n\r\n```jsx\r\nconst array = [1, 2, 3, 4, 5];\r\nconsole.log(array.join()); // 1,2,3,4,5\r\nconsole.log(array.join(' ')); // 1 2 3 4 5\r\nconsole.log(array.join(', ')); // 1, 2, 3, 4, 5\r\n```\r\n\r\n## 10. reduce\r\n\r\n배열의 각 요소에 대해 주어진 리듀서(reducer) 함수를 실행하고, 하나의 결과값을 반환합니다. 앞의 문장만 읽어서는 이해하기 어려운데, 내가 지정해준 함수를 실행 후 나온 결과값을 다시 파라미터로 사용하도록 합니다. 아래 예를 통해 이해해봅시다.\r\n\r\n```jsx\r\n// 기존 방식\r\nconst numbers = [1, 2, 3, 4, 5];\r\n\r\nlet sum = 0;\r\nnumbers.forEach(n => {\r\n  sum += n;\r\n});\r\nconsole.log(sum);  //15\r\n\r\n//reduce를 사용하는 방식\r\nconst numbers = [1, 2, 3, 4, 5];\r\nlet sum = array.reduce((accumulator, current) => accumulator + current, 0);\r\n\r\nconsole.log(sum);  //15\r\nconst numbers = [1, 2, 3, 4, 5];\r\nlet sum = numbers.reduce((accumulator, current) => {\r\n  console.log({ accumulator, current });\r\n  return accumulator + current;\r\n}, 0);\r\n\r\nconsole.log(sum);\r\n\r\n// 결과\r\n{ accumulator: 0, current: 1 }\r\n{ accumulator: 1, current: 2 }\r\n{ accumulator: 3, current: 3 }\r\n{ accumulator: 6, current: 4 }\r\n{ accumulator: 10, current: 5 }\r\n15\r\n```\r\n\r\n\r\n\r\n---\r\n\r\n**references**\r\n\r\n[LearnJS GitBook](https://learnjs.vlpt.us/basics/09-array-functions.html)");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md":
/*!***********************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"ES2021 최신 자바스크립트 새롭게 추가된 기능 살펴보기\"\r\ndate: \"2021.08.03\"\r\ntags: \r\n    - javascript\r\n    - 자바스크립트\r\n---\r\n\r\n# ES2021 최신 자바스크립트 새롭게 추가된 기능을 알아보자\r\n\r\n## replaceAll\r\n\r\nString을 변경해주는 replace의 upgrade 버전이다. \r\n\r\n'그냥 replace쓰면 되는거 아니야?'라고 생각할 수 있지만 특수문자가 들어간 경우 정규표현식을 써야해서 다소 복잡해지는 경우가 많은데, replaceAll이 있으면 훨씬 간편하다. 비교해서 보자.\r\n\r\n\r\n\r\n> Mike와 Car앞뒤로 있는 대괄호를 중괄호로 바꿔보자.\r\n\r\n```javascript\r\n// replace\r\nconst str1 = \"I'm [Mike]. This is Tom's [Car]\";\r\nstr1.replace(/\\[/g, \"~\").replace(/\\]/g, \"~\");\r\n```\r\n\r\n이렇게 정규표현식을 써서 대괄호의 각각'[' , ']'을 설정하고 'g'로 모든 해당 기호를 선택한 뒤 변경해줘야한다.\r\n\r\n```javascript\r\n// replaceAll\r\nconst str2 = \"I'm [Mike]. This is Tom's [Car]\";\r\nstr2.replaceAll(\"[\", \"~\").replaceAll(\"]\", \"~\")\r\n```\r\n\r\n정규표현식을 쓸 필요없이 직관적으로 쉽게 사용이 가능하다.\r\n\r\n\r\n\r\n## Promise.any\r\n\r\npromise.race의 경우 가장 빠르게 처리되는 객체를 반환합니다.\r\n\r\n예를 들어 두 개의 Promise요청이 있을 경우, Reject된 요청이 더 빠르게 도착한다면 promise.race는 'Reject'를 반환 할 것입니다.\r\n\r\n하지만 우리는 여러개의 요청 중 하나만이라도 성공하는게 있는지 알고 싶을 때가 있습니다. 이 경우 새로 생긴 `Promise.any`를 사용할 수 있습니다.\r\n\r\n```javascript\r\n// 1. \r\nconst Fail = new Promise((res, reject) => {\r\n    setTimeOut(()=> {\r\n        reject(\"fail..\")\r\n    }, 1000)\r\n})\r\nconst Success = new Promise((res, reject) => {\r\n    setTimeOut(()=> {\r\n        res(\"success!\")\r\n    }, 2000)\r\n})\r\n\r\nconst promiseRace = Promise.race([Fail, Success])\r\n// log -> fail..\r\nconst promiseAny = Promise.any([Fail, Success])\r\n// log -> sucess!\r\n```\r\n\r\n\r\n\r\n## ||= , &&= , ??=\r\n\r\n정식명칭은 `Logical Assignment Operator` 입니다. \r\n\r\n```javascript\r\n// 1. ||=\r\n    name = name || 'anonymous'\r\n위 코드는 다음과 같이 쓰일 수 있습니다.\r\n    name ||= 'anonymous'\r\n\r\n// 2. &&=\r\n    name = name && `Hello ${name}`\r\n\t\t\t===\r\n    name &&= `Hello ${name}`;\r\n\r\n// 3. ??= (Null병합연산자)\r\n\tname = name ?? \"Mike\";\r\n\tname ??= \"Mike\"\r\n```\r\n\r\n- Null 병합 연산자와 OR의 차이는 다음과 같다.\r\n\r\n  - `**||**` : 앞의 값이 falsy이면 뒤의 값\r\n  - `**??**` : 앞의 값이 null이나 undefined 이면 뒤의 값 \r\n\r\n  ```javascript\r\n  let num = 0\r\n  let a = num || 3\r\n  // a는?\r\n  // -> a = 3\r\n  \r\n  let b = num ?? 3\r\n  // b는? \r\n  // -> b = 0\r\n  null이나 undefined가 아니므로 num(0)이 b가 된다.\r\n  ```\r\n\r\n  \r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md":
/*!************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"자바스크립트 프로와 나의 차이는...?\"\r\ndate: \"2021.08.05\"\r\ntags: \r\n    - javascript\r\n    - 자바스크립트\r\n---\r\n\r\n\r\n# 자바스크립트를 프로처럼 세련되게 쓰는 법\r\n유튜브 드림코딩 엘리 영상을 보다 좋은 내용이 있어 정리하여 공유합니다.\r\n\r\n[TOC]\r\n\r\n\r\n## 조건문에서 조건이 두 개라면 과감하게 삼항연산자 사용\r\n\r\n```javascript\r\n// not good...\r\nfunction (score) {\r\n\tif (score > 5) {\r\n        result = 'thumbup'\r\n    } else if {\r\n        result = 'thumbdown'\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n// Better !!\r\nfunction (score) {\r\n\treturn score > 5 ? 'thumbup': 'thumbdown';\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## Nullish Coalescing operator를 사용해보자\r\n\r\n```javascript\r\n// not good...\r\nfunction printMessage(text) {\r\n    let message = text;\r\n    if (text == null || text == undefined) {\r\n        message = 'Nothing to display';\r\n    }\r\n    console.log(message);\r\n}\r\n\r\n\r\n// Better !\r\nfunction printMessage(text) {\r\n    const message = text ?? 'Nothing to Display';\r\n    console.log(message);\r\n}\r\n\r\n```\r\n\r\n- 위 코드와 아래 코드는 동일하게 동작한다.\r\n- text가 null or undefined이면 'Nothing to Display'를 할당하는 코드인데, 위 코드는 message를 일단 받고, null/undefined check 후 message에 할당한다.\r\n- 하지만 아래 코드 같은 경우 text를 바로 체크하여 message에 선언과 할당이 동시에 가능하기 때문에 message를 const로 선언할 수 있고 가독성도 좋다.\r\n\r\n\r\n\r\n### Logical Operator OR<||>와 Nullish Coalescing Operator의 차이\r\n\r\n**OR**\r\n\r\n- Left: falsy 하면 오른쪽이 true\r\n\r\n**Nullish Coalescing (??)**\r\n\r\n- Left: null, undefiend 이면 오른쪽이 true\r\n\r\n\r\n\r\nnull & undefined는 모두 falsy에 포함된다. 이외에도 0, -0, NaN, 빈문자열('') 등도 모두 falsy에 포함된다. 다시 말해 falsy가 좀 더 광범위한 범위를 포괄한다.\r\n\r\n**따라서 두 연산자가 비슷해보이지만 조금 다른 결과를 초래할 수 있으므로 차이를 정확하게 이해하고 사용하는 것이 중요하다!**\r\n\r\n\r\n\r\n## Object Destructuring으로 변수 할당/선언하기\r\n\r\n```javascript\r\n// Not good...\r\nfunction displayPerson(person) {\r\n    const name = person.name;\r\n    const age = person.age;\r\n    displayAvatar(name);\r\n    displayName(name);\r\n    displayProfile(name, age);\r\n}\r\n\r\n// Better !!\r\nfunction displayPerson(person) {\r\n    const { name, age } = person;\r\n    displayAvatar(name);\r\n    displayName(name);\r\n    displayProfile(name, age);\r\n}\r\n```\r\n\r\n\r\n\r\n## Object 결합은 Object.assign 혹은 Spread Syntax를 사용하자\r\n\r\n```javascript\r\n// Not Good...\r\nconst item = {\r\n    ...\r\n}\r\nconst detail = {\r\n\t...    \r\n}\r\n\r\nconst newObject = {\r\n    type: item.type,\r\n    size: item.size,\r\n    price: detail.price,\r\n    made: detail.made,\r\n    gender: detail.gender\r\n}\r\n\r\n\r\n// Better !!\r\n // 1. Object.assign\r\nconst newObj = Object.assign(item, detail);\r\n\r\n // 2. Spread Syntax\r\nconst newObj2 = {...item, ...detail};\r\n```\r\n\r\n\r\n\r\n## Optional Chaining\r\n\r\n```javascript\r\n// Not good...\r\nfunction displayJobTitle(person) {\r\n    if (person.job && person.job.title) {\r\n        console.log(person.job.title);\r\n    }\r\n}\r\n\r\n// Better !!\r\nfunction displayJobTitle(person) {\r\n \tif (person.job?.title){\r\n        console.log(person.job.title)\r\n\t}   \r\n}\r\n\r\n// Optional Chaining + Nullish Coalescing\r\nfunction displayJobTitle(person) {\r\n \tconst title = person.job?.title ?? 'No Job yet'\r\n\tconsole.log(title)\r\n}\r\n```\r\n\r\n- 이 내용은 오늘 낮에도 내가 Not Good으로 코드를 짰던 내용이었어서 더욱 공감하며 들었던 내용입니다.\r\n- person에 job이 있을 수도 있고, 없을 수도 있는 경우 일단 person.job을 먼저 체킹하고 person.job.title을 체킹하는 코드입니다. 이게 일반적으로 정말 많이 사용됩니다. 특히 typescript와 함께 쓰이면 job이나 job.title이 null or undefined 될 수 있어서 이 내용에 타입을 미리 설정해주는 것이 생각보다 고역입니다.\r\n- ?를 통해서 person.job이 있는지 없는지를 동시에 처리할 수 있게 됩니다.\r\n\r\n- 가장 아래에는 optional chaining과 Nullsih Coalescing을 한 번에 사용하는 경우입니다. person.job이 있는지 체크하고 person.job.title이 있는지까지 한 번에 체크해서 없는 경우에 'No job yet'을 출력할 수 있습니다.\r\n\r\n\r\n\r\n## Array 관련 연산은 map, filter, reduce를 적극 활용하자!\r\n\r\nJavascript의 배열 methods (map, filter, reduce)들은 정말 강력합니다. \r\n\r\n전통적인 for loop보다는 이 친구들을 적극적으로 활용하면 언어의 특징을 잘 이해하고 사용하는 프로다운 면모를 보여줄 수 있습니다.\r\n\r\n```javascript\r\n// Not good...\r\nconst arr = [1,2,3,4,5]\r\n\t// 짝수 구하기\r\nconst even = [];\r\nfor (let i = 0 ; i <items.length; i++) {\r\n    if (items[i] % 2 === 0) {\r\n        even.push(items[i]);\r\n    }\r\n}\r\n\r\n// Better !!\r\nconst even = arr.filter(item => item % 2 == 0)\r\n\r\n```\r\n\r\n- 코딩테스트를 주로 python을 기반으로 준비했었는데 프론트엔드 개발자로 취업을 하다보면 Javascript 단일 언어로 코테를 많이 제공합니다. 이때 초반에는 저도 위와 같은 코드를 자연스럽게 썼었는데.... 하.... 이제와서 돌이켜 생각해보니까 이게 문제가 풀린다고 해도 제가 면접관이라면 위와 같이 javascript를 쓰는 개발자와 같이 일하는게 꺼려질 것 같다는 생각이 드네요 ㅎㅎ\r\n\r\n\r\n\r\n---\r\n\r\nRef.\r\n\r\n[드림코딩엘리](https://www.youtube.com/watch?v=BUAhpB3FmS4&t=2s)\r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md":
/*!******************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"자바스크립트 변수-var, let, const 꼭 알아야할 차이점\"\r\ndate: \"2021.08.09\"\r\ntags: \r\n  - Javascript\r\n  - let\r\n  - var\r\n  - const\r\n  - 변수\r\n---\r\n\r\n# 자바스크립트 변수 var, let, const 비교\r\n\r\n유튜브 `코딩앙마 채널`의 자바스크립트 중급 1편 var, let, const를 보다가 좋은 내용이 있어 정리합니다.\r\n\r\n\r\n\r\n## 호이스팅 \r\n\r\n선언하기 전에 호출된 var변수가 오류가 나지 않는다는 것을 거의 모든 프론트엔드 개발자라면 알고 있을 것입니다. 그 이유는 바로 hoisting 때문인데, ES6 이후 나온 let이나 const 로 변수를 선언하는 것은 var와 달리 이것이 되지 않는다. 그렇다면 let은 호이스팅 되지 않는 것일까?라는 의문이 들었습니다.\r\n\r\n\r\n\r\n### 💡 let도 hoisting된다.\r\n\r\n<u>결론부터 말하자면 let도 호이스팅 됩니다</u>. 하지만 var처럼 동작하지 않는 이유는 `변수의 생성단계 3가지 ` **\"선언\"-\"초기화\"-\"할당\"** 의 진행과정이 다르기 때문이다.\r\n\r\n| var                 | let       | const                         |\r\n| ------------------- | --------- | ----------------------------- |\r\n| 1. 선언 + 2. 초기화 | 1. 선언   | 1. 선언 + 2. 초기화 + 3. 할당 |\r\n| -                   | 2. 초기화 |                               |\r\n| 3. 할당             | 3. 할당   |                               |\r\n\r\n위 표에서 보듯이 **세 가지 변수설정 타입은 모두 다른 과정을 통해 변수를 생성**합니다.\r\n\r\n```javascript\r\n// 1. var\r\nconsole.log(name) // undefined\r\nvar name=\"홍길동\"\r\n\r\n// 2. let \r\nconsole.log(name) // Error: 레퍼런스 에러\r\nlet name=\"홍길동\"\r\n\r\n// 3. const\r\nconsole.log(name) // Error\r\nconst name=\"홍길동\"\r\n\r\n// 4. const 추가\r\nconst name;\r\nname=\"홍길동\"\r\n```\r\n\r\n- var의 경우 아직 할당되지 않은 name을 먼저 호출하더라도 호이스팅된 변수명 name은 이미 알고 있으며 다만 해당 값은 undefined상태이다. 따라서 에러가 나지 않는다.\r\n\r\n- let의 경우 호이스팅은 되므로 name변수를 아예 모르는 것은 아니나, 초기화(name에 undefined)가 되지않았으므로 name에 해당하는 레퍼런스가 없어 레퍼런스 에러가 난다.\r\n- const의 경우 선언/초기화/할당 세 가지가 모두 한 번에 이뤄져야 하는데 그렇지 않았으므로 에러가 발생한다.\r\n- const의 경우 선언과 동시에 할당까지 이뤄져야 한다. 따라서 4번처럼 생성만 해두고 나중에 할당하면 오류가 발생한다.\r\n\r\n\r\n\r\n## 스코프\r\n\r\n| var                                                          | let, const                                             |\r\n| ------------------------------------------------------------ | ------------------------------------------------------ |\r\n| 함수 스코프                                                  | 블록 스코프                                            |\r\n| function() 단위                                              | if, while, for, try/catch문 등                         |\r\n| -> if문이나 while문 등 블록스코프 내에서 선언되어도 함수단위에서 호출이 가능함. <br />단, 함수단위를 넘어서는 곳에서의 호출은 안된다. | if문이나 while문등 선언된 블록 내에서만 호출이 가능함. |\r\n\r\n\r\n\r\n\r\n---\r\nRef.\r\n\r\n[유튜브 코딩앙마 채널](https://www.youtube.com/watch?v=ocGc-AmWSnQ&list=PLZKTXPmaJk8JZ2NAC538UzhY_UNqMdZB4)\r\n\r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md":
/*!**************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"자바스크립트 비동기의 꽃 async await 초스피드로 핵심만 체크\"\r\ndate: \"2021.08.17\"\r\ntags: \r\n    - javascript\r\n    - async\r\n    - 비동기\r\n---\r\n\r\n# 자바스크립트 비동기의 꽃 async await 초스피드로 알아보기\r\n\r\n## :bulb: 핵심 체크 문답\r\n\r\n### :one: asnyc await란? \r\n\r\n 자바스크립트 비동기 함수의 가독성을 높여주는 문법\r\n\r\n\r\n\r\n### :two: async await의 장점은?\r\n\r\nPromise 보다 **<u>간결</u>**하고 **<u>직관적</u>**이며 **<u>높은 가독성을 보여주는 장점</u>**이 있다.\r\n\r\n\r\n\r\n### :three: Promise를 대체하는가?\r\n\r\n**:no_good: NO!**   ***promise를 완전히 대체하지는 못한다***.\r\n\r\npromise는 값으로 존재하여 더 다양한 범위에서 활용되는 반면, **<u>async await은 함수를 정의할 때에만 사용된다</u>**는 점에서 활용 범위가 promise보다는 작다.\r\n\r\nasync 함수의 반환값은 항상 `Promise`객체이다. 이 Promise객체는 **<u>상태와 반환값</u>**이 포함되어있다.\r\n\r\n\r\n\r\n## :bulb: async await 병렬처리\r\n\r\n```javascript\r\nfunction asyncFunc1() {\r\n    return new Promise(resolve => {\r\n        console.log('처리중 1');\r\n        setTimeout(() => {\r\n            resolve(10);\r\n        }, 1000)\r\n    })\r\n}\r\nfunction asyncFunc2() {\r\n    return new Promise(resolve => {\r\n        console.log('처리중 2');\r\n        setTimeout(() => {\r\n            resolve(20);\r\n        }, 1000)\r\n    })\r\n}\r\n\r\n// 병렬처리 (O)\r\nasync function getData() {\r\n    const p1 = asuncFunc1();\r\n    const p2 = asyncFunc2();\r\n    const data1 = await p1;\r\n    const data2 = await p2;\r\n    console.log({data1, data2});\r\n} // 1초 후에 LOG: '처리중 1', '처리중 2'\r\n\r\n// 병렬처리 (X)\r\nasync function getData() {\r\n    const data1 = await asuncFunc1();\r\n    const data2 = await asyncFunc2();\r\n    console.log({data1, data2});\r\n} // 1초 후에 LOG:: '처리중 1', 2초 후에 LOG:: '처리중 2'\r\n```\r\n\r\n- 병렬처리를 진행한 예를 보면 1초에 data1과 data2의 로그를 모두 볼 수 있다.\r\n- 하지만 병렬처리를 진행하지 않은 예시처럼 코드를 작성하면 1초를 써서 data1을 받아오고 그 다음 또 다시 1초를 data2에 사용하기 때문에 총 2초가 걸리는 비효율이 발생한다.\r\n\r\n---\r\n\r\nRef.\r\n\r\n실전 자바스크립트 - 이재승");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md":
/*!**************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"자바스크립트의 새로운 함수 Generator를 알아보자\"\r\ndate: \"2021.08.26\"\r\ntags: \r\n    - javascript\r\n    - generator\r\n    - ES6\r\n---\r\n\r\n# 자바스크립트의 새로운 함수 Generator를 알아보자\r\n## Generator는?\r\n\r\n순차적으로 진행하는 자바스크립트의 특별한 함수.\r\n\r\n\r\n\r\n## 사용법\r\n\r\n### 1. 선언\r\n\r\nfunction을 선언할 때 에 `*` 을 추가한다.\r\n\r\n```javascript\r\n// Recommend\r\nfunction* example() {}\r\n\r\n// Not Recommend\r\nfunction *example() {}\r\n```\r\n\r\n- function과 함수 이름중에서 function에 `*`을 붙여주는 것을 추천한다.\r\n\r\n\r\n\r\n### 2. yeild와 next() 메소드\r\n\r\n제너레이터는 yield를 순차적으로 실행하는데, 이를 실행하기 위해서는 next() 메소드를 활용해야 다음 yield로 넘어갈 수 있다.\r\n\r\n```javascript\r\nfunction* f1() {\r\n    console.log('f1-1');\r\n    yield 10;\r\n    console.log('f1-2');\r\n    yield 20;\r\n    console.log('f1-3');\r\n    return 'finished'\r\n}\r\n\r\nconst gen = f1();\t\t//(1)\r\nconsole.log(gen.next());//(2)\r\nconsole.log(gen.next());//(3)\r\nconsole.log(gen.next());//(4)\r\n```\r\n\r\n- (1)까지는 아무것도 출력되지 않는다.\r\n- (2)가 실행되면 로그에 f1-1이 출력되고 {value: 10, done: false}가 반환된다. next의 반환값은 항상 value와 done이 포함된 객체로 넘어온다. done은 이 제너레이터 함수가 모두 실행되면 true가 된다.\r\n- (3)이 실행되면 로그에 f1-2이 출력되고 {value: 20, done: false}가 반환된다.\r\n- (3)이 실행되면 로그에 f1-3이 출력되고 {value: 'finished', done: true}가 반환된다.\r\n\r\n\r\n\r\n:heavy_exclamation_mark: **만약 return 다음에 yield가 더 있다하더라도 return이 된 순간 더 이상 next() 메소드는 동작하지 않고 이후 yield는 모두} {value: undefined, done: true} 만이 반환된다.**\r\n\r\n\r\n\r\n## 3. Generator를 쓰는 이유, 장점\r\n\r\n### :bulb: Generator는 실행되는 딱 그 순간에만 연산을 실행한다. 따라서 무의미한 반복이 필요하지 않다.\r\n\r\n>  마치 배열에서 순회하는 것과 같이 작동하는데, 배열의 경우 처음 생성할 때부터 모든 값이 정해져있기 때문에 메모리 사용량이 많다. 하지만 제너레이터는 만들어지는 그 때 메모리에 저장되기 때문에 <u>메모리 활용성 측면에서 큰 장점</u>이 있다.\r\n\r\n- 예) 배열의 끝까지 다 순회하지 않고 필요한 곳까지만 순회하는 사례\r\n\r\n  ```javascript\r\n  const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n  const result = take(3,\r\n  map(filter(values, n=> n % 2 === 0),\r\n      n => n* 10\r\n  \t)\r\n  )\r\n  ```\r\n\r\n- 위의 예시는 과연 어떤 값을 반환할까?\r\n\r\n- log를 찍어보면 [20, 40, 60]이 반환될 것이다.\r\n\r\n- 짝수를 순회하다가 `take(3)`를 보고 3번째에서 딱 멈추는 것이다. Generator의 효율성이 돋보인다.\r\n\r\n\r\n\r\n### :bulb: 메모리 사용이 효율적으로 사용할 수 있다.\r\n\r\n- 예) map, filter함수 등을 반환하는 배열 없이 만들어서 쓸 수 있다.\r\n\r\n  ```javascript\r\n  function* map(iter, mapper) {\r\n      for (const v of iter) {\r\n          yield mapper(v);\r\n      }\r\n  }\r\n  \r\n  function* filter(iter, test) {\r\n      for (const v of iter) {\r\n          if (test(v)) {\r\n              yield v;\r\n          }\r\n      }\r\n  }\r\n  \r\n  ```\r\n\r\n- 위와 같이 map, filter함수를 제너레이터로 만들어서 사용하면 기존 내장함수보다 메모리를 더 효율적으로 사용할 수 있다.\r\n\r\n\r\n\r\n---\r\n\r\nRef.\r\n\r\n실전 자바스크립트 - 이재승\r\n\r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md":
/*!********************************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"자바스크립트 iterable과 iterator에 대해 알아보자\"\r\ndate: \"2021.08.30\"\r\ntags: \r\n    - javascript\r\n    - iterable\r\n    - iterator\r\n    - ES6\r\n---\r\n\r\n# 자바스크립트 iterable과 iterator에 대해 알아보자 \r\n## 이터러블 (iterable)이란?\r\n\r\n> 반복 가능한 객체 (ES2015에 추가된 문법)\r\n\r\n객체의 `Symbol.iterator` 속성에 특정 형태의 함수가 들어있다면, 이를 ***반복 가능한 객체(iterable object)*** 혹은 줄여서 **iterable**이라 부르고, <u>해당 객체는 iterable protocol을 만족한다</u>고 말합니다.\r\n\r\n\r\n\r\n### 이터러블의 조건 \r\n\r\n1. 순회 할수 있는 데이터를 가지고 있어야한다. \r\n2. 전역 “well-known” symbol 인`Symbol.iterator` 을 메서드로 가지고 있어야한다. 또한 이 메서드는 #3 , #6 에 따라 구현되어야 한다.\r\n3. `Symbol.iterator` 메서드는 **“iterator” 객체를 반환**해야합니다\r\n4. “iterator” 객체는 **반드시 next 라고 하는 메서드를 가져야합니다.** (지난 Generator 포스팅에서 봤던 개념입니다.)\r\n5. next 에는 #1에 저장되어있는 데이터에 접근 할 수 있어야합니다.\r\n6. “iterator” 객체인 iteratorObj를 iteratorObj.next()하면 `{value:<stored data},done:false}` #1 데이터가 추출 되며 전부다 순회했을 경우 `{done:false}` 가 반환되도록 한다.\r\n\r\n\r\n\r\n### 이터러블(iterable)이 사용되는 곳\r\n\r\n- for... of 루프\r\n\r\n```javascript\r\nconst iterable = [1,2,3]\r\nfor (let value of iterable) {\r\n    console.log(value)\r\n}\r\n// 1, 2, 3\r\n```\r\n\r\n\r\n\r\n- destructuring\r\n\r\n```javascript\r\n// spread operator\r\nlet newIterable = [...iterable] // [1, 2, 3]\r\n\r\n// destructuring\r\nconst [c1, c2] = 'hello';\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 이터러블(iterable)과 이터레이터(iterator)의 차이\r\n\r\n- 이터러블: 순회할 수 있는 객체\r\n- 이터레이터: next메소드를 호출하면 {done: boolean, value} 를 반환하는 오브젝트, 객체 그 자체\r\n\r\n이터러블은 순회할 수 있는 모든 객체가 될 수 있다. 따라서 배열(Array), 문자열(string), 객체 등 다양한 것들이 될 수 있다. 이터레이터는 이터러블의 속성을 가진 바로 그 객체를 의미한다. \r\n\r\n이터레이터는 .next() 메소드를 반드시 갖는다. 즉, 앞 뒤로 바로 이전과 바로 다음 값만을 가져올 수 있다. 하지만 이터러블 중 하나인 배열은 인덱스로 랜덤 Access가 가능하다는 점에서 이터러블과 이터레이터의 차이를 알 수 있다.\r\n\r\n물론 개념적으로 완전히 포괄하는 느낌은 아니지만, 사실상 배열은 언제든 이터레이터로 변환이 가능하다는 점에서 이터레이터가 이터러블을 포함하는 관계로 볼 수 있다.\r\n\r\n| Iterable 이터러블       | Iterator 이터레이터                               |\r\n| ----------------------- | ------------------------------------------------- |\r\n| 랜덤 Access가 가능하다. | .next() 메소드, 바로 앞/뒤 값만을 가져올 수 있다. |\r\n| 기능이 많다 -> 무겁다   | 기능이 배열에 비해 상대적으로 적다 -> 가볍다      |\r\n| 메모리 사용량이 많다.   | 메모리 효율적이다.                                |\r\n\r\n\r\n\r\n---\r\n\r\nRef.\r\n\r\nhttps://helloworldjavascript.net/pages/260-iteration.html\r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md":
/*!***********************************************************************************!*\
  !*** ./contents/blog/language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"javascript 즉시실행함수(?) 일단 알아보자\"\r\ndate: \"2021.09.16\"\r\ntags: \r\n    - javascript\r\n    - 즉시실행함수\r\n---\r\n\r\n# javascript 즉시실행함수란 무엇일까\r\n\r\n> 즉시실행함수: 함수선언과 동시에 바로 실행이 되는 함수.\r\n\r\njavascript는 일회성으로 사용되는 함수가 다른 언어에 비해 많은 편인데, 이를 효율적으로 진행하기 위해`익명함수`, `즉시실행함수` 등을 지원합니다.\r\n\r\n당연히 단 한 번만 호출되고 실행됩니다.\r\n\r\n\r\n\r\n## 즉시실행함수\r\n\r\n```javascript\r\n// 일반함수\r\n\r\nfunction normal() {\r\n    console.log('Hello World!');\r\n}\r\nnormal();\r\n```\r\n\r\n```javascript\r\n// 즉시실행함수 - 이름이 있으므로 \"기명즉시실행함수\"라고도 불린다.\r\n(function immediate(){\r\n    console.log('URGENT!!')\r\n})();\r\n```\r\n\r\n위의 예시에서 보듯이 함수선언부분 전체를 괄호로 감싸고 그 뒤에 () 를 붙여서 바로 실행하도록 합니다.\r\n\r\n사실 한 번만 호출되고 더 이상 호출되지 않기 때문에 함수의 이름이 필요하지 않습니다. 따라서 다음과 같이 쓸 수 있습니다.\r\n\r\n```javascript\r\n// Anonymous function - 이름이 없으므로 \"익명즉시실행함수\"라고도 불린다.\r\n(function (){\r\n    console.log('URGENT!!')\r\n})();\r\n\r\n// ES6\r\n(()=> {console.log('URGENT!!')})();\r\n```\r\n\r\n일반적으로 즉시실행함수는 어차피 실행 선언 후 바로 사용되고 다시 사용되지 않으므로 ***익명함수***로 많이 쓰입니다.\r\n\r\n하지만 ***기명함수***로 쓰이는 경우도 있는데, 바로 재귀함수입니다. 자기 자신을 다시 호출해야 하는데 이름이 없으면 호출할 수가 없으므로 재귀함수에서는 이름을 지어서 활용합니다.\r\n\r\n\r\n\r\n### 함수 인자(arguments)는 어떻게 활용할까?\r\n\r\n```javascript\r\n(function sum(a, b){\r\n    console.log(`The answer is ${a+b}`)\r\n})(3, 5)\r\n// \"The answer is 8\"\r\n\r\n\r\n(function (arr){\r\n    arr.map((item) => {\r\n        console.log(item)\r\n    })\r\n})([\"Hello\", \"World\", \"!\"])\r\n// \"Hello\"\r\n// \"World\"\r\n// \"!\" \r\n```\r\n\r\n아래 예시와 같이 함수뒤에 붙여주는 괄호안에 인자를 넣어주면 즉시실행함수 내부에서 활용할 수 있다.\r\n\r\n지금은 숫자 자료형을 넣어줬지만 배열도 가능합니다.\r\n\r\n\r\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md":
/*!******************************************************************************!*\
  !*** ./contents/blog/language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"React프로젝트 Nodejs 버전(v10.x → v14.x) 올리기\"\ndate: \"2022.03.24\"\ntags:\n       - nodejs\n       - cra\n       - react\n       - 노드버전\n---\n\n\n# React프로젝트 Nodejs 버전(v10.x → v14.x) 올리기\n\n## buildit-co-kr-react 프로젝트 현 스펙\n\n```jsx\n// package.json\n\n\"react-scripts\": \"^2.1.8\",\n\"typescript\": \"3.8\",\n\"node-sass\": \"^4.14.1\",\n...\n```\n\n- 회사 프로젝트는 2022년 3월 21일 nodejs는 10.23.0 버전을 사용하고 있습니다.\n\nnode 버전이 낮은 편이어서 최신 javascript 문법을 쓰지 못하는 문제 상황이 있었는데, 이를 해결하기 위해서는 크게 두 가지 방법이 있습니다.\n\n1️⃣ react-rewire로 CRA 설정 중 babel설정을 override하기\n\n2️⃣ node 버전과 dependecy가 있는 라이브러리들의 버전을 같이 올려서 해결하기\n\n1번의 경우 아래 글에서 작성한 것처럼 이미 작업을 진행해보았습니다.\n\n#### :link:[react-rewired 사용해서 eject없이 CRA에babel설정 추가하기](https://likelionsungguk.github.io/22-03-23/react-rewired-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-eject%EC%97%86%EC%9D%B4-CRA%EC%97%90babel%EC%84%A4%EC%A0%95-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0)\n\n\n\n1번의 경우 CRA “one build dependecy”가 깨질 수 있는 위험성이 있으므로 이참에 2번 방법을 써보기로 했습니다.\n\n## 버전 선택하기\n\n먼저 nodejs 버전을 선택하기 전에는 다음의 내용들을 체크해봤습니다.\n\n✅ 사용하고자 하는 기능을 제공하는가?\n\n✅ 다른 프로젝트들과 버전 차이가 심하지 않는가?\n\n---\n\n### ✅ 사용하고자 하는 기능을 제공하는가?\n\n중점적으로 생각했던 기능을 ***optional chaining*** 이었습니다.\n\n![출처: mdn](/assets/img/0324-0.png)\n\n출처: mdn\n\n14.0.0 버전 이상부터 지원하는 것을 확인할 수 있었습니다.\n\n### ✅ 다른 프로젝트들과 버전 차이가 심하지 않는가?\n\n- 회사내 다른 프로젝트1: `nodejs14.x`\n- 회사내 다른 프로젝트2: `nodejs12.x`\n\n종합적으로 고려해봤을 때 최종적으로 nodejs 14버전을 사용하기로 하였습니다.\n\nnvm 으로 nodejs 버전을 10.23.0. 에서 14.15.4로 바꾸고 나서 npm start를 실행하면 에러가 발생합니다.\n\n![node버전에러](/assets/img/0324-1.png)\n\nnode버전에러\n\n```bash\nNode Sass version X.0.0 is incompatible with ^4.0.0 \n```\n\n보면 node-sass 라이브러리와 의존성 충돌이 일어나고 있습니다.\n\n![nodesass의존성충돌](/assets/img/0324-2.png)\n\nnode 14버전은 node-sass 최소 4.14 버전 이상을 설치해줘야 정상 동작하는 것으로 보입니다.\n\n살펴보니 기존 node-sass버전이 4.14 버전이었는데 충돌이 났습니다. 4.14+ 는 이상의 개념보다는 \"초과\" 개념으로 보고 4.14.1버전을 설치해봤습니다.\n\n\n\n## 작업 진행\n\n1. node version 변경 (v14.15.4로 했습니다.)\n2. node-sass uninstall\n3. node-sass@4.14.1로 재설치 (`npm i node-sass@4.14.1`)\n4. react-scripts 버전올리기 `package.json` 에서 \"react-scripts\":\"^3.3.0\"\n5. package-lock.json 지우고 다시 `npm i`\n6. es-lint 오류 수정\n\n위 단계를 실행하다보면 3번 이후에 다음과 같은 에러를 만날 수 있습니다.\n\n```bash\nAdd @babel/plugin-proposal-optional-chaining\n```\n\n이때 react-scripts의 버전을 3.3.0 이상으로 끌어올려주면 위 문제를 해결할 수 있습니다.\n\n(react-rewire를 안쓰고 최대한 react-scripts를 사용하기 위해 react-scripts버전을 같이 올려주었습니다.)\n\n이후 6번까지의 과정을 진행하면 node14버전으로 프로젝트를 컴파일 하여 실행할 수 있습니다.\n\n\n\n## 배포 문제 발생\n\n위 작업을 진행하고나면 로컬에서는 문제없이 작동시킬 수 있습니다. 하지만 배포를 하면 빌드가 실패하며 배포에 실패합니다.\n\n![여기까지는 문제없고](/assets/img/0324-3.png)\n\n여기까지는 문제없고\n\n![CI=True](/assets/img/0324-4.png)\n\n여기서부터 [process.env.CI](http://process.env.CI) = true 여서 warnings 를 errors로 본다고 하면서 compile에 실패하는 모습을 보여줍니다.\n\n![컴파일에 실패하고서 gitlab ci의 Job이 실패했습니다.](/assets/img/0324-5.png)\n\n컴파일에 실패하고서 gitlab ci의 Job이 실패했습니다.\n\n### 배포실패 문제원인 찾기\n\n### **What is this error all about? (about netlify deploy)**\n\nBeginning on *June 15, 2020,* Netlify started a gradual rollout of adding the environment variable CI to build environments, with the value of true. This environment variable, short for Continuous Integration, is commonly set in various CI environments like Travis CI and Github Actions, among many others. The ecosystem has largely agreed to use this environment setting to detect when a build is executing in a CI environment, as opposed to a local development environment.\n\nThis setting allows many common libraries to detect a CI environment and change behavior accordingly. One such behavior is the disabling of progress “spinners” that while useful in a local development terminal, can render poorly when operating in a log streamed CI environment.\n\n***Because of this some libraries now interpret what were previously just warnings as hard errors and halt the build***. The intention is that developers should not ship potentially broken configurations, but the downside is that builds that successfully completed previously started failing after this change.\n\n위 내용을 요약하면, CI환경은 github actions나 travis 등을 포함하여 다양한 곳에서 일반적으로 설정되고 있습니다. 로컬 개발 환경이 아닌 CI환경에서 빌드가 실행되는 환경에 맞춰서 빌드를 합니다. 왜냐하면 로컬 환경에서는 유용했던 것들이 CI의 log stream과 같은 곳에서 작동할 때는 working poorly 하기 때문입니다.\n\n따라서 `CI=true` 는 기본 설정이며 이 설정이 `true`로 세팅 되어있을 때에는  CI환경에 맞게 warnings를 error로 처리하여 빌드를 정상적으로 구성할 수 있도록 합니다.\n\n장점은 개발자가 config를 파괴하지 못하도록 하는 것이 있습니다. 하지만 단점은 기존에 잘 배포되던 시스템이 이 설정때문에 failed된다는 것입니다.\n\nFacebook 에서도 react-scripts를 통해 빌드할 때 CI=true를 기본설정으로 하기로 했다고 합니다. 여기서는 자기들끼리 엄청나게 discussion을 한 후 내린 결론이라고 하네요.\n\n[https://github.com/facebook/create-react-app/issues/3657](https://github.com/facebook/create-react-app/issues/3657)\n\n\n\n### 해결법 (FIX)\n\n```bash\n$ CI='' npm run build\n       or\n$ CI=false npm run build\n```\n\nCI=false와 CI= 은 조금 다릅니다.\n\n**“False” isn’t always false**\n\nThough it seems like the logical opposite of `CI=true`, setting `CI=false` may not work as expected. This is because environment variable values are processed as strings, and many libraries interpret *any* non-empty string value for `CI` as `true`.\n\n환경 변수들의 값은 스트링으로 처리되기 때문에 많은 라이브러리에서 non-empty string을 true로 하기 때문입니다. (CI=false로 False값을 주었다고 생각하지만 empty가 아니기 때문에 True라고 오류를 발생시킬 수 있다는 내용입니다.)\n\n회사에서는 gitlab CI를 쓰고 있습니다. gitlab CI에서는 `CI=fase` 로 했을 때 문제 없이 배포를 통과하긴 했습니다.\n\n\n\n---\n\nReferences.\n\n[Optional chaining - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Optional_chaining)\n\n[How to enable optional chaining with Create React App and TypeScript](https://stackoverflow.com/questions/59093630/how-to-enable-optional-chaining-with-create-react-app-and-typescript)\n\n[Treating Warnings As Errors Because Process.env.CI = True.](https://360techexplorer.com/treating-warnings-as-errors-because-process-env-ci-true-vercel-netlify-jenkins-etc/)\n\n[[Solved] \"Treating warnings as errors because of process.env.CI = true\"](https://dev.to/kapi1/solved-treating-warnings-as-errors-because-of-process-env-ci-true-bk5)\n\n");

/***/ }),

/***/ "./contents/blog/language/javascript/2022-04-07-javascript-정수만-입력받기.md":
/*!*****************************************************************************!*\
  !*** ./contents/blog/language/javascript/2022-04-07-javascript-정수만-입력받기.md ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"input 정수만 입력받기\"\ndate: \"2022.07.08\"\ntags:\n  - javascript\n  - test\n  - jest\n  - tdd\n---\n\n# javascript input 정수만 입력받기\n\n## 문제 상황\n\n<video src=\"/assets/data/소수점오류.mp4\" width=\"100%\" autoplay controls loop></video>\n\n- input의 비율을 소수점으로 입력했을 때 분명 입력한 대로는 총 합계가 100이 나와서 딱 맞아 떨어지는데, 미선택에 0.0000000001 과 같은 숫자가 남아있거나 100이 다 맞을 때 7.1023981203와 같은 엉뚱한 숫자가 나오는 오류가 있습니다.\n\n\n\n## 문제 원인\n\n![image.png](/assets/img/javascriptinput정수만입력받기1.png)\n\n문제 원인은 자바스크립트 소수의 특징입니다.\n\n자바스크립트의 숫자는 ****64 비트 부동 소수점****입니다.\n\n우리가 쓰는 10진법을 자바스크립트 엔진은 2진법으로 바꿔서 계산을 하는데, 이때 특정 소수의 경우 무한소수가 되어버립니다. (예: const 소수 = 10/3)\n\n이런 경우 자바스크립트는 무한수를 정해진 자원 안에서 표현하기 위해 유한하게 변경 하려다 보니 미세한 값들이 초과되거나 손실발생하게 됩니다.\n\n때문에 경우에 따라 대략 소수점 아래 15 ~ 17자리에서 그 무한소수를 끊고 근사값으로 저장하여 연산을 수행합니다.\n\n\n\n## 문제해결 방식 결정\n\n### toFixed, round를 사용하지 않는 이유\n\n가장 많이 쓰이는 것이 toFixed, round 같이 소수점을 특정 자릿수에서 끊고서 해당 수치들을 합계하거나 다 연산이 된 후에 동일한 처리를 할 수 있습니다.\n\n하지만 세대타입은 총합이 100이 되어야 하고 이 합계를 진행하는 로직이 생각보다 여러 곳에서 빈번하게 일어나고 있습니다.\n\n이 합계로직들을 모두 찾아다니면서 수정하는 것은 비효율적인 방법이라 판단했습니다.\n\n### 세대타입 비율 입력 시 정수값만 받도록 수정한 이유\n\n소수문제를 가장 쉽게 해결할 수 있는 것은 입력을 정수로만 받도록 하는 것입니다.\n\n하지만 UX관점에서 사용자가 세대타입의 비율을 꼭 소수점으로 표현해야만 한다면 또 다른 얘기입니다. 이 때 실제로 자주 사용하는 사용성을 체크해본 결과 세대타입 비율은 대략적인 수치이기 때문에 반드시 소수점까지 표기할 필요가 없다는 것을 확인하였습니다. 따라서 정수로 수정해도 큰 무리가 없다는 판단을 할 수 있었습니다.\n\n\n\n## 문제해결 과정\n\njavascript에서는 타언어와 다르게 숫자 타입이 딱 하나밖에 없습니다. 따라서 integer로 설정을 바꾸는 방법을 사용하지 못하므로 정수값만 입력을 받도록 하기 위해서는 약간의 트릭이 필요합니다.\n\n- 일단 정수만 입력이 가능하도록 하는pattern을 props으로 내려줘서 pattern에 맞는 입력만 입력이 가능하도록 해줘야 합니다.\n- input에 pattern을 줄 수 있는 것은 text타입입니다. (number는 X)\n- 따라서 input type=”number” 가 아닌 input type=”text”로 설정해줘야 합니다.\n\n### 1. ProjectFormHousing > ProjectFieldInput 수정\n\n```jsx\n// 기존\n<ProjectFieldInput\n\t...\n  type=\"number\"\n  unit=\"%\"\n  ...\n/>\n```\n\n```jsx\n// 수정 후\n<ProjectFieldInput\n\t...\n  type=\"text\"\n  pattern={\"[0-9]*\"}\n  unit=\"%\"\n  ...\n/>\n```\n\n1차로 이렇게 작업을 진행한 뒤 projectFielnInput에서 pattern을 props받아서 사용해보면 정수만 입력이 가능하도록 잘 동작합니다.\n\n하지만, 숫자입력값이 아닌 다른 입력값이 들어오는 경우 `NaN` 을 띄워주는 의도하지 않은 동작이 일어납니다.\n\n![숫자가 아닌 입력을 하면 NaN을 띄워주는 의도치 않은 동작을 하게 됩니다.](/assets/img/javascriptinput정수만입력받기2.png)\n\n숫자가 아닌 입력을 하면 NaN을 띄워주는 의도치 않은 동작을 하게 됩니다.\n\n### 2. onchange 에서 숫자가 아닌 값 처리해주기\n\n현재 활용하고 있는 projectFieldInput은 onChange 이벤트 발생시에 `updateValue` 함수를 통해 state값을 관리하고 있습니다.\n\n이 함수에서 숫자가 아닌 입력값을 받은 경우 return 을 막아주면, 위 오류 사항을 해결할 수 있을 거라 판단했습니다.\n\n```jsx\nupdateValue = (type: 'HOUSING' | 'MY_TYPE', index: number, area?: number, bay?: number, proportion?: number, userdef?: boolean) => {\n    if (proportion !== undefined && !isFinite(proportion)) {\n      return\n    }\n...\n}\n```\n\n위와 같이 updateValue 함수의 최상단에 proportion이 숫자가 아닌경우 return을 비어두어 처리하였습니다. `isFinite()` 은 숫자인지 아닌지 체크하는 함수입니다. 최상위 함수로 어떤 객체와도 연결되지 않았습니다. Nan, -infinite, +infinite → false, 나머지는 true를 반환합니다.\n\n### 3. CSS 맞추기\n\nBuilditInput은 크게 type이 text인지 number인지에 따라 CSS가 다르게 설정됩니다.\n\nText의 경우 input창의 왼쪽에 정렬이 되고 unit 설정은 따로 없습니다.\n\nNumber의 경우 input창의 오른쪽에 정렬이 되고 unit은 props를 받습니다.\n\n![TEXT](/assets/img/javascriptinput정수만입력받기3.png)\n\nTEXT\n\n![Number](/assets/img/javascriptinput정수만입력받기4.png)\n\nNumber\n\n세대타입의 경우 원래대로라면 우측정렬이 되고 단위인 %까지 unit으로 표현되는 것이 올바릅니다. 하지만 이번 정수만 입력가능하다는 특성이 추가되면서 이 부분에 대한 UI통일성이 깨져버리게 되었으므로 이를 다시 맞춰주는 작업이 필요합니다.\n\n이미 컴포넌트 자체에 align이라는 프로퍼티를 정의해 두었기 때문에 간단하게 left, right, center를 선택할 수 있습니다.\n\n따라서 ProjectFieldInput component에서 align=”right”을 props해주면 우측정렬을 할 수 있습니다.\n\n![Untitled](/assets/img/javascriptinput정수만입력받기5.png)\n\n—끝—");

/***/ }),

/***/ "./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md":
/*!*************************************************************************!*\
  !*** ./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Typescript 시작하기\"\r\ndate: \"2021.04.14\"\r\ntags: \r\n  - typescript\r\n  - ts\r\n  - 타입스크립트\r\n---\r\n\r\n\r\n\r\n# 타입스크립트 fundamentals - 타입, 함수, 인터페이스, enum, 클래스\r\n\r\n\r\n## 1. 기본타입\r\n\r\n변수선언방식 변수명 : 타입 = 값;\r\n\r\n```tsx\r\nlet str: string = 'hi'\r\nlet num: number = 10;\r\nlet isLoggedIn: boolean = false;\r\n```\r\n\r\n### Array\r\n\r\n요소의 집합\r\n\r\n```tsx\r\nlet arr: number[] = [1, 2, 3];\r\narr[2] = 100;\r\n\r\n// 타입이 다르므로 에러\r\narr[2] = 'hi';\r\n```\r\n\r\n### Tuple\r\n\r\n**길이가 고정**되고 요소 **타입이 지정**된 배열\r\n\r\n```tsx\r\nlet tuple: [string, number] = ['hi', 10];\r\n\r\n//길이가 고정되기때문에 에러뜸\r\ntuple[5] = 'hello';\r\n// number타입에 string 할당 x 에러\r\ntuple[1] = 'hi';\r\n\r\n```\r\n\r\n### Enum\r\n\r\n**상수**들의 집합이다.\r\n\r\n```tsx\r\nenum Avengers { Capt, IronMan, Thor }\r\nlet hero: Avengers = Avengers.Capt;\r\n\r\nconsole.log(hero); // 0\r\n\r\n//읽기전용이라서 할당불가 에러\r\nAvengers.Capt = 3;\r\n```\r\n\r\n### Any\r\n\r\n자바스크립트의 변수랑 똑같다. 뭐든 할당 가능\r\n\r\n```tsx\r\nlet str: any = 'hi';\r\nlet num: any = 10;\r\nlet arr: any = ['a', 2, true];\r\n\r\n//any라서 num에 'hi' 할당 가능\r\nnum = 'hi';\r\n```\r\n\r\n### Void\r\n\r\nundefined와 null만 할당가능하다. 일반적으로 반환하지 않는 **함수**에서 사용\r\n\r\n```tsx\r\nlet unuseful: void = undefined;\r\nfunction notuse(): void {\r\n  console.log('sth');\r\n}\r\n```\r\n\r\n### never\r\n\r\n에러를 throw 하거나 절대 반환하지 않는 함수(무한루프일때 쓰이네요)\r\n\r\n```tsx\r\nfunction neverEnd(): never {\r\n  while (true) {\r\n\r\n  }\r\n}\r\n\r\nfunction error(message: string): never {\r\n    throw new Error(message);\r\n}\r\n```\r\n\r\n## 2. 함수\r\n\r\n### 함수의 기본적인 타입 선언\r\n\r\n자바스크립트와의 차이점은 **매개 변수**와 **반환 값**에 타입 부여\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n\treturn a + b;\r\n}\r\n```\r\n\r\n### 함수의 인자\r\n\r\n전달 인자의 수가 더 많거나 적거나 하면 당연히 안되겠죠? 당연히 타입도 다르면 안되요\r\n\r\n```tsx\r\nfunction sum(a: number, b: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // error, too few parameters\r\n```\r\n\r\n### 선택적 매개변수\r\n\r\n하지만 매개변수에 ?를 달아주면 그 전달인자를 넘기지 않아도 됩니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b?: number): number {\r\n  return a + b;\r\n}\r\nsum(10, 20); // 30\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 10\r\n```\r\n\r\n```tsx\r\n// error 필수 매개변수가 선택적 매개변수 \r\n// 선택적 매개변수가 앞에 있으면 안됩니다.\r\nfunction sum(a?: number, b: number): number {\r\n  return a + b;\r\n}\r\n```\r\n\r\n기본값도 설정해 줄 수 있습니다.\r\n\r\n```tsx\r\nfunction sum(a: number, b = 100): number {\r\n  return a + b;\r\n}\r\nsum(10, undefined); // 110\r\nsum(10, 20, 30); // error, too many parameters\r\nsum(10); // 110\r\n```\r\n\r\n### 인터페이스\r\n\r\n인터페이스는 상호간의 정의한 약속이나 규칙을 의미한다.\r\n\r\n객체의 속성과 속성타입\r\n\r\n함수의 매개변수나 반환타입\r\n\r\n배열과 객체를 접근하는 방식\r\n\r\n클래스\r\n\r\nlogAge 메소드는 age라는 속성을 갖고 number타입을 갖는 객체를 받는것을 약속했다.\r\n\r\n```tsx\r\nlet person = { name: 'Capt', age: 28 };\r\n\r\nfunction logAge(obj: { age: number }) {\r\n  console.log(obj.age); // 28\r\n}\r\nlogAge(person); // 28\r\n```\r\n\r\n```tsx\r\ninterface personAge {\r\n  age: number;\r\n}\r\n\r\nfunction logAge(obj: personAge) {\r\n  console.log(obj.age);\r\n}\r\nlet person = { name: 'Capt', age: 28 };\r\nlogAge(person);\r\n```\r\n\r\n### 옵션속성\r\n\r\n아까 매개변수때와 마찬가지로 ?를 붙혀주면 그 속성을 모두 다 꼭 사용하지 않아도 됩니다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  name: string;\r\n  hop?: number;  \r\n}\r\n\r\nlet myBeer = {\r\n  name: 'Saporo'\r\n};\r\nfunction brewBeer(beer: CraftBeer) {\r\n  console.log(beer.name); // Saporo\r\n}\r\nbrewBeer(myBeer);\r\n```\r\n\r\n### 읽기 전용 속성\r\n\r\nreadonly가 붙은 속성은 읽는것만 된다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  readonly brand: string;\r\n}\r\n\r\nlet myBeer: CraftBeer = {\r\n  brand: 'Belgian Monk'\r\n};\r\nmyBeer.brand = 'Korean Carpenter'; // error!\r\n```\r\n\r\n### 읽기 전용 배열\r\n\r\nReadonlyArray로 선언하면 배열 내용 변경 불가ReadonlyArray로 선언하면 배열 내용 변경 불가\r\n\r\n```tsx\r\nlet arr: ReadonlyArray<number> = [1,2,3];\r\narr.splice(0,1); // error\r\narr.push(4); // error\r\narr[0] = 100; // error\r\narr = [10, 20, 30]; // error\r\n```\r\n\r\n객체 선언과 관련된 타입 체킹\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  brand?: string;\r\n}\r\n\r\nfunction brewBeer(beer: CraftBeer) {\r\n  // ..\r\n}\r\nbrewBeer({ brandon: 'what' }); // 속성이 다르니 에러뜹니다.\r\n```\r\n\r\n이러면 타입 체크를 무시한다.\r\n\r\n```tsx\r\nlet myBeer = { brandon: 'what' }';\r\nbrewBeer(myBeer as CraftBeer);\r\n```\r\n\r\n### 함수 타입\r\n\r\n함수 매개변수와 반환타입도 인터페이스 정의가 가능하다.\r\n\r\n```tsx\r\ninterface login {\r\n  (username: string, password: string): boolean;\r\n}\r\n\r\nlet loginUser: login; // 함수 저장할 변수 선언\r\nloginUser = function(id: string, pw: string) {\r\n  console.log('로그인 했습니다');\r\n  return true;\r\n}\r\n```\r\n\r\n클래스 타입\r\n\r\n자바의 인터페이스와 목적이 비슷한데\r\n\r\n어떤 인터페이스를 implements한 클래스가 있다면\r\n\r\n인터페이스의 메소드와 변수가 있다는 것을 보장한다.\r\n\r\n```tsx\r\ninterface CraftBeer {\r\n  beerName: string;\r\n  nameBeer(beer: string): void;\r\n}\r\n\r\nclass myBeer implements CraftBeer {\r\n  beerName: string = 'Baby Guinness';\r\n  nameBeer(b: string) {\r\n    this.beerName = b;\r\n  }\r\n  constructor() {}\r\n}\r\n```\r\n\r\n인터페이스 끼리 상속도 가능합니다.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n}\r\ninterface Drinker {\r\n  drink: string;\r\n}\r\ninterface Developer extends Person {\r\n  skill: string;\r\n}\r\nlet fe = {} as Developer;\r\nfe.name = 'josh';\r\nfe.skill = 'TypeScript';\r\nfe.drink = 'Beer';\r\n```\r\n\r\n## 4. Enum\r\n\r\n> 특정 값들의 **집합**을 의미하는 자료형으로 크게 {숫자형 이넘, 문자형 이넘} 두 가지가 있다\r\n\r\n- Enum이라는 개념을 이해하기 어려웠던 이유는, javascript에는 enum이 없었기 때문이다. (하지만 검색해보니 C언어에서는 제공하는 것 같음.)\r\n\r\n### 4-1. 숫자형 이넘\r\n\r\n```tsx\r\nenum Direction {\r\n  Up = 1,\r\n  Down,\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n특이한 것은 이렇게 선언하면  양방향으로 호출할 수 있는 특이한 자료구조가 된다는 것이다.\r\n\r\n```tsx\r\nconsole.log(Direction[1])    // \"Up\"\r\nconsole.log(Direction[\"Up\"]) // 1\r\nconsole.log(Direction[3])    // \"Left\"\r\n```\r\n\r\n이와 같이 숫자형 Enum에서 Direction.Up 으로 1값을 얻거나 반대로 Direction[1]로 \"Up\"값을 얻는 것을 **`리버스 매핑`** 이라고 한다.\r\n\r\n이렇게 초기값을 선언해주면 1, 2, 3, 4 의 순서로 1씩 증가하며 할당된다. 만약,\r\n\r\n```tsx\r\nenum Direction {\r\n\tUp, \r\n\tDown,\r\n\tLeft,\r\n\tRight\r\n}\r\n```\r\n\r\n으로 선언되었다면 Up - 0 , Down - 1, Left - 2, Right - 3이 된다.\r\n\r\n### 4-2 숫자형 enum 사용\r\n\r\n```tsx\r\nenum Response {\r\n  No = 0,\r\n  Yes = 1,\r\n}\r\n\r\nfunction respond(recipient: string, message: Response): void {\r\n  console.log(recipient, message)\r\n}\r\n\r\nrespond(\"Captain Pangyo\", Response.Yes);\r\n\r\n--------------------\r\n[LOG]: \"Captain Pangyo\",  1\r\n```\r\n\r\n### 4-3. 문자형 enum\r\n\r\n> 문자형 이넘은 이넘 값 전부 다 특정 문자 또는 다른 이넘 값으로 초기화 해줘야 합니다.\r\n\r\n```tsx\r\nenum Direction {\r\n    Up = \"UP\",\r\n    Down = \"DOWN\",\r\n    Left = \"LEFT\",\r\n    Right = \"RIGHT\",\r\n}\r\n```\r\n\r\n** 복합 enums **\r\n\r\n문자와 숫자를 혼합하여 enum을 생성할 수 있으나, 권장하지 않는 방식!\r\n\r\n```tsx\r\nenum BooleanLikeHeterogeneousEnum {\r\n    No = 0,\r\n    Yes = \"YES\",\r\n}\r\n```\r\n\r\n### 4-4. 런타임 시점에서의 이넘 특징\r\n\r\n이넘은 런타임시에 실제 객체 형태로 존재합니다. 예를 들어 아래와 같은 이넘 코드가 있을 때\r\n\r\n```tsx\r\nenum E {\r\n  X, Y, Z\r\n}\r\n\r\nfunction getX(obj: { X: number }) {\r\n  return obj.X;\r\n}\r\ngetX(E); // 이넘 E의 X는 숫자이기 때문에 정상 동작\r\n-----\r\nQuiz. \r\ngetX(E)값을 변수에 넣어서 출력한다면, 얼마나 나올까?\r\n```\r\n\r\n### 4-5. 컴파일 시점에서의 이넘 특징\r\n\r\n```tsx\r\nenum LogLevel {\r\n  ERROR, WARN, INFO, DEBUG\r\n}\r\n\r\n// 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\r\ntype LogLevelStrings = keyof typeof LogLevel;\r\n\r\nfunction printImportant(key: LogLevelStrings, message: string) {\r\n    const num = LogLevel[key];\r\n    if (num <= LogLevel.WARN) {\r\n       console.log('Log level key is: ', key);\r\n       console.log('Log level value is: ', num);\r\n       console.log('Log level message is: ', message);\r\n    }\r\n}\r\nprintImportant('ERROR', 'This is a message');\r\n\r\n-------\r\n[LOG]: \"Log level key is: \",  \"ERROR\" \r\n[LOG]: \"Log level value is: \",  0 \r\n[LOG]: \"Log level message is: \",  \"This is a message\"\r\n```\r\n\r\n### 4-6. Typescript enum을 사용하는 이유\r\n\r\nEnum은 추상화의 수단이다.\r\n\r\n다국어 코드 (Language Code)를 할당한다고 생각해보자\r\n\r\n```tsx\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\n\r\nconst code: LanguageCode = 'ko'\r\n\r\nconsole.log(code) // [LOG]: \"ko\"\r\n\r\n하지만 \r\ncost code: LanguageCode = 'hahahaha'\r\n와 같이 코드를 짜면 typescript에서 에러로 표시해준다.\r\n```\r\n\r\n이것도 좋지만 데이터 양이 많아지면 가독성이 많이 떨어진다.\r\n\r\n우리가 원하는 것은 korean을 검색하면 'ko'라는 코드가 나왔으면 하는 것이고 기존 방식으로는 다음과 같이 두 가지 방법이 있다.\r\n\r\n```tsx\r\n// 이렇게 하면 언어 코드가 위아래에 중복되고\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nlet code: LanguageCode = english\r\nconsole.log(code) // \"en\"\r\n```\r\n\r\n```tsx\r\n// 이렇게 하면 코드가 너무 길어집니다\r\nconst korean = 'ko'\r\nconst english = 'en'\r\nconst japanese = 'ja'\r\nconst chinese = 'zh'\r\nconst spanish = 'es'\r\ntype LanguageCode = typeof korean | typeof english | typeof japanese | typeof chinese | typeof spanish\r\nlet code: LanguageCode = spanish\r\nconsole.log(code) // \"es\"\r\n```\r\n\r\n이러한 이유 때문에 리터럴의 타입과 값에 이름을 붙인 `enum`을 활용하면 가독성을 크게 높일 수 있습니다.\r\n\r\n```tsx\r\nenum LanguageCode {\r\n  korean = 'ko',\r\n  english = 'en',\r\n  japanese = 'ja',\r\n  chinese = 'zh',\r\n  spanish = 'es',\r\n}\r\n// 여기서 \r\n// LanguageCode.korean === 'ko'\r\n// (의미상) LanguageCode === 'ko' | 'en' | 'ja' | 'zh' | 'es'\r\nconst code: LanguageCode = LanguageCode.korean\r\nconsole.log(code) // \"ko\"\r\n```\r\n\r\n### 4-7. Typescript enum을 사용하지 않는 이유\r\n\r\n### Tree-shaking은 무엇인가요?\r\n\r\nTree-shaking이란 간단하게 말해 사용하지 않는 코드를 삭제하는 기능을 말합니다. 나무를 흔들면 죽은 잎사귀들이 떨어지는 모습에 착안해 Tree-shaking이라고 부릅니다. Tree-shaking을 통해 export했지만 아무 데서도 import하지 않은 모듈이나 사용하지 않는 코드를 삭제해서 번들 크기를 줄여 페이지가 표시되는 시간을 단축할 수 있습니다.\r\n\r\n하지만 enum을 사용하게 되면 Tree-shaking이 되지 않습니다.\r\n\r\n결론적으로  Tree-shaking 관점에서 보았을 때 아래와 같은 순서로 사용하시길 추천하며 글을 마치겠습니다.\r\n\r\n> Union Types > const enum > enum\r\n\r\n**정리**\r\n\r\n- 같은 ‘종류’를 나타내는 여러 개의 숫자 혹은 문자열을 다뤄야 하는데, \r\n각각 적당한 이름을 붙여서 코드의 가독성을 높이고 싶다면 enum을 사용!\r\n\r\n## 5. 연산자를 이용한 타입 정의\r\n\r\n### 5-1. Union Type ( | )\r\n\r\n유니온 타입(Union Type)이란 자바스크립트의 OR 연산자(||)와 같이 A이거나 B이다 라는 의미의 타입\r\n\r\n```tsx\r\nfunction logText(text: string | number) {\r\n  // ...\r\n}\r\n```\r\n\r\n- text는 string이거나 (OR || ) number이다. 즉, 둘 다 올 수 있다는 뜻.\r\n- 이처럼 `|` 연산자를 이용하여 타입을 여러 개 연결하는 방식을 `유니온 타입 정의 방식` 이라 부른다.\r\n\r\n```tsx\r\nfunction getAge(age: number | string) {\r\n  if (typeof age === 'number') {\r\n    age.toFixed(); // 정상 동작, age의 타입이 `number`로 추론되기 때문에 숫자 관련된 API를 쉽게 자동완성 할 수 있다.\r\n    return age;\r\n  }\r\n  if (typeof age === 'string') {\r\n    return age;\r\n  }\r\n  return new TypeError('age must be number or string');\r\n}\r\nconsole.log(getAge(10))\r\nconsole.log(getAge('Hello World'))\r\nconsole.log(getAge(true))\r\n--- 출력 ---\r\n[LOG]: 10 \r\n[LOG]: \"Hello World\" \r\n[LOG]: age must be number or string\r\n```\r\n\r\n### 5-2. Intersection Type ( & )\r\n\r\n여러 타입을 모두 만족하는 하나의 타입을 의미.\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: number;\r\n}\r\ntype Capt = Person & Developer;\r\n```\r\n\r\n```tsx\r\n// Capt의 타입은\r\n\r\n{\r\n  name: string;\r\n  age: number;\r\n  skill: string;\r\n}\r\n```\r\n\r\n![Intersection Type](https://joshua1988.github.io/ts/assets/img/intersection-diagram.01f4fdfe.png)\r\n\r\n### 5-3. Union Type을 쓸 때 주의할 점\r\n\r\n```tsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: string;\r\n}\r\nfunction introduce(someone: Person | Developer) {\r\n  someone.name; // O 정상 동작\r\n  someone.age; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n  someone.skill; // X 타입 오류 -> 타입스크립트에서 빨간줄로 표시해줌\r\n}\r\n```\r\n\r\n유니온 타입은 A도 될 수 있고 B도 될 수 있는 타입이지라고 생각하면 파라미터의 타입이 Person도 되고 Developer도 될테니까 함수 안에서 당연히 이 인터페이스들이 제공하는 속성들인 age나 skill를 사용할 수 있겠지라고 생각할 수 있습니다. \r\n\r\n하지만, 타입스크립트 관점에서는 introduce() 함수를 호출하는 시점에 Person 타입이 올지 Developer 타입이 올지 알 수가 없기 때문에 어느 타입이 들어오든 간에 오류가 안 나는 방향으로 타입을 추론하게 됩니다.\r\n\r\n따라서 위의 예시 같은 경우에는 의도와는 달리 [someone.name](http://someone.name) 만 정상적으로 작동하게 됩니다.\r\n\r\n## 6. Class\r\n\r\n### 6-1. Readonly\r\n\r\n```tsx\r\nclass Developer {\r\n    readonly name: string;\r\n    constructor(theName: string) {\r\n        this.name = theName;\r\n    }\r\n}\r\nlet john = new Developer(\"John\");\r\njohn.name = \"John\"; // error! name is readonly.\r\nconsole.log(john)\r\n--- 출력 ---\r\n[LOG]: Developer: {\r\n  \"name\": \"John\"\r\n}\r\n```\r\n\r\n### 6-2. Accessor\r\n\r\n타입스크립트는 객체의 특정 속성의 접근과 할당에 대해 제어할 수 있습니다. 이를 위해선 해당 객체가 클래스로 생성한 객체여야 합니다. 아래의 간단한 예제를 봅시다.\r\n\r\n```tsx\r\nclass Developer {\r\n  name: string;\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton';\r\n```\r\n\r\n위 코드는 클래스로 생성한 객체의 `name` 속성에 `Josh Bolton`이라는 값을 대입한 코드입니다. 이제 `josh`라는 객체의 `name` 속성은 `Josh Bolton`이라는 값을 갖겠죠.\r\n\r\n여기서 만약 `name` 속성에 제약 사항을 추가하고 싶다면 아래와 같이 `get`과 `set`을 활용합니다.\r\n\r\n```tsx\r\nclass Developer {\r\n  private name: string;\r\n  \r\n  get name(): string {\r\n    return this.name;\r\n  }\r\n\r\n  set name(newValue: string) {\r\n    if (newValue && newValue.length > 5) {\r\n      throw new Error('이름이 너무 깁니다');\r\n    }\r\n    this.name = newValue;\r\n  }\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton'; // Error\r\njosh.name = 'Josh';\r\n```\r\n\r\nTIP!\r\nget만 선언하고 set을 선언하지 않는 경우에는 자동으로 readonly로 인식됩니다.\r\n\r\n### 6-3. Abstract Class\r\n\r\n추상 클래스(Abstract Class)는 인터페이스와 비슷한 역할을 하면서도 조금 다른 특징을 갖고 있습니다. 추상 클래스는 특정 클래스의 상속 대상이 되는 클래스이며 좀 더 상위 레벨에서 속성, 메서드의 모양을 정의합니다.\r\n\r\n```tsx\r\nabstract class Developer {\r\n  abstract coding(): void; // 'abstract'가 붙으면 상속 받은 클래스에서 무조건 구현해야 함\r\n  drink(): void {\r\n    console.log('drink sth');\r\n  }\r\n}\r\n\r\nclass FrontEndDeveloper extends Developer {\r\n  coding(): void {\r\n    // Developer 클래스를 상속 받은 클래스에서 무조건 정의해야 하는 메서드\r\n    console.log('develop web');\r\n  }\r\n  design(): void {\r\n    console.log('design web');\r\n  }\r\n}\r\nconst dev = new Developer(); // error: cannot create an instance of an abstract class\r\nconst josh = new FrontEndDeveloper();\r\njosh.coding(); // develop web\r\njosh.drink(); // drink sth\r\njosh.design(); // design web\r\n```\r\n\r\n\r\n\r\n\r\n---\r\nReferences\r\nhttps://joshua1988.github.io/ts/\r\n\r\n[TypeScript enum을 사용하는 이유](https://medium.com/@seungha_kim_IT/typescript-enum을-사용하는-이유-3b3ccd8e5552)\r\n\r\n[TypeScript enum을 사용하지 않는 게 좋은 이유](https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/)\r\n\r\n[C언어 Enum](https://dojang.io/mod/page/view.php?id=480)");

/***/ }),

/***/ "./contents/blog/language/typescript/2021-04-27-Typescript-실습퀴즈.md":
/*!*************************************************************************!*\
  !*** ./contents/blog/language/typescript/2021-04-27-Typescript-실습퀴즈.md ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"타입스크립트 실습 QUIZ\"\r\ndate: \"2021.04.28\"\r\ntags: \r\n  - typescript\r\n  - ts\r\n  - 타입스크립트\r\n  - quiz\r\n---\r\n# 나를 위해 내가 직접 만든 QUIZ\r\n\r\n## Q1. 다음 빈칸에 들어갈 알맞은 것은?\r\n\r\n```jsx\r\nfunction joinStudy(name: string, age: number): ( 빈칸 ) {\r\n  if (age > 23) {\r\n    console.log(name)\r\n  }\r\n}\r\njoinStudy('John Doe', 35)\r\n```\r\n\r\n\r\n\r\n## Q2. 아래 arr는 숫자로 이루어진 배열이고 수정이 불가능하다. 이때 빈칸에 들어갈 것으로 가장 알맞은 것은?\r\n\r\n```jsx\r\nlet arr: (      빈칸     ) = [1,2,3];\r\n```\r\n\r\n\r\n\r\n## Q3. OX퀴즈\r\n\r\n- (   ) 클래스끼리는 상속이 가능하지만 인터페이스간에는 상속이 불가능하다.\r\n- (   ) enum은 javascript로 컴파일 된 후에도 남아있다.\r\n\r\n\r\n\r\n## Q4. 다음중 Capt 타입은 어떤 모습인가?\r\n\r\n```jsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: number;\r\n}\r\ntype Capt = Person & Developer;\r\n\r\n```\r\n\r\n```jsx\r\n// Capt타입\r\n{\r\n\t// 여기에 답안을 작성해주세요.\r\n\t\r\n\t\r\n}\r\n```\r\n\r\n\r\n\r\n## Q5. 다음 빈칸에 들어갈 수 있는 것을 모두 작성해주세요.\r\n\r\n```jsx\r\ninterface Animal{\r\n  name: string;\r\n\tage: number,\r\n  move: number;\r\n}\r\ninterface Bird{\r\n  name: string;\r\n\tage: number;\r\n  fly: string;\r\n}\r\nfunction hawk(sth: Animal & Bird) {\r\n // 여기에 답안을 작성해주세요.\r\n}\r\n```\r\n\r\n\r\n\r\n## Q6. 다음 코드가 console에 출력되는 결과는 무엇일까요?\r\n\r\n```jsx\r\nclass Animal {\r\n    name: string;\r\n    constructor(theName: string) { this.name = theName; }\r\n    move(distanceInMeters: number = 0) {\r\n        console.log(`${this.name} moved ${distanceInMeters}m.`);\r\n    }\r\n}\r\n\r\nclass Snake extends Animal {\r\n    constructor(name: string) { super(name); }\r\n    move(distanceInMeters = 5) {\r\n        console.log(\"Slithering...\");\r\n        super.move(distanceInMeters);\r\n    }\r\n}\r\n\r\nclass Horse extends Animal {\r\n    constructor(name: string) { super(name); }\r\n    move(distanceInMeters = 45) {\r\n        console.log(\"Galloping...\");\r\n        super.move(distanceInMeters);\r\n    }\r\n}\r\n\r\nlet sam = new Snake(\"Sammy the Python\");\r\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\r\n\r\nsam.move();\r\ntom.move(34);\r\n```\r\n\r\n```jsx\r\n//답안\r\n\r\n```\r\n\r\n\r\n\r\n## Q7. 타입스크립트에서 어떠한 클래스 혹은 함수에서 사용할 타입을 그 함수나 클래스를 사용할 때 결정하는 프로그래밍 기법은?\r\n\r\n- \r\n\r\n\r\n\r\n## Q8-1. 다음 두 가지 방법 중 어떤 방법이 컴포넌트 재사용성을 높일 수 있는 방법이라고 생각하는가? 그리고 그 이유는 무엇인가?\r\n\r\n```jsx\r\n// 1번\r\nclass Stack {\r\n  private data: any[] = [];\r\n\r\n  contructor() {}\r\n\r\n  push(item: any): void {\r\n    this.data.push(item);\r\n  }\r\n\r\n  pop(): any {\r\n    return this.data.pop();\r\n  }\r\n}\r\n```\r\n\r\n```jsx\r\n// 2번\r\n\r\nclass Stack<T> {\r\n  private data: T[] = [];\r\n\r\n  constructor() {}\r\n\r\n  push(item: T): void {\r\n    this.data.push(item);\r\n  }\r\n\r\n  pop() {\r\n    return this.data.pop();\r\n  }\r\n}\r\n```\r\n\r\n- \r\n\r\n\r\n\r\n## 08-2. 마지막 로그에 찍히는 numberStack과 stringStack의 데이터를 표기하시오.\r\n\r\n```jsx\r\nclass Stack<T> {\r\n  private data: T[] = [];\r\n\r\n  constructor() {}\r\n\r\n  push(item: T): void {\r\n    this.data.push(item);\r\n  }\r\n\r\n  pop() {\r\n    return this.data.pop();\r\n  }\r\n}\r\n\r\nconst numberStack = new Stack<number>();\r\nconst stringStack = new Stack<string>();\r\nnumberStack.push(1);\r\nnumberStack.push(2);\r\nnumberStack.push(3);\r\nstringStack.push('a');\r\nstringStack.push('b');\r\nnumberStack.pop();\r\nstringStack.pop();\r\nconsole.log(numberStack);\r\nconsole.log(stringStack);\r\n```\r\n\r\n```jsx\r\n// stringStack\r\n\"data\": [\r\n\r\n]\r\n\r\n// numberStack\r\n\"data\": [\r\n\r\n]\r\n```\r\n\r\n\r\n\r\n### 퀴즈에 대한 해설은 아래 노션 링크에서 확인할 수 있습니다!\r\n\r\n[퀴즈 답안 보러가기](https://www.notion.so/Typescript-7b44163f91fc411e978ecc0c3f527173)\r\n\r\n---\r\n\r\nReferences.\r\n\r\nhttps://typescript-kr.github.io/\r\n\r\nhttps://joshua1988.github.io/ts/");

/***/ }),

/***/ "./contents/blog/react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md":
/*!********************************************************************************!*\
  !*** ./contents/blog/react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"실전 리액트 프로그래밍 section 1. 리액트 프로젝트 시작하기 \"\r\ndate: \"2021.04.28\"\r\ntags: \r\n  - react\r\n  - react-js\r\n  - 리액트\r\n  - 프론트엔드\r\n---\r\n\r\n# section 1. 리액트 프로젝트 시작하기\r\n\r\n## 1. 리액트란 무엇인가?💡\r\n\r\n- 자동으로 업데이트되는 UI\r\n- UI = render(state)\r\n- render함수는 순수함수로 작성\r\n    - 순수함수란, 입력값이 같으면 출력값이 같은 함수\r\n    - 랜덤함수 사용 X\r\n    - 외부 상태 변경 X\r\n    - 순수함수와 불변변수를 이용하는 이유?\r\n        - 복잡도가 낮아지고, 버그 발생확률이 낮아짐.\r\n        - 렌더링 성능을 크게 향상시킬 수 있음.\r\n- state는 불변 변수로 관리\r\n- 가상 돔 (virtual dom)\r\n    - 이전 UI상태를 메모리에 유지한 뒤 변경된 부분만 실제 DOM에서 변경함\r\n\r\n## 2. 리액트 개발 환경 구축하기💡\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled.png](/assets/img/react.png)\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Document</title>\r\n</head>\r\n<body>\r\n  <h2>안녕하세요.</h2>\r\n  <h3>root1</h3>\r\n  <div id=\"root1\"></div>\r\n  <h3>root2</h3>\r\n  <div id=\"root2\"></div>\r\n  <h3>root3</h3>\r\n  <div id=\"root3\"></div>\r\n  <script src=\"react.development.js\"></script>\r\n  <script src=\"react-dom.development.js\"></script>\r\n  <script src=\"simple1.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n```jsx\r\n// 방법1. 그냥 반복해서 만들기\r\n\r\nfunction LikeButton() {\r\n  const [liked, setLiked] = React.useState(false);\r\n  const text = liked ? '좋아요 취소': '좋아요';\r\n  return React.createElement(\r\n    'button',\r\n    { onClick: () => setLiked(!liked) },\r\n    text,\r\n  );\r\n}\r\nconst domContainer1 = document.getElementById('root1');\r\nReactDOM.render(React.createElement(LikeButton), domContainer1)\r\nconst domContainer2 = document.getElementById('root2');\r\nReactDOM.render(React.createElement(LikeButton), domContainer2)\r\nconst domContainer3 = document.getElementById('root3');\r\nReactDOM.render(React.createElement(LikeButton), domContainer3)\r\n```\r\n\r\n```jsx\r\n// 방법2. 리액트 render 내에서 반복하기\r\n\r\nfunction LikeButton() {\r\n  const [liked, setLiked] = React.useState(false);\r\n  const text = liked ? '좋아요 취소': '좋아요';\r\n  return React.createElement(\r\n    'button',\r\n    { onClick: () => setLiked(!liked) },\r\n    text,\r\n  );\r\n}\r\nconst domContainer = document.getElementById('root');\r\nReactDOM.render(\r\n  React.createElement(\r\n    'div',\r\n    null,\r\n    React.createElement(LikeButton),\r\n    React.createElement(LikeButton),\r\n    React.createElement(LikeButton),\r\n  ), \r\n  domContainer\r\n);\r\n```\r\n\r\n## 3. 바벨 사용해보기💡\r\n\r\n- 초기에는 ES5문법을 ES6로 바꿔주는 역할을 많이 수행했음.\r\n- 최근에는 코드 주석을 제거하거나 코드를 압축하는 용도로 사용되기도 한다.\r\n- 리액트에서는 JSX문법을 createElement함수를 호출하는 코드로 변환하기 위해 바벨 사용\r\n- JSX문법은 javascript표준이 아니기 때문에 에러가 나지 않도록 babel을 사용한다.\r\n\r\n```bash\r\n$ npx babel --watch src --out-dir . --presets @babel/preset-react\r\n\r\n```\r\n\r\n## 4. 웹팩 기본 개념 이해하기💡\r\n\r\n- 파일 내용 기본으로 파일이름에 해시값을 추가해주기도 함.\r\n\r\n    → 이것은 효율적으로 브라우저 캐싱을 이용할 수 있게 도와주는 역할을 함.\r\n\r\n- 사용되지 않은 코드 제거\r\n- 자바스크립트 압축\r\n- JS에서 CSS, JSON, 텍스트 파일 등을 일반 모듈처럼 불러오기\r\n- 환경변수 주입\r\n- 그 중에서도 웹팩을 사용하는 가장 큰 이유는 `모듈 시스템` (ESM, commonJS)을 사용하고 싶어서임.\r\n- 여러개의 js 파일에서 같은 전역 변수를 사용하면 문제가 생기기도 한다. 따라서 js파일은 불러오는 순서도 중요하다.\r\n  \r\n    - 이때, 웹팩을 쓰면 이러한 것들을 컴파일 단계에서 잡아주기 때문에 충돌 위험을 미리 파악할 수 있다.\r\n\r\n### ESM 문법\r\n\r\n```jsx\r\n// file1.js\r\n\r\nexport default function func1() {}\r\nexport function func2() {}\r\nexport const variable1 = 123;\r\nexport let variable2 = 'hello';\r\n\r\n// file2.js\r\nimport myFunc1, { func2, variable1, variable2 } from './file1.js';\r\n\r\n// file3.js\r\nimport { func2 as myFunc2 } from './file1.js';\r\n```\r\n\r\n- file1에서 default로 export해주는 func1() 은 가져올 때 중괄호 없이 바로 가져올 수 있다.\r\n- 반면 func2, variable1, variable2는 중괄호 안에 가져와야한다.\r\n- 가져온 후에는 `as` 로 별칭을 설정해 쓸 수 있다.\r\n\r\n## 5. create-react-app으로 시작하기💡\r\n\r\n- 이 명령어로 react 프로젝트를 시작할 때의 장점\r\n    - babel, webpack 몰라도 알아서 해준다.\r\n    - jest같은 테스트 프레임워크를 따로 사용하지 않고도 테스트를 할 수 있다.\r\n- 기타 개발 환경 구축 등을 알아서 해준다. (예전에는 create-react-app 없었음ㅠ)\r\n    - polyfill : 오래된 브라우저를 지원\r\n    - eslint : 코딩 컨벤션\r\n    - HMR (Hot Module Replacement) : 코드 수정 시 화면에 바로 적용되는 것\r\n    - CSS 후처리: sass 컴파일, 벤더 접두사 등...\r\n\r\n### Create-react-app VS Next.js\r\n\r\n- 리액트 프로젝트를 실행할 때 크게 두 가지 옵션이 있다. (더 많긴 하지만 일단 )\r\n- 이 둘의 차이 중 가장 큰 것은 Next.js는 서버사이드 렌더링을 지원하지만 create-react-app은 지원하지 않아 깔끔하게 서버사이드 렌더링을 하기 어렵다는 것이다. 따라서 서버사이드 렌더링이 필요하면 next.js를 활용하는게 훨씬 낫다.\r\n- 또 CRA는 빌드 시스템이나 eslint등의 설정을 거의 변경하기 어렵다는 것이다. Next.js는 웹팩, eslint, 바벨 등의 설정을 변경하기 쉬운 편이다.\r\n\r\n### package.json 탐방\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%201.png](/assets/img/react_1.png)\r\n\r\n- create-react-app 에서 react-scripts 명령어를 사용하는데, 만약 새로운 버전의 기능을 사용하고 싶다면 react-scripts의 버전을 바꿔주면 된다.\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%202.png](/assets/img/react_2.png)\r\n\r\n- 'polyfill이 브라우저 점유율 0.2% 이상인 브라우저들을 지원하겠다' 는 뜻\r\n\r\n### 효율적인 react의 데이터 불러오기 - 데이터가 필요한 순간 딱 불러올 수 있다.\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%203.png](/assets/img/react_3.png)\r\n\r\n이제 저 버튼을 누르면 이전에 없던 `1.chunks.js`가 추가됨.\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%204.png](/assets/img/react_4.png)\r\n\r\n```jsx\r\nfunction App() {\r\n  function onClick () {\r\n    import('./data.json').then(({default: data}) => {\r\n      console.log({data})\r\n    })\r\n  }\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.js</code> and save to reload.\r\n        </p>\r\n        <button onClick={onClick}> 데이터 보여주세요</button>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n  );\r\n}\r\n\r\n-> Promise처럼 통신 후 then 문법을 쓸 수가 있다. \r\n따라서 데이터를 import하고, 이게 성공하면 그 뒤에 데이터를 불러와 rendering할 수 있다.\r\n```\r\n\r\n기본적으로 http로 실행이 되지만 https로 실행하고 싶을 때 다음의 명령어로 실행한다.\r\n\r\n```bash\r\n// mac OS\r\n$ HTTPS=true npm start\r\n\r\n// windows OS\r\n$ set HTTPS=true && npm start\r\n```\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%205.png](/assets/img/react_5.png)\r\n\r\n### build 시 이미지 처리\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%206.png](/assets/img/react_6.png)\r\n\r\n- 빌드할 때 큰 사이즈의 이미지와 작은 사이즈 이미지의 처리가 다르다.\r\n    - 큰 사이즈 이미지는 /dist/media/라는 폴더에 이미지가 추가된다.\r\n    - 반면 작은 사이즈 이미지는 javascript파일 내부에 내장된다.\r\n    - 이렇게 하는 이유는 http요청 횟수를 줄여 성능을 향상시키기 위함이다.\r\n        - 하지만 http 2.0부터는 별로 성능 차이 없어서 다소 불필요해지긴 했다 ;;\r\n\r\n### 환경변수 관리법\r\n\r\n- development: root위치에 .env.development 파일로 관리\r\n- production: root 위치에 .env.production 파일로 관리\r\n- 접근할 때는 `process.env.{변수명}` 이런식으로 접근해서 사용할 수 있다.\r\n\r\n## 6. CSS 작성 방법 결정하기💡\r\n\r\n### 6-1. 일반 CSS파일로 작성하기\r\n\r\n```css\r\n.big {\r\n\twidth: 100%;\r\n\theight: 100px;\r\n}\r\n.small {\r\n\twidth: 50%;\r\n\theight: 50px;\r\n}\r\n```\r\n\r\n```jsx\r\n// Box.js\r\n\r\nimport './Box.css'; // 이렇게 불러올 수 있다.\r\n```\r\n\r\n- 이 방식은 여러 CSS파일에 같은 클래스명으로 정의된 것이 있으면 나중에 불러와지는 클래스명의 속성만 적용된다는 점이 있다.\r\n\r\n### 6-2. css-module로 작성하기\r\n\r\n```css\r\nBox.moduel.css\r\n\r\n```\r\n\r\n```jsx\r\nimport Style from './Button.module.css';\r\n// CSS모듈을 쓰면 이렇게 객체형태로 불러올 수가 있다.\r\n\r\n<button className={`${Style.button} ${Style.big}}>큰 버튼</button>\r\n```\r\n\r\n- 모듈 형식으로 사용하면, 여러 CSS파일 내의 클래스명이 동일하더라도 각각의 CSS 스타일을 적용받을 수 있다.\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%207.png](/assets/img/react_7.png)\r\n\r\n- 이렇게 클래스명 뒤에 해시값이 붙기 때문에 구별된다.\r\n\r\n### 6-3. sass로 작성하기\r\n\r\n> 필수요소: node-sass\r\n\r\n```bash\r\n$ npm install node-sass\r\n```\r\n\r\n```scss\r\n// Box.module.scss\r\n\r\n@import './shared.scss';\r\n\r\n.box {\r\n\theight: 50px;\r\n\tcolor: $infoColor;  // <- shared.scss에서 받아온 infoColor라는 변수값을 사용할 수 있음.\r\n}\r\n```\r\n\r\n### 6-4. css-in-js로 작성하기\r\n\r\n> CSS를 자바스크립트 내에서 만들고 사용. 모든 개발자가 JS를 다룰 수 있다면 좋은 선택이지만, 마크업 전담하시는 분이 따로 있다면 비추!\r\n\r\n```jsx\r\nconst BoxCommon = styled.div`\r\n\theight: 50px;\r\n`;\r\n\r\nconst BoxBig = styled(BoxCommon)` \r\n\twidth: 200px;\r\n`;\r\n```\r\n\r\n- 미리 만들어둔 BoxCommon을 BoxBig에서 불러와서 활용할 수 있다. 이처럼 확장해서 또 다른 컴포넌트를 만들기 쉽다는 것이 장점이다.\r\n\r\n## 7. SPA 만들기💡\r\n\r\n![section%201%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5%20676220463cf64096955da450c765587d/Untitled%208.png](/assets/img/react_8.png)\r\n\r\n### react-router-dom 라이브러리 활용해서 라우팅하기\r\n\r\n- SPA의 경우 초기화면에서 많은 파일을 불러오기 때문에 로딩이 길어질 수 있다는 단점이 있다.\r\n- 이때 react-router-dom을 사용하면 코드 분할을 이용해 페이지 단위로 불러오기 때문에 초기로딩을 줄일 수 있다.\r\n\r\n```bash\r\n$ npm install react-router-dom\r\n```\r\n\r\n```jsx\r\nimport { BrowserRouter, Link} from 'react-router-dom';\r\n\r\n<BrowserRouter>\r\n    <Link to=\"/\">Home</Link>\r\n    <Link to=\"/rooms\">Rooms</Link>\r\n</BrowserRouter>\r\n```\r\n\r\n- 이렇게 react-router-dom에서 broswerRouter와 Link를 불러오고 활용하면 라우팅을 연결할 수 있다.");

/***/ }),

/***/ "./contents/blog/react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md":
/*!*****************************************************************************!*\
  !*** ./contents/blog/react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"리액트 디자인 패턴 1. Container+Presenter\"\r\ndate: \"2021.05.04\"\r\ntags: \r\n  - react\r\n  - react-js\r\n  - 리액트\r\n  - 프론트엔드\r\n  - 디자인패턴\r\n---\r\n\r\n# 리액트 디자인 패턴 1. 컨테이너 - 프리젠터\r\n\r\n리액트에서 코드 짜는 방식은 상당히 자유로운 편이다. 권장하는 방식이 있긴 하지만 CSS스타일링에 대한 Strict한 제약은 없다.\r\n\r\n이런 자유도가 개발자에게 좋을 때도 있지만 때때로 너무 중구난방으로 코드가 작성될 가능성이 있다.\r\n\r\n이런 단점을 예방하는 방법 중 하나는 디자인 패턴을 사용하는 것이다. 오늘은 그 중 대표적인 `컨테이너 - 프리젠터` 디자인 패턴을 알아보자\r\n\r\n\r\n\r\n## :bulb: 컨테이너 프리젠터 디자인 패턴이란?\r\n\r\n데이터 처리 로직  -  데이터 출력 (디자인) **분리!**\r\n\r\n\r\n\r\n### Container컨테이너\r\n\r\n**<u>Logic</u>** : API Request, Exception Error, setState... ETC...\r\n\r\n\r\n\r\n### Presenter 프리젠터\r\n\r\nData comes from props. **<u>No logic. Only UI</u>**\r\n\r\n![디자인패턴도식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbWsxc1%2Fbtqzmk5UVvm%2FFgvzV9NbwOEvCC0mdhrkNk%2Fimg.png)\r\n\r\n\r\n\r\n## :computer: 코드로 알아보기\r\n\r\n![containerpresenter](/assets/img/containerpresenter.png)\r\n\r\n```javascript\r\nimport React from \"react\";\r\nimport HomePresenter from \"./HomePresenter\";\r\nimport { moviesApi } from \"../../api\";\r\n\r\nexport default class extends React.Component {\r\n  state = {\r\n    nowPlaying: null,\r\n    upcoming: null,\r\n    popular: null,\r\n    error: null,\r\n    loading: true\r\n  };\r\n\r\n  async componentDidMount() {\r\n    try {\r\n      const {\r\n        data: { results: nowPlaying }\r\n      } = await moviesApi.nowPlaying();\r\n      const {\r\n        data: { results: upcoming }\r\n      } = await moviesApi.upcoming();\r\n      const {\r\n        data: { results: popular }\r\n      } = await moviesApi.popular();\r\n      this.setState({\r\n        nowPlaying,\r\n        upcoming,\r\n        popular\r\n      });\r\n    } catch {\r\n      this.setState({\r\n        error: \"Can't find movies information.\"\r\n      });\r\n    } finally {\r\n      this.setState({\r\n        loading: false\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { nowPlaying, upcoming, popular, error, loading } = this.state;\r\n    return (\r\n      <HomePresenter\r\n        nowPlaying={nowPlaying}\r\n        upcoming={upcoming}\r\n        popular={popular}\r\n        error={error}\r\n        loading={loading}\r\n      />\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n");

/***/ }),

/***/ "./contents/blog/react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md":
/*!***************************************************************************************!*\
  !*** ./contents/blog/react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"react-rewired 사용해서 eject없이 CRA에babel설정 추가하기\"\ndate: \"2022.03.23\"\ntags:\n\t- babel\n\t- cra\n\t- react-rewired\n---\n\n\n\n# react-rewired 사용해서 eject없이 CRA에babel설정 추가하기\n\n\n\n## 1️⃣. 이 작업을 진행한 목적\n\nReact로 작업한 회사의 프로젝트 코드에서 Object 데이터의 값이 존재하는지 아닌지 알아 보기 위해서는 `&&` 연산자를 활용하거나 `if else` 구문을 활용해야 하는 등 코드가 다소 불필요하게 길어지는 문제가 있었습니다.\n\n해당 데이터가 존재하는 경우와 아닌 경우에 따라 rendering되는 것이 달라지기 때문에 react에서 이 component를 렌더링 하기 전에 데이터의 존재 여부를 특정 지을 수 있는 코드가 필요한 것이죠.\n\n예를 들면 다음과 같습니다.\n\n```jsx\nconst language = {\n\tname: \"javascript\",\n\tbest_friend: {\n\t\tname: \"Typescript\",\n\t}\n}\n\n{\n\tlanguage && language.best_friend && language.best_friend.name === \"Typescript\" && \n\t<h1>Hello {language.best_friend.name}</h1>\n}\n```\n\nlanguage라는 객체의 best_friend의 name값이 있는 경우에 Hello 뒤에 해당 데이터를 렌더링 하려는 경우 기존에는 위와 같은 방식으로 language안에 best_friend가 있는지를 보장하는 경우에만 렌더링 할 수 있도록 해야 했습니다.\n\n중요한 건 이 경우에 문제가 되는 것은 `name`값이 아니라 `best_friend`입니다. best_friend의 name값이 비어있더라도 react에서 렌더링하는데 문제가 없습니다. 그저 undefined를 할당하고 빈 값을 띄워주면 되니까요. 하지만 best_friend자체가 없으면 그것은 문제가 됩니다. undefiend의 “name”을 찾아오라는 잘못된 코드를 작성했기 때문이죠.\n\n### optional chaining (?)\n\n옵셔널 체이닝이라는 것은 2020년 javascript에 추가된 새로운 문법입니다. 바로 위의 language 객체와 같이 객체내부에 또다른 객체를 체이닝으로 연결할 때 발생하는 위와 같은 문제를 간편한 문법으로 해결하기 위한 기능이라 볼 수 있습니다. `?` 앞의 평가대상이 `undefined`이거나 `null`일 경우 평가를 멈추고 그 두 가지가 아닌 경우 뒤의 평가를  이어나갑니다. 옵셔널 체이닝을 활용하면 다소 지저분한 방어로직이나 외부 라이브러리를 사용할 필요없이 깔끔한 코드를 짤 수 있습니다. 아래와 같이 사용됩니다.\n\n```jsx\n{\n\tlanguage.best_friend?.name && \n\t<h1>Hello {language.best_friend.name} </h1>\n}\n```\n\n훨씬 깔끔해졌죠?\n\n주의할 점은 **옵셔널 체이닝을 남용하지 않는 것**입니다**.**\n\n`?.`는 존재하지 않아도 괜찮은 대상에만 사용해야 합니다.\n\n사용자 주소를 다루는 위 예시에서 논리상 `language`는 반드시 있어야 하는데 `best_friend`필수값이 아닙니다. 그러니 `language.best_friend?.name` 를 사용하는 것이 바람직합니다.\n\n실수로 인해 `language`값을 할당하지 않았다면 바로 알아낼 수 있도록 해야 합니다. 그렇지 않으면 에러를 조기에 발견하지 못하고 디버깅이 어려워집니다.\n\n결과적으로 이 작업을 진행하는 것은 빌드잇 프로젝트에서 이 최신 문법인 optional chaining을 활용할 수 있도록 하기 위해 설정값을 변경하는 것이 목적이었습니다.\n\n## 2️⃣. react-rewired\n\n회사의 project는 CRA(npm create-react-app buildit-co-kr-react) 명령어로 설치된 프로젝트입니다. 즉 기본적인 설정들을 직접 설정하기 보다는 자동적으로 세팅해주는 값으로 초기 프로젝트를 세팅했습니다. \n\nCRA는 빠른 프로젝트 설정을 도와준다는 장점(babel, webpack 등 사실상의 프로젝트 필수 설정)이 있지만 이러한 세팅값들을 프로젝트 디렉토리에서 쉽게 찾을 수 없게 되어 원하는대로 바꿀 수 없다는 단점이 있습니다. 이 CRA 설정을 깨고 다시 설정하는 것을 `eject`라 표현하는데 이렇게 하면 CRA의 장점인 (**one Build Dependency**)가 깨지게 됩니다. 따라서 eject하면 서로간의 dependency가 어떻게 꼬일 지 아는 것이 어렵다는 단점이 있습니다.\n\n![eject는 뭔가 두렵다](/assets/img/eject.png)\n\n(음... eject는 뭔가 두렵다)\n\n### react-rewired의 장점\n\nreact-rewired는 `eject`를 하지 않고 CRA의 설정값을 바꾸도록 도와주는 라이브러리 입니다.\n\n최대한 CRA 설정을 그대로 유지한채 특정 부분만 Custom하는 것을 도와줍니다.\n\n[https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired)\n\n### react-rewired의 단점\n\n하지만 아무리 react-rewired를 사용한다해도 CRA가 제공하는 기능을 완전히 provide하지는 않습니다.\n\n⚠️ **Please Note:**\n```\n💡 \"Stuff can break\" - Dan Abramov\n```\n\n> By doing this you're breaking the \"guarantees\" that CRA provides. That is to say you now \"own\" the configs. No support will be provided. Proceed with caution.\n\nUsing this library will override the default behavior and configuration of `create-react-app`\n, therefore invalidating the guarantees that come with it. Use with discretion!\n\n\n\n## 3️⃣. 작업 진행\n\n### 1. react-rewired\n\n#### 설치\n\n```bash\n$ npm install react-app-rewired --save-dev\n```\n\n#### 프로젝트 root 디렉토리에 ****`config-overrides.js` 설정**\n\n```jsx\n/* config-overrides.js */\n\nmodule.exports = function override(config, env) {\n  //do stuff with the webpack config...\n  return config;\n}\n```\n\n#### `package.json` 파일에서 scripts 부분 명령어 수정\n\n```jsx\n\"scripts\": {\n-   \"start\": \"react-scripts start\",\n+   \"start\": \"react-app-rewired start\",\n-   \"build\": \"react-scripts build\",\n+   \"build\": \"react-app-rewired build\",\n-   \"test\": \"react-scripts test\",\n+   \"test\": \"react-app-rewired test\",\n    \"eject\": \"react-scripts eject\"\n}\n```\n\n### 2. Customize-cra\n\n[customize-cra](https://www.npmjs.com/package/customize-cra)\n\n#### 설치\n\n```bash\n$ npm i customize-cra\n```\n\n#### `config-overrides.js` 설정 Override\n\n```jsx\nconst { override, useBabelRc } = require('customize-cra');\n\nmodule.exports = override(useBabelRc());\n```\n\n- babelrc 설정을 사용하기 위해 config-overrides.js의 설정을 변경해줍니다.\n\n### 3. babel 플러그인 “plugin-proposal-optional-chaining”\n\n#### 설치\n\n```bash\n$ npm install --save-dev @babel/plugin-proposal-optional-chaining\n```\n\n#### .babelrc\n\n```jsx\n{\n  \"plugins\": [\"@babel/plugin-proposal-optional-chaining\"]\n}\n```\n\n이제 ***optional chaining***을 쓸 수 있습니다.✌️\n\n\n\n다음에는 react-rewire를 하지 않고 직접 nodejs 버전과 react-scripts, 그리고 다른 라이브러리와의 의존성 문제를 해결한 내용을 업로드 하겠습니다.\n\n---\n\n참고\n\n[https://github.com/arackaf/customize-cra](https://github.com/arackaf/customize-cra)\n\n[Micalgenus](https://micalgenus.github.io/articles/2019-02/React-eject-%EC%97%86%EC%9D%B4-babelrc-%EC%A0%81%EC%9A%A9)\n\n[@babel/preset-react · Babel](https://babeljs.io/docs/en/babel-preset-react)\n\n[@babel/plugin-syntax-optional-chaining · Babel](https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture)");

/***/ }),

/***/ "./contents/blog/react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md":
/*!***************************************************************!*\
  !*** ./contents/blog/react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"CRA없이 리액트 프로젝트 설정하기\"\ndate: \"2022.04.01\"\ntags:\n  - react\n  - cra\n  - create-react-app\n---\n\n\n## 1. CRA (Create-React-App)없이 리액트 프로젝트 설정하기\n\n### CRA를 사용하는 이유?\n\n- 프로젝트 세팅을 위해 따로 학습할 필요가 없습니다.\n- 고민하지 않고 빠르게 설정할 수 있습니다.\n- 세팅보다는 코드에 좀 더 고민할 시간을 마련할 수 있습니다.\n- 잘 안쓰는 파일들을 굳이 생성하지 않아서 따로 지울 필요가 없습니다.\n\n### CRA에서 세팅해주는 내용은 무엇이 있을까?\n\n- 웹팩\n- 바벨\n- eslint\n\n​\t외 기타 등등\n\nCRA 명령어 없이 웹팩과 바벨 설정만으로 localhost로 리액트 프로젝트를 띄워보겠습니다.\n\n\n\n## 2. CRA없이 React Project를 세팅해보기\n\n<aside>\n💡 맹목적인 CRA의존을 하지 않고 직접 리액트 프로젝트를 세팅해보면서 프로젝트를 시작할 때 프로젝트의 목적에 가장 잘 부합하는 세팅을 진행할 수 있는 것이 목표.\n</aside>\n\n\n### 1. 프로젝트 시작하기\n\n```bash\n$ mkdir no-cra\n$ cd no-cra\n$ no-cra > npm init -y\n$ no-cra > mkdir src public\n$ no-cra > cd src\n$ no-cra > src > touch index.js index.css\n$ no-cra > public > touch index.html\n```\n\n- no-cra\n  - public\n    - index.html\n  - src\n    - index.js\n    - index.css\n  - package.json\n\n### 2. npm 패키지 설치\n\n```bash\n$ no-cra > npm i react react-dom\n$ no-cra > npm i webpack webpack-cli webpack-dev-server\n$ no-cra > npm i babel-loader css-loader style-loader\n$ no-cra > npm i @babel/core @babel/preset-react @babel/preset-env\n$ no-cra > npm install --save-dev html-webpack-plugin\n$ no-cra > npm install --save-dev clean-webpack-plugin\n```\n\n### 3. babel 설정 코드 작성\n\n```jsx\n// babel.config.js \nmodule.exports = {\n    presets: ['@babel/preset-env', '@babel/preset-react'] \n}\n```\n\n### 4. webpack 설정 코드 작성\n\n```jsx\n// webpack.config.js\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst path = require('path');\n\nmodule.exports = {\n    mode: process.env.mode,\n    entry: './src/index.js',\n    output: {\n      path: path.resolve(__dirname, 'dist'),\n      filename: '[hash].js',\n      publicPath: '/'\n    },\n    resolve: {\n      // path.resove 형태로 사용할 수도 있다.\n      // 그러면 node의 기본 모듈 'path'를 불러와야 한다.\n      extensions: ['.js', '.jsx', '.css']\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.(js|jsx)$/,\n                exclude: '/node_modules/',\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: 'style-loader', \n                    },\n                    {\n                        loader: 'css-loader', \n                    },\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new CleanWebpackPlugin(),\n        new HtmlWebpackPlugin({\n            template: './public/index.html'\n        })\n    ],\n    devServer: {\n        host: 'localhost',\n        port: 3000,\n        hot: true,\n        open: true\n    }\n};\n```\n\n\n\n### 5. package.json\n\n```javascript\n{\n  \"name\": \"no-cra\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start:dev\": \"webpack serve --progress --mode development\",\n    \"start:build\": \"webpack\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"@babel/core\": \"^7.17.8\",\n    \"@babel/preset-env\": \"^7.16.11\",\n    \"@babel/preset-react\": \"^7.16.7\",\n    \"babel-loader\": \"^8.2.4\",\n    \"css-loader\": \"^6.7.1\",\n    \"react\": \"^17.0.2\",\n    \"react-dom\": \"^17.0.2\",\n    \"style-loader\": \"^3.3.1\",\n    \"webpack\": \"^5.70.0\",\n    \"webpack-cli\": \"^4.9.2\",\n    \"webpack-dev-server\": \"^4.7.4\"\n  },\n  \"devDependencies\": {\n    \"clean-webpack-plugin\": \"^4.0.0\",\n    \"html-webpack-plugin\": \"^5.5.0\"\n  }\n}\n\n```\n\n\n\n이렇게 설정하고서 `npm run start:dev` 명령어를 입력해주시면 로컬에서 리액트 프로젝트를 실행해볼 수 있습니다.\n\n\n\n---\n\n[[Co'Talk] Create-React-App 없이 리액트 프로젝트 시작하기 - 코드스테이츠 강한결 교육 매니저](https://www.youtube.com/watch?v=wSzh8iSdYUQ)\n\n[Create-React-App 없이 리액트 프로젝트 보일러 플레이스 세팅하기](https://hankyeolk.github.io/2021/08/08/withoutCRA.html)\n\n");

/***/ }),

/***/ "./contents/blog/react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md":
/*!*******************************************************************!*\
  !*** ./contents/blog/react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"리액트 콘솔창 에러 그대로 놔두고 계신가요?\"\ndate: \"2022.10.07\"\ntags:\n  - 리액트\n  - 콘솔\n  - 에러\n---\n\n\n\n# 리액트 console warning, error 제거하기\n\n평소 개발할 때 마다 켜는 크롬개발자도구의 콘솔창에는 수 많은 에러와 경고 메시지가 뜨고 있었습니다. 개발자를 도와주는 고마운 메시지들이지만 사실 볼 때 마다 좀 꼴뵈기 싫었다고(?) 표현하는게 가장 저의 정확한 심정이었습니다. 짬이 좀 나면 검도 9단이 대나무 썰듯이 썰어보겠다고 다짐만 했었다가 드디어 기다리던 기회가 와서(짬이 나서;) 한 번 처리해봤습니다.\n\n![에러 메시지를 썰기 전 나의 상상 속 내 모습 ;](https://cdn-ak.f.st-hatena.com/images/fotolife/g/gaou2/20170611/20170611020308.gif)\n\n에러 메시지를 썰기 전 나의 상상 속 내 모습 ;\n\n## 현상황\n\n![BUILDIT-error](/assets/img/BUILDIT-error.png)\n\n![BUILDIT-error1](/assets/img/BUILDIT-error1.png)\n\n## Error 해결\n\n### 1. MuiThemeProvider\n\n```tsx\n// Error log\n\nWarning: Failed prop type: The prop `theme` is marked as required in `MuiThemeProviderOld`, but its value is `undefined`.\n```\n\n```tsx\nconst jss = create(jssPreset());\n\nfunction withRoot(Component) {\n  function WithRoot(props) {\n    // JssProvider allows customizing the JSS styling solution.\n    return (\n      <JssProvider jss={jss} >\n        {/* MuiThemeProvider makes the theme available down the React tree\n          thanks to React context. */}\n        <MuiThemeProvider>\n          {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n          <CssBaseline />\n          <Component {...props} />\n        </MuiThemeProvider>\n      </JssProvider>\n    );\n  }\n\n  return WithRoot;\n}\n```\n\n```\nconst jss = create(jssPreset());\nconst theme = createMuiTheme({})\n\nfunction withRoot(Component) {\n  function WithRoot(props) {\n    // JssProvider allows customizing the JSS styling solution.\n    return (\n      <JssProvider jss={jss} >\n        {/* MuiThemeProvider makes the theme available down the React tree\n          thanks to React context. */}\n        <MuiThemeProvider theme={theme}>\n          {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n          <CssBaseline />\n          <Component {...props} />\n        </MuiThemeProvider>\n      </JssProvider>\n    );\n  }\n\n  return WithRoot;\n}\n```\n\n- MuiThemeProvider 에 theme 속성을 undefined로 주고 있기 때문에 발생한 에러였습니다.\n- theme에 createMuiTheme 메소드를 통해 만든 객체를 넣어줘서 해결했습니다.\n\n## 2. MuiInputLabel\n\n```tsx\n// Error log\n\nWarning: Material-UI: the `MuiInputlabel` component increases the css specificity of the `focused` internal state. you can not override it like this ...\n```\n\n```tsx\nconst darkTheme = createMuiTheme({\n  overrides: {\n\t\t...\n    MuiInputLabel: {\n      root: {\n        color: \"#ccc\",\n        fontSize: \"12px\",\n        marginTop: -3,\n      },\n      focused: {\n        display: \"none\",\n      },\n      shrink: {\n        display: \"none\",\n      },\n    },\n    MuiInput: {\n      underline: {\n        \"&:hover\": {\n          \":&before\": {\n            borderBottom: \"1px solid #ccc\",\n          },\n          margin: \"0 !important\",\n          borderBottom: \"1px solid #ccc\",\n        },\n        \"&:after\": {\n          borderBottom: \"1px solid #ccc\",\n        },\n      },\n    },\n  },\n});\n```\n\n- 불필요한 override theme 객체를 삭제하여 해결했습니다.\n\n### 3. Warning: Received `false` for a non-boolean attribute `display`.\n\n> 이 warning은 styled component에서 자주 발생하는 오류이다. html,css element 속성 중에서 non-boolean attributes에 boolean속성을 넘겨줘서 발생하는 오류인데, 예를 들면 img 태그의 src에 string타입이 와야 맞지만 boolean이나 숫자를 넣는 경우 발생할 수 있다.\n> 현재 타이틀 메시지는 boolean값이 아닌 display에 true/false 등의 boolean을 넣었다고 해서 에러메시지를 뿜고 있는 것이다. \n> 참고.\n> [https://mygumi.tistory.com/382](https://mygumi.tistory.com/382)\n\nIf you used to conditionally omit it with display={condition && value}, pass display={condition ? value : undefined} instead.\n\n→ display를 조건부로 변경하고 싶다면 && 연산자를 사용하기보다는 삼항연산자를 사용할 것을 권장하고 있다.\n\n하지만 모든 styled컴포넌트의 display를 살펴봤는데 모든 곳에서 display 속성에 삼항연산자로 제대로 설정이 되어있었습니다.\n\n![뭐지? 트릭인가?](https://d3kxs6kpbh59hp.cloudfront.net/community/COMMUNITY/598060f2ac1843b1ba8979f4ed292de2/abd9f49cdf72485a8d5cb892bce85937_1617101551.jpg)\n\n뭐지? 트릭인가?\n\n문제 원인은 Banner 컴포넌트의 display 속성 이었습니다. 삼항연산자가 해결의 키는 아니었던 것이죠.\n\n```tsx\n<Banner\n  onClose={() => {\n    this.setState({ showBanner: false });\n    localStorage.setItem('showBanner', 'false');\n  }}\n  display={this.state.showBanner!}\n  href=\"/myPage/information\"\n  buttonContent=\"결제 수단 변경하기\"\n  icon={<ErrorOutline />}\n  content={`정기구독 자동결제가 실패했습니다. 결제 수단을 변경 부탁드립니다! \n  결제수단 변경 전까지 새 프로젝트를 시작할 수 없으며 ${moment(App.session.plan_finished_at).add(8, 'days').format('YYYY-MM-DD')} 23:59:59 까지 실패 시 자동으로 플랜이 해지됩니다.`} />\n```\n\n- 위 배너 컴포넌트는 showBanner state값에 따라서 display를 하느냐 마느냐가 결정됩니다.\n- 아마도 이 컴포넌트를 짜신 분께서 해당 props에 따라서 css의 display속성을 변경하므로 그대로 display attributes를 사용하셨던 것 같습니다. 하지만 display라는 동일한 이름의 attributes가 있어서 이 부분에서 에러를 발생시키는 문제가 있었습니다. display는 불리언 타입이 아니기 때문이죠.\n- 이 코드를 display={~} ⇒ show={~}로 attributes의 이름을 변경해주어 해결했습니다. (적으면서 다시 생각해보니 isShow로 이름을 지을걸 하는 후회가 살짝 되네요)\n\n### 4. each child in a list should have a unique key prop\n\n이 에러는 리액트에서 상당히 자주 나오는 에러로 map 반복문으로 render할 경우 해당 element에 고유한 key값을 넣어달라는 뜻이니 넣어주어 해결할 수 있습니다.\n\n### 5. index.js:1420 Warning: BuilditInput contains an input of type text with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props.\n\nhtml `input` 태그의 defaultValue는 string | string[] | undefined 타입입니다. 하지만 defaultValue가 props로 내려오지 않는 경우 “”로 빈 스트링을 넣도록 하였는데 이 경우에는 오히려 undefined로 선언하는 것이 더 적절합니다. 따라서 undefined로 수정하여 해결했습니다.\n\n![BUILDIT-error2](/assets/img/BUILDIT-error2.png)\n\n- “” 대신 undefined로 타입스크립트 타입 오류를 제거하였습니다.\n\n### 6. **Warning: React does not recognize the XXX prop on a DOM element**\n\n![BUILDIT-error3](/assets/img/BUILDIT-error3.png)\n\n> 참고: \n> **[How to solve Warning: React does not recognize the X prop on a DOM element](https://stackoverflow.com/questions/54468535/how-to-solve-warning-react-does-not-recognize-the-x-prop-on-a-dom-element)** \n> [https://ko.reactjs.org/warnings/unknown-prop.html](https://ko.reactjs.org/warnings/unknown-prop.html)\n\n올바른 DOM 어트리뷰트/프로퍼티로 인식되지 않는 DOM 엘리먼트를 렌더링하려고 하면 unknown-prop 경고가 발생합니다. DOM 엘리먼트에 잘못된 props가 추가되지 않도록 해야 합니다. 하지만 borderRadius, justifyContent와 같은 코드가 있으면 리액트에서 이런 에러를 내뱉습니다. 따라서 다음과 같이 (borderradius, justifycontent) 소문자로 변경해주면 해결할 수 있습니다.\n\n## Warning 해결\n\n### 1. componentWillReceiveProps, componentWillmount 라이프사이클 변경하기\n\n```tsx\nWarning: componentWillMount has been renamed, and is not recommended for use.\n\nWarning: componentWillReceiveProps has been renamed, and is not recommended for use\n```\n\n- 이전에도 봤던 경고 메시지입니다. componentWillmount, componentWillRecieveProps같은 라이프사이클은 다음버전의 리액트에서는 더 이상 쓰이지 않으니 변경해달라는 내용입니다.\n\n- `npx react-codemod rename-unsafe-lifecycles` 명령어로 모두 UNSAFE_ prefix를 앞에 달아줬습니다. 하지만 안타깝게 그럼에도 불구하고 이 메시지가 계속 뜨고 있습니다.\n\n- [https://stackoverflow.com/questions/58769752/componentwillmount-warnings-visible-even-though-componentwillmount-is-not-ex](https://stackoverflow.com/questions/58769752/componentwillmount-warnings-visible-even-though-componentwillmount-is-not-ex)\n\n  - 여기 답변을 살펴보면 You're getting this warning because `componentWillMount`\n    is deprecated in newer React versions. If you're not using `componentWillMount`\n     anywhere then one of your libraries is and it needs to be updated.\n\n     즉, 프로젝트 내부 코드가 아닌 다른 라이브러리의 예전 버전에서 이 hook들을 사용하고 있기 때문에 발생하는 메시지라는 내용이네요. 그래서 해당 라이브러리의 버전을 같이 올려서 해결할 수 있다고 합니다.\n\n     어떤 라이브러리인지도 모르고, 해당 라이브러리 버전을 올렸다가 충돌이 날 수도 있어 이 warning 메시지는 그대로 두는게 좋겠습니다.\n\n### 2. react.development.js:217 Warning: React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\n\n- 이 에러메시지도 위의 1번과 비슷한 현상때문에 발생하는 것으로 파악됩니다. 현 코드에서 React.createFactory() 라는 코드를 사용하는 곳이 없는데 이 기능이 곧 사라지니까 바꾸라는 걸로 봐서는 라이브러리 내에서 활용하고 있는 것으로 볼 수 있겠습니다.\n\n### 3. maps.js?ncpClientId=nhthwdjbzm&submodules=geocoder,drawing,stylemap:15 A parser-blocking, cross site (i.e. different eTLD+1) script, [https://openapi.map.naver.com/openapi/v3/maps-geocoder.js](https://openapi.map.naver.com/openapi/v3/maps-geocoder.js), is invoked via document.write. The network request for this script MAY be blocked by the browser in this or a future page load due to poor network connectivity. If blocked in this page load, it will be confirmed in a subsequent console message. See [https://www.chromestatus.com/feature/5718547946799104](https://www.chromestatus.com/feature/5718547946799104) for more details.\n\n- 이 이슈는 네이버 뿐만 아니라 카카오 지도 로드 시에도 발생하는 문제인 것 같은데, 용량이 큰 라이브러리를 로드할 때 그 라이브러리 내에 document.write이 들어있으면 나머지 html parsing이나 JS를 block하여 흰화면이 오래 나올 수 있습니다. 이러면 사용자는 오류라고 느낄 수 있는데요 특히나 느린 네트워크 환경에서는 정도가 더 심할 것입니다. 때문에 크롬에서 주의하라고 알려주는 내용입니다.\n\n- [https://github.com/navermaps/maps.js/issues/298](https://github.com/navermaps/maps.js/issues/298) 에는 네이버에서 답변한 내용이 있는데 해결에 도움이 되지 않습니다.\n\n- [https://devtalk.kakao.com/t/topic/53763](https://devtalk.kakao.com/t/topic/53763) 에 있는 카카오의 답변에 따르면 지도가 뜬다면 그닥 큰 문제는 아니니 무시해도 괜찮다고 합니다. 카카오가 직접 무시해도 된다고 하니 좀 안심(?)이 되긴 하네요. 아무튼 이 warning도 무시하고 넘어갑니다.\n\n  ![BUILDIT-error4](/assets/img/BUILDIT-error4.png)\n\n## 결과\n\n![BUILDIT-error5](/assets/img/BUILDIT-error5.png)\n\n콘솔창이 완전히 깨끗해지지는 않았지만 그래도 한 페이지 내로 줄어들었습니다.\n\n이제 스스로 해결할 수는 없거나 무시해도 되는 메시지들과 내부 API 오류만 남았네요. 모든 페이지를 브루트포스하게 탐색하지는 않았기 때문에 다른 라우트들을 돌아다니며 확인해보고 처음 보는 오류메시지이면 추가하도록 하겠습니다🙏\n\n\n\n\n\n");

/***/ }),

/***/ "./contents/blog/testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md":
/*!******************************************************************!*\
  !*** ./contents/blog/testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"Jest로 리액트에서 유닛 테스트 하기\"\ndate: \"2022.07.08\"\ntags:\n  - javascript\n  - test\n  - jest\n  - tdd\n---\n\n# React Test (1) Unit test\n\n## Test 환경 설정 - JEST\n\n`CRA`를 하면 자동으로 설치해주는 jest로 시작해보자. jest는 jasmine 기반 테스팅라이브러리이다. \n\n이 외에도 mocha, Karma 등 다양한 [테스팅 라이브러리간 비교](https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a) 글을 읽고 싶으면 링크를 클릭해보자.\n\n\n\nCRA로 만든 react 프로젝트에서 jest를 테스트 해볼 예정이다. 귀찮으면 이미 해놓은 아래 프로젝트를 클론하면서 따라해보자.\n\n```bash\n$ git clone https://github.com/likelionSungGuk/todolistRTKtypescript.git\n```\n\n\n\n## :one: Matchers\n\n### 1. toBe\n\n```javascript\n// fn.js\nexport const fn = {\n  add: (num1, num2) => num1 + num2,\n  makeUser: (name, age)=> ({\n    name,\n    age\n  })\n}\n```\n\n```javascript\n// fn.test.js\n\ntest('a + b =', ()=> {\n  // fn.add(1, 2)를 하면 3이 될거라 기대한다.\n  expect(fn.add(1, 2)).toBe(3)\n})\n```\n\n위 처럼 test의 첫번째 인자는 화면에 표시될 텍스트를 넣어주면 된다. 두 번째 인자에는 콜백함수를 열어주고 그 안에서 expect().`matchers` 형식으로 써준다. 여기서 살펴볼 `toBe` matcher는 expect내부의 값이 나타낼 기대값을 의미한다. 결과가 toBe내부와 같다면 true로 테스트를 통과한다.\n\n\n\n:bulb: 간단 Tip!\n\n>  가장 처음에 쓰는 `test`는 `it`으로 써도 똑같이 동작한다. 영어 문장에서 `it`으로 쓰면 하나의 완결된 문장을 만들기 쉽기 때문에 it으로도 쓰는 경향이 있다고 한다. 둘 중 취향에 따라 골라 쓰자!\n\n\n\n### 2. toEqual / toStrictEqual\n\n```javascript\ntest('make user: 이름과 나이를 전달받아서 객체를 반환', ()=>{\n  expect(fn.makeUser(\"Mike\", 25)).toEqual({\n  // expect(fn.makeUser(\"Mike\", 25)).toBe({ // X\n    name: \"Mike\",\n    age: 25\n  })\n})\n```\n\n이렇게 객체를 만드는 경우에는 toBe를 쓰면 false가 나온다. `객체는 depth가 깊을 수 있기 때문에` 재귀적으로 타고 들어가는 `toEqual/toStrictEqual`을 toBe대신 써줘야 한다.\n\n\n\n### 3. 기타 jest matcher들\n\n위 두 가지 외에도 다양한 matcher들이 있다. 활용법들을 한 번 쭉 살펴보는 것이 좋지만 이 글에서는 소개만 하고 넘어간다.\n\n1. Boolean \n\n    - toBeNull\n\n    - toBeUndefined\n\n    - toBeDefined\n\n\n2. Falsy/Truthy\n\n    - toBeFalsy\n\n    - toBeTruthy\n\n\n3. 대소비교\n\n    - toBeGreaterThan (크다)\n\n    - toBeGreaterThanOrEqual (크거나 같다)\n\n    - toBeLessThan\n\n    - toBeLessThanOrEqual\n\n\n4. epsilon check\n    - toBeCloseTo // ex: add(0.1, 0.2).toBeCloseTo(0.3) -> true (toBe(0,3) -> false)\n\n\n\n\n\n## :two: Describe\n\n`describe` 라는 키워드를 사용하면 여러 테스트 케이스를 묶을 수 있습니다. \n\n'sum' 이라는 공통 키워드로 묶을 수 있는 테스트의 경우 describe 키워드를 사용해 하나로 묶어서 테스트할 수 있습니다.\n\n```javascript\n// sum.js\nfunction sum(a, b) {\n  return a + b;\n}\n\nfunction sumOf(numbers) {\n  let result = 0;\n  numbers.forEach(n => {\n    result += n;\n  });\n  return result;\n}\n\n// 각각 내보내기\nexports.sum = sum;\nexports.sumOf = sumOf;\n```\n\n```javascript\n// sum.test.js\nconst { sum, sumOf } = require('./sum');\n\ndescribe('sum', () => {\n  it('calculates 1 + 2', () => {\n    expect(sum(1, 2)).toBe(3);\n  });\n\n  it('calculates all numbers', () => {\n    const array = [1, 2, 3, 4, 5];\n    expect(sumOf(array)).toBe(15);\n  });\n});\n```\n\n![describe로 테스트하면 하나로 묶어준다.](https://i.imgur.com/CP1J77P.png)\n\n\n\n### sumOf 함수 리팩토링해서 테스트코드의 진수 맛보기\n\n```javascript\n// sum.js\nfunction sum(a, b) {\n  return a + b;\n}\n\nfunction sumOf(numbers) {\n  return numbers.reduce((acc, current) => acc + current, 0);\n}\n\n// 각각 내보내기\nexports.sum = sum;\nexports.sumOf = sumOf;\n```\n\n위와 같이 reduce를 사용해서 sumOf를 리팩토링한 후 그대로 테스트를 돌리면 통과한다. 이렇게 코드를 리팩토링해도 테스트가 있다면 품질을 보장할 수 있다는 것이 장점이다.\n\n\n\n\n\n## :three: 비동기 함수의 경우 어떻게 테스트를 할 수 있을까?\n\n### 1. done() \n\n```javascript\n// fn.js\nexport const fn = {\n  ...,\n  getName: (callback) => {\n    const name = \"Mike\";\n    setTimeout(()=> {\n      callback(name)\n    }, 3000);\n  }\n}\n```\n\n```javascript\n// fn.test.js\nit('name is Mike', (done) => {\n  fn.getName((name) => {\n    expect(name).toBe(\"Mike\");\n    done();\n  });\n})\n```\n\n여기서 done을 쓰지 않으면 어떻게 될까?\n\n```bash\nPASS  src/components/__tests__/fn.test.js\nPASS  src/components/__tests__/TodoList.test.js\n\nTest Suites: 2 passed, 2 total\nTests:       5 passed, 5 total\nSnapshots:   1 passed, 1 total\nTime:        2.715 s\n\nRan all test suites related to changed files.\n\nWatch Usage: Press w to show more.\n\n```\n\nsetTimeout을 3000ms 로 줬는데도 불구하고 2.715s 만에 테스트가 끝나버렸다. 결과는 그냥 PASS.\n\n해당 콜백을 기다리지 않고 지나쳤기 때문인데, 이 때문에 `done()`을 활용한다. \n\ndone()에 도착하기 전까지의 동작을 전부 기다리다가 done에 도착하면 끝난다.\n\n\n\n### 2. Promise resolve\n\n(1) then\n\n```javascript\n// fn.js\nexport const fn = {\n...,\n  getName: (callback) => {\n    const name = \"Mike\";\n    setTimeout(()=> {\n      callback(name)\n    }, 3000);\n  },\n  getAge: () => {\n    const age = 30;\n    return new Promise((resolve, reject) => {\n      setTimeout(()=> {\n        resolve(age)\n      }, 3000);\n    })\n  }\n}\n```\n\n```javascript\n// fn.test.js\nit('age is 30', () => {\n  // async 2. Promise()\n  return fn.getAge().then( age => {\n    expect(age).toBe(30);\n  });\n})\n```\n\nfn.getAge()함수는 Promise객체를 리턴해준다. 해당 함수의 return 값을 받아야 하기 때문에 테스트 함수에서도 return을 받아줘야 한다.\n\n\n\n(2) Matcher 활용 - resolves\n\n```javascript\n// fn.test.js\nit('age is 30', () => {\n  // async 2. Promise()\n    return expect(fn.getAge()).resolves.toBe(30)\n  });\n})\n```\n\n위와 같이 `resolves` matcher를 활용해서 좀 더 간단히 작성할 수 있다.\n\n\n\n### 3. async / await\n\n```javascript\n// fn.test.js\nit('age is 30', async () => {\n  // async 3. async/await\n\tawait expect(fn.getAge()).resolves.toBe(30)\n});\n```\n\n역시나 async/await을 사용하면 가장 간단하게 비동기처리를 할 수 있다.\n\n\n\n## :four: 테스트 전/후 처리\n\n### beforeEach / afterEach\n\n```javascript\n// fail\nlet num = 1; \ntest('1+1 = 2', () => {\n  num = fn.add(num, 1)\n  expect(num).toBe(2)\n})\ntest('1+2 = 3', () => {\n  fn.add(num, 2)\n  expect(num).toBe(3)\n})\n```\n\n이 경우 num 이 매 테스트마다 재할당되면서 두번째 테스트가 실패하게 된다.\n\n이럴 때는 모든 테스트 이전에 num을 1로 지정해주는 matcher인 beforeEach를 활용하면 된다.\n\n```javascript\n// success!!\nlet num;\nbeforeEach(()=>{\n  num = 1;\n})\ntest('1+1 = 2', () => {\n  num = fn.add(num, 1)\n  expect(num).toBe(2)\n})\ntest('1+2 = 3', () => {\n  num = fn.add(num, 2)\n  expect(num).toBe(3)\n})\n```\n\n- afterEach는 모든 테스트 직후에 실행되는 로직이다.\n- 첫 num값만 다르게 주고 싶은 경우에 활용할 수 있다.\n\n\n\n### beforeAll / afterAll\n\n만약 각각의 테스트 전/후에 해둬야 할 작업이 중복되면서 꽤 시간이 걸리는 작업이라면 이런 경우에는 beforeAll/afterAll 을 활용해서 테스트 전/후에 한 번만 해두고 테스트가 끝날때까지 유지할 수 있다.\n\n```javascript\n// fn\nexport const fn = {\n ...\n  connectUserDB: () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(()=> {\n        resolve({\n          name: \"Mike\",\n          age: 30\n        })\n      }, 3000)\n    })\n  },\n  disConnectUserDB: () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(()=> {\n        resolve()\n      }, 3000)\n    })\n  }\n}\n```\n\nuser DB를 연결하는 상황이라 가정해보자. user DB에 연결하는데 3초, disconnect하는데 3초가 걸린다. 이걸 beforeEach, afterEach로 매 테스트마다 초기화 한다면 매우 비효율적이다. afterAll과 beforeAll을 테스트가 전부 실행되기 전과 전부 실행되고 나서 한 번씩 실행되는 matcher이므로 아래와 같이 사용하면 된다.\n\n```javascript\nlet user;\nbeforeAll(async()=>{\n  user = await fn.connectUserDB();\n})\n\nafterAll(async () => {\n  return await fn.disConnectUserDB();\n})\n\ntest('User name is Mike', () => {\n  expect(user.name).toBe(\"Mike\")\n})\ntest('Mike is 30', () => {\n  expect(user.age).toBe(30)\n})\n```\n\n\n\n\n\n## :five: Mock함수\n\n```javascript\nconst mockCallback = jest.fn(x => 42 + x);\nforEach([0, 1], mockCallback);\n\n// The mock function is called twice\nexpect(mockCallback.mock.calls.length).toBe(2);\n\n// The first argument of the first call to the function was 0\nexpect(mockCallback.mock.calls[0][0]).toBe(0);\n\n// The first argument of the second call to the function was 1\nexpect(mockCallback.mock.calls[1][0]).toBe(1);\n\n// The return value of the first call to the function was 42\nexpect(mockCallback.mock.results[0].value).toBe(42);\n```\n\n\n\nmock함수는 왜 사용하는 것일까?\n\n예를 들어 createUser함수가 있다고 가정해보자. 이 함수가 실행되면 db에 실제로 유저가 생성된다. createUser함수를 테스트하기 위해서 createUser함수를 호출한다면 원치않는 유저가 DB에 계속 생성될 수 있다. 때문에 createUser함수를 모방한 함수(mockCreateUser)를 하나 만들어서 모방한 함수가 테스트를 잘 통과하면 createUser도 무사히 통과될 것이라 예상할 수 있다.\n\n\n\n```javascript\n//\njest.mock('../fn')\nfn.connectUserDB().mockReturnValue({name: \"Mike\", age: 30})\n\ntest('test', async ()=>{\n  const user = await fn.connectUserDB();\n  expect(user.name).toEqual(\"Mike\");\n})\n```\n\n\n\n\n\n\n\n---\n\nreferences.\n\nhttps://learn-react-test.vlpt.us/#/01-javascript-testing\n\nhttps://www.youtube.com/playlist?list=PLZKTXPmaJk8L1xCg_1cRjL5huINlP2JKt\n");

/***/ }),

/***/ "./contents/blog/vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md":
/*!********************************************************************************!*\
  !*** ./contents/blog/vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기\"\r\ndate: \"2021.02.09\"\r\ntags: \r\n  - AWS\r\n  - Lambda\r\n  - Vuejs\r\n  - javascript\r\n  - email\r\n---\r\n\r\n\r\n# 보고 그대로 따라하기 쌉가능\r\n\r\n## 0. 이 문서를 작성하는 이유\r\n\r\n(요약: 블로그 잘못 읽으면 골로간다...)\r\n\r\n![작성이유](/assets/img/Untitled 2.png)\r\n\r\n처음 이메일 기능을 넣으려 했을 때 한 블로거의 글을 읽었습니다. 마지막 멘트까지 살펴본 결과 '아 그대로 따라하면 쉽게 할 수 있겠구나', '이 정도면 얼마 안걸리겠다' 생각하고 착수했습니다. \r\n하지만 이 글은 AWS Lambda 사용에 포커스를 맞추고 이메일링에 대해서는 크게 설명하지 않았습니다. \r\n때문에 오히려 이 블로그글을 보고 따라하다가 중간중간 많은 내용들이 생략되어 있어서 오히려 많이 헤맸습니다.\r\n믿고 그대로 따라했다가 삽질을 많이 했지만, 이제는 오히려 이 목적을 직접 달성하기 위해 다시 글을 작성하게 되었습니다.\r\n\r\n![기성룡좌 짤](https://ppss.kr/wp-content/uploads/2013/07/20130402_025303.png)\r\n\r\n(~~답답하면 니가 직접 뛰던가~~ ~~ )\r\n\r\n`AWS lambda, AWS SES, nodemailer, Vuejs를 활용한 이메일 전송 기능`에 대해 이 글만 보고 따라해도 충분할 정도로 정리해보겠습니다.\r\nGo Go Go!\r\n\r\n\r\n\r\n\r\n## 1. 왜 AWS lambda를 사용해야 할까?\r\n\r\n메일 기능... 간단한 것 같으면서도 그렇게 간단하지만은 않은 기능.\r\n\r\n이걸 EC2에 올려서 메일 전송만 해주기에는 너무 리소스 낭비이고, 그렇다고 프론트에서 정적으로 동작하게만 만드는 것도 애매하다.\r\n\r\n이럴 때 쓰라고 있는게 `AWS의 Lambda 기능`이다.\r\n\r\n> AWS lambda란 간단히 말해서 '함수' 단위의 deploy이다.\r\n\r\n어떤 이벤트가 발생했을 때에만 필요한 함수들은 클라우드 서버에 deploy하면 시간당 과금을 묻게된다. 이 경우 서버 호출이 자주 발생하지 않는 경우 비효율적(a.k.a. 돈낭비)이다.\r\n\r\n반면, AWS lambda를 사용하면 함수가 호출되는 횟수에 따라 과금이 부과되기 때문에 메일링 서비스 같이 자주 불리지 않는 함수들은 따로 떼내어 관리하면 더욱 경제적이고 효율적으로 서버를 운영할 수 있게 되는 장점이 있다.\r\n\r\n\r\n\r\n(2021. 2월 기준, 지원하는 언어는 C#, Go, Java, `Javascript(node.js)`, Perl, PHP, Python, Ruby이다.)\r\n\r\n이번에는 javascript를 활용해보았다. (중간에 javascript에 대한 부족한 이해력때문에 삽질을 많이해서 순간적으로 python으로 할까 고민했던 순간을 간신히 넘겼다 ;;;)\r\n\r\n\r\n\r\n## 2. 로컬환경에서 먼저 테스트 해보기\r\n\r\n### 2-1. 로컬에서 메일 보내기\r\n\r\n먼저, `nodemailer` 와 `nodemailer-smtp-transport`라는 npm 라이브러리를 먼저 설치하고 아래 예제 파일을 `index.js` 로 저장한다.\r\n\r\n```bash\r\n$ npm install nodemailer\r\n$ npm i nodemailer-smtp-transport\r\n```\r\n\r\n```jsx\r\n// index.js\r\n/*\r\n출처: https://docs.aws.amazon.com/ko_kr/ses/latest/DeveloperGuide/examples-send-using-smtp.html\r\nThis code uses callbacks to handle asynchronous function responses.\r\nIt currently demonstrates using an async-await pattern.\r\nAWS supports both the async-await and promises patterns.\r\nFor more information, see the following:\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\r\nhttps://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/calling-services-asynchronously.html\r\nhttps://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html\r\n*/\r\n\r\n\"use strict\";\r\nconst nodemailer = require(\"nodemailer\");\r\n\r\n// If you're using Amazon SES in a region other than US West (Oregon),\r\n// replace email-smtp.us-west-2.amazonaws.com with the Amazon SES SMTP\r\n// endpoint in the appropriate AWS Region.\r\nconst smtpEndpoint = \"email-smtp.us-west-2.amazonaws.com\";\r\n\r\n// The port to use when connecting to the SMTP server.\r\nconst port = 587;\r\n\r\n// Replace sender@example.com with your \"From\" address.\r\n// This address must be verified with Amazon SES.\r\nconst senderAddress = \"Mary Major <sender@example.com>\";\r\n\r\n// Replace recipient@example.com with a \"To\" address. If your account\r\n// is still in the sandbox, this address must be verified. To specify\r\n// multiple addresses, separate each address with a comma.\r\nvar toAddresses = \"recipient@example.com\";\r\n\r\n// CC and BCC addresses. If your account is in the sandbox, these\r\n// addresses have to be verified. To specify multiple addresses, separate\r\n// each address with a comma.\r\nvar ccAddresses = \"cc-recipient0@example.com,cc-recipient1@example.com\";\r\nvar bccAddresses = \"bcc-recipient@example.com\";\r\n\r\n// Replace smtp_username with your Amazon SES SMTP user name.\r\nconst smtpUsername = \"AKIAIOSFODNN7EXAMPLE\";\r\n\r\n// Replace smtp_password with your Amazon SES SMTP password.\r\nconst smtpPassword = \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\";\r\n\r\n// (Optional) the name of a configuration set to use for this message.\r\nvar configurationSet = \"ConfigSet\";\r\n\r\n// The subject line of the email\r\nvar subject = \"Amazon SES test (Nodemailer)\";\r\n\r\n// The email body for recipients with non-HTML email clients.\r\nvar body_text = `Amazon SES Test (Nodemailer)\r\n---------------------------------\r\nThis email was sent through the Amazon SES SMTP interface using Nodemailer.\r\n`;\r\n\r\n// The body of the email for recipients whose email clients support HTML content.\r\nvar body_html = `<html>\r\n<head></head>\r\n<body>\r\n  <h1>Amazon SES Test (Nodemailer)</h1>\r\n  <p>This email was sent with <a href='https://aws.amazon.com/ses/'>Amazon SES</a>\r\n        using <a href='https://nodemailer.com'>Nodemailer</a> for Node.js.</p>\r\n</body>\r\n</html>`;\r\n\r\n// The message tags that you want to apply to the email.\r\nvar tag0 = \"key0=value0\";\r\nvar tag1 = \"key1=value1\";\r\n\r\nasync function main(){\r\n\r\n  // Create the SMTP transport.\r\n  let transporter = nodemailer.createTransport({\r\n    host: smtpEndpoint,\r\n    port: port,\r\n    secure: false, // true for 465, false for other ports\r\n    auth: {\r\n      user: smtpUsername,\r\n      pass: smtpPassword\r\n    }\r\n  });\r\n\r\n  // Specify the fields in the email.\r\n  let mailOptions = {\r\n    from: senderAddress,\r\n    to: toAddresses,\r\n    subject: subject,\r\n    cc: ccAddresses,\r\n    bcc: bccAddresses,\r\n    text: body_text,\r\n    html: body_html,\r\n    // Custom headers for configuration set and message tags.\r\n    headers: {\r\n      'X-SES-CONFIGURATION-SET': configurationSet,\r\n      'X-SES-MESSAGE-TAGS': tag0,\r\n      'X-SES-MESSAGE-TAGS': tag1\r\n    }\r\n  };\r\n\r\n  // Send the email.\r\n  let info = await transporter.sendMail(mailOptions)\r\n\r\n  console.log(\"Message sent! Message ID: \", info.messageId);\r\n}\r\n\r\nmain().catch(console.error);\r\n```\r\n\r\n각각의 변수들이 무엇을 뜻하는지는 주석에 자세히 달려있다.\r\n\r\n\r\n\r\n먼저 간단하게 몇 가지만 살펴보자.\r\n\r\n```jsx\r\n// 1. aws-email region이다. 기본적으로 us-west로 설정되어있는데 서울은 email-stmp.ap-northeast-2이다.\r\nconst smtpEndpoint = \"email-smtp.us-west-2.amazonaws.com\";\r\n\r\n// 2. 보안사항\r\nconst smtpUsername = \"AXXXXXXXXXXXXXXXE\";\r\n// Replace smtp_password with your Amazon SES SMTP password.\r\nconst smtpPassword = \"wXXXXXXXXXXXXXXXXXXEY\";\r\n\r\n/*\r\n이메일을 접속하기 위해서는 보낼 이메일이 있어야한다. \r\n간단하게 자신의 이메일을 활용한다면 아이디와 비밀번호가 필요하다.\r\n하지만 아이디와 비밀번호를 코드에 그대로 노출시키는 것은 보안에 좋지 않으므로,\r\nAWS에서 제공하는 SES(~~요정)~~ 기능을 사용하여 username과 password를 사용할 수 있다.\r\n*/\r\n```\r\n\r\n\r\n\r\n### 2-2. AWS SES SMTP사용하기\r\n\r\nAWS의 SES(~~요정?~~)는 뭔가 약자로 쓰면 멋있고 복잡한 기능같지만 그 뜻을 보면 생각보다 친근(?)하다. Simple Email Service의 약자로 말그대로 간단한 email 서비스다. \r\n\r\n![SES](/assets/img/Untitled%203.png)\r\n\r\nSES를 검색하고 클릭!\r\n\r\n![email verify2](/assets/img/Untitled 4.png)\r\n\r\nEmail Address클릭!\r\n\r\n![email verify2](/assets/img/Untitled 5.png)\r\n\r\nemail 인증 ㄱㄱ!\r\n\r\n![AWS인증메일](/assets/img/Untitled 6.png)\r\n\r\n*이 화면은 Gmail에서 AWS로부터 받은 메일 화면이다. 붉은 부분의 링크를 클릭하면 인증이 완료된다.*\r\n\r\n![email verify3](/assets/img/Untitled 7.png)\r\n\r\n*인증이 완료되면 pending verification이 `verified`로 변경된다.*\r\n\r\n![email SMTP](/assets/img/Untitled 8.png)\r\n\r\n\r\n\r\n인증이 완료되면 SMTP credentials를 생성한다.\r\n\r\n이 과정을 거치면 `credentials.csv` 파일이 생성되고 이 파일을 다운로드 받아 열면 위의 `smtpUsername` 과 `smtpPassword`가 있으므로 index.js 파일의 해당 위치에 복붙한다.\r\n\r\n\r\n\r\n여기까지 진행하고서 terminal에서 `node index` 를 입력하면 index.js가 실행되면서 내가 sendTo로 설정했던 메일로 메일이 날라가 있을 것이다.\r\n\r\n\r\n\r\n## 3.  Lambda 사용해보기\r\n\r\n### 3-1. AWS Lambda에서 함수 생성\r\n\r\n![aws lambda1](/assets/img/Untitled 9.png)\r\n\r\n*'Lambda 서버에 대한 걱정없이 코드 실행' 클릭*\r\n\r\n![aws lambda2](/assets/img/Untitled 10.png)\r\n\r\n*우상단 '함수 생성' 버튼 클릭*\r\n\r\n![aws lambda3](/assets/img/Untitled%2011.png)\r\n\r\n*함수이름, 런타임을 선택하고 함수생성 (이번에는 example이라는 함수명과 node14.x로 만들었습니다.)*\r\n\r\n![aws lambda4](/assets/img/Untitled 12.png)\r\n\r\n*트리거 추가 버튼 클릭*\r\n\r\n![aws lambda5](/assets/img/Untitled 13.png)\r\n\r\n*API 게이트웨이*\r\n\r\n![aws gateway1](/assets/img/Untitled 14.png)\r\n\r\n*보안 - 열기, CORS 체크는 일단 하지않고 놔두고 나중에 처리 ㄱㄱ*\r\n\r\n\r\n\r\n아래로 내려와서 '함수 코드'쪽으로 내려온 뒤 index.js를 클릭해준다.\r\n\r\n이 part가 lambda 함수를 작성하는 메인 공간이다.\r\n\r\n![aws lambda6](/assets/img/Untitled 15.png)\r\n\r\n*밝은 화면을 눈뜨고 지켜볼 수 없어 aws에서도 dark theme로 바꿔서 쓰는중이라 화면이 다르게 보일 수 있음 ;;*\r\n\r\n\r\n\r\n간단한 예시 코드가 적혀있다\r\n\r\n```jsx\r\nexports.handler = async (event) => {\r\n    // TODO implement\r\n    const response = {\r\n        statusCode: 200,\r\n        body: JSON.stringify('Hello from Lambda!'),\r\n    };\r\n    return response;\r\n};\r\n\r\n람다는 이 exports.handler가 필수적이다. \r\n이후 response에 상태번호 200과 \"hello from Lambda!\"라는 문자열을 JSON으로 작성해 담아주고\r\n이 response를 return해준다.\r\n\r\n```\r\n\r\n[handler에 대한 설명](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html)[영문]\r\n\r\nTest버튼을 누르면 execution results 창이 나오면서 함수 실행 결과를 보여준다\r\n\r\n![aws lambda7](/assets/img/Untitled 16.png)\r\n\r\n성공적으로 통신이 된다면 Response에 statusCode와 Body에 문자열이 담겨있는 것을 확인할 수 있다.\r\n\r\n\r\n\r\n### 3-2. AWS lamda에 로컬 환경과 똑같이 환경설정하기\r\n\r\n![로컬파일트리](/assets/img/Untitled 17.png)\r\n\r\n*로컬환경의 파일트리*\r\n\r\n![lambda 파일트리](/assets/img/Untitled 18.png)\r\n\r\n*AWS 람다 환경의 파일트리*\r\n\r\n\r\n\r\n로컬 환경에서는 `npm`을 활용해서 nodemailer를 설치해 활용했다.\r\n\r\n가장 문제는 이 라이브러리를 어떻게 aws 환경에서도 구성할 수 있을까였다.\r\n\r\nAWS lambda에서 터미널을 찾아 헤맸지만 보이지 않아 이 부분에서 많이 당황했다.\r\n\r\n해결방법은 생각보다 간단했다. 로컬의 이 디렉토리를 통째로 zip파일로 압축한 뒤 업로드하면 되는 것이었다.\r\n\r\n\r\n\r\n[How to install npm modules in AWS Lambda?](https://www.youtube.com/watch?v=RnFowJ130pc)\r\n\r\n이 유튜브 동영상을 보며 힌트를 얻고 따라할 수 있었다.\r\n\r\n1. 로컬환경에서 zip 파일을 만든다.\r\n2.  작업 버튼을 누르고 나오는 `.zip파일 업로드`로 압축해놓은 zip파일을 AWS에 올린다.\r\n\r\n![index.js](/assets/img/Untitled 19.png)\r\n\r\n(이렇게 쉬운 방법이 있었는데 하필 aws-sdk를 사용해 CLI환경에서 하는 방법이 구글링에서 먼저 나와 고생좀 했었다...ㅠ)\r\n\r\n![업로드완료](/assets/img/Untitled 20.png)\r\n\r\n이제 로컬 환경과 AWS lambda환경이 같아졌다. 여기까지 왔다면 거의 다왔다!\r\n\r\n\r\n\r\n## 4. Vuejs로 이메일 전송 폼 만들기\r\n\r\n### 4-1. .vue파일 만들기\r\n\r\n```jsx\r\n// Feedback.vue 전체 코드는 다음과 같다\r\n\r\n<template>\r\n  <div class=\"container\">\r\n    <h3>뉴하팀에 피드백 메일 보내기</h3>\r\n    <v-form @submit.prevent=\"submit\">\r\n      <v-text-field\r\n        v-model=\"email\"\r\n        :rules=\"emailRules\"\r\n        label=\"답장 받을 이메일\"\r\n        required\r\n      ></v-text-field>\r\n\r\n      <v-text-field\r\n        v-model=\"title\"\r\n        label=\"제목\"\r\n        required\r\n        autocapitalize=\"off\"\r\n      ></v-text-field>\r\n\r\n      <v-textarea\r\n        v-model=\"content\"\r\n        type=\"text\"\r\n        label=\"본문\"\r\n        required\r\n      ></v-textarea>\r\n      <br />\r\n      <v-btn\r\n        :disabled=\"!valid\"\r\n        color=\"#ff9800\"\r\n        @click=\"submit\"\r\n        >전송하기</v-btn\r\n      >\r\n    </v-form> \r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport axios from 'axios';\r\nconst API_FROM_AWS_API_GATEWAY = 'https://??????.ap-northeast-2.amazonaws.com/default/<함수명>';\r\n\r\nexport default {\r\n  name: 'Feedback',\r\n  methods: {\r\n    isValid: function () {\r\n      if (this.title == '' || this.content == '') {\r\n        this.valid = false\r\n      } else {\r\n        this.valid = true\r\n      }\r\n    },\r\n    submit: function () {\r\n      axios.post(API_FROM_AWS_API_GATEWAY, JSON.stringify({\r\n        email: this.email,\r\n        title: this.title,\r\n        content: this.content,\r\n        }\r\n      ))\r\n      .then((res) => {\r\n        console.log(res)\r\n      })\r\n      .catch((e) => {\r\n        console.log(e)\r\n      })\r\n    },\r\n  },\r\n  data: function () {\r\n    return {\r\n      email: '',\r\n      title: '',\r\n      content: '',\r\n      valid: false,\r\n      emailRules: [\r\n        v => !!v || 'E-mail is required',\r\n        v => /.+@.+/.test(v) || 'E-mail must be valid',\r\n      ],\r\n    }\r\n  },\r\n  watch: {\r\n    title: function () {\r\n      this.isValid();\r\n    },\r\n    content: function () {\r\n      this.isValid();\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n1. v-form을 활용해 간단히 세 줄 짜리 input을 만들었다.\r\n    - email\r\n    - title\r\n    - content\r\n2. v-model로 email, title, content를 각각 입력받는 값을 string으로 binding했다.\r\n3. AWS람다함수의 주소값을 넣어준다\r\n4. axios를 import 한다\r\n\r\n![주소1](/assets/img/Untitled%2021.png)\r\n\r\n*lambda 화면에서 API게이트웨이를 클릭한다*\r\n\r\n![주소2](/assets/img/Untitled 22.png)\r\n\r\n이 붉은색 표시를 한 URL이 함수호출 게이트웨이값이다.\r\n\r\n이 주소값을 const API_FROM_AWS_API_GATEWAY에 넣어준다.\r\n\r\n```jsx\r\nimport axios from 'axios';\r\nconst API_FROM_AWS_API_GATEWAY = 'https://??????.ap-northeast-2.amazonaws.com/default/<함수명>';\r\n```\r\n\r\n5. submit 이라는 전송 함수를 methods에 추가한다.\r\n\r\n- API 게이트웨이 주소로 POST방식의 axios 비동기 요청을 한다.\r\n\r\n```jsx\r\nsubmit: function () {\r\n    axios.post(API_FROM_AWS_API_GATEWAY, JSON.stringify({\r\n      email: this.email,\r\n      title: this.title,\r\n      content: this.content,\r\n      }\r\n    ))\r\n    .then((res) => {\r\n      console.log(res)\r\n    })\r\n    .catch((e) => {\r\n      console.log(e)\r\n    })\r\n  },\r\n},\r\n```\r\n\r\n여기까지 진행하고 크롬의 console창을 열어보면 status:200의 메시지가 도착해 있을 것으로 기대를 했겠지만 \r\n\r\n크흠....역시나 한 번에 되지 않는다.\r\n\r\n\r\n\r\n## 5. CORS 허용해주기\r\n\r\nAPI Gateway에서 CORS를 허용해 줘야한다. \r\n\r\n![CORS](/assets/img/Untitled 23.png)\r\n\r\n*CORS 클릭*\r\n\r\n![CORS2](/assets/img/Untitled 24.png)\r\n\r\n![CORS3](/assets/img/Untitled 25.png)\r\n\r\n\r\n\r\n첫 번째 input창에 원하는 주소값을 넣어준다. 예시로는 http://[localhost:8080](http://localhost:8080) 을 추가한 모습인데, \r\n\r\n> 주의! 👏\r\n> **마지막에 '/'슬래시를 붙이지 않는다.**\r\n\r\n이유까지는 잘 모르겠지만  http://[localhost:8080](http://localhost:8080)/ 과 같은 형태로 했을 때 잘 작동하지 않는 문제가 있으니 이 점을 꼭 유의한다.\r\n\r\n이렇게 하고 다시 폼을 전송해보면 반가운 statusCode 200을 받을 수 있을 것이다.\r\n\r\n여기까지 성공했다면 거의 막바지에 다다랐다.\r\n\r\n\r\n\r\n## 6. index.js 정리\r\n\r\n### 6-1 event handler\r\n\r\n현재 `index.js` 파일은 AWS제공해주는 기본 형식 그대로일 것이다.\r\n\r\n하지만 Lambda에서 event가 발생하고 이것을 핸들하기 위해서는 event handler가 반드시 필요하다\r\n\r\n따라서 시작 부분을 \r\n\r\n'exports.handler = async (event, callback) => {'\r\n\r\n와 같이 수정해준다.\r\n\r\n\r\n\r\n### 6-2. 기타 설정하기\r\n\r\n아래 완성된 코드 예시를 보면서 자신에게 맞도록 설정된 변수 값들을 수정해준다.\r\n\r\n👏**이때 반드시 주의할 점은 시작은 exports.handler로 열어주고, 마지막은 꼭 return값을 넣어주도록 한다.**\r\n(handler 스코프 바깥쪽에 변수같은건 설정 가능하다)\r\n\r\n```jsx\r\nexports.handler = async (event, callback) => {\r\n---\r\nlet info = transporter.sendMail(mailOptions);   // 메일을 전송하는 마지막 코드\r\nreturn info;     // 그리고 마지막에 return해줘야 함수가 제대로 실행된다.\r\n}\r\n```\r\n\r\n\r\n\r\n### 6-3. 완성 코드 예시\r\n\r\n```jsx\r\nexports.handler = async (event, callback) => {\r\n  // \"use strict\";\r\n  const nodemailer = require(\"nodemailer\");\r\n  const smtpTransport = require('nodemailer-smtp-transport');\r\n\r\n  // If you're using Amazon SES in a region other than US West (Oregon),\r\n  // replace email-smtp.us-west-2.amazonaws.com with the Amazon SES SMTP\r\n  // endpoint in the appropriate AWS Region.\r\n  const smtpEndpoint = \"email-smtp.ap-northeast-2.amazonaws.com\"; // 서울 region을 사용하고 있다면 그대로 써도 좋다.\r\n  \r\n  // The port to use when connecting to the SMTP server.\r\n  const port = 587;\r\n  \r\n  // Replace sender@example.com with your \"From\" address.\r\n  // This address must be verified with Amazon SES.\r\n  const senderAddress = \"----@gmail.com\";\r\n  \r\n  // Replace recipient@example.com with a \"To\" address. If your account\r\n  // is still in the sandbox, this address must be verified. To specify\r\n  // multiple addresses, separate each address with a comma.\r\n  var toAddresses = \"----@gmail.com\";\r\n  \r\n  // Replace smtp_username with your Amazon SES SMTP user name.\r\n  const smtpUsername = \"AXXXXXXXXXXXXE\";\r\n  \r\n  // Replace smtp_password with your Amazon SES SMTP password.\r\n  const smtpPassword = \"BXXXXXXXXXXXXXXXXXXXXXXO\";\r\n  \r\n  // The subject line of the email\r\n  \r\n  // The email body for recipients with non-HTML email clients.\r\n  \r\n  \r\n  const base64body = JSON.stringify(event.body)\r\n  const body = JSON.parse(Buffer.from(base64body, 'base64').toString('utf8'))\r\n  const data = {\r\n    email: body.email,\r\n    title: body.title,\r\n    content: body.content,\r\n  }\r\n  var subject = `${data.title}`;\r\n  var body_text = `${data.content}`;\r\n  // The body of the email for recipients whose email clients support HTML content.\r\n  var body_html = `<html>\r\n  <head></head>\r\n  <body>\r\n    <h2> ${data.email} 님으로부터 NewsHi 피드백이 도착했습니다.</h2>\r\n    <p> ${data.content}</p>\r\n  </body>\r\n  </html>`;\r\n  \r\n  // The message tags that you want to apply to the email.\r\n  var tag0 = \"key0=value0\";\r\n  var tag1 = \"key1=value1\";\r\n  \r\n\r\n  // Create the SMTP transport.\r\n  let transporter = nodemailer.createTransport(smtpTransport({\r\n    host: smtpEndpoint,\r\n    port: port,\r\n    secure: false, // true for 465, false for other ports\r\n    auth: {\r\n      user: smtpUsername,\r\n      pass: smtpPassword\r\n    }\r\n  }));\r\n\r\n  // Specify the fields in the email.\r\n  let mailOptions = {\r\n    from: senderAddress,\r\n    to: toAddresses,\r\n    subject: subject,\r\n    text: body_text,\r\n    html: body_html,\r\n    service: \"Gmail\",\r\n    // Custom headers for configuration set and message tags.\r\n    headers: {\r\n      'X-SES-MESSAGE-TAGS': tag0,\r\n      'X-SES-MESSAGE-TAGS': tag1\r\n    }\r\n  };\r\n  // Send the email.\r\n  // let info = await transporter.sendMail(mailOptions);\r\n  \r\n  let info = transporter.sendMail(mailOptions);\r\n  return info;\r\n}\r\n```\r\n\r\n*<완성 모습>*\r\n\r\n![완성1](/assets/img/Untitled.png)\r\n\r\n*사이트에서 이메일 작성하는 폼*\r\n\r\n![완성2](/assets/img/mailcomplete.png)\r\n\r\n*G메일로 날아오는 결과*\r\n\r\n\r\n\r\n끝.\r\n\r\n---\r\n\r\n### References.\r\n\r\n**웬만하면 이 순서대로 참고하는 것을 추천.**\r\n\r\n**특히, 마지막에 있는 velog 블로그 글은 꼭 마지막에 읽을 것을 추천함.**\r\n\r\n[Amazon SES SMTP 인터페이스를 사용하여 이메일 전송](https://docs.aws.amazon.com/ko_kr/ses/latest/DeveloperGuide/examples-send-using-smtp.html)\r\n\r\n[Amazon SES SMTP 인터페이스를 사용하여 이메일 전송](https://docs.aws.amazon.com/ko_kr/ses/latest/DeveloperGuide/examples-send-using-smtp.html)\r\n\r\n[AWS Lambda 배포 패키지(Node.js)](https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/nodejs-package.html)\r\n\r\n[AWS Lambda 함수 핸들러(Node.js)](https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/nodejs-handler.html)\r\n\r\n[Sending email with Nodemailer using a lambda - Edward Beazer Blog](https://www.edwardbeazer.com/sending-email-using-nodemailer-using-a-lambda/)\r\n\r\n[How to load npm modules in AWS Lambda?](https://stackoverflow.com/questions/34437900/how-to-load-npm-modules-in-aws-lambda)\r\n\r\n[Vue.js와 AWS Lambda, Nodemailer 로 이메일 전송 폼 만들기](https://velog.io/@bluestragglr/Vue.js%EC%99%80-AWS-Lambda-Nodemailer-%EB%A1%9C-%EC%9D%B4%EB%A9%94%EC%9D%BC-%EC%A0%84%EC%86%A1-%ED%8F%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0)");

/***/ }),

/***/ "./contents/blog/vuejs/2021-03-12-Vuex를 알아보자.md":
/*!******************************************************!*\
  !*** ./contents/blog/vuejs/2021-03-12-Vuex를 알아보자.md ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"Vuex가 무엇이고 왜 쓰는것인가?\"\r\ndate: \"2021.03.12\"\r\ntags: \r\n  - vuejs\r\n  - vuex\r\n  - javascript\r\n  - es6\r\n---\r\n\r\n## 1. 뷰엑스는 왜 필요한가?\r\n\r\n1. Vue인스턴스\r\n\r\n![vue인스턴스](/assets/img/vue인스턴스.png)\r\n\r\n화면(View) -> 화면에서의 이벤트 발생(Actions) -> 데이터 변경(State)의 **단방향 데이터 흐름**이 특징입니다.\r\n\r\n하지만, Component 관계가 복잡해질수록 상태관리가 어렵다\r\n\r\n![상태관리](/assets/img/vuestate.png)\r\n\r\n```jsx\r\n// 참고) Props를 정의할 때 Vue스타일 가이드에서 추천하는 스타일... \r\n// 여러번 반복되면 코드가 상당히 복잡해질듯\r\nprops: {\r\n  status: {\r\n    type: String,\r\n    required: true,\r\n    validator: function (value) {\r\n      return [\r\n        'syncing',\r\n        'synced',\r\n        'version-conflict',\r\n        'error'\r\n      ].indexOf(value) !== -1\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. 글로벌 이벤트 버스\r\n\r\n이런 상태관리의 어려움을 해결하기 위해 소규모 Vue 프로젝트에서는 `이벤트 버스`를 사용한다.\r\n\r\n![vue인스턴스](/assets/img/eventbus.png)\r\n\r\n하지만 글로벌 이벤트 버스에도 한계가 있다.\r\n\r\n![vue인스턴스](/assets/img/buslimit.png)\r\n\r\n## 2. Vuex란?\r\n\r\n> Application을 구성하는 모든 컴포넌트가 참조가능한 상태를 중앙에서 관리하는 저장소\r\n> Vue.js가 효율적인 업데이트를 위해 세분화된 반응 시스템을 활용하도록 특별히 고안된 Vuex는 뷰의 상태관리 패턴이자 라이브러리이다. \r\n> 주로 중대형 프로젝트에 적합하다.\r\n\r\nVuex는 이 문제를 어떻게 해결하는가? → 전역 상태 관리 매니저 (Store)에 각각의 Component들이 접근하는 방식\r\n\r\n![vue인스턴스](/assets/img/storeconcept.png)\r\n\r\n![vue인스턴스](/assets/img/vuestructure.png)\r\n\r\n아래에서 각각의 주요 오소들을 자세히 살펴봅시다.\r\n\r\n## 3. 주요 요소\r\n\r\n### A. State\r\n\r\n> 여러 컴포넌트 간에 공유되는 데이터를 의미합니다\r\n\r\n1. state선언\r\n\r\n```javascript\r\nnew Vuex.Store({\r\n  state: {\r\n    message: 'Hello Vue.js'\r\n  }\r\n})\r\n```\r\n\r\n- message의 상태값 정의\r\n\r\n접근법은?\r\n\r\n```javascript\r\n<div>{{ this.$store.state.message }}</div>\r\n```\r\n\r\n2. state 호출\r\n\r\n```javascript\r\ndata: function () {\r\n\treturn {\r\n        sharedState = this.$store.state.message;\r\n\t}\r\n}\r\n```\r\n\r\n이렇게 중앙에 있는 store의 state 중 message에 접근해서 해당 데이터를 호출할 수 있다.\r\n\r\n하지만, 이 방식으로 호출하는 것은 비추천!\r\n\r\n### B. Getters\r\n\r\n> 상태(state) 값이 변경되었을 때 변화에 따른 차이를 자동으로 반영하여 값을 계산해줍니다.\r\n> **Computed 속성과 매칭**\r\n\r\n```javascript\r\nnew Vuex.Store({\r\n  state: {\r\n    message: 'Hello Vue.js'\r\n  },\r\n  getters: {\r\n    reverseMessage(state) {\r\n      return state.message.split('').reverse().join('');\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n위에서 `State`를 설명할 때 호출하는 방식을 이야기 했는데, Vue에서 추천하는 방식은 이 `Getters` 를 활용해서'만' 호출할 것을 강하게 추천한다.\r\n\r\n### C. Mutations\r\n\r\n> 뷰엑스에서 **상태 값을 변경하는 유일한 방법**입니다. 상태는 항상 뮤테이션으로 변경됩니다\r\n> **Method속성과 매칭**\r\n\r\n1. Mutation 선언\r\n\r\n```javascript\r\nnew Vuex.Store({\r\n  state: {\r\n    message: 'Hello Vue.js'\r\n  },\r\n  mutations: {\r\n    reverseMessage(state) {\r\n      state.message = state.message.split('').reverse().join('');\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n2. Mutation 호출\r\n\r\n```javascript\r\nnew Vue({\r\n  methods: {\r\n    reverseMsg() {\r\n      this.$store.commit('reverseMessage');\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n### D. Actions\r\n\r\n> 뮤테이션 중에서 **비동기 처리 로직들을 정의**하는 속성\r\n> 동기 처리는 뮤테이션, 비동기 처리는 액션\r\n\r\n1. actions 선언\r\n\r\n```javascript\r\nnew Vuex.Store({\r\n  state: {\r\n    message: ''\r\n  },\r\n  mutations: {\r\n    reverseMessage(state, data) {\r\n      state.message = data.split('').reverse().join('');\r\n    }\r\n  },\r\n  actions: {\r\n    fetchMessage(context) {\r\n      axios.get(url).then(function(response) {\r\n        context.commit('reverseMessage', response.message);\r\n      });\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n2. actions 호출\r\n\r\n```javascript\r\nnew Vue({\r\n  methods: {\r\n    getMessage() {\r\n      this.$store.dispatch('fetchMessage');\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n---\r\n\r\n### 요약\r\n\r\n- Vue.js에서 중앙 Store에 저장된 State를 호출할 때는 `this.$store.state.message` 와 같이 호출하는 것이 아니라 `this.$store.getters.` 에서 `return` 해주는 값을 가져다가 써야 한다.\r\n- State 값을 변경하기 위해서는 컴포넌트에서 커밋으로 `Mutation` or `Action`을 호출해서 변경해준다.\r\n\r\n---\r\n\r\n## 4. 헬퍼 함수\r\n\r\n> 헬퍼 함수는 뷰엑스 기술 요소들을 **컴포넌트에서 더 편하게 쓸 수 있도록 도와주는 API**\r\n\r\n### A. 일반적인 접근 방법\r\n\r\n```javascript\r\n<div>{{ this.$store.getters.reverseMessage }}</div>\r\n```\r\n\r\n```javascript\r\nexport default {\r\n  computed: {\r\n    reverseMessage() {\r\n      return this.$store.getters.reverseMessage;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### B. 헬퍼 함수 사용\r\n\r\n```javascript\r\n<div>{{ reverseMessage }}</div>\r\n```\r\n\r\n```javascript\r\nimport { mapGetters } from 'vuex';\r\n\r\nexport default {\r\n  computed: {\r\n    ...mapGetters(['reverseMessage'])\r\n  }\r\n}\r\n```\r\n\r\n- `this.$store. ~~~` 와 같이 복잡한 방식X → 가독성 좋아짐\r\n\r\n```javascript\r\nimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex'\r\n등 mapGetters뿐만 아니라 mapState, mapMutations, mapActions 모두 사용 가능!\r\n```\r\n\r\n## 5. 추가 학습 필요 사항\r\n\r\n### 스토어 모듈화\r\n\r\n> 애플리케이션에 스토어를 적용해서 사용하다가 보면 금방 스토어의 덩어리가 커진다. 그럴때 데이터(상태)의 성격별로 스토어를 모듈화 해주면 관리하기 수월하다.\r\n\r\n[Modules - Cracking Vue.js](https://joshua1988.github.io/vue-camp/vuex/modules.html#%EC%8A%A4%ED%86%A0%EC%96%B4-%EB%AA%A8%EB%93%88%ED%99%94-%EC%BD%94%EB%93%9C-%ED%98%95%EC%8B%9D)\r\n\r\n### ES6 - 스프레드 오퍼레이터\r\n\r\n[[ES6] Spread Operator (스프레드 연산자)](https://paperblock.tistory.com/62)\r\n\r\n---\r\n\r\nReferences\r\n\r\n[State - Cracking Vue.js](https://joshua1988.github.io/vue-camp/vuex/state.html)");

/***/ }),

/***/ "./contents/blog/면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md":
/*!**************************************************************************!*\
  !*** ./contents/blog/면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"2021 프론트엔드 개발자 직접 받은 기술 면접 질문 리스트와 느낀점\"\r\ndate: \"2021.06.02\"\r\ntags: \r\n  - react\r\n  - 리액트\r\n  - 프론트엔드\r\n  - Vue\r\n  - Vuejs\r\n---\r\n\r\n# 2021 기술면접 질문과 느낀점\r\n\r\n조금 까먹었는데, 최대한 기억나는 것들을 적어보겠습니다.\r\n\r\n\r\n\r\n## :book: 질문리스트\r\n\r\n- 미들웨어란 무엇인가요?\r\n- React Hook에 대해 설명해주세요.\r\n- CDN이 무엇인가요?\r\n- 교착상태(Deadlock)을 해결하는 방법이 무엇인가요?\r\n\r\n- HTTP에 대해 설명해 주세요.\r\n  - HTTP response status code에 대해 설명해주세요.\r\n- 자료구조 Linked List에 대해 설명해주세요.\r\n  - Linked List와 Array의 차이는 무엇인가요?\r\n  - 새로운 것을 삽입, 삭제하는 트랜잭션의 경우 Array와 Linked List중 어떤 것의 성능이 더 좋나요?\r\n- Restful API에 대해 설명해주세요.\r\n  - Restful API의 장점은?\r\n  - Restful API의 단점은?\r\n- javascript var, let, const의 차이는?\r\n- javascript scope에 대해 설명해 주세요\r\n- event loop에 대해 자세히 설명해주세요.\r\n  - web API에서 루프 돌고 Queue로 들어가는데 이 때 Queue의 종류는 무엇이 있나요?\r\n- CSR과 SSR의 차이점에 대해 말해주세요.\r\n- (Vue.js) Computed와 Watch의 차이를 말해주세요.\r\n  - 성능적으로 어떤 것이 더 뛰어난가요?\r\n- (Vue.js) 컴포넌트가 Re-rendering 되는 경우는 어떤 경우인가요?\r\n- (Vue.js) VUEX에 대해 설명해주세요.\r\n\r\n---\r\n\r\n\r\n\r\n## :sweat: 느낀점\r\n\r\n면접에서 좀 규모가 있는회사와 규모가 작은 회사와의 차이점이 느껴진 점은 큰 회사일수록 언어나 컴퓨터 공학적 지식 그리고 그것이 작동하는 '원리'와 '이유'를 아는지를 묻는 질문이 많았습니다. 상대적으로 규모가 조금 작은 회사일수록 스킬셋과 어떤 프로젝트 경험이 있는지, 거기에서 맡은 역할과 담당한 부분을 많이 물어본다는 느낌을 받았습니다.\r\n\r\n\r\n\r\n프론트엔드 개발에 초점을 맞춰서 좀 더 자세히 얘기하자면, \r\n\r\n### 상대적으로 큰 회사일수록 \r\n\r\n- 자바스크립트 언어\r\n\r\n  - var, let, const의 차이 ( [여기에 잘 정리되어있네요!](https://likelionsungguk.github.io/21-08-09/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-var-let-const-%EC%A7%84%EC%A7%9C-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B5%AC%EB%B3%84%ED%95%98%EA%B8%B0) )\r\n  - 호이스팅\r\n  - this\r\n\r\n- 브라우저 동작 원리\r\n\r\n  - \"브라우저 검색창에 www.google.com을 검색하고 나면 그 다음 이뤄지는 동작을 설명해보세요\"\r\n  - 이벤트 루프\r\n\r\n- DOM트리\r\n\r\n  - Reflow & Repaint\r\n\r\n  와 관련된 최적화에 관한 내용에 대한 질문을 받았습니다.\r\n\r\n\r\n\r\n### 상대적으로 작은 회사일수록\r\n\r\n- 프론트엔드 프레임워크 관련 질문\r\n  - SPA란 무엇인가요?\r\n    - 그렇다면 SPA를 쓰는 이유는 무엇인가요?\r\n    - SPA의 장단점을 설명해보세요.\r\n  - (React) 리액트 컴포넌트 라이프 사이클\r\n  - (React) 클래스형 컴포넌트와 함수형 컴포넌트의 차이를 알고 있는가?\r\n  - (Vuejs) Vue 인스턴스 라이프 사이클\r\n- 정적 언어 사용 경험 \r\n  - \"Typescript 써본적 있으신가요?\"\r\n  - Typescript의 interface와 class차이를 설명해주세요.\r\n  - Typescript 제네릭은 무엇이고 언제 사용하나요?\r\n    - 유니언 타입으로 쓸 수도 있는데 굳이 제네릭을 쓰는 이유가 뭘까요?\r\n- 프로젝트 관련 경험에서 더 깊은 내용 질문\r\n  - \"검색 기능을 개발하셨던데, 입력창에 인풋이 있을 때마다 state값을 변경했었나요? 아니면 다른 방식을 사용했었나요?\" + \"어떻게 하면 더 효율적으로 만들 수 있을까요?\"\r\n    - 나중에 알고보니 이 질문은 debounce에 대해 알고 있냐는 질문이었습니다. 사내에서 검색기능에서 이 `debounce` 관련 이슈가 있었고 마침 그때 면접이어서 생각나서 질문하셨다고 하더라구요 ㅎㅎ.\r\n  - 다크모드를 개발하셨는데 이때 다크모드인지 아닌지 나타내는 true/false 플래그는 어디에 저장하셨나요? \r\n    - localStorage냐 sessionStorage냐 cache냐를 묻는 질문\r\n\r\n\r\n\r\n혼자만의 뇌피셜이지 않을까 싶은데, 아마도 작은 규모일수록 지금까지 만들어온 것보다는 앞으로 만들어 나가야 할 것이 더 많기 때문에 바로 합류해서 빈틈없이 작업을 이어나갈 수 있도록 관련 기술스택을 활용한 프로젝트 경험이 있어 코드를 보고 빠르게 파악할 수 있는 이른바 `즉시 전력감`을 찾는 경향성이 있다고 느껴졌습니다.\r\n\r\n반면, 큰 기업일수록 인력이 많고 이미 짜여진 코드의 양도 상당히 방대합니다. 주니어 개발자가 별 생각없이 짠 코드가 의도치 않은 연쇄작용을 일으켜 대규모 시스템에 안좋은 영향을 끼치지 않도록 하는 것이 더 중요하게 생각하지 않을까 싶습니다. 때문에 다양한 기초 내용과 원리를 이해하여 버그를 최소화 하는 잘 짠 코드가 중요하므로 이런 내용을 이미 잘 알고 있고 빠른 학습을 할 수 있는 잠재력을 갖고 있는 인재들을 찾아서 이런 경향성이 있지 않을까 추측해봅니다...\r\n\r\n\r\n\r\n아무쪼록 이글은 보신 분들은 모두 저 보다 더 좋은 답변 하시길 바랍니다.");

/***/ }),

/***/ "./contents/blog/번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md":
/*!************************************************************!*\
  !*** ./contents/blog/번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"45년 동안 개발자로 일하며 배운것들\"\r\ndate: \"2021.01.10\"\r\ntags: \r\n  - developer\r\n  - Curse of Knowledge\r\n---\r\n\r\n# What I’ve Learned in 45 Years in the Software Industry\r\n\r\n45년 동안 소프트웨어 산업에서 일했던 Joel Goldberg가 은퇴하며 사내 동료들에게 마지막으로 남긴 좋은 글이 있어 공유드립니다.\r\n\r\n[What I’ve Learned in 45 Years in the Software Industry](https://www.bti360.com/what-ive-learned-in-45-years-in-the-software-industry/)\r\n\r\n\r\n\r\n---\r\n\r\n## *INTRO*\r\n\r\n소프트웨어 산업에서의 40여 년을 되돌아 보면 얼마나 많은 변화가 있었는지 놀랐습니다. 저는 *펀치 카드*(아래 이미지)로 경력을 시작해서 마지막은 클라우드 컴퓨팅 시대로 끝을 맺고 있습니다. 이러한 모든 변화에도 불구하고 제 커리어 전반에 걸쳐 저를 도왔던 많은 원칙은 변하지 않았습니다. 이제 키보드에서 물러나면서 소프트웨어 엔지니어로서의 경력에서 배운 `6 가지 아이디어`를 공유하고 싶습니다.\r\n\r\n![Punched card](/assets/img/300px-Used_Punchcard_(5151286161).jpg)\r\n\r\n\r\n\r\n## 1. *Beware of the Curse of Knowledge*\r\n\r\n> *지식의 저주를 조심하라*\r\n\r\n당신이 무언가를 알고있을 때 그 것을 모르는 것이 어떤 것인지 상상하는 것은 거의 불가능에 가깝습니다. 이것은 지식의 저주이며 수많은 오해와 비효율성의 근원입니다. 복잡성에 익숙한 똑똑한 사람들은 특히 이것에 취약할 수 있습니다!\r\n\r\n지식의 저주를 경계하지 않으면 코드를 포함한 모든 형태의 커뮤니케이션을 복잡하게 할 가능성이 있습니다. 업무가 전문화 될수록 초보자가 이해할 수 없는 방식으로 의사소통 할 위험이 커집니다. \r\n\r\n끊임없이 지식의 저주와 싸우세요. 듣는 사람이 이해할 수 있게 말하기 위해 노력하세요. 처음으로 소통하는 내용을 배우는 것이 어떤 것인지 상상해보세요.\r\n\r\n\r\n\r\n## 2. *Focus on the Fundamentals*\r\n\r\n> *핵심에 집중해라*\r\n\r\n기술은 끊임없이 변화하지만 소프트웨어 개발에 대한 몇 가지 기본적인 접근 방식은 이러한 트렌드를 초월합니다. 다음은 오랫동안 유지될 6 가지 기본 사항입니다.\r\n\r\n- **팀워크** — 훌륭한 팀은 훌륭한 소프트웨어를 구축합니다. 팀워크를 당연하게 생각하지 마세요.\r\n- **신뢰** — 팀은 신뢰의 속도로 움직입니다. 함께 일하고 싶은 신뢰할 수 있는 사람이 되세요.\r\n- **의사 소통** — 정직하고 적극적으로 의사 소통하세요. 그리고 지식의 저주를 피하세요.\r\n- **합의 추구** — 전체 팀이 함께 할 시간을 가지세요. 토론과 불일치가 최상의 솔루션을 제공하도록 하세요.\r\n- **자동화 된 테스트** — 잘 테스트 된 코드를 사용하면 팀이 자신감을 가지고 빠르게 다음 레벨로 이동할 수 있습니다.\r\n- **깔끔하고 이해하기 쉬우 며 탐색 가능한 코드 및 디자인** — 코드를 인수 받을 다음 엔지니어를 고객으로 생각하세요. 후임자가 읽기, 유지 관리 및 업데이트하는 데 문제가 없는 코드를 빌드하도록 노력하세요.\r\n\r\n\r\n\r\n## 3. *Simplicity*\r\n\r\n복잡성과의 싸움은 끝이 없는 원인입니다. 솔루션은 가능한 한 간단해야 합니다. 코드를 관리 할 다음 사람이 당신만큼 똑똑하지 않다고 가정합니다. 더 적은 수의 기술을 사용할 수 있으면 그렇게 하십시오.\r\n\r\n>  *“A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away.”* -*Antoine de Saint-Exupery*\r\n\r\n\r\n\r\n## 4. *Seek First to Understand*\r\n\r\n> *이해하기 위해 먼저 찾아봐라* - 다른 사람의 말을 이해하기 위해 그들의 말을 먼저 들어라\r\n\r\n`스티븐 코비의 7가지 습관` (The 7 Habits of Highly Effective People - 스티븐 코비가 쓴 비즈니스/자기계발서이다. 이 책은 전 세계에서 38개 언어로 번역되었으며, 총 1500만부 이상 판매되었다. 대한민국에서는 1994년 최초로 출간되어 2021년 현재까지 약 300만부가 팔린 베스트 셀러이다.)중 하나는 \"먼저 이해하려고 노력해라, 그러면 이해될 것이다.\"입니다. 이 격언은 훌륭한 청취자(Listener)가 되기 위해서, 또 좋은 동료가 되기 위해 기타 다른 어떤 조언보다도 나에게 도움이 되었습니다. \r\n\r\n만약 여러분이 다른 사람들에게 영향력을 끼치고 효과적으로 일하고 싶다면, 먼저 그들을 이해할 필요가 있습니다. 여러분 자신의 생각을 알리기 전에 그들의 감정, 생각, 관점을 이해할 수 있도록 그들의 말을 먼저 적극적으로 들어보세요.\r\n\r\n\r\n\r\n## 5. *Beware of Lock-In*\r\n\r\n> *Lock-in 을 주의하라*\r\n\r\n미래에는 소프트웨어를 구축하는 방식에 혁명을 일으킬 Hot한 생산성 도구들이 반드시 많이 있을 겁니다. \r\n\r\n예를 들어, CASE (Computer Assisted Software Engineering) 도구, COTS, Peoplesoft 및 SAP와 같은 Enterprise Resource Planning 제품, 심지어 Ruby도 포함됩니다. 그들은 하나 같이 자신들의 전체적인 개발 방법론을 채택하면 비용과 시간이 크게 절감된다고 주장합니다. 하지만 상당한 선행 비용(up-front cost)과 제약(Constraints)이 없다고 할 수는 없습니다. `Lock-in`은 주로 공급하는 회사로부터 주로 발생했지만 이제는 `프레임 워크`에서도 발생할 수 있습니다. \r\n\r\n어느 쪽이든, 고정하는 것은 변경에 상당한 비용을 의미합니다. 현명하게 선택하세요. 새로운 것이 항상 좋은 것만은 아닙니다!\r\n\r\n\r\n\r\n## 6. *Be Honest and Acknowledge When You Don’t Fit the Role *\r\n\r\n> *정직해라 그리고 스스로 맡은 역할에 맞지 않다고 생각하면 그것을 인정하고 받아들여라*\r\n\r\n커리어의 어느 시점에서 자신에게 적합하지 않은 역할을 맡게 될 수도 있습니다. 잘못된 Fit은 어떤 잘못된 행동을 야기할 만큼 중대한 잘못까지는(Character flaws) 아니지만 무시할 수 있는 정도로 가벼운 문제도 아닙니다. 이러한 딜레마를 해결하기 위해서는 한 가지 이상의 방법이 있을 수 있습니다: 스스로 진화하거나 아니면 역할이 진화 할 수 있습니다. 주요 point는 무슨 일이 일어나고 있는지 정확히 인식하고 건강에 해로운 곳으로부터 벗어나기 위해 자기자신을 아는 것(Self-Knowledge)입니다. 불행한 것은 누구에게도 최선의 이익이되지 않으며, BTI360은 이러한 사실을 인지하고 있습니다.\r\n\r\n제가 GM에 있었을 때 다음 단계가 진행되지 않았다면 실패했다고 여겨졌습니다. '관리자로 승진하여 더 많은 사람을 관리하거나 더 크고 복잡한 프로젝트를 수행하는 것'입니다. 많은 사람들에게 이것은 <u>비참한 커리어 패스</u>를 만들었습니다.\r\n\r\n하지만 EDS의 문화는 GM의 그것과는 달랐습니다. 사람들은 관리 역할에 들어갔다가 종종 다시 나가곤 했습니다. 전략적 플래너와 같이 범위가 더 큰 역할에서 PM 또는 프로젝트 수준 개발자와 같이 범위가 더 좁은 역할로 이동하는 것을 좌천 또는 오명으로 여기는 문화가 없었습니다. 저는 이러한 유연성을 이용하여 기술 피라미드의 최상위 역할에서 프로젝트 수준의 개발자로 다시 이동 한 사람 중 한 명이었습니다. 그리고 저는 결코 뒤돌아 후회하지 않았습니다.\r\n\r\n\r\n\r\n## *Final Thoughts*\r\n\r\n저는 BTI360에 입사하기 전에도 위에서 설명한 원칙을 소중히 여기는 곳이라는 것을 알 정도로 BTI360의 문화에 대해 충분히 알고 있었습니다. \r\n\r\n제가 바라는 것은 여러분 각자가 BTI360이란 회사를 지속적으로 소프트웨어 구축을 위한 훌륭한 장소로 만들도록 하는 강력한 엔지니어링 문화를 유지할 뿐만 아니라 그러한 문화를 지켜나가고 이에 대한 주인의식을 가지는 것입니다.");

/***/ }),

/***/ "./contents/blog/번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md":
/*!*******************************************************************************!*\
  !*** ./contents/blog/번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"처음부터 끝까지 상세히 알아보자 - HTTP3에 대한 A TO Z 1편\"\r\ndate: \"2021.08.14\"\r\ntags: \r\n  - HTTP3\r\n  - 프로토콜\r\n---\r\n\r\n# (번역) HTTP/3 FROM A To Z: Core Concepts (Part 1) by Robin Marx\r\n\r\n원문링크: [https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)\r\n\r\n이 글은 *Robin Marx*의 [**HTTP/3 FROM A To Z: Core Concepts (Part1)**](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)을 번역하였습니다.\r\n\r\n\r\n\r\n## TL;DR\r\n\r\n- **HTTP3가 왜 필요한가?** - 엄밀히 말하면 우리에게 필요한 것은 실제로 HTTP/3가 아니라 \"TCP/2\"였으며 그 과정에서 TCP자체를 업그레이드 하는 것보다는 HTTP 버전업이 더 손쉬운 방법이었습니다. (네트워크 계층 구조에 따르면 HTTP는 TCP프로토콜 위에서 동작하는데 HTTP/3가 HTTP 프로토콜의 발전보다는 기저에 깔린 TCP의 발전이 더 필요했고 HTTP/3는 좀 더 로우 레벨의 프로토콜에서 발전이 있었음을 의미합니다.) 우리가 HTTP/3에 대해 기대하는 주요 기능(더 빠른 연결 설정, 더 적은 HoL 차단, 연결 마이그레이션 등)은 실제로 모두 QUIC(TCP의 단점을 보완한 새로운 프로토콜)에서 제공됩니다.\r\n- **QUIC과 UDP** -  HTTP/3는 TCP를 UDP로 바꿨다고 해서 HTTP/2보다 엄청나게 빠르지 않습니다.(정보처리기사에서 많이 나오는 프로토콜 간의 차이인데 UDP는 속도가 빠른 프로토콜입니다.) 대신 QUIC이라는 훨씬 더 발전된 TCP 버전을 재구상하고 구현했습니다. 그리고 이 QUIC은 더 쉽게 배포할 수 있도록 인터넷에서 광범위하게 지원되는 다른 하나의 전송 계층 프로토콜인 UDP 위에서 실행합니다. (TCP를 업그레이드 하는 것은 사실상 매우 어렵기 때문입니다.)\r\n- **BIG CHANGES** - 이전 버전의 HTTP에서는 데이터 통신과 TSL 암호화과정이 분리되어 있었습니다. 따라서 TSL암호화를 진행하다보면 성능이 떨어지는 것이 당연했습니다. 하지만 QUIC은 always-on-TSL 원칙에 맞춰 기본적으로 TSL를 탑재하였습니다. 따라서 연결이 더 빨라지고 보안 성능이 뛰어나다는 장점이 있으나 암호화 오버헤드가 더 큰 문제가 생기는 것, 인터넷 환경이 더 중앙집중화 되는 것 등의 단점이 예상되고 있습니다.\r\n\r\n\r\n\r\n*본문 START!*\r\n\r\n\r\n\r\n## Quick Summary\r\n\r\n약 5년여간의 개발 끝에, 새로운 HTTP/3 프로토콜이 거의 막바지 단계에 이르렀다. 이미 실험적 기능으로 몇몇의 기능은 제공되었음에도 불구하고 HTTP/3의 가용성과 사용은 2021년에 증가할 것으로 기대되고 있습니다. \r\n\r\n> 그래서 HTTP/3가 정확히 뭔데? \r\n> 왜 HTTP/2 가 나온지 얼마 안되서 곧바로 또 나온걸까? \r\n> 우리가 어떻게 쓸 수 있고 어떻게 써야 하는거지? \r\n> 그리고 특히 웹 퍼포먼스를 어떻게 향상시키는거지?\r\n\r\n자 이제 알아봅시다!\r\n\r\n\r\n\r\n## 💀 HTTP/3에 대한 잘못된 기대가 퍼지고 있다!\r\n\r\n이 주제에 대한 몇 가지 블로그 게시물을 읽거나 컨퍼런스 등을 듣고 어느 정도 답을 알고 있다고 생각할 수도 있습니다. \"HTTP/3는 패킷 손실이 있을 때 HTTP/2보다 훨씬 빠르다.\" 또는 \"HTTP/3 연결은 대기 시간이 짧고 설정하는 데 시간이 덜 걸린다.\", 아마도 \"HTTP/3 데이터를 더 빨리 보낼 수 있고 더 많은 리소스를 병렬로 보낼 수 있습니다.\"\r\n\r\n위와 같은 문장과 아티클들은 종종 중대한 기술적 디테일들을 건너 뛰거나 혹은 정확한 문맥 파악을 위한 뉘앙스를 빠뜨리거나 부분적으로 맞는 얘기들이다. 종종 그들은 HTTP/3가 성능면에서 엄청난 혁명인 것처럼 보이게 말하지면 실제로는 그렇게까지 급견한 진화는 아닌(그러나 여전히 유용한!) 진화입니다. 이것은 자칫 위험합니다. 왜냐하면 새로운 프로토콜이 실질적으로 이렇게까지 높은 기대치를 충족시키기지 못해서 살아남지 못할 수도 있기 떄문입니다. 따라서 나는 이것들이 많은 사람들을 결국 실망시켜서 새로온 사람들에게 맹목적인 오해를 아주 오래도록 각인시키게 될까 두렵습니다.\r\n\r\n나는 HTTP/2에서 똑같은 일이 일어나는 것을 보았습니다. 당시 서버 푸시, 병렬 스트림 및 우선 순위 지정과 같은 흥미로운 새 기능으로 놀라운 성능 혁명으로 예고되었습니다. 특히 '리소스 번들링을 중지하고 여러 서버에서 리소스 분할을 중지하고 페이지 로드 프로세스를 크게 간소화할 수 있었습니다. 스위치만 누르면 웹사이트가 마법처럼 50% 빨라집니다!'와 같이 너무 큰 기대를 불러모았죠.\r\n\r\n5년이 지나고 나서, 우리는 서버푸시가 실질적으로 그렇게 작동하지 않는다는 것과 스트림 및 우선 순위 지정은 종종 잘못 구현된다는 것을 압니다. 그리고 결과적으로 어떤 상황에서는 (감소된) 리소스 번들링 및 샤딩조차도 일부 상황에서 여전히 좋은 방법입니다. 마찬가지로 PreloadHint 힌트와 같이 프로토콜 동작을 조정하는 다른 메커니즘에는 종종 숨겨진 깊이와 버그가 포함되어 있어 올바르게 사용하기 어렵습니다. <u>때문에 나는 이런 잘못된 오보를 막아 HTTP/3에 대한 비현실적인 기대감이 널리 퍼지기 전에 막는 것이 중요하다고 판단</u>했습니다.\r\n\r\n이 글에서 나는 **<u>새로운 프로토콜과 특히 그 퍼포먼스적 특징</u>**에 대해 이야기할 것입니다. 그리고 HTTP3의 유망한 새로운 컨셉과 그렇지만 동시에 슬프게도 대부분의 웹 페이지에와 유저에게는 제한된 임팩트만을 줄 것에 대해 이야기하겠습니다. HTTP3는 또한 준비하고 사용하기 까지 꽤 어렵습니다. 때문에 새로운 프로토콜을 이해하기 위해 단단히 준비하세요!\r\n\r\n이 시리즈는 **<u>크게 3가지 파트</u>**로 나뉩니다:\r\n\r\n### 01. HTTP/3 history and core concepts HTTP/3에 관한 역사와 핵심 컨셉\r\n\r\n: 일반적으로 HTTP/3 및 프로토콜을 처음 접하는 사람들을 대상으로 하며 기본 사항들에 대해 설명합니다.\r\n\r\n### 02. HTTP/3 Perfomance features: 퍼포먼스적 특징\r\n\r\n: 더 깊이 있고 기술적인 파트입니다. 기본 사항을 이미 알고 있는 사람들은 1번을 스킵하고 여기부터 시작해도 좋습니다.\r\n\r\n### 03. Practical HTTP/3 deployment options: 실질적 배포 옵션\r\n\r\n: HTTP/3를 직접 배포하고 테스트하는 것과 관련된 문제를 설명합니다. 웹 페이지와 리소스도 변경해야 할 수도 있는데, 그렇게 하는 방법과 그렇게 해야 하는 이유에 대해 자세히 설명합니다.\r\n\r\n이 시리즈는 프로토콜에 대한 깊은 이해가 필요없는 웹 개발자들을 타겟으로 쓰였습니다. 그러나, 충분한 양의 기술적 디테일과 많은 외부링크들을 포함하고 있으므로 advanced readers들 역시 충분히 배울 것이 있을 겁니다.\r\n\r\n\r\n\r\n## ❓ HTTP/3 도대체 왜 필요한건데?\r\n\r\n종종 드는 생각인데, \"HTTP2가 나온 2015 이후에 왜이렇게 빨리 HTTP3가 필요해진거지?\" 이 질문에 대해서 사실 당신이 새로운 HTTP버전이 굳이 필요하지는 않지만 TCP의 업그레이드가 필요하다는 것을 깨닫기 전까지는 이상하다고 느낄것이다. \r\n\r\n(새로운 HTTP로 보기보단 TCP의 업그레이드 버전이라는 관점에서 보면 HTTP3가 2버전 이후 빠르게 다시 나오는 것을 이해할 수 있다는 의미로 해석됩니다.)\r\n\r\nTCP는 HTTP와 같이 다른 프로토콜에 대한 안정성(reliability) 및 순서 전달(in-order delivery)과 같은 중요한 서비스를 제공하는 주요 프로토콜입니다. 이 프로토콜이 사용자 대역폭 사용량을 스마트하고 공정하게 제한하는덕분에 수많은 사람이 인터넷에 동시 접속을해도 사용할 수 있습니다.\r\n\r\n프로토콜의 이러한 \"계층화(Layering)\"는 해당 기능을 쉽게 재사용할 수 있도록 하기 위해 수행됩니다. 상위 계층 프로토콜(예: HTTP)은 하위 계층 프로토콜(예: TLS)이 이미 이를 수행하기 때문에 복잡한 기능(예: 암호화)을 다시 구현할 필요가 없습니다. 또 다른 예로 인터넷의 대부분의 응용 프로그램은 내부적으로 TCP를 사용하여 모든 데이터가 완전히 전송되도록 합니다. 이러한 이유로 TCP는 인터넷에서 가장 널리 사용되고 배포된 프로토콜 중 하나입니다.\r\n\r\n![프로토콜레이어](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ef36d1e-d91e-43e0-8732-f3e66ba9ea64/protocol-stack-h2-h3.png)\r\n\r\nTCP는 수십 년 동안 웹의 초석이었지만 2000년대 후반에 그 단점(원문 age를 의역함.)을 보여주기 시작했습니다. QUIC라는 이름의 새로운 전송 프로토콜은 TCP와 몇 가지 주요 면에서 충분히 다르기 때문에 그 위에서 직접 HTTP/2를 실행하는 것이 매우 어려울 수 있습니다. 따라서 **HTTP/3 자체는 사람들이 열광하는 대부분의 새로운 기능을 포함하는 새로운 QUIC 프로토콜과 호환되도록 HTTP/2를 비교적 작게 개조한 것**입니다.\r\n\r\nQUIC은 인터넷 초창기부터 존재했던 TCP가 실제로 최대 효율성을 염두에 두고 구축되지 않았기 때문에 발생하는 효율성 때문에 그 가치가 있습니다. 예를 들어 TCP는 새 연결을 설정하기 위해 **`핸드셰이크`**가 필요합니다. 이는 클라이언트와 서버가 모두 존재하고 데이터를 교환할 의사와 능력이 있는지 확인하기 위해 수행됩니다. 그러나 연결에서 다른 작업을 수행하기 전(preflight)에 완료하려면 전체 네트워크 왕복이 필요합니다. 클라이언트와 서버가 지리적으로 멀리 떨어져 있는 경우 각 RTT(왕복 시간)에 100밀리초 이상이 소요되어 눈에 띄는 지연이 발생할 수 있습니다.\r\n\r\n두 번째 예로, TCP는 실제로 동시에 여러 파일을 전송하는 데 사용하더라도 전송하는 모든 데이터를 단일 \"파일\" 또는 바이트 스트림으로 봅니다(예: 인터넷 웹페이지에서 많은 리소스를 다운로드 받는 것). 실제로 이것은 단일 파일의 데이터를 포함하는 TCP 패킷이 손실되면 해당 패킷이 복구될 때까지 다른 모든 파일도 지연됨을 의미합니다. 이를 **<u>헤드 오브 라인(HoL) 차단</u>**이라고 합니다. 이러한 비효율성은 실제로 관리할 수 있지만(그렇지 않으면 TCP를 30년 이상 사용하지 않았을 것입니다) HTTP와 같은 상위 수준 프로토콜에 눈에 띄는 방식으로 영향을 미칩니다.(앞에서 하나만 손상되더라도 뒤에 모두가 지연되는 상태. 정보처리기사에 자주 출제되는 내용이 나오네요 ;;)\r\n\r\n시간이 지남에 따라 이러한 문제 중 일부를 개선하고 새로운 성능 기능을 도입하기 위해 TCP를 발전 및 업그레이드하려고 했습니다. 예를 들어 TCP Fast Open은 상위 계층 프로토콜이 처음부터 데이터를 보낼 수 있도록 하여 핸드셰이크 오버헤드를 제거합니다. 또 다른 노력은 MultiPath TCP라고 합니다. 여기서 아이디어는 휴대 전화에 일반적으로 Wi-Fi와 (4G) 셀룰러 연결이 모두 있다는 것입니다. 그러므로 추가 처리량과 견고성을 위해 두 가지를 동시에 사용하지 않을 이유가 없겠다는 생각이 당연히 들겠죠?\r\n\r\n이러한 TCP 확장을 구현하는 것은 그리 어렵지 않습니다. 그러나 <u>실제로 인터넷 규모로 배포하는 것은 매우 어렵습니다</u>. TCP는 널리 사용되기 때문에 연결된 거의 모든 장치에는 자체 프로토콜 구현이 탑재되어 있습니다. 이러한 구현이 너무 오래되었거나 업데이트가 부족하거나 버그가 있는 경우 확장을 실제로 사용할 수 없습니다. 달리 말하면, 모든 구현은 확장이 유용하려면 확장에 대해 알아야 합니다. 최종 사용자 장치(예: 컴퓨터 또는 웹 서버)에 대해서만 이야기하는 경우 수동으로 비교적 쉽게 업데이트할 수 있기 때문에 이는 큰 문제가 되지 않습니다. 그러나 자체 TCP 코드도 탑재된 클라이언트와 서버 사이에 다른 많은 장치가 있습니다(예: 방화벽, 로드 밸런서, 라우터, 캐싱 서버, 프록시 등). <u>이러한 미들박스는 업데이트하기가 더 어렵고 때로는 더 엄격합니다</u>. 예를 들어 장치가 방화벽인 경우 (알 수 없는) 확장을 포함하는 모든 트래픽을 차단하도록 구성될 수 있습니다. 실제로, 엄청난 수의 활성 미들박스가 새로운 확장에 대해 더 이상 유지되지 않는 TCP에 대한 특정 가정을 하는 것으로 나타났습니다. <u>결과적으로 충분한 (미들박스) TCP 구현이 실제로 대규모로 확장을 사용하도록 업데이트되기까지는 몇 년에서 10년 이상이 걸릴 수 있습니다. TCP를 진화시키는 것은 사실상 불가능해졌다고 말할 수 있습니다.</u>\r\n\r\n결과적으로 이러한 문제를 해결하려면 직접적인 업그레이드가 아니라 TCP에 대한 대체 프로토콜이 필요하다는 것이 분명해졌습니다. 그러나 TCP 기능과 다양한 구현의 복잡성으로 인해 처음부터 새롭고 더 나은 것을 만드는 것은 기념비적인 일이 될 것입니다. 그래서 2010년대 초반에 이 작업을 연기하기로 결정했습니다. 결국 TCP뿐만 아니라 HTTP/1.1에도 문제가 있었습니다. 우리는 작업을 분할하고 먼저 HTTP/1.1을 \"수정\"하여 현재 HTTP/2가 되도록 선택했습니다. 이 작업이 완료되면 현재 QUIC인 TCP를 대체하는 작업을 시작할 수 있습니다. 원래 QUIC 위에서 HTTP/2를 직접 실행할 수 있기를 희망했지만 주로 기능 중복으로 인해 실제로는 구현이 너무 비효율적이었습니다. 대신 <u>HTTP/2는 QUIC와 호환되도록 몇 가지 주요 영역에서 조정</u>되었습니다. 이 조정된 버전은 주로 마케팅 이유와 명확성을 위해 HTTP/3(QUIC 대신 HTTP/2)으로 명명되었습니다. 따라서 <u>HTTP/1.1과 HTTP/2의 차이점은 HTTP/2와 HTTP/3의 차이점보다 훨씬 더 중요합니다.</u>\r\n\r\n\r\n\r\n## :bulb: What Is QUIC?\r\n\r\n당신은 아마 이게 왜 중요한지 궁금할 것입니다. 이러한 기능이 HTTP/3 에 있는지 QUIC에 있는지 그런걸 누가 신경 쓰나요? QUIC은 TCP와 마찬가지로 HTTP 및 웹 페이지 로딩 외에도 많은 사용 사례에 사용될 수 있고 앞으로도 사용될 일반 전송 프로토콜이기 때문에 이것이 중요하다고 생각합니다. 예를 들어 DNS, SSH, SMB, RTP 등은 모두 QUIC를 통해 실행할 수 있습니다. 따라서 내가 읽은 HTTP/3에 대한 대부분의 오해가 여기에 있기 때문에 QUIC에 대해 좀 더 자세히 살펴보겠습니다.\r\n\r\n아마 QUIC가 *UDP(User Datagram Protocol)*라는 또 다른 프로토콜 위에서 실행된다는 것을 들어보셨을 것입니다. 이것은 사실이지만 많은 사람들이 주장하는 성능 이유는 아닙니다. 이상적으로 QUIC는 위에서 공유한 이미지에 표시된 프로토콜 스택의 IP 위에서 직접 실행되는 완전히 독립적인 새로운 전송 프로토콜이었을 것입니다. 그러나 그렇게 하면 <u>TCP를 발전시키려고 할 때 직면했던 것과 동일한 문제가 발생했을 것</u>(미들웨어 problems)입니다. QUIC를 인식하고 허용하려면 인터넷의 모든 장치를 먼저 업데이트해야 합니다. 운이 좋게도 **<u>인터넷에서 광범위하게 지원되는 다른 하나의 전송 계층 프로토콜인 UDP 위에 QUIC를 구축</u>**할 수 있습니다.\r\n\r\n많은 출처에서 HTTP/3가 성능 때문에 UDP 위에 구축되었다고 주장합니다. HTTP/3는 UDP와 마찬가지로 연결을 설정하지 않고 패킷 재전송을 기다리지 않기 때문에 더 빠르다고 합니다. 하지만 이러한 주장은 잘못된 것입니다. 위에서 말했듯이 **<u>UDP는 QUIC에서 사용</u>**되며, HTTP/3은 주로 인터넷의 (거의) 모든 장치에 이미 알려져 있고 구현되기 때문에 배포가 더 쉬워지기를 희망하기 때문입니다. UDP 위에 얹어진 QUIC은 기본적으로 TCP의 강력하고 대중적인(그러나 다소 느린) 거의 모든 기능을 다시 구현합니다. **QUIC는 수신된 패킷과 재전송에 대한 승인을 사용하여 손실된 패킷이 여전히 도착하도록 하는 절대적으로 신뢰**할 수 있습니다. QUIC는 여전히 연결을 설정하고 **<u>매우 복잡한 핸드셰이크를 사용</u>**합니다. \r\n\r\n마지막으로 QUIC는 발신자가 네트워크나 수신자에 과부하를 주지 않도록 하는, 소위 흐름 제어 및 혼잡 제어 메커니즘을 사용하지만, 이로 인해 원시 UDP로 할 수 있는 것보다 TCP를 느리게 합니다. 핵심은 QUIC이 이러한 기능을 TCP보다 더 똑똑하고 더 성능이 좋은 방식으로 구현한다는 것입니다. 수십 년의 배포 경험과 TCP의 모범 사례를 몇 가지 핵심 새 기능과 결합합니다. 이 기사의 뒷부분에서 이러한 기능에 대해 더 자세히 설명합니다.\r\n\r\n\r\n\r\n## The Big Changes\r\n\r\n그렇다면 QUIC은 TCP보다 정확히 어떤 점이 얼마나 향상된다는 겁니까? 뭐가 그렇게 다른건가요? 시리즈의 다음 부분에서 자세히 논의할 QUIC(0-RTT 데이터, 연결 마이그레이션, 패킷 손실 및 느린 네트워크에 대한 복원력 향상)에는 몇 가지 새로운 구체적인 기능과 기회가 있습니다. 그러나 이러한 모든 새로운 사항은 기본적으로 4가지 주요 변경 사항으로 요약됩니다.\r\n\r\n1. QUIC deeply integrates with TLS. QUIC는 TLS와 긴밀하게 통합됩니다.\r\n2. QUIC supports multiple *independent* byte streams. QUIC는 여러 개의 독립적인 바이트 스트림을 지원합니다.\r\n3. QUIC uses connection IDs. QUIC는 연결 ID를 사용합니다.\r\n4. QUIC uses frames. QUIC는 프레임을 사용합니다.\r\n\r\n좀 더 자세히 알아보자.\r\n\r\n### TLS 없이 QUIC도 없다\r\n\r\n언급했듯이 TLS는 인터넷을 통해 전송되는 데이터의 보안 및 암호화를 담당합니다. HTTPS를 사용하는 경우 일반 텍스트 HTTP 데이터는 TCP로 전송되기 전에 먼저 TLS로 암호화됩니다.\r\n\r\n![TSL, TCP and QUIC](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f2240cb4-eb62-4054-ad19-0e72190e0a4f/connection-setup.png)\r\n\r\n인터넷 초창기 시절에는 트래픽을 암호화처리 비용이 많이 들었습니다. 또한 모든 유스 케이스에 반드시 필요한 것으로 여겨지지 않았습니다. 역사적으로 TLS는 TCP 위에서 선택적으로 사용할 수 있는 완전히 별도의 프로토콜이었습니다. 이것이 HTTP(TLS 없음)와 HTTPS(TLS 포함)를 구분하는 이유입니다. 시간이 지나면서 인터넷 보안에 대한 우리의 태도는 변화했습니다. \"보안이 된 것(HTTPS)가 기본이다\"라고 말이죠. 따라서 HTTP/2는 이론적으로 TSL없이 TCP를 통해 직접 실행할 수 있지만 실제로 이 모드를 지원하는 웹 브라우저는 없습니다. 어떤 면에서 브라우저 제조업체는 성능을 희생하면서까지 보안상의 안전을 위해 일부러 절충안을 택했습니다.\r\n\r\nalways-on TSL로의 분명한 진보 덕분에 QUIC의 설계자(designer)가 이 트렌드를 한 단계 더 발전시키기로 결정한 것은 어찌보면 당연한 것일지도 모릅니다. 단순히 HTTP/3에 대한 일반 텍스트 모드를 정의하지 않는 대신 QUIC 자체에 암호화를 깊숙이 뿌리기로 선택했습니다. QUIC의 첫 번째 Google 전용 버전은 이를 위해 맞춤 설정을 사용했지만 표준화된 QUIC는 기존 TLS 1.3 자체를 직접 사용합니다. 이를 위해 이전 이미지에서 볼 수 있듯이 <u>프로토콜 스택의 프로토콜 간의 일반적인 명확한 분리를 깨뜨립니다</u>. TLS 1.3은 여전히 TCP 위에서 독립적으로 실행할 수 있지만 QUIC는 대신 TLS 1.3을 캡슐화합니다. <u>달리 말하면 TLS 없이 QUIC를 사용할 방법이 없습니다. QUIC(및 확장하여 HTTP/3)는 항상 완전히 암호화됩니다</u>. 또한 QUIC는 거의 모든 패킷 헤더 필드도 암호화합니다. 전송 계층 정보(예: TCP에 대해 암호화되지 않은 패킷 번호)는 더 이상 QUIC의 중개자가 읽을 수 없습니다(일부 패킷 헤더 플래그도 암호화됨).\r\n\r\n![*Unlike TCP + TLS, QUIC also encrypts its transport-layer meta data in the packet header and payload.*](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fbf86b42-8f20-4b27-aea5-f1fc164b2683/tcp-vs-quic-packetization.png)\r\n\r\n이 모든 것을 위해 QUIC는 먼저 수학적 암호화 매개변수를 설정하기 위해 <u>TCP를 사용하는 것처럼 TLS 1.3 핸드셰이크를 사용</u>합니다. 그러나 이후에는 QUIC가 패킷 자체를 인수하여 암호화하는 반면 TLS-over-TCP에서는 TLS가 자체 암호화를 수행합니다. 이 겉보기에 작은 차이는 더 낮은 프로토콜 계층에서 시행되는 상시 작동 암호화에 대한 근본적인 개념적 변화를 나타냅니다.\r\n\r\n이 방법은 QUIC에 **<u>몇 가지 이득을 제공</u>**합니다.\r\n\r\n###  이점1. QUIC is more secure for its users. 유저는 attacker와 도청자로부터 더욱 안전합니다.\r\n\r\n일반 텍스트 QUIC를 실행할 수 있는 방법이 없으므로 공격자와 도청자가 들을 수 있는 옵션도 적습니다.\r\n\r\n### 이점2. QUIC’s connection set-up is faster. 연결이 더 빠릅니다.\r\n\r\nTLS-over-TCP 방식에서는 두 프로토콜 모두에서 분리된 핸드셰이크가 필요했다면 QUIC은 전송과 암호화 핸드셰이크를 하나로 결합하여 왕복 시 코스트를 절약할 수 있습니다.\r\n\r\n### 이점3. QUIC can evolve more easily. 새롭게 진화하기 쉽다.\r\n\r\n완전히 암호화 되어있기 때문에 네트워크의 미들박스는 더 이상 TCP에서와 같이 내부 작동을 관찰하고 해석할 수 없습니다. 결과적으로 업데이트에 실패했기 때문에 최신 버전의 QUIC에서 더 이상 중단될 수 없습니다. 향후 QUIC에 새로운 기능을 추가하려면 모든 미들박스 대신 최종 장치만 업데이트하면 됩니다.\r\n\r\n하지만 동시에 **<u>잠재적 DOWNSIDE도 예상</u>**됩니다.\r\n\r\n### 단점1. Many networks will hesitate to allow QUIC. 다수의 네트워크에서 QUIC도입을 꺼릴 것이다.\r\n\r\n원치 않는 트래픽을 감지하는 것이 더 어려워지기 때문에 <u>회사는 방화벽에서 이를 차단하려고 할 수 있습니다</u>. 평균 지연 및 패킷 손실 비율과 같은 메트릭을 더 이상 쉽게 사용할 수 없어 <u>문제를 감지하고 진단하기가 더 어려워지기 때문에 ISP 및 중간 네트워크가 이를 차단할 수 있습니다.</u>\r\n\r\n### 단점2. QUIC has a higher encryption overhead. 암호화 오버헤드가 더 크다.\r\n\r\nQUIC는 TLS로 각 개별 패킷을 암호화하는 반면 TLS-over-TCP는 동시에 여러 패킷을 암호화할 수 있습니다.\r\n\r\n### 단점 3. QUIC makes the web more centralized. QUIC이 웹을 더 중앙집중화 시킬 것이다.\r\n\r\n첫째로 내가 자주 접한 불만은 \"QUIC은 다른 사람과 데이터를 공유하지 않고 <u>데이터에 대한 전체 액세스 권한을 부여</u>하기 때문에 Google에서 푸시하고 있습니다.\"와 같은 것입니다. QUIC는 TLS-over-TCP(QUIC는 현상을 유지한다)보다 외부 관찰자로부터 더 많은(또는 적게!) 사용자 수준 정보(예: 방문 중인 URL)를 숨기지 않습니다.\r\n\r\n둘째로, Google이 QUIC 프로젝트를 시작했지만 오늘 우리가 이야기하는 최종 프로토콜은 IETF(Internet Engineering Task Force)의 훨씬 더 광범위한 팀에서 설계했습니다. IETF의 QUIC는 기술적으로 Google의 QUIC와 매우 다릅니다. 그러나 IETF의 사람들은 대부분 Google 및 Facebook과 같은 대기업과 Cloudflare 및 Fastly와 같은 CDN에서 온 사람들입니다. QUIC의 복잡성으로 인해, 예를 들어 실제로 HTTP/3을 올바르고 성능적으로 배포하는 데 필요한 노하우를 가진 회사는 주로 앞서 언급한 회사들일 것입니다. 이것은 아마도 이러한 회사들로의 더 많은 <u>중앙 집중화</u>로 이어질 것이 우려되는 사항입니다.\r\n\r\n\r\n\r\n---\r\n\r\n여기까지도 내용이 많은데 이게 절반 정도입니다... \r\n\r\n나머지 내용도 곧 번역해서 업로드하겠습니다..!\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n");

/***/ }),

/***/ "./contents/blog/번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md":
/*!*******************************************************************************!*\
  !*** ./contents/blog/번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\r\ntitle: \"처음부터 끝까지 상세히 알아보자 HTTP3에 대한 A TO Z 2편\"\r\ndate: \"2021.08.22\"\r\ntags: \r\n  - HTTP3\r\n  - 프로토콜\r\n---\r\n\r\n# (번역) HTTP/3 FROM A To Z: Core Concepts (Part 1) by Robin Marx\r\n\r\n원문링크: [https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)\r\n\r\n이 글은 *Robin Marx*의 [**HTTP/3 FROM A To Z: Core Concepts (Part1)**](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)을 두 포스트로 나눠 번역하였습니다.\r\n\r\n앞부분 첫 번째 포스트는 [처음부터 끝까지 상세히 알아보자! - HTTP/3에 대한 A TO Z (1)]()에서 보실 수 있습니다.\r\n\r\n\r\n\r\n*2부 START!*\r\n\r\n\r\n\r\n## :bulb: QUIC은 다중 바이트 스트림을 구분할 수 있습니다\r\n\r\nHTTP/1.1의 리소스 로드 프로세스는 매우 간단합니다. 각 파일은 자체 TCP가 연결되고 파일 전체가 다운로드 됩니다. 예를 들어, A, B, C 파일이 있다면 우리는 3개의 TCP연결이 있습니다 (HTTP/1.1에서). 실제로 브라우저는 사용할 수 있는 동시 연결 수(병렬로 다운로드할 수 있는 파일 수)에 대한 제한을 부과합니다 (일반적으로 페이지 로드당 약 6~30개). 그런 다음 이전 파일이 완전히 전송되면 연결을 다시 사용하여 새 파일을 다운로드합니다. 이러한 제한은 결국 30개 이상의 리소스를 로드하는 최신 페이지의 웹 성능을 방해하기 시작했습니다.\r\n\r\n이러한 상황을 개선하는 것이 HTTP/2의 주요 목표 중 하나였습니다. 프로토콜은 더 이상 각각의 모든 파일에 대해 새 TCP 연결을 열지 않고 단일 TCP 연결을 통해 다른 리소스를 다운로드하여 이를 수행합니다. 이것은 \"멀티플렉싱\"이라는 여러개 바이트 스트림에 의해 수행됩니다. 그것은 우리가 그것을 전송할 때 다른 파일의 데이터를 혼합하는 멋진 방법을 뜻합니다. 세 가지 예제 파일의 경우 단일 TCP 연결을 통해 들어오는 데이터는 AABBCCAABBCC처럼 보일 수 있습니다(다른 많은 순서 체계가 가능하지만). 이것은 충분히 간단해 보이고 실제로 아주 잘 작동하여 HTTP/2를 일반적으로 HTTP/1.1만큼 빠르거나 약간 빠르지만 오버헤드는 훨씬 적습니다.\r\n\r\n이미지를 통해 차이점을 확인해봅시다.\r\n\r\n![http1.1과 http2의 차이점](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/900ea8f0-3782-4505-b1b6-99ca2954bbce/multiplexing-basic.png)\r\n\r\n<u>그러나, TCP 쪽에 문제가 있습니다.</u> 알다시피 TCP는 오래된 프로토콜이고 웹 페이지를 로딩하기 위해 만들어진 것이 아니기 때문에 A, B, C가 무엇인지 알지 못합니다. TCP는 내부적으로 그냥 단순한 하나의 파일 X를 전송하고 있다고 생각하고 있어 실제로 HTTP 수준에서 AABBCCAABBCC로 전달되는 것인지 XXXXXXXXXXXX로 보이는 것인지에 대해 신경 쓰지 않습니다. 대부분의 경우에서는 이게 큰 문제가 되지는 않습니다. <u>하지만 네트워크 상에서 패킷로스가 있을 경우에는 문제가 됩니다.</u>\r\n\r\n모든 데이터 전송은 문제없었지만 3번째 패킷(file B의 첫 데이터를 담고 있는)이 손실되었다고 생각해봅시다. TCP는 이 손실을 메꾸기 위해 손실 데이터의 새로운 복사본을 재전송합니다. 그러나 이 재전송은 도착까지 시간이 꽤 걸립니다. 아마 이글을 읽는 독자분께서는 A랑 C파일 LOSS만 없었다면 '그게 뭐 대수라고', '그냥 다시 B 파일을 재전송하면 되는거 아니냐' 생각할 수도 있습니다. \r\n\r\n하지만 안타깝게도 재전송 로직은 TCP 계층에서 발생하고 앞서 언급했듯이 <u>TCP는 A, B, C에 대해 알지 못하기 때문에</u> 그렇지 않습니다!(-> 문제가 됩니다!) <u>대신 TCP는 단일 X 파일의 일부가 손실되었다고 생각</u>하므로 구멍이 채워질 때까지 X의 나머지 데이터가 처리되지 않도록 해야 한다고 생각합니다. 달리 말하면, HTTP/2 수준에서 우리는 이미 A와 C를 처리할 수 있다는 것을 알고 있지만 TCP는 이것을 알지 못하므로 잠재적인 것보다 일 처리가 더 느립니다. 이러한 문제를 **HOL(Head of Line) Blocking**이라고 합니다. HOL에 대해 더 자세히 알고 싶으면 [Head-of-line example](https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/) 에서 알아보세요.\r\n\r\n<u>전송 계층에서 HoL 차단을 해결하는 것은 QUIC의 주요 목표 중 하나였습니다.</u> TCP와 달리 QUIC는 여러 개의 독립적인 바이트 스트림을 다중화하고 있음을 잘 알고 있습니다. 물론 CSS, JavaScript 및 이미지를 전송하고 있다는 사실까지는 알지 못합니다만 스트림이 분리되어 있다는 것을 알고 있습니다. 이와 같이 QUIC는 스트림별로 패킷 손실 감지와 복구 논리를 수행할 수 있습니다. 위의 시나리오에서는 스트림 B에 대한 데이터만 보류하고 TCP와 달리 A 및 C에 대한 모든 데이터를 가능한 한 빨리 HTTP/3 계층에 전달합니다. 이렇게 되면 이론적으로 퍼포먼스 향상을 기대할 수 있습니다. \r\n\r\n![HOL](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7981cb82-395c-4484-8873-46fd92804b4d/hol-blocking-basic.png)\r\n\r\n\r\n\r\n## ❓ QUIC은 CONNECTION MIGRATION을 지원합니다.\r\n\r\nQUIC의 세 번째 주요 개선 사항은 연결이 더 오래 유지될 수 있다는 사실입니다. 따라서 문제는 이러한 패킷이 올바른 목적지에 어떻게 도착하는가 하는 것입니다. \r\n\r\n인터넷에서 IP 주소는 두 개의 고유한 시스템 간에 패킷을 라우팅하는 데 사용됩니다. 그러나 당신의 전화기와 서버에 대한 IP 두 가지만로는 충분하지 않습니다.  왜냐하면 당신과 서버 모두 양쪽 끝에서 동시에 여러 네트워크 프로그램을 실행할 수 있기를 희망하기 때문입니다. 이것이 각각의 개별 연결마다 양쪽 끝점에서 <u>포트 번호가 할당되어 연결(Connection)과 해당 연결이 속한 응용 프로그램(Application)을 구별하는 이유</u>입니다. 서버 응용 프로그램은 일반적으로 기능에 따라 고정 포트 번호(예: HTTP(S)의 경우 포트 80 및 443, DNS의 경우 포트 53)를 갖는 반면 클라이언트는 일반적으로 각 연결에 대해 포트 번호를 (반)임의로 선택합니다.\r\n\r\n따라서 머신과 애플리케이션 간에 고유한 연결을 정의하려면 **(1)클라이언트 IP 주소** + **(2)클라이언트 포트** + **(3)서버 IP 주소** + **(4)서버 포트**의 <u>4가지가 필요</u>합니다.\r\n\r\nTCP에서 연결은 4-튜플로만 식별됩니다. 따라서 이 네 가지 매개변수 중 하나만 변경되면 연결이 무효화되고 다시 설정해야 합니다(새 핸드셰이크 포함). 이를 이해하려면 `주차장 문제 예시`를 활용하면 좋습니다. 한 번 상상해 보세요. 현재 건물 안에서 Wi-Fi로 스마트폰을 사용하고 있습니다. 따라서 이 Wi-Fi 네트워크에 IP 주소가 있습니다. 이제 외부로 이동하면 휴대전화가 셀룰러 4G 네트워크로 전환될 것입니다. 이것은 새로운 네트워크이기 때문에 완전히 새로운 IP 주소를 갖게 됩니다. 이제 서버는 이전에 본 적이 없는 클라이언트 IP에서 들어오는 TCP 패킷을 보게 됩니다(물론 두 포트와 서버 IP는 동일하게 유지될 수 있지만).\r\n\r\n![wifi에서 셀룰러로의 통신전환](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9413b221-47e9-427b-b958-b0e62fe7f681/1-migration-tcp.png)\r\n\r\n그렇다면 서버는 새로운 IP패킷이 이 기존의 \"연결\"에 속한다는 것을 어떻게 알 수 있을까요? 이러한 패킷이 동일한(임의) 클라이언트 포트(쉽게 발생할 수 있음)를 선택한 셀룰러 네트워크의 다른 클라이언트로부터의 새 연결에 속하지 않는다는 것을 어떻게 알 수 있을까요? 안타깝게도, TCP로는 이것을 알 수 없습니다. TCP는 우리가 셀룰러 네트워크와 스마트폰을 꿈꾸기도 전에 발명되었기 때문에 클<u>라이언트가 IP가 변경되었음을 서버에 알릴 수 있는 메커니즘이 없습니다.</u> 기존 4-튜플에 전송된 TCP 재설정 또는 fin 명령이 더 이상 클라이언트에 도달하지도 않기 때문에 연결을 \"닫을\" 방법조차 없습니다. 따라서 실제로 모든 네트워크 변경은 기존 TCP 연결을 더 이상 사용할 수 없음을 의미합니다. 새 연결을 설정하려면 새 TCP(및 TLS) 핸드셰이크를 실행해야 하며 응용 프로그램 수준 프로토콜에 따라 진행 중인 작업을 다시 시작해야 합니다. 예를 들어 HTTP를 통해 대용량 파일을 다운로드하는 경우 해당 파일을 처음부터 다시 요청해야 할 수 있습니다. 또 다른 예로는 네트워크를 전환할 때 짧은 정전이 발생할 수 있는 라이브 화상 회의가 있습니다. 하지만 위와 같은 상황에서 TCP 연결을 다시 시작하면 심각한 영향을 미칠 수 있습니다. **<u>이 문제를 해결하기 위해 QUIC에서는 연결 식별자(CID)라는 새로운 개념을 도입</u>**했습니다. 각 연결에는 두 끝점 사이에서 고유하게 식별하는 4-튜플 위에 다른 번호가 할당됩니다. 결정적으로 <u>이 CID는 QUIC 자체의 전송 계층에서 정의되기 때문에 네트워크 간에 이동할 때 변경되지 않습니다</u>!  아래 이미지를 통해 네트워크 원리를 확인해보세요. 이를 가능하게 하기 위해 CID는 모든 QUIC 패킷의 전면에 포함됩니다.\r\n\r\n![QUIC과 CID](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e6ae0ec1-3b85-49a9-9707-ee21ce5b02b3/2-migration-single-cid.png)\r\n\r\n<u>QUIC의 이 설정을 사용하면 4-튜플의 항목 중 하나가 변경되더라도 QUIC 서버와 클라이언트는 CID만 보고 동일한 이전 연결임을 알고 계속 사용할 수 있습니다.</u> 새로운 핸드셰이크가 필요하지 않으며 다운로드 상태를 그대로 유지할 수 있습니다. 이 기능을 일반적으로 연결 마이그레이션이라고 합니다. \r\n\r\n물론 CID도 극복해야 할 다른 과제가 있습니다. 예를 들어, 실제로 하나의 CID만 사용한다면 해커와 도청자가 네트워크를 통해 사용자를 추적하고 확장하여 그들의 (대략적인) 물리적 위치를 추론하는 것이 매우 쉬워질 것입니다. 이러한 프라이버시 악용을 방지하기 위해 QUIC은 새 네트워크가 사용될 때마다 CID를 변경합니다.\r\n\r\n??? 이 얘기는 아마도 이 글을 읽는 독자분들을 혼란스럽게 할 수 있습니다. 방금까지 CID가 네트워크에서 동일해야 한다고 말하지 않았었나요? 흠... 글쎄요, 그것은 지나친 단순화였습니다. 실제로 내부적으로 발생하는 것은 클라이언트와 서버가 모두 동일한 개념적 \"연결\"에 매핑되는 (임의로 생성된) CID의 공통 목록에 동의한다는 것입니다. 예를 들어 둘 다 실제로 CID K, C 및 D가 모두 연결 X에 매핑된다는 것을 알고 있습니다. 따라서 클라이언트는 Wi-Fi에서 패킷에 K로 태그를 지정할 수 있지만 4G에서는 C를 사용하도록 전환할 수 있습니다. 이러한 공통 목록은 QUIC에서 완전히 암호화되어 협상되므로 잠재적인 공격자는 K와 C가 실제로 X인지 알지 못하지만 클라이언트와 서버는 이를 알고 연결을 계속 유지할 수 있습니다. (wifi에서 셀룰러로 전환될 때 똑같은 CID 안에 여러개의 마커를 두고 해당 마커를 포함하기만 하면 같은 사용자라고 식별. 다만 외부에서는 이것을 정정확히 구분할 수 없어 해커로부터 좀 더 안전.)\r\n\r\n![QUIC과 CID2](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/715f189e-4ae6-4c4c-8db8-9fd8170049d8/3-migration-multi-cid.png)\r\n\r\n라이언트와 서버가 스스로 선택한 CID 목록이 다르기 때문에(포트 번호가 다른 것과 유사) 훨씬 더 복잡해집니다. 이는 주로 대규모 서버 설정에서 라우팅 및 로드 밸런싱을 지원하기 위한 것입니다.\r\n\r\n\r\n\r\n## :bulb: QUIC은 유연하고 진화할 수 있습니다.\r\n\r\nQUIC의 마지막 측면은 진화하기 쉽도록 특별히 제작되었다는 것입니다. 이것은 여러 가지 방법으로 수행됩니다. 먼저 논의한 바와 같이 QUIC가 거의 완전히 암호화되어 있다는 사실은 최신 버전의 QUIC를 배포하려는 경우 모든 미들박스가 아니라 끝점(클라이언트 및 서버)만 업데이트하면 된다는 것을 의미합니다. 그것은 여전히 시간이 걸리지 만 일반적으로 몇 년이 아닌 몇 개월 정도입니다. \r\n\r\n둘째, TCP와 달리 QUIC는 단일 고정 패킷 헤더를 사용하여 모든 프로토콜 메타 데이터를 전송하지 않습니다. 대신 QUIC는 패킷 헤더가 짧고 패킷 페이로드 내부에 다양한 \"프레임\"(예: 소형 특수 패킷)을 사용하여 추가 정보를 전달합니다. 예를 들어, 아래 이미지와 같이 ACK 프레임(승인용), NEW_CONNECTION_ID 프레임(연결 마이그레이션 설정을 돕기 위해) 및 STREAM 프레임(데이터 전달용)이 있습니다.\r\n\r\n이것은 모든 패킷이 가능한 모든 메타 데이터를 전달하는 것은 아니기 때문에 주로 최적화로 수행됩니다. 그러나 프레임 사용의 매우 유용한 부작용은 새로운 프레임 유형을 QUIC에 대한 확장으로 정의하는 것이 미래에 매우 쉬울 것이라는 점입니다. 예를 들어 매우 중요한 프레임은 DATAGRAM 프레임으로, 암호화된 QUIC 연결을 통해 신뢰할 수 없는 데이터를 전송할 수 있습니다.\r\n\r\n![QUIC evlolve1](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88c76a7a-2752-4e5b-a829-290cd4951af3/quic-framing.png)\r\n\r\n\r\n\r\n셋째, QUIC는 사용자 지정 TLS 확장을 사용하여 소위 전송 매개변수라 불리는 것을 전달합니다. 이를 통해 클라이언트와 서버는 QUIC 연결을 위한 구성을 선택할 수 있습니다. 이것은 어떤 기능이 활성화되었는지(예: 연결 마이그레이션 허용 여부, 지원되는 확장 등) 협상하고 일부 메커니즘(예: 지원되는 최대 패킷 크기, 흐름 제어 제한)에 대해 가장 합리적인 기본값을 전달할 수 있다는 것을 의미합니다. QUIC 표준은 이들의 긴 목록을 정의하지만 확장을 통해 새 항목을 정의할 수도 있으므로 프로토콜을 더욱 유연하게 만들 수 있습니다.\r\n\r\n마지막으로, QUIC 자체의 실제 요구 사항은 아니지만 대부분의 구현은 현재 \"사용자 공간\"에서 수행됩니다(일반적으로 \"커널 공간\"에서 수행되는 TCP와 반대). 이는 주로 TCP보다 QUIC 구현 변형 및 확장을 실험하고 배포하는 것이 훨씬 쉽다는 것을 의미합니다.\r\n\r\n\r\n\r\n## Conclusion\r\n이 부분에서 배운 내용을 요약해 보겠습니다. 우리는 주로 어디에나 존재하는 TCP 프로토콜과 오늘날의 많은 문제가 알려지지 않은 시기에 HTTP프로토콜이 어떻게 설계되었는지에 대해 이야기했습니다. 하지만 TCP를 발전시키려고 시도하면서 거의 모든 장치에 업데이트해야 하는 자체 TCP 구현이 탑재되어 있기 때문에 TCP자체를 발전시키는 것이 실제로 어렵다는 것이 분명해졌습니다.\r\n\r\nTCP를 계속 개선하면서 이 문제를 우회하기 위해 <u>새로운 QUIC 프로토콜</u>(실제로는 TCP 2.0)을 만들었습니다. <u>QUIC를 더 쉽게 배포할 수 있도록 UDP 프로토콜(대부분의 네트워크 장치도 지원함) 위에서 실행되며 향후 발전할 수 있도록 기본적으로 거의 완전히 암호화되며 유연한 프레이밍을 사용</u>합니다.\r\n\r\n이 외에도 <u>QUIC는 핸드셰이크, 안정성 및 혼잡 제어와 같은 알려진 TCP 기능을 대부분 따라</u>합니다. 암호화 및 프레이밍 외에 두 가지 주요 변경 사항은 다중 바이트 스트림 인식과 연결 ID 도입입니다. 그러나 이러한 변경 사항은 QUIC 위에서 HTTP/2를 직접 실행하는 것을 방지하기에 충분하여 HTTP/3(실제로는 QUIC을 통한 HTTP/2임)을 만들어야 했습니다.\r\n\r\n**QUIC의 새로운 접근 방식은 여러 가지 성능 향상을 제공**하지만 잠재적인 이점은 QUIC 및 HTTP/3에 대한 기사에서 일반적으로 전달되는 것보다 더 미묘한 차이가 있습니다. 이제 기본 사항을 알았으므로 이 시리즈의 다음 부분에서 이러한 뉘앙스를 더 깊이 논의할 수 있습니다. 계속 지켜봐 주세요!\r\n\r\n\r\n\r\n---\r\n\r\n긴 글 읽어주셔서 감사합니다.\r\n\r\n");

/***/ }),

/***/ "./contents/blog/요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md":
/*!***********************************************************!*\
  !*** ./contents/blog/요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"좋은 개발자란 무엇일까\"\ndate: \"2022.08.15\"\ntags:\n- 회고\n---\n\n\n\n\n\n여태까지는 뭔가 \"***기술***\" 블로그라는 것에 갇혀서 현재 블로그에는 내 생각보다는 다른 사람들이 들어와서 참고할 만한 \"기술\"에 관한 것만 포스팅을 해왔습니다.\n\n하지만 향로님의 [2021년 회고](https://jojoldu.tistory.com/626?utm_source=pocket_mylist) 와 같이 좋은 글을 읽으면서 내가 현재 느끼고 있는 생각이나 감정을 남겨보는 것도 좋겠다고 생각해서 처음으로 그러한 내용을 담아보려 합니다.\n\n\n\n# 좋은 개발자란 무엇일까\n\n막연히 좋은 개발자가 되고 싶었습니다. 그러다 문득 ***'좋은 개발자란 무엇인가?'*** 에 대한 정의를 스스로 한 번 내려봐야 겠다고 생각하였고 같은 회사 팀원분과 이런 저런 이야기를 나눴습니다. 잊기 전에 그 내용을 한 번 정리해봤습니다.\n\n내용은 크게 두 가지로 분류해봤습니다. \n\n첫 번째는 **개발 능력,** \n두 번째는 **협업 능력**\n\n인데 그냥 `개발 능력`과 `개발 외 능력` 으로 볼 수 있습니다.\n\n\n\n## A. 개발능력\n\n### 1. 깊이 탐구하는 능력(a.k.a DFS)\n\n제 스스로에 대한 반성이기도 하지만 저 뿐만 아니라 꽤나 많은 개발자들 역시 어떤 것을 공부해 나갈 때, 피상적인 레벨에서 그치는 경우가 종종 있습니다. \n\n예를 들어 프론트엔드 개발자의 면접 단골 질문인 '브라우저는 어떻게 동작하는가?'에 대해서 알고 싶다면 해당 내용을 구글링해서 정리된 내용을 보고 기계적으로 외우거나 이해하는 거죠.\n\n- DNS로 부터 서버 IP 받아오고, HTML 파싱하고, CSSOM, 렌더트리, Reflow, Repaint ...\n\n부끄럽지만 저는 항상 이 수준에 머물렀었던 것 같습니다.\n\n'그러다가 우리가 자주 쓰는 리액트는 이 과정 중에 언제 붙는걸까?' 라는 질문을 받게 되었고 그와 관련해서 리서치를 다시 시작해보는 중 아래와 같은 글을 만나게 되었습니다.\n\n[왜 virtual dom이 더 좋은가?](https://velog.io/@yesbb/virtual-dom%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%9D%B4-%EB%8D%94-%EC%A2%8B%EC%9D%80%EC%9D%B4%EC%9C%A0) (:bulb: 강추!)\n\n위 아티클을 읽어보면 정말 리액트의 가상돔에 대한 아주 깊은 레벨까지의 리서치, 그리고 그것을 정리해낸 내용을 볼 수 있습니다. 처음 이 글을 읽고 좋은 의미에서의 충격을 좀 받았습니다. **'여태까지 내가 한 것은 공부가 아니었구나'**를 일깨워 준 그런 느낌까지 받았습니다.\n\n이후 이렇게 하나의 주제에 대해서 깊은 레벨까지 파고들어서 학습을 해내는 능력이 개발자의 성장에 정말 중요하다는 것을 깨닫게 되었습니다. 그리고 이 능력이 뭔가 깊이우선탐색(DFS)과 동작원리가 유사한 것 같다고 느껴 제 맘대로 `깊이우선탐색(DFS)능력이 있는 개발자` 라고 명명해봤습니다.\n\n\n\n### 2. 넓게 학습하는 능력\n\n개발 영역에서의 기술 발전 속도는 정말 빠릅니다. 스스로 '한 가지를 이해했다!' 싶으면 열 가지의 새로운 것이 생겨나는 기분입니다. 때문에 한 가지를 깊이 파고드는 능력외에도 다양한 기술을 빨리 습득하는 능력도 매우 중요하다고 생각합니다. \n\n- 해당 기술을 어떻게 사용해야 하는지,\n- 해당 기술이 기존 기술의 어떤 점을 보완하는지\n- 기존 기술이 해당 기술보다 더 나은 점은 없는지\n\n를 비교 분석하여 기존에 사용하는 것보다 더 나은 기술이라는 판단이 들면 프로젝트에 도입할 수 있는 능력도 중요하다고 여겨집니다. \n\n이렇게 다양한 것을 넓게 습득하는 능력이 중요한 이유로 크게 두 가지가 더 생각납니다.\n\n#### 2-1. **우리가 현재 닭 잡는 칼로 소를 잡고 있는 것은 아닌가?**\n\n기술은 특정한 문제를 해결하기 위해 만들어지는 경향이 있습니다. 리액트 초기에 프롭드릴링 같은 상태관리 문제를 해결하기 위한 리덕스가 있었고 그 덕분에 FLUX패턴과 전역 상태관리 개념이 생겨났습니다. 이후 프론트엔드에서 리덕스를 사용하는 비율이 상당히 높아졌습니다. 하지만 리덕스의 큰 덩치와 더불어 상태 하나를 추가하기 위해 여러 줄의 보일러플레이트 코드를 만들어야 하는 문제가 있죠. 또한 리액트에서 제공하는 context API와 Recoil 등 여러 대체제가 생겨나면서 대규모 프로젝트가 아닌 경우에는 굳이 새 프로젝트에 리덕스를 사용하지 않아도 되어가고 있습니다. 이처럼 프로젝트에 딱 알맞는 기술을 취사 선택해서 쓸 수 있는 능력을 위해서는 역시 여러 기술들을 익혀놓는 것이 중요합니다.\n\n\n\n#### 2-2. **사용하는 혹은 사용하려는 기술이 시장에서 어떤 포지션에 있고, 그와 관련하여 인력을 보충하거나 기존 팀원들의 러닝커브를 만들지는 않는가?**\n\n대기업과 달리 스타트업에서는 개발자 한 명을 고용하는 것이 참 어려운 일입니다. 때문에 어떤 기술스택을 쓸 것인지를 판단할 때 위에서 말한 프로젝트 레벨에서만 생각해서는 다소 부족합니다. 프로젝트에는 딱 맞는 스킬일 수 있지만 개발자 시장에서는 해당 기술 스택을 가진 인력을 구하는 것이 매우 어려울 수도 있기 때문입니다. 따라서 프로젝트의 현재 뿐만 아니라 미래에도 프로젝트를 이어나가기 위해서 인력 보충에 용이한 기술, 혹은 앞으로 더 인기가 많아질 확률이 높은 기술을 선택하는 것도 (스타트업 한정? 일 수도 있겠습니다...)개발자의 능력이 될 수 있습니다.\n\n\n\n## 3. 다시 돌아보는 능력\n\n처음에는 이 능력에 대한 제목을 '로그를 남기는 능력'으로 하려했습니다. 어떤 것을 했으면 해당 내용에 대해 그 일을 한 사람 뿐만 아니라 다른 사람이 봐도 알아볼 수 있게 기록을 남기는 능력을 말하고 싶었기 때문이었습니다. 하지만 제목을 '다시 돌아보는 능력'이라고 변경한 데는 기록을 남기기만 하는 것에서 그치는 것이 아니라 과거를 뒤돌아보고 당시 상황에서의 잘한 것과 못한 것을 구분하고 그것을 자신 혹은 팀의 성장에 다시 활용할 수 있어야 한다는 생각이 들었기 때문입니다.\n\n사용자의 로그 기록을 아무리 남겨봐야 그 로그를 가지고 사용자 패턴을 분석하거나 하는데 쓰지 않는다면 의미 없는 로그가 되겠죠.\n\n개발자로서 업무를 하는 것도 일맥상통하는점이 있습니다. 시간에 쫓겨 어떤 feature를 개발했더라도 추후에 시간이 남으면 스스로 더 좋게 리팩토링 할 수 없는지 다시 보고, 혼자서 하기 어렵다면 팀원에게 묻고 그것도 안된다면 스택 오버 플로우나 카카오톡 오픈 채팅방에서 물어볼 사람을 찾아서라도 스스로를 되돌아 보려는 능력이 좋은 개발자가 되는 하나의 능력이라 생각합니다.\n\n\n\n작성해 놓고 보니 위 내용들이 꼭 개발에만 한정되는 것은 아니라는 생각이 듭니다.\n\n개발을 떠나 한 명의 개인으로서도 어떤 것을 깊이 파고들고, 또 다방면으로 학습하는 것, 그리고 스스로를 돌아보는 능력은 그 사람이 얼마나 성장할 수 있는 사람인지를 보여준다는 생각이 드네요. \n\n---\n\n\n\n## B. 개발 외 능력\n\n## 1. 커뮤니케이션 능력\n\n개발자에게 타직군과의 소통능력을 요구하는 내용을 이곳 저곳에서 꽤 많이 봤던 것 같습니다. 그때는 이 내용을 상세히 알지 못해서 '뭐 그거 그냥 잘 얘기해서 일하면 되는거 아닌가?'하고 가볍게 생각했었습니다. 하지만 실전은 다르더군요. 주로 겪는 사례는 다음과 같았습니다.\n\n버전 1. 디자이너\n\n- 디자이너: 이거 이렇게 돼요?\n- 개발자: ('어... 되긴 하는데, 그럴려면 기존에 짜둔거를 이렇게 저렇게 바꿔야 되고 좀 이상한데... 꼭 이걸 그렇게 해야되나?'라고 생각하며) \"예, 되긴 되는데...\"\n- 디자이너: 되면 그렇게 해주세요.\n- 개발자: 음... 근데 그럴거면 기존에 이 컴포넌트를 쓰는 다른 곳에서 레이아웃이 무너질 수 있어서 별로 인거 같아요.\n- 디자이너: 되게 해주시면 안돼요? 혹은 \"그냥 해주세요\"\n- 개발자: ...\n\n\n\n여기서 개발자는 어떤 커뮤니케이션을 잘못한 것일까요?\n\n사실 엄밀히 따졌을 때 개발자의 말 중에서 딱히 틀린말은 없습니다. 별로 좋지 않은 요구사항이어서 그렇지 안되는건 아니니까 되긴 한다고 했거든요.\n\n다소 억울하지만 이럴 때 잘 조율해 나가는 것이 바로 개발자의 커뮤니케이션 능력이라 볼 수 있습니다.\n\n\n\n개발자의 첫 번 째 대답을 다음과 같이 수정해 봅시다.\n\n- 디자이너: 이거 이렇게 돼요?\n- 개발자: 음... 이게 기존에 동일하게 사용하고 있는 컴포넌트에 전체적으로 영향을 줄 수 있는 수정사항이라서 이렇게 적용하는 것은 좋지 않을 것 같습니다. 대신 B방식은 어떨까요?\n\n라고 원 제안에 대해서 왜 안좋은 지를 설명하고나서 바로 다른 대안을 바로 제시하는 것이죠.\n\n물론 실전은 이렇게 간단하게 끝나지를 않지만 그래도 이런 커뮤니케이션이 누적되어야 다른 팀원들도 해당 사항에 대해 지속적으로 듣고 생각하면서 점차 발전해나갈 수 있어서 꼭 필요한 능력이라 여겨집니다.\n\n\n\n## 2. 비즈니스 임팩트를 고려하는 능력\n\n개발자가 신규 기능을 만들거나, 코드 장애 상황을 대처할 때 자신이 하는 일이 비즈니스 적으로 얼만큼의 가치를 가진 일인지를 생각할 수 있는 능력이 있으면 좋은 개발자라고 생각합니다.\n\n예를 들어, 어떤 장애 상황이 발생하여 1시간 동안 신규유저가 가입을 할 수 없는 상황이라 가정해 봅시다. 평상시에 해당 시간대에 평균적으로 약 100명이 들어오고 1명의 회원당 5만원의 밸류를 갖는 것을 알고 있다면 이 한 시간동안의 장애가 500만원짜리 장애라는 것을 추산해볼 수 있습니다. \n\n또, 반대로 이와 같이 신규 회원을 모집하는 이벤트를 할 때 한 시간의 가치가 500만원인 경우 이 이벤트를 한 시간 빨리 런칭할 수 있도록 만들어 낸다면 이 개발자는 회사에서 한 시간이라는 추가적인 리소스 비용을 감축시키고 동시에 500만원의 가치를 한 시간 더 일찍 벌어들일 수 있도록 만들었으므로 500만 +의 가치를 생산해냈다고 여길 수 있습니다.\n\n이처럼 개발자가 자신이 스스로 얼마만큼의 가치를 만들어내고 있는지를 알고 그 가치를 안다면, 그 가치를 더욱 크게 만들 수도 있고 반대로 손실도 줄일 수 있습니다. 또한 어떤 일의 우선순위를 정할 때도 이 \"비즈니스 임팩트\"를 기준으로 하면 더 중요한 일에 집중하고 덜 중요한 일을 나중에 할 수도 있습니다. 때문에 개발자에게 비즈니스 임팩트를 고려하는 능력이 중요한 역량이라 생각합니다.\n\n\n\n여기까지가 제가 생각하는 `좋은 개발자` 에 대한 내용이었습니다. \n\n나중에 더 좋은 내용이 생각나면 추가해보도록 하겠습니다.\n\n여러분이 생각하는 좋은 개발자에 대한 의견이 있으시다면 댓글 남겨주세요. 감사합니다.\n\n");

/***/ }),

/***/ "./contents/blog/요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md":
/*!*********************************************************************************!*\
  !*** ./contents/blog/요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: \"요즘들어 개발자도 커뮤니케이션 능력이 중요하다고 느끼는 이유\"\ndate: \"2022.08.28\"\ntags:\n  - 회고\n  - 커뮤니케이션\n---\n\n\n\n## Intro: 커뮤니케이션 능력? 뭐 그거 걍 최대한 잘 얘기하면 되는거 아니야?\n\n예전에는 `커뮤니케이션 능력`을 보면 '뭐 그거 그냥 최대한 잘 얘기하면 되는거 아니야?'라고 가볍게 생각했던 시절이 있었습니다.\n\n하지만 시간이 지날수록 `커뮤니케이션` 이 참 어렵다는 것을 점점 느껴가고 있습니다. 오늘은 그렇게 느끼는 이유에 대해 한 번 작성해보겠습니다.\n\n![잘안됑](/assets/img/실패.jpg)\n\n\n\n## :one:개발자 커뮤니케이션 실패 사례 \n\n이번에 회사 서비스에 인 앱 결제기능을 추가하는 꽤 규모가 큰 태스크가 있었습니다. 토스 페이먼츠를 연동시켜서 한 번 신용카드를 등록해두면 넷플릭스와 같이 매월마다 자동 결제가 되는 시스템입니다.\n\n하지만 기존에는 결제를 어플리케이션 내부에서 구현하지 않았고 전통적인 계좌이체 방식을 통해 계좌이체가 확인된 경우에만 아이디를 발급하여 유저의 접근을 허용해왔습니다. 다시 말해서 결제와 관련된 내용이 하나도 준비되어있지 않은 상태였죠. 따라서 개발자 입장에서는 이것저것 따져봐야할 게 많은 작업이었습니다.\n\n기존에 일하는 방식은 기획팀에서 기획안을 노션 카드로 작성하면 그 내용을 확인하고 읽은 뒤 개발자가 피드백을 주고 그 뒤에 해당 내용을 보완해서 다시 기획안을 수정한 뒤 개발을 진행하는 방식이었습니다. 다소 전통적인 방식이었죠.\n\n**[구 방식]**\n\n- 1) 기획팀 기획안 작성 \n- 2) 개발팀 보완 사항 피드백\n- 3) 기획팀 기획안 수정 보완\n- 4) 개발 진행\n\n근데 이렇게 하다보면 2-3번 과정이 꽤 여러번 반복될 때도 있습니다. 이 경우 개발팀에서 보완을 요청한 내용을 기획팀에서 정확히 받아들이지 못했다는 이야기이거나 반대 혹은 모두의 이해도가 떨어지는 경우일 수도 있습니다.\n\n이런 문제를 해결하기 위해 저희팀은 앞으로 정식적으로 기획안을 작성하기 전에 기획 초안을 가지고 기획/개발 모두가 함께 모이는 `킥오프 미팅`을 진행할 것을 제안했습니다. 앞서 언급한 결제시스템을 추가하는 기획 내용이 첫 번째 케이스가 되었습니다.\n\n**[킥오프 미팅 진행]**\n\n- 기획팀 Draft 설명\n- 개발팀 피드백\n- 회의 마무리\n\n킥오프 미팅은 단계로 따지면 간단하지만 실상은 저 과정에서 많은 내용이 오갔습니다. 저희가 판매하는 상품은 **월별 or 연별 구독 \"플랜\"**이었고 그 플랜의 종류는 크게 다섯가지가 있습니다. 이 중에서 Education 플랜이 있었는데 대학생/대학원생을 위한 할인 개념의 플랜입니다. 이 과정에서 개발팀에서 예측 가능한 문제들을 생각나는대로 피드백을 드렸습니다.\n\n- 'Education 플랜은 어떻게 구별할 수가 있을까요? 가입할 때의 메일 뒤 도메인을 살펴야 할까요? 아니면 학교 이메일로 verification메일을 전송할까요?'\n- '졸업을 해도 학생 이메일이 살아있는 경우는 어떻게 구별할 수 있을까요?'\n- '지금 설명해주신 User Flow에서는 아무 플랜도 선택하지 않은 유저들의 플로우가 빠져있습니다. 이 NONE 타입 플랜일 경우의 User Flow를 추가해주세요.'\n- '새 플랜을 할인하고 있는데, 이런 할인을 언제까지 할 것인지가 누락되어있습니다. 유저 입장에서는 할인이 언제까지 계속될지를 아는 것이 구매에 중요한 요소가 될텐데, 이를 구매전에 미리 알 수 있도록 공지하는 것이 좋을 것 같습니다. 할인이벤트는 언제까지 할 생각이신가요?'\n\n\n\n\n\n### 다른건 몰라도 유저의 돈이 걸린 일은 최대한 꼼꼼하게 처리해야한다!\n\n![유저는 돈에 예민](https://user-images.githubusercontent.com/18045958/188258485-5123f793-efc0-491b-a766-fa22e6cd1bd6.gif)\n\n유저는 돈에 예민하다\n\n\n\n저와 저희팀은 이번 일은 \"유저의 돈\"을 결제/환불하는 시스템이므로 이전까지의 Feature 개발보다 더욱 견고한 아키텍쳐와 타입을 사용해서 진행해야 한다는 마음이 지배적이었습니다. 따라서 위와 같이 발생할 수 있는 오류 사항과 누락사항들을 다 같이 모인 자리에서 최대한 많이 전달해서 더 좋은 기획안을 만들 수 있도록 기여를 해야겠다는 생각으로 회의실에서 최대한 머리를 쥐어 짜냈고 공유했습니다.\n\n회의를 끝내고서도 혹시나 더 빠뜨린 것은 없을까 생각하며 여러번 검토하고 생각나는 사항들은 그때 그때 기획팀으로 전달했습니다.\n\n![쎄한느낌](/assets/img/쎄한느낌.jpg)\n\n\n\n하지만 뭔가 쎄한 느낌이었습니다. 우리 쪽에서 이렇게 열심히 피드백을 해도 기획팀에서는 개발팀의 피드백에 대한 피드백을 따로 하거나, 별로 달가워 하지 않는 듯한 기분이 들었기 때문입니다.\n\n아무튼 기한은 정해져있고, 토스페이먼츠와 카드사의 심사 또한 필요했으므로 기획을 너무 길게 끌 수는 없는 상황이었습니다. 회사는 기획이 완벽하지 않더라도 일단 최대한 빨리 진행하기를 희망했고 일단 프론트 작업과 꼭 필요해보이는 api 작업부터 먼저 진행하기 시작했습니다.\n\n\n\n### (기획) 그거 별로 일어나지도 않을 상황인거 같은데 너무 깐깐하게 구는거 아냐? 개발팀 일하기 싫어서 꼬장부리는거 같은데?\n\n작업이 시작되고 꽤 시간이 지난 후의 일입니다. 한창 일에 열중해있던 그 즈음 건너 건너 건너서 기획팀이 저희 개발팀에 불만을 갖고 있다는 내용을 알게 되었는데 그 내용이 저에게는 가히 충격적이었습니다.\n\n> 그거 별로 일어나지도 않을 상황인거 같은데 너무 깐깐하게 구는거 아냐? 개발팀 일하기 싫어서 꼬장부리는거 같은데?\n\n그렇게 중요한 것 같지 않은데 킥오프 미팅에서 너무 디테일한 면까지 피드백을 한 그 상황이 맘에 들지 않았다는 것이었습니다. 흠.... 백번 양보해서 '킥오프 미팅에서 너무 디테일한 면까지 이야기하는 것이 뭔가 자신의 기획안을 까는 것처럼 느껴져서 기분나쁠 수도 있겠다.'고 스스로를 반성해보기도 했습니다. 하지만 아무리 생각해도 **\"일 하기 싫어서 일부러 그런다\"** 는 도저히 받아들일 수가 없고 속이 부글부글 끓더라구요. 그럼에도 불구하고 다시 한 번 가슴에 손을 얹고 스스로에게 물어봤습니다. **'정말 단 1g의 마음이라도 일을 하기 싫어했던 마음이 있었는가?'**를 자신에게 여러번 다시 반문해보았습니다. 하지만 여러번 생각해봐도 이 사안에 대해서는 스스로 \"전혀 그런 마음이 1g도 없었다\"고 확신할 수 있었습니다.\n\n\n\n도대체 어떤 이유로  우리팀이 이렇게까지 신뢰를 잃었을까... 참 착잡했습니다.\n\n모르는게 약이라고 차라리 이 내용을 몰랐더라면 괜찮았을텐데 알고 나니까 마인드 컨트롤이 쉽지 않았습니다.\n\n어찌저찌 마음을 추스리고 이 상황을 객관적으로 다시 파악해보려 노력했습니다. 도대체 어떤 과정에서 오류가 있었고, 그 과정을 이전과 다른 어떤 새로운 방식으로 대응한다면 지금과는 다른 결과를 이끌어 낼 수 있을지 고민해봤습니다.\n\n\n\n#### 1. 태도가 문제였는가?\n\n- 기획 내용 피드백을 진행하는 과정속에서 너무 '아는 척' 했었던 것일까?\n- 새로운 방안이나 대안을 생각하기 보다는 비판에만 초점을 맞췄던 것일까?\n\n\n\n#### 2. 피드백의 양이 문제였는가? 즉, 프로세스의 단계별 업무 레벨이 있는데 너무 앞서간 것 아닐까?\n\n- 그렇다면 킥오프 미팅에서 전체 100% 중에서 N%만 피드백을 진행하고 해당 과정을 여러번 반복하며 완성도를 높여 나갔어야 했는가?\n\n\n\n## :two: 개발자의 딜레마 1\n\n![딜레마](/assets/img/가불기.jpg)\n\n> 좋은 기획안을 만들기 위해서는 개발자가 줄 수 있는 최대한 많은 양질의 피드백을 준다. 하지만 이 과정 중에 팀간 conflict 발생 가능성이 높다.\n> VS\n> 기획안의 퀄리티를 조금 포기하더라도 최대한 부드러운 태도와 어투로 필수적인 피드백만을 준다. 하지만 이 과정 속에서 놓칠 수 있는 상황은 스스로 처리해야 한다.\n\n현재 제가 처해있는 상황을 바라봤을 때 저는 어느쪽으로 가더라도 장단점이 있는 명확하게 있어서 한 쪽으로 쉽게 선택하지 못하는 딜레마 상황에 빠져있다는 것을 알게 되었습니다. 이 상황에서는 \"피드백을 하면 할수록 갈등상황이 발생한다\"는 것이 전제로 깔려있습니다.\n\n**\"개발자\"** 즉, 엔지니어로서 가장 높은 퀄리티의 프로덕트를 만드는 것이 직업적 소명이라 볼 수 있습니다. 이를 위해서 최대한 완벽한 기획안을 작성할 수 있도록 가능한 모든 피드백을 전달해야 하지 않을까? 하는 생각이 하나 있고,\n\n다른 하나는 '개발자이기 이전에 한 명의 조직구성원으로서 구성원간의 갈등 상황을 줄이고 최대이익을 위해 어느 정도 타협을 해야 하는 것일까?'하는 것이 두 번째 생각입니다.\n\n이상적으로는 1번과 같이 공리주의적으로 각자의 직군에서 최선의 선을 추구하면  전체 조직의 이익이 최대가 될 수 있지 않을까 생각합니다. 하지만 제가 속한 현실은 대부분 2번처럼 타협을 하게 되더군요.\n\n그렇지만 2번처럼 한다고 해도 문제가 해결되지도 않습니다. 개발자에게는 다음과 같은 사항이 주어지게 되는거죠.\n\n\n\n## :three: 개발자의 딜레마 2\n\n> 오케이. 기획의 빈틈 정도는 어느 정도 인정하고 넘어간다. 하지만 개발자의 역량으로 그 나머지 빈틈을 채워넣어서 최대한 오류를 없애도록 하자\n> VS\n> 기획의 빈틈 인정한다. 하지만 기한이 더 중요하므로 빈틈을 채워넣다가 기한을 놓칠바에는 기한에 맞춰 요구사항만을 지켜 개발한다.\n\n훌륭한 개발자라면 기한 안에 모든 요구사항을 만족하고서 부족한 부분까지 채우겠지만, 그럴 수 없는 상황에 처해 위 2개 중에 하나만을 골라야 하는 상황이 대부분입니다.\n\n물론 1번처럼 하는 것이 개발자의 책임이라 볼 수 있습니다. 저 역시 그렇게 하고 싶습니다. 하지만 대부분 시간이 부족합니다. 1번을 선택했을 때의 단점은, 빈틈을 채워넣더라도 아무도 몰라준다는 것이죠. 알아주는 것까지 바라지는 않지만 \"속도가 느린 개발자\", \"일못하는 개발자\"소리를 들을 수 있다는 것이죠.\n\n또 다른 문제로는 이렇게 되면 이게 기준이 되어서 앞으로도 계속 기획안은 이정도 수준에 머물게 될 수도 있습니다.\n\n\n\n2번처럼 하면 지금 당장은 문제가 생기지 않고 조직 내 갈등 상황도 줄여줄 수 있고 잘하면 인정까지 받을 수 있습니다. 하지만 언제 어디서 그 넘어갔던 이슈가 발생할 수도 있다는 불안감, 그리고 실제로 예상했던 그 버그가 발생하여 서비스 장애를 일으키는 상황이 일어날 수 있다는 단점이 있습니다.\n\n\n\n최근 이런 상황을 실전에서 맞닥뜨리면서 여러 회사에서 말하는 `개발자의 커뮤니케이션 능력`이 얼마나 중요한지를 새삼 체감하고 있습니다.\n\n'커뮤니케이션 그까이꺼 대충'하면 되는게 아니네요. 정답이 없는 이런 문제를 해결하는 것이 가장 어려운 것 같습니다.\n\n안타깝게도 지금은 어떻게 해야 옳은 것인지 잘 모르겠습니다. 찾아나가는 중이라 생각하고 이리 치이고 저리 치이면서 좌충우돌하고 있습니다. \n\n이런 상황 속에서도 그때 그때의 최선의 선택을 고르기 위해 고민해 나가는 경험을 많이 갖으면서 고민하는 시간을 많이 가져가다보면 그래도 꽤 좋은 개발자가 될 수 있지 않을까 기대를 해보며 글을 마칩니다.\n");

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _assertThisInitialized; }
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _asyncToGenerator; }
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _classCallCheck; }
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _createClass; }
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _defineProperty; }
/* harmony export */ });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _getPrototypeOf; }
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*****************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*****************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _inherits; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/setPrototypeOf */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0,_babel_runtime_helpers_esm_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__.default)(subClass, superClass);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \********************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _objectWithoutProperties; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__.default)(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*************************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _objectWithoutPropertiesLoose; }
/* harmony export */ });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _possibleConstructorReturn; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(call) === "object" || typeof call === "function")) {
    return call;
  }

  return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__.default)(self);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _setPrototypeOf; }
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!**********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithHoles */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArrayLimit */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableRest */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js":
/*!******************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _taggedTemplateLiteral; }
/* harmony export */ });
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _typeof; }
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \***********************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./.yarn/cache/@babel-runtime-npm-7.12.5-b3edb8ee8e-64964a0fd1.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ }),

/***/ "./.yarn/cache/@emotion-is-prop-valid-npm-1.2.0-332d343e3d-cc7a19850a.zip/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@emotion-is-prop-valid-npm-1.2.0-332d343e3d-cc7a19850a.zip/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js ***!
  \******************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emotion_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @emotion/memoize */ "./.yarn/cache/@emotion-memoize-npm-0.8.0-c5dd451828-c87bb110b8.zip/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js");


var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */(0,_emotion_memoize__WEBPACK_IMPORTED_MODULE_0__.default)(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

/* harmony default export */ __webpack_exports__["default"] = (isPropValid);


/***/ }),

/***/ "./.yarn/cache/@emotion-memoize-npm-0.8.0-c5dd451828-c87bb110b8.zip/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js":
/*!************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@emotion-memoize-npm-0.8.0-c5dd451828-c87bb110b8.zip/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js ***!
  \************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (memoize);


/***/ }),

/***/ "./.yarn/cache/@emotion-stylis-npm-0.8.5-3e9db8959f-67ff595844.zip/node_modules/@emotion/stylis/dist/stylis.browser.esm.js":
/*!*********************************************************************************************************************************!*\
  !*** ./.yarn/cache/@emotion-stylis-npm-0.8.5-3e9db8959f-67ff595844.zip/node_modules/@emotion/stylis/dist/stylis.browser.esm.js ***!
  \*********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function stylis_min (W) {
  function M(d, c, e, h, a) {
    for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
      g = e.charCodeAt(l);
      l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

      if (0 === b + n + v + m) {
        if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
          switch (g) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;

            default:
              f += e.charAt(l);
          }

          g = 59;
        }

        switch (g) {
          case 123:
            f = f.trim();
            q = f.charCodeAt(0);
            k = 1;

            for (t = ++l; l < B;) {
              switch (g = e.charCodeAt(l)) {
                case 123:
                  k++;
                  break;

                case 125:
                  k--;
                  break;

                case 47:
                  switch (g = e.charCodeAt(l + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u = l + 1; u < J; ++u) {
                          switch (e.charCodeAt(u)) {
                            case 47:
                              if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                l = u + 1;
                                break a;
                              }

                              break;

                            case 10:
                              if (47 === g) {
                                l = u + 1;
                                break a;
                              }

                          }
                        }

                        l = u;
                      }

                  }

                  break;

                case 91:
                  g++;

                case 40:
                  g++;

                case 34:
                case 39:
                  for (; l++ < J && e.charCodeAt(l) !== g;) {
                  }

              }

              if (0 === k) break;
              l++;
            }

            k = e.substring(t, l);
            0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

            switch (q) {
              case 64:
                0 < r && (f = f.replace(N, ''));
                g = f.charCodeAt(1);

                switch (g) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r = c;
                    break;

                  default:
                    r = O;
                }

                k = M(c, r, k, g, a + 1);
                t = k.length;
                0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                if (0 < t) switch (g) {
                  case 115:
                    f = f.replace(da, ea);

                  case 100:
                  case 109:
                  case 45:
                    k = f + '{' + k + '}';
                    break;

                  case 107:
                    f = f.replace(fa, '$1 $2');
                    k = f + '{' + k + '}';
                    k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                    break;

                  default:
                    k = f + k, 112 === h && (k = (p += k, ''));
                } else k = '';
                break;

              default:
                k = M(c, X(c, f, I), k, h, a + 1);
            }

            F += k;
            k = I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
            break;

          case 125:
          case 59:
            f = (0 < r ? f.replace(N, '') : f).trim();
            if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
              case 0:
                break;

              case 64:
                if (105 === g || 99 === g) {
                  G += f + e.charAt(l);
                  break;
                }

              default:
                58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
            }
            I = r = u = q = 0;
            f = '';
            g = e.charCodeAt(++l);
        }
      }

      switch (g) {
        case 13:
        case 10:
          47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
          0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
          z = 1;
          D++;
          break;

        case 59:
        case 125:
          if (0 === b + n + v + m) {
            z++;
            break;
          }

        default:
          z++;
          y = e.charAt(l);

          switch (g) {
            case 9:
            case 32:
              if (0 === n + m + b) switch (x) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y = '';
                  break;

                default:
                  32 !== g && (y = ' ');
              }
              break;

            case 0:
              y = '\\0';
              break;

            case 12:
              y = '\\f';
              break;

            case 11:
              y = '\\v';
              break;

            case 38:
              0 === n + b + m && (r = I = 1, y = '\f' + y);
              break;

            case 108:
              if (0 === n + b + m + E && 0 < u) switch (l - u) {
                case 2:
                  112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                case 8:
                  111 === K && (E = K);
              }
              break;

            case 58:
              0 === n + b + m && (u = l);
              break;

            case 44:
              0 === b + v + n + m && (r = 1, y += '\r');
              break;

            case 34:
            case 39:
              0 === b && (n = n === g ? 0 : 0 === n ? g : n);
              break;

            case 91:
              0 === n + b + v && m++;
              break;

            case 93:
              0 === n + b + v && m--;
              break;

            case 41:
              0 === n + b + m && v--;
              break;

            case 40:
              if (0 === n + b + m) {
                if (0 === q) switch (2 * x + 3 * K) {
                  case 533:
                    break;

                  default:
                    q = 1;
                }
                v++;
              }

              break;

            case 64:
              0 === b + v + n + m + u + k && (k = 1);
              break;

            case 42:
            case 47:
              if (!(0 < n + m + v)) switch (b) {
                case 0:
                  switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                    case 235:
                      b = 47;
                      break;

                    case 220:
                      t = l, b = 42;
                  }

                  break;

                case 42:
                  47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
              }
          }

          0 === b && (f += y);
      }

      K = x;
      x = g;
      l++;
    }

    t = p.length;

    if (0 < t) {
      r = c;
      if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
      p = r.join(',') + '{' + p + '}';

      if (0 !== w * E) {
        2 !== w || L(p, 2) || (E = 0);

        switch (E) {
          case 111:
            p = p.replace(ha, ':-moz-$1') + p;
            break;

          case 112:
            p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
        }

        E = 0;
      }
    }

    return G + p + F;
  }

  function X(d, c, e) {
    var h = c.trim().split(ia);
    c = h;
    var a = h.length,
        m = d.length;

    switch (m) {
      case 0:
      case 1:
        var b = 0;

        for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
          c[b] = Z(d, c[b], e).trim();
        }

        break;

      default:
        var v = b = 0;

        for (c = []; b < a; ++b) {
          for (var n = 0; n < m; ++n) {
            c[v++] = Z(d[n] + ' ', h[b], e).trim();
          }
        }

    }

    return c;
  }

  function Z(d, c, e) {
    var h = c.charCodeAt(0);
    33 > h && (h = (c = c.trim()).charCodeAt(0));

    switch (h) {
      case 38:
        return c.replace(F, '$1' + d.trim());

      case 58:
        return d.trim() + c.replace(F, '$1' + d.trim());

      default:
        if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
    }

    return d + c;
  }

  function P(d, c, e, h) {
    var a = d + ';',
        m = 2 * c + 3 * e + 4 * h;

    if (944 === m) {
      d = a.indexOf(':', 9) + 1;
      var b = a.substring(d, a.length - 1).trim();
      b = a.substring(0, d).trim() + b + ';';
      return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
    }

    if (0 === w || 2 === w && !L(a, 1)) return a;

    switch (m) {
      case 1015:
        return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

      case 951:
        return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

      case 963:
        return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

      case 1009:
        if (100 !== a.charCodeAt(4)) break;

      case 969:
      case 942:
        return '-webkit-' + a + a;

      case 978:
        return '-webkit-' + a + '-moz-' + a + a;

      case 1019:
      case 983:
        return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

      case 883:
        if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
        if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
        break;

      case 932:
        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
          case 103:
            return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

          case 115:
            return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

          case 98:
            return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
        }
        return '-webkit-' + a + '-ms-' + a + a;

      case 964:
        return '-webkit-' + a + '-ms-flex-' + a + a;

      case 1023:
        if (99 !== a.charCodeAt(8)) break;
        b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
        return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

      case 1005:
        return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

      case 1e3:
        b = a.substring(13).trim();
        c = b.indexOf('-') + 1;

        switch (b.charCodeAt(0) + b.charCodeAt(c)) {
          case 226:
            b = a.replace(G, 'tb');
            break;

          case 232:
            b = a.replace(G, 'tb-rl');
            break;

          case 220:
            b = a.replace(G, 'lr');
            break;

          default:
            return a;
        }

        return '-webkit-' + a + '-ms-' + b + a;

      case 1017:
        if (-1 === a.indexOf('sticky', 9)) break;

      case 975:
        c = (a = d).length - 10;
        b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

        switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b.charCodeAt(8)) break;

          case 115:
            a = a.replace(b, '-webkit-' + b) + ';' + a;
            break;

          case 207:
          case 102:
            a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
        }

        return a + ';';

      case 938:
        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
          case 105:
            return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

          case 115:
            return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

          default:
            return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
        }
        break;

      case 973:
      case 989:
        if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

      case 931:
      case 953:
        if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
        break;

      case 962:
        if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
    }

    return a;
  }

  function L(d, c) {
    var e = d.indexOf(1 === c ? ':' : '{'),
        h = d.substring(0, 3 !== c ? e : 10);
    e = d.substring(e + 1, d.length - 1);
    return R(2 !== c ? h : h.replace(na, '$1'), e, c);
  }

  function ea(d, c) {
    var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
    return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
  }

  function H(d, c, e, h, a, m, b, v, n, q) {
    for (var g = 0, x = c, w; g < A; ++g) {
      switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;

        default:
          x = w;
      }
    }

    if (x !== c) return x;
  }

  function T(d) {
    switch (d) {
      case void 0:
      case null:
        A = S.length = 0;
        break;

      default:
        if ('function' === typeof d) S[A++] = d;else if ('object' === typeof d) for (var c = 0, e = d.length; c < e; ++c) {
          T(d[c]);
        } else Y = !!d | 0;
    }

    return T;
  }

  function U(d) {
    d = d.prefix;
    void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
    return U;
  }

  function B(d, c) {
    var e = d;
    33 > e.charCodeAt(0) && (e = e.trim());
    V = e;
    e = [V];

    if (0 < A) {
      var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
      void 0 !== h && 'string' === typeof h && (c = h);
    }

    var a = M(O, e, c, 0, 0);
    0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
    V = '';
    E = 0;
    z = D = 1;
    return a;
  }

  var ca = /^\0+/g,
      N = /[\0\r\f]/g,
      aa = /: */g,
      ka = /zoo|gra/,
      ma = /([,: ])(transform)/g,
      ia = /,\r+?/g,
      F = /([\t\r\n ])*\f?&/g,
      fa = /@(k\w+)\s*(\S*)\s*/,
      Q = /::(place)/g,
      ha = /:(read-only)/g,
      G = /[svh]\w+-[tblr]{2}/,
      da = /\(\s*(.*)\s*\)/g,
      oa = /([\s\S]*?);/g,
      ba = /-self|flex-/g,
      na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
      la = /stretch|:\s*\w+\-(?:conte|avail)/,
      ja = /([^-])(image-set\()/,
      z = 1,
      D = 1,
      E = 0,
      w = 1,
      O = [],
      S = [],
      A = 0,
      R = null,
      Y = 0,
      V = '';
  B.use = T;
  B.set = U;
  void 0 !== W && U(W);
  return B;
}

/* harmony default export */ __webpack_exports__["default"] = (stylis_min);


/***/ }),

/***/ "./.yarn/cache/@emotion-unitless-npm-0.7.5-14e1171640-f976e5345b.zip/node_modules/@emotion/unitless/dist/unitless.browser.esm.js":
/*!***************************************************************************************************************************************!*\
  !*** ./.yarn/cache/@emotion-unitless-npm-0.7.5-14e1171640-f976e5345b.zip/node_modules/@emotion/unitless/dist/unitless.browser.esm.js ***!
  \***************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ __webpack_exports__["default"] = (unitlessKeys);


/***/ }),

/***/ "./.yarn/cache/base64-js-npm-1.5.1-b2f7275641-669632eb37.zip/node_modules/base64-js/index.js":
/*!***************************************************************************************************!*\
  !*** ./.yarn/cache/base64-js-npm-1.5.1-b2f7275641-669632eb37.zip/node_modules/base64-js/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./.yarn/cache/buffer-npm-5.6.0-e1494693bf-d659494c50.zip/node_modules/buffer/index.js":
/*!*********************************************************************************************!*\
  !*** ./.yarn/cache/buffer-npm-5.6.0-e1494693bf-d659494c50.zip/node_modules/buffer/index.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./.yarn/cache/base64-js-npm-1.5.1-b2f7275641-669632eb37.zip/node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./.yarn/cache/ieee754-npm-1.2.1-fb63b3caeb-5144c0c981.zip/node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./.yarn/cache/esprima-npm-4.0.1-1084e98778-b45bc805a6.zip/node_modules/esprima/dist/esprima.js":
/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/esprima-npm-4.0.1-1084e98778-b45bc805a6.zip/node_modules/esprima/dist/esprima.js ***!
  \******************************************************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __nested_webpack_require_583__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_583__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_583__.m = modules;

/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_583__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_583__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_583__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __nested_webpack_require_1808__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __nested_webpack_require_1808__(1);
	var jsx_parser_1 = __nested_webpack_require_1808__(3);
	var parser_1 = __nested_webpack_require_1808__(8);
	var tokenizer_1 = __nested_webpack_require_1808__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __nested_webpack_require_1808__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __nested_webpack_require_6456__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_6456__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __nested_webpack_require_15019__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __nested_webpack_require_15019__(4);
	var JSXNode = __nested_webpack_require_15019__(5);
	var jsx_syntax_1 = __nested_webpack_require_15019__(6);
	var Node = __nested_webpack_require_15019__(7);
	var parser_1 = __nested_webpack_require_15019__(8);
	var token_1 = __nested_webpack_require_15019__(13);
	var xhtml_entities_1 = __nested_webpack_require_15019__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __nested_webpack_require_54354__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __nested_webpack_require_54354__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __nested_webpack_require_58416__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __nested_webpack_require_58416__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __nested_webpack_require_80491__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_80491__(9);
	var error_handler_1 = __nested_webpack_require_80491__(10);
	var messages_1 = __nested_webpack_require_80491__(11);
	var Node = __nested_webpack_require_80491__(7);
	var scanner_1 = __nested_webpack_require_80491__(12);
	var syntax_1 = __nested_webpack_require_80491__(2);
	var token_1 = __nested_webpack_require_80491__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __nested_webpack_require_226595__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __nested_webpack_require_226595__(9);
	var character_1 = __nested_webpack_require_226595__(4);
	var messages_1 = __nested_webpack_require_226595__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __nested_webpack_require_277122__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __nested_webpack_require_277122__(10);
	var scanner_1 = __nested_webpack_require_277122__(12);
	var token_1 = __nested_webpack_require_277122__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

/***/ }),

/***/ "./.yarn/cache/extend-shallow-npm-2.0.1-e6ef52b29c-8fb58d9d7a.zip/node_modules/extend-shallow/index.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/extend-shallow-npm-2.0.1-e6ef52b29c-8fb58d9d7a.zip/node_modules/extend-shallow/index.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! is-extendable */ "./.yarn/cache/is-extendable-npm-0.1.1-322b4649ec-3875571d20.zip/node_modules/is-extendable/index.js");

module.exports = function extend(o/*, objects*/) {
  if (!isObject(o)) { o = {}; }

  var len = arguments.length;
  for (var i = 1; i < len; i++) {
    var obj = arguments[i];

    if (isObject(obj)) {
      assign(o, obj);
    }
  }
  return o;
};

function assign(a, b) {
  for (var key in b) {
    if (hasOwn(b, key)) {
      a[key] = b[key];
    }
  }
}

/**
 * Returns true if the given `key` is an own property of `obj`.
 */

function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/index.js":
/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/index.js ***!
  \*******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const fs = __webpack_require__(/*! fs */ "?aa6d");
const sections = __webpack_require__(/*! section-matter */ "./.yarn/cache/section-matter-npm-1.0.0-2f79fd59d6-3cc4131705.zip/node_modules/section-matter/index.js");
const defaults = __webpack_require__(/*! ./lib/defaults */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js");
const stringify = __webpack_require__(/*! ./lib/stringify */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/stringify.js");
const excerpt = __webpack_require__(/*! ./lib/excerpt */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/excerpt.js");
const engines = __webpack_require__(/*! ./lib/engines */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engines.js");
const toFile = __webpack_require__(/*! ./lib/to-file */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/to-file.js");
const parse = __webpack_require__(/*! ./lib/parse */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/parse.js");
const utils = __webpack_require__(/*! ./lib/utils */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/utils.js");

/**
 * Takes a string or object with `content` property, extracts
 * and parses front-matter from the string, then returns an object
 * with `data`, `content` and other [useful properties](#returned-object).
 *
 * ```js
 * const matter = require('gray-matter');
 * console.log(matter('---\ntitle: Home\n---\nOther stuff'));
 * //=> { data: { title: 'Home'}, content: 'Other stuff' }
 * ```
 * @param {Object|String} `input` String, or object with `content` string
 * @param {Object} `options`
 * @return {Object}
 * @api public
 */

function matter(input, options) {
  if (input === '') {
    return { data: {}, content: input, excerpt: '', orig: input };
  }

  let file = toFile(input);
  const cached = matter.cache[file.content];

  if (!options) {
    if (cached) {
      file = Object.assign({}, cached);
      file.orig = cached.orig;
      return file;
    }

    // only cache if there are no options passed. if we cache when options
    // are passed, we would need to also cache options values, which would
    // negate any performance benefits of caching
    matter.cache[file.content] = file;
  }

  return parseMatter(file, options);
}

/**
 * Parse front matter
 */

function parseMatter(file, options) {
  const opts = defaults(options);
  const open = opts.delimiters[0];
  const close = '\n' + opts.delimiters[1];
  let str = file.content;

  if (opts.language) {
    file.language = opts.language;
  }

  // get the length of the opening delimiter
  const openLen = open.length;
  if (!utils.startsWith(str, open, openLen)) {
    excerpt(file, opts);
    return file;
  }

  // if the next character after the opening delimiter is
  // a character from the delimiter, then it's not a front-
  // matter delimiter
  if (str.charAt(openLen) === open.slice(-1)) {
    return file;
  }

  // strip the opening delimiter
  str = str.slice(openLen);
  const len = str.length;

  // use the language defined after first delimiter, if it exists
  const language = matter.language(str, opts);
  if (language.name) {
    file.language = language.name;
    str = str.slice(language.raw.length);
  }

  // get the index of the closing delimiter
  let closeIndex = str.indexOf(close);
  if (closeIndex === -1) {
    closeIndex = len;
  }

  // get the raw front-matter block
  file.matter = str.slice(0, closeIndex);

  const block = file.matter.replace(/^\s*#[^\n]+/gm, '').trim();
  if (block === '') {
    file.isEmpty = true;
    file.empty = file.content;
    file.data = {};
  } else {

    // create file.data by parsing the raw file.matter block
    file.data = parse(file.language, file.matter, opts);
  }

  // update file.content
  if (closeIndex === len) {
    file.content = '';
  } else {
    file.content = str.slice(closeIndex + close.length);
    if (file.content[0] === '\r') {
      file.content = file.content.slice(1);
    }
    if (file.content[0] === '\n') {
      file.content = file.content.slice(1);
    }
  }

  excerpt(file, opts);

  if (opts.sections === true || typeof opts.section === 'function') {
    sections(file, opts.section);
  }
  return file;
}

/**
 * Expose engines
 */

matter.engines = engines;

/**
 * Stringify an object to YAML or the specified language, and
 * append it to the given string. By default, only YAML and JSON
 * can be stringified. See the [engines](#engines) section to learn
 * how to stringify other languages.
 *
 * ```js
 * console.log(matter.stringify('foo bar baz', {title: 'Home'}));
 * // results in:
 * // ---
 * // title: Home
 * // ---
 * // foo bar baz
 * ```
 * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.
 * @param {Object} `data` Front matter to stringify.
 * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].
 * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.
 * @api public
 */

matter.stringify = function(file, data, options) {
  if (typeof file === 'string') file = matter(file, options);
  return stringify(file, data, options);
};

/**
 * Synchronously read a file from the file system and parse
 * front matter. Returns the same object as the [main function](#matter).
 *
 * ```js
 * const file = matter.read('./content/blog-post.md');
 * ```
 * @param {String} `filepath` file path of the file to read.
 * @param {Object} `options` [Options](#options) to pass to gray-matter.
 * @return {Object} Returns [an object](#returned-object) with `data` and `content`
 * @api public
 */

matter.read = function(filepath, options) {
  const str = fs.readFileSync(filepath, 'utf8');
  const file = matter(str, options);
  file.path = filepath;
  return file;
};

/**
 * Returns true if the given `string` has front matter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Boolean} True if front matter exists.
 * @api public
 */

matter.test = function(str, options) {
  return utils.startsWith(str, defaults(options).delimiters[0]);
};

/**
 * Detect the language to use, if one is defined after the
 * first front-matter delimiter.
 * @param  {String} `string`
 * @param  {Object} `options`
 * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed
 */

matter.language = function(str, options) {
  const opts = defaults(options);
  const open = opts.delimiters[0];

  if (matter.test(str)) {
    str = str.slice(open.length);
  }

  const language = str.slice(0, str.search(/\r?\n/));
  return {
    raw: language,
    name: language ? language.trim() : ''
  };
};

/**
 * Expose `matter`
 */

matter.cache = {};
matter.clearCache = function() {
  matter.cache = {};
};
module.exports = matter;


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js":
/*!**************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js ***!
  \**************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const engines = __webpack_require__(/*! ./engines */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engines.js");
const utils = __webpack_require__(/*! ./utils */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/utils.js");

module.exports = function(options) {
  const opts = Object.assign({}, options);

  // ensure that delimiters are an array
  opts.delimiters = utils.arrayify(opts.delims || opts.delimiters || '---');
  if (opts.delimiters.length === 1) {
    opts.delimiters.push(opts.delimiters[0]);
  }

  opts.language = (opts.language || opts.lang || 'yaml').toLowerCase();
  opts.engines = Object.assign({}, engines, opts.parsers, opts.engines);
  return opts;
};


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engine.js":
/*!************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engine.js ***!
  \************************************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function(name, options) {
  let engine = options.engines[name] || options.engines[aliase(name)];
  if (typeof engine === 'undefined') {
    throw new Error('gray-matter engine "' + name + '" is not registered');
  }
  if (typeof engine === 'function') {
    engine = { parse: engine };
  }
  return engine;
};

function aliase(name) {
  switch (name.toLowerCase()) {
    case 'js':
    case 'javascript':
      return 'javascript';
    case 'coffee':
    case 'coffeescript':
    case 'cson':
      return 'coffee';
    case 'yaml':
    case 'yml':
      return 'yaml';
    default: {
      return name;
    }
  }
}


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engines.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engines.js ***!
  \*************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const yaml = __webpack_require__(/*! js-yaml */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/index.js");

/**
 * Default engines
 */

const engines = exports = module.exports;

/**
 * YAML
 */

engines.yaml = {
  parse: yaml.safeLoad.bind(yaml),
  stringify: yaml.safeDump.bind(yaml)
};

/**
 * JSON
 */

engines.json = {
  parse: JSON.parse.bind(JSON),
  stringify: function(obj, options) {
    const opts = Object.assign({replacer: null, space: 2}, options);
    return JSON.stringify(obj, opts.replacer, opts.space);
  }
};

/**
 * JavaScript
 */

engines.javascript = {
  parse: function parse(str, options, wrap) {
    /* eslint no-eval: 0 */
    try {
      if (wrap !== false) {
        str = '(function() {\nreturn ' + str.trim() + ';\n}());';
      }
      return eval(str) || {};
    } catch (err) {
      if (wrap !== false && /(unexpected|identifier)/i.test(err.message)) {
        return parse(str, options, false);
      }
      throw new SyntaxError(err);
    }
  },
  stringify: function() {
    throw new Error('stringifying JavaScript is not supported');
  }
};


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/excerpt.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/excerpt.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const defaults = __webpack_require__(/*! ./defaults */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js");

module.exports = function(file, options) {
  const opts = defaults(options);

  if (file.data == null) {
    file.data = {};
  }

  if (typeof opts.excerpt === 'function') {
    return opts.excerpt(file, opts);
  }

  const sep = file.data.excerpt_separator || opts.excerpt_separator;
  if (sep == null && (opts.excerpt === false || opts.excerpt == null)) {
    return file;
  }

  const delimiter = typeof opts.excerpt === 'string'
    ? opts.excerpt
    : (sep || opts.delimiters[0]);

  // if enabled, get the excerpt defined after front-matter
  const idx = file.content.indexOf(delimiter);
  if (idx !== -1) {
    file.excerpt = file.content.slice(0, idx);
  }

  return file;
};


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/parse.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/parse.js ***!
  \***********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const getEngine = __webpack_require__(/*! ./engine */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engine.js");
const defaults = __webpack_require__(/*! ./defaults */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js");

module.exports = function(language, str, options) {
  const opts = defaults(options);
  const engine = getEngine(language, opts);
  if (typeof engine.parse !== 'function') {
    throw new TypeError('expected "' + language + '.parse" to be a function');
  }
  return engine.parse(str, opts);
};


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/stringify.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/stringify.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const typeOf = __webpack_require__(/*! kind-of */ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js");
const getEngine = __webpack_require__(/*! ./engine */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/engine.js");
const defaults = __webpack_require__(/*! ./defaults */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/defaults.js");

module.exports = function(file, data, options) {
  if (data == null && options == null) {
    switch (typeOf(file)) {
      case 'object':
        data = file.data;
        options = {};
        break;
      case 'string':
        return file;
      default: {
        throw new TypeError('expected file to be a string or object');
      }
    }
  }

  const str = file.content;
  const opts = defaults(options);
  if (data == null) {
    if (!opts.data) return file;
    data = opts.data;
  }

  const language = file.language || opts.language;
  const engine = getEngine(language, opts);
  if (typeof engine.stringify !== 'function') {
    throw new TypeError('expected "' + language + '.stringify" to be a function');
  }

  data = Object.assign({}, file.data, data);
  const open = opts.delimiters[0];
  const close = opts.delimiters[1];
  const matter = engine.stringify(data, options).trim();
  let buf = '';

  if (matter !== '{}') {
    buf = newline(open) + newline(matter) + newline(close);
  }

  if (typeof file.excerpt === 'string' && file.excerpt !== '') {
    if (str.indexOf(file.excerpt.trim()) === -1) {
      buf += newline(file.excerpt) + newline(close);
    }
  }

  return buf + newline(str);
};

function newline(str) {
  return str.slice(-1) !== '\n' ? str + '\n' : str;
}


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/to-file.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/to-file.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const typeOf = __webpack_require__(/*! kind-of */ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js");
const stringify = __webpack_require__(/*! ./stringify */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/stringify.js");
const utils = __webpack_require__(/*! ./utils */ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/utils.js");

/**
 * Normalize the given value to ensure an object is returned
 * with the expected properties.
 */

module.exports = function(file) {
  if (typeOf(file) !== 'object') {
    file = { content: file };
  }

  if (typeOf(file.data) !== 'object') {
    file.data = {};
  }

  // if file was passed as an object, ensure that
  // "file.content" is set
  if (file.contents && file.content == null) {
    file.content = file.contents;
  }

  // set non-enumerable properties on the file object
  utils.define(file, 'orig', utils.toBuffer(file.content));
  utils.define(file, 'language', file.language || '');
  utils.define(file, 'matter', file.matter || '');
  utils.define(file, 'stringify', function(data, options) {
    if (options && options.language) {
      file.language = options.language;
    }
    return stringify(file, data, options);
  });

  // strip BOM and ensure that "file.content" is a string
  file.content = utils.toString(file.content);
  file.isEmpty = false;
  file.excerpt = '';
  return file;
};


/***/ }),

/***/ "./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/utils.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/gray-matter-npm-4.0.3-852ae4f34c-37717bd424.zip/node_modules/gray-matter/lib/utils.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./.yarn/cache/buffer-npm-5.6.0-e1494693bf-d659494c50.zip/node_modules/buffer/index.js")["Buffer"];


const stripBom = __webpack_require__(/*! strip-bom-string */ "./.yarn/cache/strip-bom-string-npm-1.0.0-aa6cb548d1-5635a3656d.zip/node_modules/strip-bom-string/index.js");
const typeOf = __webpack_require__(/*! kind-of */ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js");

exports.define = function(obj, key, val) {
  Reflect.defineProperty(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value: val
  });
};

/**
 * Returns true if `val` is a buffer
 */

exports.isBuffer = function(val) {
  return typeOf(val) === 'buffer';
};

/**
 * Returns true if `val` is an object
 */

exports.isObject = function(val) {
  return typeOf(val) === 'object';
};

/**
 * Cast `input` to a buffer
 */

exports.toBuffer = function(input) {
  return typeof input === 'string' ? Buffer.from(input) : input;
};

/**
 * Cast `val` to a string.
 */

exports.toString = function(input) {
  if (exports.isBuffer(input)) return stripBom(String(input));
  if (typeof input !== 'string') {
    throw new TypeError('expected input to be a string or buffer');
  }
  return stripBom(input);
};

/**
 * Cast `val` to an array.
 */

exports.arrayify = function(val) {
  return val ? (Array.isArray(val) ? val : [val]) : [];
};

/**
 * Returns true if `str` starts with `substr`.
 */

exports.startsWith = function(str, substr, len) {
  if (typeof len !== 'number') len = substr.length;
  return str.slice(0, len) === substr;
};


/***/ }),

/***/ "./.yarn/cache/hoist-non-react-statics-npm-3.3.2-e7b709e6c1-b153827042.zip/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./.yarn/cache/hoist-non-react-statics-npm-3.3.2-e7b709e6c1-b153827042.zip/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(/*! react-is */ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./.yarn/cache/ieee754-npm-1.2.1-fb63b3caeb-5144c0c981.zip/node_modules/ieee754/index.js":
/*!***********************************************************************************************!*\
  !*** ./.yarn/cache/ieee754-npm-1.2.1-fb63b3caeb-5144c0c981.zip/node_modules/ieee754/index.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./.yarn/cache/is-extendable-npm-0.1.1-322b4649ec-3875571d20.zip/node_modules/is-extendable/index.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/is-extendable-npm-0.1.1-322b4649ec-3875571d20.zip/node_modules/is-extendable/index.js ***!
  \***********************************************************************************************************/
/***/ (function(module) {

"use strict";
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */



module.exports = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null
    && (typeof val === 'object' || typeof val === 'function');
};


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/index.js":
/*!************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/index.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";



var yaml = __webpack_require__(/*! ./lib/js-yaml.js */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml.js");


module.exports = yaml;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml.js":
/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml.js ***!
  \******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";



var loader = __webpack_require__(/*! ./js-yaml/loader */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/loader.js");
var dumper = __webpack_require__(/*! ./js-yaml/dumper */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/dumper.js");


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type = __webpack_require__(/*! ./js-yaml/type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");
module.exports.Schema = __webpack_require__(/*! ./js-yaml/schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");
module.exports.FAILSAFE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.JSON_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/json */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/json.js");
module.exports.CORE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/core */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/core.js");
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(/*! ./js-yaml/exception */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js");

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/failsafe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js");
module.exports.SAFE_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_safe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
module.exports.DEFAULT_SCHEMA = __webpack_require__(/*! ./js-yaml/schema/default_full */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js");

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js ***!
  \*************************************************************************************************************/
/***/ (function(module) {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/dumper.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/dumper.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
    // byte-order-mark
    && c !== 0xFEFF
    // b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON
    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js ***!
  \****************************************************************************************************************/
/***/ (function(module) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/loader.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/loader.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(/*! ./common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException       = __webpack_require__(/*! ./exception */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js");
var Mark                = __webpack_require__(/*! ./mark */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/mark.js");
var DEFAULT_SAFE_SCHEMA = __webpack_require__(/*! ./schema/default_safe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js");
var DEFAULT_FULL_SCHEMA = __webpack_require__(/*! ./schema/default_full */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js");


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/mark.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/mark.js ***!
  \***********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";



var common = __webpack_require__(/*! ./common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common        = __webpack_require__(/*! ./common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");
var YAMLException = __webpack_require__(/*! ./exception */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js");
var Type          = __webpack_require__(/*! ./type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/core.js":
/*!******************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/core.js ***!
  \******************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(/*! ../schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./json */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/json.js")
  ]
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js":
/*!**************************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_full.js ***!
  \**************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __webpack_require__(/*! ../schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(/*! ./default_safe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/js/undefined */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"),
    __webpack_require__(/*! ../type/js/regexp */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"),
    __webpack_require__(/*! ../type/js/function */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/function.js")
  ]
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js":
/*!**************************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js ***!
  \**************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(/*! ../schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./core */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/core.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/timestamp */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"),
    __webpack_require__(/*! ../type/merge */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/merge.js")
  ],
  explicit: [
    __webpack_require__(/*! ../type/binary */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/binary.js"),
    __webpack_require__(/*! ../type/omap */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/omap.js"),
    __webpack_require__(/*! ../type/pairs */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/pairs.js"),
    __webpack_require__(/*! ../type/set */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/set.js")
  ]
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js ***!
  \**********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(/*! ../schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  explicit: [
    __webpack_require__(/*! ../type/str */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/str.js"),
    __webpack_require__(/*! ../type/seq */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/seq.js"),
    __webpack_require__(/*! ../type/map */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/map.js")
  ]
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/json.js":
/*!******************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/json.js ***!
  \******************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __webpack_require__(/*! ../schema */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema.js");


module.exports = new Schema({
  include: [
    __webpack_require__(/*! ./failsafe */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js")
  ],
  implicit: [
    __webpack_require__(/*! ../type/null */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/null.js"),
    __webpack_require__(/*! ../type/bool */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/bool.js"),
    __webpack_require__(/*! ../type/int */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/int.js"),
    __webpack_require__(/*! ../type/float */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/float.js")
  ]
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js":
/*!***********************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js ***!
  \***********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(/*! ./exception */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/exception.js");

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/binary.js":
/*!******************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/binary.js ***!
  \******************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = undefined;
  NodeBuffer = __webpack_require__(/*! buffer */ "./.yarn/cache/buffer-npm-5.6.0-e1494693bf-d659494c50.zip/node_modules/buffer/index.js").Buffer;
} catch (__) {}

var Type       = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/bool.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/bool.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/float.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/float.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(/*! ../common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/int.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/int.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(/*! ../common */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/common.js");
var Type   = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/function.js":
/*!***********************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/function.js ***!
  \***********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = undefined;
  esprima = __webpack_require__(/*! esprima */ "./.yarn/cache/esprima-npm-4.0.1-1084e98778-b45bc805a6.zip/node_modules/esprima/dist/esprima.js");
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(/*! ../../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js":
/*!*********************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js":
/*!************************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js ***!
  \************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/map.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/map.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/merge.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/merge.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/null.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/null.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/omap.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/omap.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/pairs.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/pairs.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/seq.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/seq.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/set.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/set.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/str.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/str.js ***!
  \***************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),

/***/ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/timestamp.js":
/*!*********************************************************************************************************************!*\
  !*** ./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type/timestamp.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(/*! ../type */ "./.yarn/cache/js-yaml-npm-3.14.1-b968c6095e-bef146085f.zip/node_modules/js-yaml/lib/js-yaml/type.js");

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),

/***/ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js":
/*!***********************************************************************************************!*\
  !*** ./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js ***!
  \***********************************************************************************************/
/***/ (function(module) {

var toString = Object.prototype.toString;

module.exports = function kindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';

  var type = typeof val;
  if (type === 'boolean') return 'boolean';
  if (type === 'string') return 'string';
  if (type === 'number') return 'number';
  if (type === 'symbol') return 'symbol';
  if (type === 'function') {
    return isGeneratorFn(val) ? 'generatorfunction' : 'function';
  }

  if (isArray(val)) return 'array';
  if (isBuffer(val)) return 'buffer';
  if (isArguments(val)) return 'arguments';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  if (isRegexp(val)) return 'regexp';

  switch (ctorName(val)) {
    case 'Symbol': return 'symbol';
    case 'Promise': return 'promise';

    // Set, Map, WeakSet, WeakMap
    case 'WeakMap': return 'weakmap';
    case 'WeakSet': return 'weakset';
    case 'Map': return 'map';
    case 'Set': return 'set';

    // 8-bit typed arrays
    case 'Int8Array': return 'int8array';
    case 'Uint8Array': return 'uint8array';
    case 'Uint8ClampedArray': return 'uint8clampedarray';

    // 16-bit typed arrays
    case 'Int16Array': return 'int16array';
    case 'Uint16Array': return 'uint16array';

    // 32-bit typed arrays
    case 'Int32Array': return 'int32array';
    case 'Uint32Array': return 'uint32array';
    case 'Float32Array': return 'float32array';
    case 'Float64Array': return 'float64array';
  }

  if (isGeneratorObj(val)) {
    return 'generator';
  }

  // Non-plain objects
  type = toString.call(val);
  switch (type) {
    case '[object Object]': return 'object';
    // iterators
    case '[object Map Iterator]': return 'mapiterator';
    case '[object Set Iterator]': return 'setiterator';
    case '[object String Iterator]': return 'stringiterator';
    case '[object Array Iterator]': return 'arrayiterator';
  }

  // other
  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
};

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isArray(val) {
  if (Array.isArray) return Array.isArray(val);
  return val instanceof Array;
}

function isError(val) {
  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function'
    && typeof val.getDate === 'function'
    && typeof val.setDate === 'function';
}

function isRegexp(val) {
  if (val instanceof RegExp) return true;
  return typeof val.flags === 'string'
    && typeof val.ignoreCase === 'boolean'
    && typeof val.multiline === 'boolean'
    && typeof val.global === 'boolean';
}

function isGeneratorFn(name, val) {
  return ctorName(name) === 'GeneratorFunction';
}

function isGeneratorObj(val) {
  return typeof val.throw === 'function'
    && typeof val.return === 'function'
    && typeof val.next === 'function';
}

function isArguments(val) {
  try {
    if (typeof val.length === 'number' && typeof val.callee === 'function') {
      return true;
    }
  } catch (err) {
    if (err.message.indexOf('callee') !== -1) {
      return true;
    }
  }
  return false;
}

/**
 * If you need to support Safari 5-7 (8-10 yr-old browser),
 * take a look at https://github.com/feross/is-buffer
 */

function isBuffer(val) {
  if (val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}


/***/ }),

/***/ "./.yarn/cache/marked-npm-2.0.6-d375c0da85-f9088d33f8.zip/node_modules/marked/lib/marked.js":
/*!**************************************************************************************************!*\
  !*** ./.yarn/cache/marked-npm-2.0.6-d375c0da85-f9088d33f8.zip/node_modules/marked/lib/marked.js ***!
  \**************************************************************************************************/
/***/ (function(module) {

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, (function () { 'use strict';

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var defaults$5 = {exports: {}};

  function getDefaults$1() {
    return {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }

  function changeDefaults$1(newDefaults) {
    defaults$5.exports.defaults = newDefaults;
  }

  defaults$5.exports = {
    defaults: getDefaults$1(),
    getDefaults: getDefaults$1,
    changeDefaults: changeDefaults$1
  };

  /**
   * Helpers
   */
  var escapeTest = /[&<>"']/;
  var escapeReplace = /[&<>"']/g;
  var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
  var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
  var escapeReplacements = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  var getEscapeReplacement = function getEscapeReplacement(ch) {
    return escapeReplacements[ch];
  };

  function escape$2(html, encode) {
    if (encode) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }

    return html;
  }

  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

  function unescape$1(html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(unescapeTest, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') return ':';

      if (n.charAt(0) === '#') {
        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
      }

      return '';
    });
  }

  var caret = /(^|[^\[])\^/g;

  function edit$1(regex, opt) {
    regex = regex.source || regex;
    opt = opt || '';
    var obj = {
      replace: function replace(name, val) {
        val = val.source || val;
        val = val.replace(caret, '$1');
        regex = regex.replace(name, val);
        return obj;
      },
      getRegex: function getRegex() {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }

  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

  function cleanUrl$1(sanitize, base, href) {
    if (sanitize) {
      var prot;

      try {
        prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();
      } catch (e) {
        return null;
      }

      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
        return null;
      }
    }

    if (base && !originIndependentUrl.test(href)) {
      href = resolveUrl(base, href);
    }

    try {
      href = encodeURI(href).replace(/%25/g, '%');
    } catch (e) {
      return null;
    }

    return href;
  }

  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

  function resolveUrl(base, href) {
    if (!baseUrls[' ' + base]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (justDomain.test(base)) {
        baseUrls[' ' + base] = base + '/';
      } else {
        baseUrls[' ' + base] = rtrim$1(base, '/', true);
      }
    }

    base = baseUrls[' ' + base];
    var relativeBase = base.indexOf(':') === -1;

    if (href.substring(0, 2) === '//') {
      if (relativeBase) {
        return href;
      }

      return base.replace(protocol, '$1') + href;
    } else if (href.charAt(0) === '/') {
      if (relativeBase) {
        return href;
      }

      return base.replace(domain, '$1') + href;
    } else {
      return base + href;
    }
  }

  var noopTest$1 = {
    exec: function noopTest() {}
  };

  function merge$2(obj) {
    var i = 1,
        target,
        key;

    for (; i < arguments.length; i++) {
      target = arguments[i];

      for (key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
          obj[key] = target[key];
        }
      }
    }

    return obj;
  }

  function splitCells$1(tableRow, count) {
    // ensure that every cell-delimiting pipe has a space
    // before it to distinguish it from an escaped pipe
    var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
          curr = offset;

      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }

      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
        cells = row.split(/ \|/);
    var i = 0;

    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }

    for (; i < cells.length; i++) {
      // leading or trailing whitespace is ignored per the gfm spec
      cells[i] = cells[i].trim().replace(/\\\|/g, '|');
    }

    return cells;
  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
  // /c*$/ is vulnerable to REDOS.
  // invert: Remove suffix of non-c chars instead. Default falsey.


  function rtrim$1(str, c, invert) {
    var l = str.length;

    if (l === 0) {
      return '';
    } // Length of suffix matching the invert condition.


    var suffLen = 0; // Step left until we fail to match the invert condition.

    while (suffLen < l) {
      var currChar = str.charAt(l - suffLen - 1);

      if (currChar === c && !invert) {
        suffLen++;
      } else if (currChar !== c && invert) {
        suffLen++;
      } else {
        break;
      }
    }

    return str.substr(0, l - suffLen);
  }

  function findClosingBracket$1(str, b) {
    if (str.indexOf(b[1]) === -1) {
      return -1;
    }

    var l = str.length;
    var level = 0,
        i = 0;

    for (; i < l; i++) {
      if (str[i] === '\\') {
        i++;
      } else if (str[i] === b[0]) {
        level++;
      } else if (str[i] === b[1]) {
        level--;

        if (level < 0) {
          return i;
        }
      }
    }

    return -1;
  }

  function checkSanitizeDeprecation$1(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
    }
  } // copied from https://stackoverflow.com/a/5450113/806777


  function repeatString$1(pattern, count) {
    if (count < 1) {
      return '';
    }

    var result = '';

    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }

      count >>= 1;
      pattern += pattern;
    }

    return result + pattern;
  }

  var helpers = {
    escape: escape$2,
    unescape: unescape$1,
    edit: edit$1,
    cleanUrl: cleanUrl$1,
    resolveUrl: resolveUrl,
    noopTest: noopTest$1,
    merge: merge$2,
    splitCells: splitCells$1,
    rtrim: rtrim$1,
    findClosingBracket: findClosingBracket$1,
    checkSanitizeDeprecation: checkSanitizeDeprecation$1,
    repeatString: repeatString$1
  };

  var defaults$4 = defaults$5.exports.defaults;
  var rtrim = helpers.rtrim,
      splitCells = helpers.splitCells,
      _escape = helpers.escape,
      findClosingBracket = helpers.findClosingBracket;

  function outputLink(cap, link, raw) {
    var href = link.href;
    var title = link.title ? _escape(link.title) : null;
    var text = cap[1].replace(/\\([\[\]])/g, '$1');

    if (cap[0].charAt(0) !== '!') {
      return {
        type: 'link',
        raw: raw,
        href: href,
        title: title,
        text: text
      };
    } else {
      return {
        type: 'image',
        raw: raw,
        href: href,
        title: title,
        text: _escape(text)
      };
    }
  }

  function indentCodeCompensation(raw, text) {
    var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

    if (matchIndentToCode === null) {
      return text;
    }

    var indentToCode = matchIndentToCode[1];
    return text.split('\n').map(function (node) {
      var matchIndentInNode = node.match(/^\s+/);

      if (matchIndentInNode === null) {
        return node;
      }

      var indentInNode = matchIndentInNode[0];

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    }).join('\n');
  }
  /**
   * Tokenizer
   */


  var Tokenizer_1 = /*#__PURE__*/function () {
    function Tokenizer(options) {
      this.options = options || defaults$4;
    }

    var _proto = Tokenizer.prototype;

    _proto.space = function space(src) {
      var cap = this.rules.block.newline.exec(src);

      if (cap) {
        if (cap[0].length > 1) {
          return {
            type: 'space',
            raw: cap[0]
          };
        }

        return {
          raw: '\n'
        };
      }
    };

    _proto.code = function code(src) {
      var cap = this.rules.block.code.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ {1,4}/gm, '');
        return {
          type: 'code',
          raw: cap[0],
          codeBlockStyle: 'indented',
          text: !this.options.pedantic ? rtrim(text, '\n') : text
        };
      }
    };

    _proto.fences = function fences(src) {
      var cap = this.rules.block.fences.exec(src);

      if (cap) {
        var raw = cap[0];
        var text = indentCodeCompensation(raw, cap[3] || '');
        return {
          type: 'code',
          raw: raw,
          lang: cap[2] ? cap[2].trim() : cap[2],
          text: text
        };
      }
    };

    _proto.heading = function heading(src) {
      var cap = this.rules.block.heading.exec(src);

      if (cap) {
        var text = cap[2].trim(); // remove trailing #s

        if (/#$/.test(text)) {
          var trimmed = rtrim(text, '#');

          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            // CommonMark requires space before trailing #s
            text = trimmed.trim();
          }
        }

        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[1].length,
          text: text
        };
      }
    };

    _proto.nptable = function nptable(src) {
      var cap = this.rules.block.nptable.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
          raw: cap[0]
        };

        if (item.header.length === item.align.length) {
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells(item.cells[i], item.header.length);
          }

          return item;
        }
      }
    };

    _proto.hr = function hr(src) {
      var cap = this.rules.block.hr.exec(src);

      if (cap) {
        return {
          type: 'hr',
          raw: cap[0]
        };
      }
    };

    _proto.blockquote = function blockquote(src) {
      var cap = this.rules.block.blockquote.exec(src);

      if (cap) {
        var text = cap[0].replace(/^ *> ?/gm, '');
        return {
          type: 'blockquote',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.list = function list(src) {
      var cap = this.rules.block.list.exec(src);

      if (cap) {
        var raw = cap[0];
        var bull = cap[2];
        var isordered = bull.length > 1;
        var list = {
          type: 'list',
          raw: raw,
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : '',
          loose: false,
          items: []
        }; // Get each top-level item.

        var itemMatch = cap[0].match(this.rules.block.item);
        var next = false,
            item,
            space,
            bcurr,
            bnext,
            addBack,
            loose,
            istask,
            ischecked,
            endMatch;
        var l = itemMatch.length;
        bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

        for (var i = 0; i < l; i++) {
          item = itemMatch[i];
          raw = item;

          if (!this.options.pedantic) {
            // Determine if current item contains the end of the list
            endMatch = item.match(new RegExp('\\n\\s*\\n {0,' + (bcurr[0].length - 1) + '}\\S'));

            if (endMatch) {
              addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join('\n').length;
              list.raw = list.raw.substring(0, list.raw.length - addBack);
              item = item.substring(0, endMatch.index);
              raw = item;
              l = i + 1;
            }
          } // Determine whether the next list item belongs here.
          // Backpedal if it does not belong in this list.


          if (i !== l - 1) {
            bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

            if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
              // nested list or continuation
              itemMatch.splice(i, 2, itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? '' : '\n') + itemMatch[i + 1]);
              i--;
              l--;
              continue;
            } else if ( // different bullet style
            !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
              addBack = itemMatch.slice(i + 1).join('\n').length;
              list.raw = list.raw.substring(0, list.raw.length - addBack);
              i = l - 1;
            }

            bcurr = bnext;
          } // Remove the list item's bullet
          // so it is seen as the next token.


          space = item.length;
          item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
          // list item contains. Hacky.

          if (~item.indexOf('\n ')) {
            space -= item.length;
            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
          } // trim item newlines at end


          item = rtrim(item, '\n');

          if (i !== l - 1) {
            raw = raw + '\n';
          } // Determine whether item is loose or not.
          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
          // for discount behavior.


          loose = next || /\n\n(?!\s*$)/.test(raw);

          if (i !== l - 1) {
            next = raw.slice(-2) === '\n\n';
            if (!loose) loose = next;
          }

          if (loose) {
            list.loose = true;
          } // Check for task list items


          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;

            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }
          }

          list.items.push({
            type: 'list_item',
            raw: raw,
            task: istask,
            checked: ischecked,
            loose: loose,
            text: item
          });
        }

        return list;
      }
    };

    _proto.html = function html(src) {
      var cap = this.rules.block.html.exec(src);

      if (cap) {
        return {
          type: this.options.sanitize ? 'paragraph' : 'html',
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.def = function def(src) {
      var cap = this.rules.block.def.exec(src);

      if (cap) {
        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
        var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
        return {
          type: 'def',
          tag: tag,
          raw: cap[0],
          href: cap[2],
          title: cap[3]
        };
      }
    };

    _proto.table = function table(src) {
      var cap = this.rules.block.table.exec(src);

      if (cap) {
        var item = {
          type: 'table',
          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
        };

        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          var l = item.align.length;
          var i;

          for (i = 0; i < l; i++) {
            if (/^ *-+: *$/.test(item.align[i])) {
              item.align[i] = 'right';
            } else if (/^ *:-+: *$/.test(item.align[i])) {
              item.align[i] = 'center';
            } else if (/^ *:-+ *$/.test(item.align[i])) {
              item.align[i] = 'left';
            } else {
              item.align[i] = null;
            }
          }

          l = item.cells.length;

          for (i = 0; i < l; i++) {
            item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
          }

          return item;
        }
      }
    };

    _proto.lheading = function lheading(src) {
      var cap = this.rules.block.lheading.exec(src);

      if (cap) {
        return {
          type: 'heading',
          raw: cap[0],
          depth: cap[2].charAt(0) === '=' ? 1 : 2,
          text: cap[1]
        };
      }
    };

    _proto.paragraph = function paragraph(src) {
      var cap = this.rules.block.paragraph.exec(src);

      if (cap) {
        return {
          type: 'paragraph',
          raw: cap[0],
          text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1]
        };
      }
    };

    _proto.text = function text(src) {
      var cap = this.rules.block.text.exec(src);

      if (cap) {
        return {
          type: 'text',
          raw: cap[0],
          text: cap[0]
        };
      }
    };

    _proto.escape = function escape(src) {
      var cap = this.rules.inline.escape.exec(src);

      if (cap) {
        return {
          type: 'escape',
          raw: cap[0],
          text: _escape(cap[1])
        };
      }
    };

    _proto.tag = function tag(src, inLink, inRawBlock) {
      var cap = this.rules.inline.tag.exec(src);

      if (cap) {
        if (!inLink && /^<a /i.test(cap[0])) {
          inLink = true;
        } else if (inLink && /^<\/a>/i.test(cap[0])) {
          inLink = false;
        }

        if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = true;
        } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          inRawBlock = false;
        }

        return {
          type: this.options.sanitize ? 'text' : 'html',
          raw: cap[0],
          inLink: inLink,
          inRawBlock: inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
        };
      }
    };

    _proto.link = function link(src) {
      var cap = this.rules.inline.link.exec(src);

      if (cap) {
        var trimmedUrl = cap[2].trim();

        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          // commonmark requires matching angle brackets
          if (!/>$/.test(trimmedUrl)) {
            return;
          } // ending angle bracket cannot be escaped


          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');

          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          // find closing parenthesis
          var lastParenIndex = findClosingBracket(cap[2], '()');

          if (lastParenIndex > -1) {
            var start = cap[0].indexOf('!') === 0 ? 5 : 4;
            var linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
        }

        var href = cap[2];
        var title = '';

        if (this.options.pedantic) {
          // split pedantic href and title
          var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : '';
        }

        href = href.trim();

        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            // pedantic allows starting angle bracket without ending angle bracket
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }

        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
          title: title ? title.replace(this.rules.inline._escapes, '$1') : title
        }, cap[0]);
      }
    };

    _proto.reflink = function reflink(src, links) {
      var cap;

      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
        var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
        link = links[link.toLowerCase()];

        if (!link || !link.href) {
          var text = cap[0].charAt(0);
          return {
            type: 'text',
            raw: text,
            text: text
          };
        }

        return outputLink(cap, link, cap[0]);
      }
    };

    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
      if (prevChar === void 0) {
        prevChar = '';
      }

      var match = this.rules.inline.emStrong.lDelim.exec(src);
      if (!match) return;
      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

      var nextChar = match[1] || match[2] || '';

      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
        var lLength = match[0].length - 1;
        var rDelim,
            rLength,
            delimTotal = lLength,
            midDelimTotal = 0;
        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src.length + lLength); // Bump maskedSrc to same section of string as src (move to lexer?)

        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim) continue; // matched the first alternative in rules.js (skip the * in __abc*abc__)

          rLength = rDelim.length;

          if (match[3] || match[4]) {
            // found another Left Delim
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            // either Left or Right Delim
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue; // CommonMark Emphasis Rules 9-10
            }
          }

          delimTotal -= rLength;
          if (delimTotal > 0) continue; // Haven't found enough closing delimiters
          // If this is the last rDelimiter, remove extra characters. *a*** -> *a*

          if (delimTotal + midDelimTotal - rLength <= 0 && !maskedSrc.slice(endReg.lastIndex).match(endReg)) {
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          }

          if (Math.min(lLength, rLength) % 2) {
            return {
              type: 'em',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: src.slice(1, lLength + match.index + rLength)
            };
          }

          if (Math.min(lLength, rLength) % 2 === 0) {
            return {
              type: 'strong',
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: src.slice(2, lLength + match.index + rLength - 1)
            };
          }
        }
      }
    };

    _proto.codespan = function codespan(src) {
      var cap = this.rules.inline.code.exec(src);

      if (cap) {
        var text = cap[2].replace(/\n/g, ' ');
        var hasNonSpaceChars = /[^ ]/.test(text);
        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }

        text = _escape(text, true);
        return {
          type: 'codespan',
          raw: cap[0],
          text: text
        };
      }
    };

    _proto.br = function br(src) {
      var cap = this.rules.inline.br.exec(src);

      if (cap) {
        return {
          type: 'br',
          raw: cap[0]
        };
      }
    };

    _proto.del = function del(src) {
      var cap = this.rules.inline.del.exec(src);

      if (cap) {
        return {
          type: 'del',
          raw: cap[0],
          text: cap[2]
        };
      }
    };

    _proto.autolink = function autolink(src, mangle) {
      var cap = this.rules.inline.autolink.exec(src);

      if (cap) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
          href = 'mailto:' + text;
        } else {
          text = _escape(cap[1]);
          href = text;
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.url = function url(src, mangle) {
      var cap;

      if (cap = this.rules.inline.url.exec(src)) {
        var text, href;

        if (cap[2] === '@') {
          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
          href = 'mailto:' + text;
        } else {
          // do extended autolink path validation
          var prevCapZero;

          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);

          text = _escape(cap[0]);

          if (cap[1] === 'www.') {
            href = 'http://' + text;
          } else {
            href = text;
          }
        }

        return {
          type: 'link',
          raw: cap[0],
          text: text,
          href: href,
          tokens: [{
            type: 'text',
            raw: text,
            text: text
          }]
        };
      }
    };

    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
      var cap = this.rules.inline.text.exec(src);

      if (cap) {
        var text;

        if (inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
        } else {
          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
        }

        return {
          type: 'text',
          raw: cap[0],
          text: text
        };
      }
    };

    return Tokenizer;
  }();

  var noopTest = helpers.noopTest,
      edit = helpers.edit,
      merge$1 = helpers.merge;
  /**
   * Block-Level Grammar
   */

  var block$1 = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
    html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')',
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
    nptable: noopTest,
    table: noopTest,
    lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
  block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();
  block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block$1.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
  block$1.item = edit(block$1.item, 'gm').replace(/bull/g, block$1.bullet).getRegex();
  block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();
  block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block$1.def.source + ')').getRegex();
  block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
  block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
  block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();
  /**
   * Normal Block Grammar
   */

  block$1.normal = merge$1({}, block$1);
  /**
   * GFM Block Grammar
   */

  block$1.gfm = merge$1({}, block$1.normal, {
    nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
    + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
    // Cells
    table: '^ *\\|(.+)\\n' // Header
    + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells

  });
  block$1.gfm.nptable = edit(block$1.gfm.nptable).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();
  /**
   * Pedantic grammar (original John Gruber's loose markdown specification)
   */

  block$1.pedantic = merge$1({}, block$1.normal, {
    html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
  });
  /**
   * Inline-Level Grammar
   */

  var inline$1 = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    reflinkSearch: 'reflink|nolink(?!\\()',
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //        () Skip other delimiter (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /\_\_[^_]*?\*[^_]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
      rDelimUnd: /\*\*[^*]*?\_[^*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _

    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  }; // list of punctuation marks from CommonMark spec
  // without * and _ to handle the different emphasis markers * and _

  inline$1._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
  inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>

  inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline$1.escapedEmSt = /\\\*|\\_/g;
  inline$1._comment = edit(block$1._comment).replace('(?:-->|$)', '-->').getRegex();
  inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
  inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
  inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
  inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();
  inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();
  inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();
  inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();
  inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();
  /**
   * Normal Inline Grammar
   */

  inline$1.normal = merge$1({}, inline$1);
  /**
   * Pedantic Inline Grammar
   */

  inline$1.pedantic = merge$1({}, inline$1.normal, {
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline$1._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline$1._label).getRegex()
  });
  /**
   * GFM Inline Grammar
   */

  inline$1.gfm = merge$1({}, inline$1.normal, {
    escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  });
  inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();
  /**
   * GFM + Line Breaks Inline Grammar
   */

  inline$1.breaks = merge$1({}, inline$1.gfm, {
    br: edit(inline$1.br).replace('{2,}', '*').getRegex(),
    text: edit(inline$1.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
  });
  var rules = {
    block: block$1,
    inline: inline$1
  };

  var Tokenizer$1 = Tokenizer_1;
  var defaults$3 = defaults$5.exports.defaults;
  var block = rules.block,
      inline = rules.inline;
  var repeatString = helpers.repeatString;
  /**
   * smartypants text replacement
   */

  function smartypants(text) {
    return text // em-dashes
    .replace(/---/g, "\u2014") // en-dashes
    .replace(/--/g, "\u2013") // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018") // closing singles & apostrophes
    .replace(/'/g, "\u2019") // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C") // closing doubles
    .replace(/"/g, "\u201D") // ellipses
    .replace(/\.{3}/g, "\u2026");
  }
  /**
   * mangle email addresses
   */


  function mangle(text) {
    var out = '',
        i,
        ch;
    var l = text.length;

    for (i = 0; i < l; i++) {
      ch = text.charCodeAt(i);

      if (Math.random() > 0.5) {
        ch = 'x' + ch.toString(16);
      }

      out += '&#' + ch + ';';
    }

    return out;
  }
  /**
   * Block Lexer
   */


  var Lexer_1 = /*#__PURE__*/function () {
    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || defaults$3;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      var rules = {
        block: block.normal,
        inline: inline.normal
      };

      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;

        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }

      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */


    /**
     * Static Lex Method
     */
    Lexer.lex = function lex(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    }
    /**
     * Static Lex Inline Method
     */
    ;

    Lexer.lexInline = function lexInline(src, options) {
      var lexer = new Lexer(options);
      return lexer.inlineTokens(src);
    }
    /**
     * Preprocessing
     */
    ;

    var _proto = Lexer.prototype;

    _proto.lex = function lex(src) {
      src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
      this.blockTokens(src, this.tokens, true);
      this.inline(this.tokens);
      return this.tokens;
    }
    /**
     * Lexing
     */
    ;

    _proto.blockTokens = function blockTokens(src, tokens, top) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (top === void 0) {
        top = true;
      }

      if (this.options.pedantic) {
        src = src.replace(/^ +$/gm, '');
      }

      var token, i, l, lastToken;

      while (src) {
        // newline
        if (token = this.tokenizer.space(src)) {
          src = src.substring(token.raw.length);

          if (token.type) {
            tokens.push(token);
          }

          continue;
        } // code


        if (token = this.tokenizer.code(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

          if (lastToken && lastToken.type === 'paragraph') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // fences


        if (token = this.tokenizer.fences(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // heading


        if (token = this.tokenizer.heading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // table no leading pipe (gfm)


        if (token = this.tokenizer.nptable(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // hr


        if (token = this.tokenizer.hr(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // blockquote


        if (token = this.tokenizer.blockquote(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.blockTokens(token.text, [], top);
          tokens.push(token);
          continue;
        } // list


        if (token = this.tokenizer.list(src)) {
          src = src.substring(token.raw.length);
          l = token.items.length;

          for (i = 0; i < l; i++) {
            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
          }

          tokens.push(token);
          continue;
        } // html


        if (token = this.tokenizer.html(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // def


        if (top && (token = this.tokenizer.def(src))) {
          src = src.substring(token.raw.length);

          if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }

          continue;
        } // table (gfm)


        if (token = this.tokenizer.table(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // lheading


        if (token = this.tokenizer.lheading(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // top-level paragraph


        if (top && (token = this.tokenizer.paragraph(src))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.text(src)) {
          src = src.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += '\n' + token.raw;
            lastToken.text += '\n' + token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _proto.inline = function inline(tokens) {
      var i, j, k, l2, row, token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'paragraph':
          case 'text':
          case 'heading':
            {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }

          case 'table':
            {
              token.tokens = {
                header: [],
                cells: []
              }; // header

              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              } // cells


              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];

                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }

              break;
            }

          case 'blockquote':
            {
              this.inline(token.tokens);
              break;
            }

          case 'list':
            {
              l2 = token.items.length;

              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }

              break;
            }
        }
      }

      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    ;

    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
      if (tokens === void 0) {
        tokens = [];
      }

      if (inLink === void 0) {
        inLink = false;
      }

      if (inRawBlock === void 0) {
        inRawBlock = false;
      }

      var token, lastToken; // String with links masked to avoid interference with em and strong

      var maskedSrc = src;
      var match;
      var keepPrevChar, prevChar; // Mask out reflinks

      if (this.tokens.links) {
        var links = Object.keys(this.tokens.links);

        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      } // Mask out other blocks


      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      } // Mask out escaped em & strong delimiters


      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      }

      while (src) {
        if (!keepPrevChar) {
          prevChar = '';
        }

        keepPrevChar = false; // escape

        if (token = this.tokenizer.escape(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // tag


        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
          src = src.substring(token.raw.length);
          inLink = token.inLink;
          inRawBlock = token.inRawBlock;
          var _lastToken = tokens[tokens.length - 1];

          if (_lastToken && token.type === 'text' && _lastToken.type === 'text') {
            _lastToken.raw += token.raw;
            _lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // link


        if (token = this.tokenizer.link(src)) {
          src = src.substring(token.raw.length);

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          }

          tokens.push(token);
          continue;
        } // reflink, nolink


        if (token = this.tokenizer.reflink(src, this.tokens.links)) {
          src = src.substring(token.raw.length);
          var _lastToken2 = tokens[tokens.length - 1];

          if (token.type === 'link') {
            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            tokens.push(token);
          } else if (_lastToken2 && token.type === 'text' && _lastToken2.type === 'text') {
            _lastToken2.raw += token.raw;
            _lastToken2.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        } // em & strong


        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // code


        if (token = this.tokenizer.codespan(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // br


        if (token = this.tokenizer.br(src)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // del (gfm)


        if (token = this.tokenizer.del(src)) {
          src = src.substring(token.raw.length);
          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
          tokens.push(token);
          continue;
        } // autolink


        if (token = this.tokenizer.autolink(src, mangle)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // url (gfm)


        if (!inLink && (token = this.tokenizer.url(src, mangle))) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          continue;
        } // text


        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
          src = src.substring(token.raw.length);

          if (token.raw.slice(-1) !== '_') {
            // Track prevChar before string of ____ started
            prevChar = token.raw.slice(-1);
          }

          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];

          if (lastToken && lastToken.type === 'text') {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }

          continue;
        }

        if (src) {
          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }

      return tokens;
    };

    _createClass(Lexer, null, [{
      key: "rules",
      get: function get() {
        return {
          block: block,
          inline: inline
        };
      }
    }]);

    return Lexer;
  }();

  var defaults$2 = defaults$5.exports.defaults;
  var cleanUrl = helpers.cleanUrl,
      escape$1 = helpers.escape;
  /**
   * Renderer
   */

  var Renderer_1 = /*#__PURE__*/function () {
    function Renderer(options) {
      this.options = options || defaults$2;
    }

    var _proto = Renderer.prototype;

    _proto.code = function code(_code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];

      if (this.options.highlight) {
        var out = this.options.highlight(_code, lang);

        if (out != null && out !== _code) {
          escaped = true;
          _code = out;
        }
      }

      _code = _code.replace(/\n$/, '') + '\n';

      if (!lang) {
        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
      }

      return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
    };

    _proto.blockquote = function blockquote(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    _proto.html = function html(_html) {
      return _html;
    };

    _proto.heading = function heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
      } // ignore IDs


      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    _proto.hr = function hr() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    _proto.list = function list(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    };

    _proto.listitem = function listitem(text) {
      return '<li>' + text + '</li>\n';
    };

    _proto.checkbox = function checkbox(checked) {
      return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
    };

    _proto.paragraph = function paragraph(text) {
      return '<p>' + text + '</p>\n';
    };

    _proto.table = function table(header, body) {
      if (body) body = '<tbody>' + body + '</tbody>';
      return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
    };

    _proto.tablerow = function tablerow(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    _proto.tablecell = function tablecell(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    } // span level renderer
    ;

    _proto.strong = function strong(text) {
      return '<strong>' + text + '</strong>';
    };

    _proto.em = function em(text) {
      return '<em>' + text + '</em>';
    };

    _proto.codespan = function codespan(text) {
      return '<code>' + text + '</code>';
    };

    _proto.br = function br() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    _proto.del = function del(text) {
      return '<del>' + text + '</del>';
    };

    _proto.link = function link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<a href="' + escape$1(href) + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += '>' + text + '</a>';
      return out;
    };

    _proto.image = function image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

      if (href === null) {
        return text;
      }

      var out = '<img src="' + href + '" alt="' + text + '"';

      if (title) {
        out += ' title="' + title + '"';
      }

      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    return Renderer;
  }();

  /**
   * TextRenderer
   * returns only the textual part of the token
   */

  var TextRenderer_1 = /*#__PURE__*/function () {
    function TextRenderer() {}

    var _proto = TextRenderer.prototype;

    // no need for block level renderers
    _proto.strong = function strong(text) {
      return text;
    };

    _proto.em = function em(text) {
      return text;
    };

    _proto.codespan = function codespan(text) {
      return text;
    };

    _proto.del = function del(text) {
      return text;
    };

    _proto.html = function html(text) {
      return text;
    };

    _proto.text = function text(_text) {
      return _text;
    };

    _proto.link = function link(href, title, text) {
      return '' + text;
    };

    _proto.image = function image(href, title, text) {
      return '' + text;
    };

    _proto.br = function br() {
      return '';
    };

    return TextRenderer;
  }();

  /**
   * Slugger generates header id
   */

  var Slugger_1 = /*#__PURE__*/function () {
    function Slugger() {
      this.seen = {};
    }

    var _proto = Slugger.prototype;

    _proto.serialize = function serialize(value) {
      return value.toLowerCase().trim() // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '') // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
    }
    /**
     * Finds the next safe (unique) slug to use
     */
    ;

    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
      var slug = originalSlug;
      var occurenceAccumulator = 0;

      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];

        do {
          occurenceAccumulator++;
          slug = originalSlug + '-' + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }

      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }

      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} options
     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
     */
    ;

    _proto.slug = function slug(value, options) {
      if (options === void 0) {
        options = {};
      }

      var slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options.dryrun);
    };

    return Slugger;
  }();

  var Renderer$1 = Renderer_1;
  var TextRenderer$1 = TextRenderer_1;
  var Slugger$1 = Slugger_1;
  var defaults$1 = defaults$5.exports.defaults;
  var unescape = helpers.unescape;
  /**
   * Parsing & Compiling
   */

  var Parser_1 = /*#__PURE__*/function () {
    function Parser(options) {
      this.options = options || defaults$1;
      this.options.renderer = this.options.renderer || new Renderer$1();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer$1();
      this.slugger = new Slugger$1();
    }
    /**
     * Static Parse Method
     */


    Parser.parse = function parse(tokens, options) {
      var parser = new Parser(options);
      return parser.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    ;

    Parser.parseInline = function parseInline(tokens, options) {
      var parser = new Parser(options);
      return parser.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    ;

    var _proto = Parser.prototype;

    _proto.parse = function parse(tokens, top) {
      if (top === void 0) {
        top = true;
      }

      var out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'space':
            {
              continue;
            }

          case 'hr':
            {
              out += this.renderer.hr();
              continue;
            }

          case 'heading':
            {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }

          case 'code':
            {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }

          case 'table':
            {
              header = ''; // header

              cell = '';
              l2 = token.header.length;

              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                  header: true,
                  align: token.align[j]
                });
              }

              header += this.renderer.tablerow(cell);
              body = '';
              l2 = token.cells.length;

              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = '';
                l3 = row.length;

                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), {
                    header: false,
                    align: token.align[k]
                  });
                }

                body += this.renderer.tablerow(cell);
              }

              out += this.renderer.table(header, body);
              continue;
            }

          case 'blockquote':
            {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }

          case 'list':
            {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = '';

              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = '';

                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);

                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }

          case 'html':
            {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }

          case 'paragraph':
            {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }

          case 'text':
            {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;

              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }

              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    }
    /**
     * Parse Inline Tokens
     */
    ;

    _proto.parseInline = function parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      var out = '',
          i,
          token;
      var l = tokens.length;

      for (i = 0; i < l; i++) {
        token = tokens[i];

        switch (token.type) {
          case 'escape':
            {
              out += renderer.text(token.text);
              break;
            }

          case 'html':
            {
              out += renderer.html(token.text);
              break;
            }

          case 'link':
            {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }

          case 'image':
            {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }

          case 'strong':
            {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'em':
            {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'codespan':
            {
              out += renderer.codespan(token.text);
              break;
            }

          case 'br':
            {
              out += renderer.br();
              break;
            }

          case 'del':
            {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }

          case 'text':
            {
              out += renderer.text(token.text);
              break;
            }

          default:
            {
              var errMsg = 'Token with "' + token.type + '" type was not found.';

              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
        }
      }

      return out;
    };

    return Parser;
  }();

  var Lexer = Lexer_1;
  var Parser = Parser_1;
  var Tokenizer = Tokenizer_1;
  var Renderer = Renderer_1;
  var TextRenderer = TextRenderer_1;
  var Slugger = Slugger_1;
  var merge = helpers.merge,
      checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,
      escape = helpers.escape;
  var getDefaults = defaults$5.exports.getDefaults,
      changeDefaults = defaults$5.exports.changeDefaults,
      defaults = defaults$5.exports.defaults;
  /**
   * Marked
   */

  function marked(src, opt, callback) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    if (typeof opt === 'function') {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    if (callback) {
      var highlight = opt.highlight;
      var tokens;

      try {
        tokens = Lexer.lex(src, opt);
      } catch (e) {
        return callback(e);
      }

      var done = function done(err) {
        var out;

        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }

            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }
        }

        opt.highlight = highlight;
        return err ? callback(err) : callback(null, out);
      };

      if (!highlight || highlight.length < 3) {
        return done();
      }

      delete opt.highlight;
      if (!tokens.length) return done();
      var pending = 0;
      marked.walkTokens(tokens, function (token) {
        if (token.type === 'code') {
          pending++;
          setTimeout(function () {
            highlight(token.text, token.lang, function (err, code) {
              if (err) {
                return done(err);
              }

              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }

              pending--;

              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });

      if (pending === 0) {
        done();
      }

      return;
    }

    try {
      var _tokens = Lexer.lex(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(_tokens, opt.walkTokens);
      }

      return Parser.parse(_tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  }
  /**
   * Options
   */


  marked.options = marked.setOptions = function (opt) {
    merge(marked.defaults, opt);
    changeDefaults(marked.defaults);
    return marked;
  };

  marked.getDefaults = getDefaults;
  marked.defaults = defaults;
  /**
   * Use Extension
   */

  marked.use = function (extension) {
    var opts = merge({}, extension);

    if (extension.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer();

        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];

          renderer[prop] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var ret = extension.renderer[prop].apply(renderer, args);

            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.renderer) {
          _loop(prop);
        }

        opts.renderer = renderer;
      })();
    }

    if (extension.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer();

        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];

          tokenizer[prop] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            var ret = extension.tokenizer[prop].apply(tokenizer, args);

            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }

            return ret;
          };
        };

        for (var prop in extension.tokenizer) {
          _loop2(prop);
        }

        opts.tokenizer = tokenizer;
      })();
    }

    if (extension.walkTokens) {
      var walkTokens = marked.defaults.walkTokens;

      opts.walkTokens = function (token) {
        extension.walkTokens(token);

        if (walkTokens) {
          walkTokens(token);
        }
      };
    }

    marked.setOptions(opts);
  };
  /**
   * Run callback for every token
   */


  marked.walkTokens = function (tokens, callback) {
    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
      var token = _step.value;
      callback(token);

      switch (token.type) {
        case 'table':
          {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {
              var cell = _step2.value;
              marked.walkTokens(cell, callback);
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {
              var row = _step3.value;

              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
                var _cell = _step4.value;
                marked.walkTokens(_cell, callback);
              }
            }

            break;
          }

        case 'list':
          {
            marked.walkTokens(token.items, callback);
            break;
          }

        default:
          {
            if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
      }
    }
  };
  /**
   * Parse Inline
   */


  marked.parseInline = function (src, opt) {
    // throw error in case of non string input
    if (typeof src === 'undefined' || src === null) {
      throw new Error('marked.parseInline(): input parameter is undefined or null');
    }

    if (typeof src !== 'string') {
      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
    }

    opt = merge({}, marked.defaults, opt || {});
    checkSanitizeDeprecation(opt);

    try {
      var tokens = Lexer.lexInline(src, opt);

      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }

      return Parser.parseInline(tokens, opt);
    } catch (e) {
      e.message += '\nPlease report this to https://github.com/markedjs/marked.';

      if (opt.silent) {
        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }

      throw e;
    }
  };
  /**
   * Expose
   */


  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.parse = marked;
  var marked_1 = marked;

  return marked_1;

})));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-bash.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-bash.js ***!
  \****************************************************************************************************************/
/***/ (function() {

(function (Prism) {
	// $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
	// + LC_ALL, RANDOM, REPLY, SECONDS.
	// + make sure PS1..4 are here as they are not always set,
	// - some useless things.
	var envVars = '\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b';

	var commandAfterHeredoc = {
		pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
		lookbehind: true,
		alias: 'punctuation', // this looks reasonably well in all themes
		inside: null // see below
	};

	var insideString = {
		'bash': commandAfterHeredoc,
		'environment': {
			pattern: RegExp('\\$' + envVars),
			alias: 'constant'
		},
		'variable': [
			// [0]: Arithmetic Environment
			{
				pattern: /\$?\(\([\s\S]+?\)\)/,
				greedy: true,
				inside: {
					// If there is a $ sign at the beginning highlight $(( and )) as variable
					'variable': [
						{
							pattern: /(^\$\(\([\s\S]+)\)\)/,
							lookbehind: true
						},
						/^\$\(\(/
					],
					'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
					// Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
					'operator': /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
					// If there is no $ sign at the beginning highlight (( and )) as punctuation
					'punctuation': /\(\(?|\)\)?|,|;/
				}
			},
			// [1]: Command Substitution
			{
				pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
				greedy: true,
				inside: {
					'variable': /^\$\(|^`|\)$|`$/
				}
			},
			// [2]: Brace expansion
			{
				pattern: /\$\{[^}]+\}/,
				greedy: true,
				inside: {
					'operator': /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
					'punctuation': /[\[\]]/,
					'environment': {
						pattern: RegExp('(\\{)' + envVars),
						lookbehind: true,
						alias: 'constant'
					}
				}
			},
			/\$(?:\w+|[#?*!@$])/
		],
		// Escape sequences from echo and printf's manuals, and escaped quotes.
		'entity': /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
	};

	Prism.languages.bash = {
		'shebang': {
			pattern: /^#!\s*\/.*/,
			alias: 'important'
		},
		'comment': {
			pattern: /(^|[^"{\\$])#.*/,
			lookbehind: true
		},
		'function-name': [
			// a) function foo {
			// b) foo() {
			// c) function foo() {
			// but not “foo {”
			{
				// a) and c)
				pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
				lookbehind: true,
				alias: 'function'
			},
			{
				// b)
				pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
				alias: 'function'
			}
		],
		// Highlight variable names as variables in for and select beginnings.
		'for-or-select': {
			pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
			alias: 'variable',
			lookbehind: true
		},
		// Highlight variable names as variables in the left-hand part
		// of assignments (“=” and “+=”).
		'assign-left': {
			pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
			inside: {
				'environment': {
					pattern: RegExp('(^|[\\s;|&]|[<>]\\()' + envVars),
					lookbehind: true,
					alias: 'constant'
				}
			},
			alias: 'variable',
			lookbehind: true
		},
		// Highlight parameter names as variables
		'parameter': {
			pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
			alias: 'variable',
			lookbehind: true
		},
		'string': [
			// Support for Here-documents https://en.wikipedia.org/wiki/Here_document
			{
				pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
				lookbehind: true,
				greedy: true,
				inside: insideString
			},
			// Here-document with quotes around the tag
			// → No expansion (so no “inside”).
			{
				pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
				lookbehind: true,
				greedy: true,
				inside: {
					'bash': commandAfterHeredoc
				}
			},
			// “Normal” string
			{
				// https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
				pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
				lookbehind: true,
				greedy: true,
				inside: insideString
			},
			{
				// https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
				pattern: /(^|[^$\\])'[^']*'/,
				lookbehind: true,
				greedy: true
			},
			{
				// https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
				pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
				greedy: true,
				inside: {
					'entity': insideString.entity
				}
			}
		],
		'environment': {
			pattern: RegExp('\\$?' + envVars),
			alias: 'constant'
		},
		'variable': insideString.variable,
		'function': {
			pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		'keyword': {
			pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		// https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
		'builtin': {
			pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
			lookbehind: true,
			// Alias added to make those easier to distinguish from strings.
			alias: 'class-name'
		},
		'boolean': {
			pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
			lookbehind: true
		},
		'file-descriptor': {
			pattern: /\B&\d\b/,
			alias: 'important'
		},
		'operator': {
			// Lots of redirections here, but not just that.
			pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
			inside: {
				'file-descriptor': {
					pattern: /^\d/,
					alias: 'important'
				}
			}
		},
		'punctuation': /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
		'number': {
			pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
			lookbehind: true
		}
	};

	commandAfterHeredoc.inside = Prism.languages.bash;

	/* Patterns in command substitution. */
	var toBeCopied = [
		'comment',
		'function-name',
		'for-or-select',
		'assign-left',
		'parameter',
		'string',
		'environment',
		'function',
		'keyword',
		'builtin',
		'boolean',
		'file-descriptor',
		'operator',
		'punctuation',
		'number'
	];
	var inside = insideString.variable[1].inside;
	for (var i = 0; i < toBeCopied.length; i++) {
		inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
	}

	Prism.languages.sh = Prism.languages.bash;
	Prism.languages.shell = Prism.languages.bash;
}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-css.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-css.js ***!
  \***************************************************************************************************************/
/***/ (function() {

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-javascript.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-javascript.js ***!
  \**********************************************************************************************************************/
/***/ (function() {

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-json.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-json.js ***!
  \****************************************************************************************************************/
/***/ (function() {

// https://www.json.org/json-en.html
Prism.languages.json = {
	'property': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'string': {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
		lookbehind: true,
		greedy: true
	},
	'comment': {
		pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
		greedy: true
	},
	'number': /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	'punctuation': /[{}[\],]/,
	'operator': /:/,
	'boolean': /\b(?:false|true)\b/,
	'null': {
		pattern: /\bnull\b/,
		alias: 'keyword'
	}
};

Prism.languages.webmanifest = Prism.languages.json;


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-jsx.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-jsx.js ***!
  \***************************************************************************************************************/
/***/ (function() {

(function (Prism) {

	var javascript = Prism.util.clone(Prism.languages.javascript);

	var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
	var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
	var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;

	/**
	 * @param {string} source
	 * @param {string} [flags]
	 */
	function re(source, flags) {
		source = source
			.replace(/<S>/g, function () { return space; })
			.replace(/<BRACES>/g, function () { return braces; })
			.replace(/<SPREAD>/g, function () { return spread; });
		return RegExp(source, flags);
	}

	spread = re(spread).source;


	Prism.languages.jsx = Prism.languages.extend('markup', javascript);
	Prism.languages.jsx.tag.pattern = re(
		/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
	);

	Prism.languages.jsx.tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
	Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
	Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
	Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];

	Prism.languages.insertBefore('inside', 'attr-name', {
		'spread': {
			pattern: re(/<SPREAD>/.source),
			inside: Prism.languages.jsx
		}
	}, Prism.languages.jsx.tag);

	Prism.languages.insertBefore('inside', 'special-attr', {
		'script': {
			// Allow for two levels of nesting
			pattern: re(/=<BRACES>/.source),
			alias: 'language-javascript',
			inside: {
				'script-punctuation': {
					pattern: /^=(?=\{)/,
					alias: 'punctuation'
				},
				rest: Prism.languages.jsx
			},
		}
	}, Prism.languages.jsx.tag);

	// The following will handle plain text inside tags
	var stringifyToken = function (token) {
		if (!token) {
			return '';
		}
		if (typeof token === 'string') {
			return token;
		}
		if (typeof token.content === 'string') {
			return token.content;
		}
		return token.content.map(stringifyToken).join('');
	};

	var walkTokens = function (tokens) {
		var openedTags = [];
		for (var i = 0; i < tokens.length; i++) {
			var token = tokens[i];
			var notTagNorBrace = false;

			if (typeof token !== 'string') {
				if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
					// We found a tag, now find its kind

					if (token.content[0].content[0].content === '</') {
						// Closing tag
						if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
							// Pop matching opening tag
							openedTags.pop();
						}
					} else {
						if (token.content[token.content.length - 1].content === '/>') {
							// Autoclosed tag, ignore
						} else {
							// Opening tag
							openedTags.push({
								tagName: stringifyToken(token.content[0].content[1]),
								openedBraces: 0
							});
						}
					}
				} else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {

					// Here we might have entered a JSX context inside a tag
					openedTags[openedTags.length - 1].openedBraces++;

				} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {

					// Here we might have left a JSX context inside a tag
					openedTags[openedTags.length - 1].openedBraces--;

				} else {
					notTagNorBrace = true;
				}
			}
			if (notTagNorBrace || typeof token === 'string') {
				if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
					// Here we are inside a tag, and not inside a JSX context.
					// That's plain text: drop any tokens matched.
					var plainText = stringifyToken(token);

					// And merge text with adjacent text
					if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {
						plainText += stringifyToken(tokens[i + 1]);
						tokens.splice(i + 1, 1);
					}
					if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {
						plainText = stringifyToken(tokens[i - 1]) + plainText;
						tokens.splice(i - 1, 1);
						i--;
					}

					tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);
				}
			}

			if (token.content && typeof token.content !== 'string') {
				walkTokens(token.content);
			}
		}
	};

	Prism.hooks.add('after-tokenize', function (env) {
		if (env.language !== 'jsx' && env.language !== 'tsx') {
			return;
		}
		walkTokens(env.tokens);
	});

}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-markup-templating.js":
/*!*****************************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-markup-templating.js ***!
  \*****************************************************************************************************************************/
/***/ (function() {

(function (Prism) {

	/**
	 * Returns the placeholder for the given language id and index.
	 *
	 * @param {string} language
	 * @param {string|number} index
	 * @returns {string}
	 */
	function getPlaceholder(language, index) {
		return '___' + language.toUpperCase() + index + '___';
	}

	Object.defineProperties(Prism.languages['markup-templating'] = {}, {
		buildPlaceholders: {
			/**
			 * Tokenize all inline templating expressions matching `placeholderPattern`.
			 *
			 * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
			 * `true` will be replaced.
			 *
			 * @param {object} env The environment of the `before-tokenize` hook.
			 * @param {string} language The language id.
			 * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
			 * @param {(match: string) => boolean} [replaceFilter]
			 */
			value: function (env, language, placeholderPattern, replaceFilter) {
				if (env.language !== language) {
					return;
				}

				var tokenStack = env.tokenStack = [];

				env.code = env.code.replace(placeholderPattern, function (match) {
					if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
						return match;
					}
					var i = tokenStack.length;
					var placeholder;

					// Check for existing strings
					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
						++i;
					}

					// Create a sparse array
					tokenStack[i] = match;

					return placeholder;
				});

				// Switch the grammar to markup
				env.grammar = Prism.languages.markup;
			}
		},
		tokenizePlaceholders: {
			/**
			 * Replace placeholders with proper tokens after tokenizing.
			 *
			 * @param {object} env The environment of the `after-tokenize` hook.
			 * @param {string} language The language id.
			 */
			value: function (env, language) {
				if (env.language !== language || !env.tokenStack) {
					return;
				}

				// Switch the grammar back
				env.grammar = Prism.languages[language];

				var j = 0;
				var keys = Object.keys(env.tokenStack);

				function walkTokens(tokens) {
					for (var i = 0; i < tokens.length; i++) {
						// all placeholders are replaced already
						if (j >= keys.length) {
							break;
						}

						var token = tokens[i];
						if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {
							var k = keys[j];
							var t = env.tokenStack[k];
							var s = typeof token === 'string' ? token : token.content;
							var placeholder = getPlaceholder(language, k);

							var index = s.indexOf(placeholder);
							if (index > -1) {
								++j;

								var before = s.substring(0, index);
								var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
								var after = s.substring(index + placeholder.length);

								var replacement = [];
								if (before) {
									replacement.push.apply(replacement, walkTokens([before]));
								}
								replacement.push(middle);
								if (after) {
									replacement.push.apply(replacement, walkTokens([after]));
								}

								if (typeof token === 'string') {
									tokens.splice.apply(tokens, [i, 1].concat(replacement));
								} else {
									token.content = replacement;
								}
							}
						} else if (token.content /* && typeof token.content !== 'string' */) {
							walkTokens(token.content);
						}
					}

					return tokens;
				}

				walkTokens(env.tokens);
			}
		}
	});

}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-tsx.js":
/*!***************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-tsx.js ***!
  \***************************************************************************************************************/
/***/ (function() {

(function (Prism) {
	var typescript = Prism.util.clone(Prism.languages.typescript);
	Prism.languages.tsx = Prism.languages.extend('jsx', typescript);

	// doesn't work with TS because TS is too complex
	delete Prism.languages.tsx['parameter'];
	delete Prism.languages.tsx['literal-property'];

	// This will prevent collisions between TSX tags and TS generic types.
	// Idea by https://github.com/karlhorky
	// Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
	var tag = Prism.languages.tsx.tag;
	tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);
	tag.lookbehind = true;
}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-typescript.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-typescript.js ***!
  \**********************************************************************************************************************/
/***/ (function() {

(function (Prism) {

	Prism.languages.typescript = Prism.languages.extend('javascript', {
		'class-name': {
			pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
			lookbehind: true,
			greedy: true,
			inside: null // see below
		},
		'builtin': /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
	});

	// The keywords TypeScript adds to JavaScript
	Prism.languages.typescript.keyword.push(
		/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
		// keywords that have to be followed by an identifier
		/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
		// This is for `import type *, {}`
		/\btype\b(?=\s*(?:[\{*]|$))/
	);

	// doesn't work with TS because TS is too complex
	delete Prism.languages.typescript['parameter'];
	delete Prism.languages.typescript['literal-property'];

	// a version of typescript specifically for highlighting types
	var typeInside = Prism.languages.extend('typescript', {});
	delete typeInside['class-name'];

	Prism.languages.typescript['class-name'].inside = typeInside;

	Prism.languages.insertBefore('typescript', 'function', {
		'decorator': {
			pattern: /@[$\w\xA0-\uFFFF]+/,
			inside: {
				'at': {
					pattern: /^@/,
					alias: 'operator'
				},
				'function': /^[\s\S]+/
			}
		},
		'generic-function': {
			// e.g. foo<T extends "bar" | "baz">( ...
			pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
			greedy: true,
			inside: {
				'function': /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
				'generic': {
					pattern: /<[\s\S]+/, // everything after the first <
					alias: 'class-name',
					inside: typeInside
				}
			}
		}
	});

	Prism.languages.ts = Prism.languages.typescript;

}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-yaml.js":
/*!****************************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/components/prism-yaml.js ***!
  \****************************************************************************************************************/
/***/ (function() {

(function (Prism) {

	// https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
	// https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
	var anchorOrAlias = /[*&][^\s[\]{},]+/;
	// https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
	var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
	// https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
	var properties = '(?:' + tag.source + '(?:[ \t]+' + anchorOrAlias.source + ')?|'
		+ anchorOrAlias.source + '(?:[ \t]+' + tag.source + ')?)';
	// https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
	// This is a simplified version that doesn't support "#" and multiline keys
	// All these long scarry character classes are simplified versions of YAML's characters
	var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source
		.replace(/<PLAIN>/g, function () { return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source; });
	var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;

	/**
	 *
	 * @param {string} value
	 * @param {string} [flags]
	 * @returns {RegExp}
	 */
	function createValuePattern(value, flags) {
		flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag
		var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
			.replace(/<<prop>>/g, function () { return properties; }).replace(/<<value>>/g, function () { return value; });
		return RegExp(pattern, flags);
	}

	Prism.languages.yaml = {
		'scalar': {
			pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source
				.replace(/<<prop>>/g, function () { return properties; })),
			lookbehind: true,
			alias: 'string'
		},
		'comment': /#.*/,
		'key': {
			pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
				.replace(/<<prop>>/g, function () { return properties; })
				.replace(/<<key>>/g, function () { return '(?:' + plainKey + '|' + string + ')'; })),
			lookbehind: true,
			greedy: true,
			alias: 'atrule'
		},
		'directive': {
			pattern: /(^[ \t]*)%.+/m,
			lookbehind: true,
			alias: 'important'
		},
		'datetime': {
			pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
			lookbehind: true,
			alias: 'number'
		},
		'boolean': {
			pattern: createValuePattern(/false|true/.source, 'i'),
			lookbehind: true,
			alias: 'important'
		},
		'null': {
			pattern: createValuePattern(/null|~/.source, 'i'),
			lookbehind: true,
			alias: 'important'
		},
		'string': {
			pattern: createValuePattern(string),
			lookbehind: true,
			greedy: true
		},
		'number': {
			pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, 'i'),
			lookbehind: true
		},
		'tag': tag,
		'important': anchorOrAlias,
		'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
	};

	Prism.languages.yml = Prism.languages.yaml;

}(Prism));


/***/ }),

/***/ "./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/prism.js":
/*!************************************************************************************************!*\
  !*** ./.yarn/cache/prismjs-npm-1.29.0-6faa5b04b8-007a8869d4.zip/node_modules/prismjs/prism.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* **********************************************
     Begin prism-core.js
********************************************** */

/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		/**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element) {
					var m = lang.exec(element.className);
					if (m) {
						return m[1].toLowerCase();
					}
					element = element.parentElement;
				}
				return 'none';
			},

			/**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
			setLanguage: function (element, language) {
				// remove all `language-xxxx` classes
				// (this might leave behind a leading space)
				element.className = element.className.replace(RegExp(lang, 'gi'), '');

				// add the new `language-xxxx` class
				// (using `classList` will automatically clean up spaces for us)
				element.classList.add('language-' + language);
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			_.util.setLanguage(element, language);

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				_.util.setLanguage(parent, language);
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			if (!env.grammar) {
				throw new Error('The language "' + env.language + '" has no grammar.');
			}
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match || match.index >= text.length) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if ( true && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof __webpack_require__.g !== 'undefined') {
	__webpack_require__.g.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': {
		pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
		greedy: true
	},
	'prolog': {
		pattern: /<\?[\s\S]+?\?>/,
		greedy: true
	},
	'doctype': {
		// https://www.w3.org/TR/xml/#NT-doctypedecl
		pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: true,
		inside: {
			'internal-subset': {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: true,
				greedy: true,
				inside: null // see below
			},
			'string': {
				pattern: /"[^"]*"|'[^']*'/,
				greedy: true
			},
			'punctuation': /^<!|>$|[[\]]/,
			'doctype-tag': /^DOCTYPE/i,
			'name': /[^\s<>'"]+/
		}
	},
	'cdata': {
		pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
		greedy: true
	},
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: true,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'special-attr': [],
			'attr-value': {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					'punctuation': [
						{
							pattern: /^=/,
							alias: 'attr-equals'
						},
						{
							pattern: /^(\s*)["']|["']$/,
							lookbehind: true
						}
					]
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': [
		{
			pattern: /&[\da-z]{1,8};/i,
			alias: 'named-entity'
		},
		/&#x?[\da-f]{1,8};/i
	]
};

Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
	Prism.languages.markup['entity'];
Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function (env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
	/**
	 * Adds an inlined language to markup.
	 *
	 * An example of an inlined language is CSS with `<style>` tags.
	 *
	 * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addInlined('style', 'css');
	 */
	value: function addInlined(tagName, lang) {
		var includedCdataInside = {};
		includedCdataInside['language-' + lang] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: true,
			inside: Prism.languages[lang]
		};
		includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;

		var inside = {
			'included-cdata': {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: includedCdataInside
			}
		};
		inside['language-' + lang] = {
			pattern: /[\s\S]+/,
			inside: Prism.languages[lang]
		};

		var def = {};
		def[tagName] = {
			pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),
			lookbehind: true,
			greedy: true,
			inside: inside
		};

		Prism.languages.insertBefore('markup', 'cdata', def);
	}
});
Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
	/**
	 * Adds an pattern to highlight languages embedded in HTML attributes.
	 *
	 * An example of an inlined language is CSS with `style` attributes.
	 *
	 * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
	 * case insensitive.
	 * @param {string} lang The language key.
	 * @example
	 * addAttribute('style', 'css');
	 */
	value: function (attrName, lang) {
		Prism.languages.markup.tag.inside['special-attr'].push({
			pattern: RegExp(
				/(^|["'\s])/.source + '(?:' + attrName + ')' + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				'i'
			),
			lookbehind: true,
			inside: {
				'attr-name': /^[^\s=]+/,
				'attr-value': {
					pattern: /=[\s\S]+/,
					inside: {
						'value': {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: true,
							alias: [lang, 'language-' + lang],
							inside: Prism.languages[lang]
						},
						'punctuation': [
							{
								pattern: /^=/,
								alias: 'attr-equals'
							},
							/"|'/
						]
					}
				}
			}
		});
	}
});

Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;

Prism.languages.xml = Prism.languages.extend('markup', {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;


/* **********************************************
     Begin prism-css.js
********************************************** */

(function (Prism) {

	var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;

	Prism.languages.css = {
		'comment': /\/\*[\s\S]*?\*\//,
		'atrule': {
			pattern: RegExp('@[\\w-](?:' + /[^;{\s"']|\s+(?!\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\s*\{))/.source),
			inside: {
				'rule': /^@[\w-]+/,
				'selector-function-argument': {
					pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: true,
					alias: 'selector'
				},
				'keyword': {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: true
				}
				// See rest below
			}
		},
		'url': {
			// https://drafts.csswg.org/css-values-3/#urls
			pattern: RegExp('\\burl\\((?:' + string.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)', 'i'),
			greedy: true,
			inside: {
				'function': /^url/i,
				'punctuation': /^\(|\)$/,
				'string': {
					pattern: RegExp('^' + string.source + '$'),
					alias: 'url'
				}
			}
		},
		'selector': {
			pattern: RegExp('(^|[{}\\s])[^{}\\s](?:[^{};"\'\\s]|\\s+(?![\\s{])|' + string.source + ')*(?=\\s*\\{)'),
			lookbehind: true
		},
		'string': {
			pattern: string,
			greedy: true
		},
		'property': {
			pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: true
		},
		'important': /!important\b/i,
		'function': {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: true
		},
		'punctuation': /[(){};:,]/
	};

	Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

	var markup = Prism.languages.markup;
	if (markup) {
		markup.tag.addInlined('style', 'css');
		markup.tag.addAttribute('style', 'css');
	}

}(Prism));


/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: true,
			greedy: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true,
			greedy: true
		}
	],
	'string': {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: true,
		inside: {
			'punctuation': /[.\\]/
		}
	},
	'keyword': /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	'boolean': /\b(?:false|true)\b/,
	'function': /\b\w+(?=\()/,
	'number': /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	'operator': /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'class-name': [
		Prism.languages.clike['class-name'],
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: true
		}
	],
	'keyword': [
		{
			pattern: /((?:^|\})\s*)catch\b/,
			lookbehind: true
		},
		{
			pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: true
		},
	],
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	'number': {
		pattern: RegExp(
			/(^|[^\w$])/.source +
			'(?:' +
			(
				// constant
				/NaN|Infinity/.source +
				'|' +
				// binary integer
				/0[bB][01]+(?:_[01]+)*n?/.source +
				'|' +
				// octal integer
				/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
				'|' +
				// hexadecimal integer
				/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
				'|' +
				// decimal bigint
				/\d+(?:_\d+)*n/.source +
				'|' +
				// decimal number (integer or float) but no bigint
				/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source
			) +
			')' +
			/(?![\w$])/.source
		),
		lookbehind: true
	},
	'operator': /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});

Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: RegExp(
			// lookbehind
			// eslint-disable-next-line regexp/no-dupe-characters-character-class
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
			// Regex pattern:
			// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
			// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
			// with the only syntax, so we have to define 2 different regex patterns.
			/\//.source +
			'(?:' +
			/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source +
			'|' +
			// `v` flag syntax. This supports 3 levels of nested character classes.
			/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +
			')' +
			// lookahead
			/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
		),
		lookbehind: true,
		greedy: true,
		inside: {
			'regex-source': {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: true,
				alias: 'language-regex',
				inside: Prism.languages.regex
			},
			'regex-delimiter': /^\/|\/$/,
			'regex-flags': /^[a-z]+$/,
		}
	},
	// This must be declared before keyword because we use "function" inside the look-forward
	'function-variable': {
		pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: 'function'
	},
	'parameter': [
		{
			pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		},
		{
			pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: true,
			inside: Prism.languages.javascript
		}
	],
	'constant': /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});

Prism.languages.insertBefore('javascript', 'string', {
	'hashbang': {
		pattern: /^#!.*/,
		greedy: true,
		alias: 'comment'
	},
	'template-string': {
		pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: true,
		inside: {
			'template-punctuation': {
				pattern: /^`|`$/,
				alias: 'string'
			},
			'interpolation': {
				pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: true,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	},
	'string-property': {
		pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: true,
		greedy: true,
		alias: 'property'
	}
});

Prism.languages.insertBefore('javascript', 'operator', {
	'literal-property': {
		pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: true,
		alias: 'property'
	},
});

if (Prism.languages.markup) {
	Prism.languages.markup.tag.addInlined('script', 'javascript');

	// add attribute support for all DOM events.
	// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
	Prism.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
		'javascript'
	);
}

Prism.languages.js = Prism.languages.javascript;


/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
	if (!Element.prototype.matches) {
		Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	}

	var LOADING_MESSAGE = 'Loading…';
	var FAILURE_MESSAGE = function (status, message) {
		return '✖ Error ' + status + ' while fetching file: ' + message;
	};
	var FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';

	var EXTENSIONS = {
		'js': 'javascript',
		'py': 'python',
		'rb': 'ruby',
		'ps1': 'powershell',
		'psm1': 'powershell',
		'sh': 'bash',
		'bat': 'batch',
		'h': 'c',
		'tex': 'latex'
	};

	var STATUS_ATTR = 'data-src-status';
	var STATUS_LOADING = 'loading';
	var STATUS_LOADED = 'loaded';
	var STATUS_FAILED = 'failed';

	var SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '="' + STATUS_LOADED + '"])'
		+ ':not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';

	/**
	 * Loads the given file.
	 *
	 * @param {string} src The URL or path of the source file to load.
	 * @param {(result: string) => void} success
	 * @param {(reason: string) => void} error
	 */
	function loadFile(src, success, error) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', src, true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState == 4) {
				if (xhr.status < 400 && xhr.responseText) {
					success(xhr.responseText);
				} else {
					if (xhr.status >= 400) {
						error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
					} else {
						error(FAILURE_EMPTY_MESSAGE);
					}
				}
			}
		};
		xhr.send(null);
	}

	/**
	 * Parses the given range.
	 *
	 * This returns a range with inclusive ends.
	 *
	 * @param {string | null | undefined} range
	 * @returns {[number, number | undefined] | undefined}
	 */
	function parseRange(range) {
		var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || '');
		if (m) {
			var start = Number(m[1]);
			var comma = m[2];
			var end = m[3];

			if (!comma) {
				return [start, start];
			}
			if (!end) {
				return [start, undefined];
			}
			return [start, Number(end)];
		}
		return undefined;
	}

	Prism.hooks.add('before-highlightall', function (env) {
		env.selector += ', ' + SELECTOR;
	});

	Prism.hooks.add('before-sanity-check', function (env) {
		var pre = /** @type {HTMLPreElement} */ (env.element);
		if (pre.matches(SELECTOR)) {
			env.code = ''; // fast-path the whole thing and go to complete

			pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading

			// add code element with loading message
			var code = pre.appendChild(document.createElement('CODE'));
			code.textContent = LOADING_MESSAGE;

			var src = pre.getAttribute('data-src');

			var language = env.language;
			if (language === 'none') {
				// the language might be 'none' because there is no language set;
				// in this case, we want to use the extension as the language
				var extension = (/\.(\w+)$/.exec(src) || [, 'none'])[1];
				language = EXTENSIONS[extension] || extension;
			}

			// set language classes
			Prism.util.setLanguage(code, language);
			Prism.util.setLanguage(pre, language);

			// preload the language
			var autoloader = Prism.plugins.autoloader;
			if (autoloader) {
				autoloader.loadLanguages(language);
			}

			// load file
			loadFile(
				src,
				function (text) {
					// mark as loaded
					pre.setAttribute(STATUS_ATTR, STATUS_LOADED);

					// handle data-range
					var range = parseRange(pre.getAttribute('data-range'));
					if (range) {
						var lines = text.split(/\r\n?|\n/g);

						// the range is one-based and inclusive on both ends
						var start = range[0];
						var end = range[1] == null ? lines.length : range[1];

						if (start < 0) { start += lines.length; }
						start = Math.max(0, Math.min(start - 1, lines.length));
						if (end < 0) { end += lines.length; }
						end = Math.max(0, Math.min(end, lines.length));

						text = lines.slice(start, end).join('\n');

						// add data-start for line numbers
						if (!pre.hasAttribute('data-start')) {
							pre.setAttribute('data-start', String(start + 1));
						}
					}

					// highlight code
					code.textContent = text;
					Prism.highlightElement(code);
				},
				function (error) {
					// mark as failed
					pre.setAttribute(STATUS_ATTR, STATUS_FAILED);

					code.textContent = error;
				}
			);
		}
	});

	Prism.plugins.fileHighlight = {
		/**
		 * Executes the File Highlight plugin for all matching `pre` elements under the given container.
		 *
		 * Note: Elements which are already loaded or currently loading will not be touched by this method.
		 *
		 * @param {ParentNode} [container=document]
		 */
		highlight: function highlight(container) {
			var elements = (container || document).querySelectorAll(SELECTOR);

			for (var i = 0, element; (element = elements[i++]);) {
				Prism.highlightElement(element);
			}
		}
	};

	var logged = false;
	/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */
	Prism.fileHighlight = function () {
		if (!logged) {
			console.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');
			logged = true;
		}
		Prism.plugins.fileHighlight.highlight.apply(this, arguments);
	};

}());


/***/ }),

/***/ "./.yarn/cache/process-npm-0.11.10-aeb3b641ae-bfcce49814.zip/node_modules/process/browser.js":
/*!***************************************************************************************************!*\
  !*** ./.yarn/cache/process-npm-0.11.10-aeb3b641ae-bfcce49814.zip/node_modules/process/browser.js ***!
  \***************************************************************************************************/
/***/ (function(module) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js":
/*!**********************************************************************************************************************!*\
  !*** ./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js":
/*!***************************************************************************************************!*\
  !*** ./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/index.js ***!
  \***************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./.yarn/cache/react-is-npm-16.13.1-a9b9382b4f-f7a19ac349.zip/node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/** @license React v17.0.2
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/polyfills/object-assign.js");

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.jsxDEV = jsxDEV$1;
  })();
}


/***/ }),

/***/ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js":
/*!******************************************************************************************************!*\
  !*** ./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/jsx-dev-runtime.js ***!
  \******************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}


/***/ }),

/***/ "./.yarn/cache/section-matter-npm-1.0.0-2f79fd59d6-3cc4131705.zip/node_modules/section-matter/index.js":
/*!*************************************************************************************************************!*\
  !*** ./.yarn/cache/section-matter-npm-1.0.0-2f79fd59d6-3cc4131705.zip/node_modules/section-matter/index.js ***!
  \*************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var typeOf = __webpack_require__(/*! kind-of */ "./.yarn/cache/kind-of-npm-6.0.3-ab15f36220-3ab01e7b1d.zip/node_modules/kind-of/index.js");
var extend = __webpack_require__(/*! extend-shallow */ "./.yarn/cache/extend-shallow-npm-2.0.1-e6ef52b29c-8fb58d9d7a.zip/node_modules/extend-shallow/index.js");

/**
 * Parse sections in `input` with the given `options`.
 *
 * ```js
 * var sections = require('{%= name %}');
 * var result = sections(input, options);
 * // { content: 'Content before sections', sections: [] }
 * ```
 * @param {String|Buffer|Object} `input` If input is an object, it's `content` property must be a string or buffer.
 * @param {Object} options
 * @return {Object} Returns an object with a `content` string and an array of `sections` objects.
 * @api public
 */

module.exports = function(input, options) {
  if (typeof options === 'function') {
    options = { parse: options };
  }

  var file = toObject(input);
  var defaults = {section_delimiter: '---', parse: identity};
  var opts = extend({}, defaults, options);
  var delim = opts.section_delimiter;
  var lines = file.content.split(/\r?\n/);
  var sections = null;
  var section = createSection();
  var content = [];
  var stack = [];

  function initSections(val) {
    file.content = val;
    sections = [];
    content = [];
  }

  function closeSection(val) {
    if (stack.length) {
      section.key = getKey(stack[0], delim);
      section.content = val;
      opts.parse(section, sections);
      sections.push(section);
      section = createSection();
      content = [];
      stack = [];
    }
  }

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var len = stack.length;
    var ln = line.trim();

    if (isDelimiter(ln, delim)) {
      if (ln.length === 3 && i !== 0) {
        if (len === 0 || len === 2) {
          content.push(line);
          continue;
        }
        stack.push(ln);
        section.data = content.join('\n');
        content = [];
        continue;
      }

      if (sections === null) {
        initSections(content.join('\n'));
      }

      if (len === 2) {
        closeSection(content.join('\n'));
      }

      stack.push(ln);
      continue;
    }

    content.push(line);
  }

  if (sections === null) {
    initSections(content.join('\n'));
  } else {
    closeSection(content.join('\n'));
  }

  file.sections = sections;
  return file;
};

function isDelimiter(line, delim) {
  if (line.slice(0, delim.length) !== delim) {
    return false;
  }
  if (line.charAt(delim.length + 1) === delim.slice(-1)) {
    return false;
  }
  return true;
}

function toObject(input) {
  if (typeOf(input) !== 'object') {
    input = { content: input };
  }

  if (typeof input.content !== 'string' && !isBuffer(input.content)) {
    throw new TypeError('expected a buffer or string');
  }

  input.content = input.content.toString();
  input.sections = [];
  return input;
}

function getKey(val, delim) {
  return val ? val.slice(delim.length).trim() : '';
}

function createSection() {
  return { key: '', data: '', content: '' };
}

function identity(val) {
  return val;
}

function isBuffer(val) {
  if (val && val.constructor && typeof val.constructor.isBuffer === 'function') {
    return val.constructor.isBuffer(val);
  }
  return false;
}


/***/ }),

/***/ "./.yarn/cache/shallowequal-npm-1.1.0-6688d419cb-f4c1de0837.zip/node_modules/shallowequal/index.js":
/*!*********************************************************************************************************!*\
  !*** ./.yarn/cache/shallowequal-npm-1.1.0-6688d419cb-f4c1de0837.zip/node_modules/shallowequal/index.js ***!
  \*********************************************************************************************************/
/***/ (function(module) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),

/***/ "./.yarn/cache/strip-bom-string-npm-1.0.0-aa6cb548d1-5635a3656d.zip/node_modules/strip-bom-string/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./.yarn/cache/strip-bom-string-npm-1.0.0-aa6cb548d1-5635a3656d.zip/node_modules/strip-bom-string/index.js ***!
  \*****************************************************************************************************************/
/***/ (function(module) {

"use strict";
/*!
 * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
 *
 * Copyright (c) 2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(str) {
  if (typeof str === 'string' && str.charAt(0) === '\ufeff') {
    return str.slice(1);
  }
  return str;
};


/***/ }),

/***/ "./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/unplugged/styled-components-virtual-4118695063/node_modules/styled-components/dist/styled-components.browser.esm.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ServerStyleSheet": function() { return /* binding */ Je; },
/* harmony export */   "StyleSheetConsumer": function() { return /* binding */ le; },
/* harmony export */   "StyleSheetContext": function() { return /* binding */ ue; },
/* harmony export */   "StyleSheetManager": function() { return /* binding */ ye; },
/* harmony export */   "ThemeConsumer": function() { return /* binding */ Le; },
/* harmony export */   "ThemeContext": function() { return /* binding */ Ge; },
/* harmony export */   "ThemeProvider": function() { return /* binding */ Fe; },
/* harmony export */   "__PRIVATE__": function() { return /* binding */ Ke; },
/* harmony export */   "createGlobalStyle": function() { return /* binding */ We; },
/* harmony export */   "css": function() { return /* binding */ Ce; },
/* harmony export */   "isStyledComponent": function() { return /* binding */ N; },
/* harmony export */   "keyframes": function() { return /* binding */ Ue; },
/* harmony export */   "useTheme": function() { return /* binding */ Ze; },
/* harmony export */   "version": function() { return /* binding */ C; },
/* harmony export */   "withTheme": function() { return /* binding */ Xe; }
/* harmony export */ });
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-is */ "./.yarn/cache/react-is-npm-17.0.2-091bbb8db6-9d6d111d89.zip/node_modules/react-is/index.js");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./.yarn/cache/react-npm-17.0.2-99ba37d931-b254cc17ce.zip/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shallowequal */ "./.yarn/cache/shallowequal-npm-1.1.0-6688d419cb-f4c1de0837.zip/node_modules/shallowequal/index.js");
/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(shallowequal__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _emotion_stylis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/stylis */ "./.yarn/cache/@emotion-stylis-npm-0.8.5-3e9db8959f-67ff595844.zip/node_modules/@emotion/stylis/dist/stylis.browser.esm.js");
/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/unitless */ "./.yarn/cache/@emotion-unitless-npm-0.7.5-14e1171640-f976e5345b.zip/node_modules/@emotion/unitless/dist/unitless.browser.esm.js");
/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/is-prop-valid */ "./.yarn/cache/@emotion-is-prop-valid-npm-1.2.0-332d343e3d-cc7a19850a.zip/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! hoist-non-react-statics */ "./.yarn/cache/hoist-non-react-statics-npm-3.3.2-e7b709e6c1-b153827042.zip/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6__);
/* provided dependency */ var process = __webpack_require__(/*! process */ "./.yarn/cache/process-npm-0.11.10-aeb3b641ae-bfcce49814.zip/node_modules/process/browser.js");
function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}var g=function(e,t){for(var n=[e[0]],r=0,o=t.length;r<o;r+=1)n.push(t[r],e[r+1]);return n},S=function(t){return null!==t&&"object"==typeof t&&"[object Object]"===(t.toString?t.toString():Object.prototype.toString.call(t))&&!(0,react_is__WEBPACK_IMPORTED_MODULE_0__.typeOf)(t)},w=Object.freeze([]),E=Object.freeze({});function b(e){return"function"==typeof e}function _(e){return true&&"string"==typeof e&&e||e.displayName||e.name||"Component"}function N(e){return e&&"string"==typeof e.styledComponentId}var A="undefined"!=typeof process&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",C="5.3.6",I="undefined"!=typeof window&&"HTMLElement"in window,P=Boolean("boolean"==typeof SC_DISABLE_SPEEDY?SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&""!==process.env.REACT_APP_SC_DISABLE_SPEEDY?"false"!==process.env.REACT_APP_SC_DISABLE_SPEEDY&&process.env.REACT_APP_SC_DISABLE_SPEEDY:"undefined"!=typeof process&&void 0!==process.env.SC_DISABLE_SPEEDY&&""!==process.env.SC_DISABLE_SPEEDY?"false"!==process.env.SC_DISABLE_SPEEDY&&process.env.SC_DISABLE_SPEEDY:"production"!=="development"),O={},R= true?{1:"Cannot create styled-component for component: %s.\n\n",2:"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n",3:"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n",4:"The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n",5:"The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n",6:"Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n",7:'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n',8:'ThemeProvider: Please make your "theme" prop an object.\n\n',9:"Missing document `<head>`\n\n",10:"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n",11:"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n",12:"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n",13:"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n",14:'ThemeProvider: "theme" prop is required.\n\n',15:"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n",16:"Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n",17:"CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n"}:0;function D(){for(var e=arguments.length<=0?void 0:arguments[0],t=[],n=1,r=arguments.length;n<r;n+=1)t.push(n<0||arguments.length<=n?void 0:arguments[n]);return t.forEach((function(t){e=e.replace(/%[a-z]/,t)})),e}function j(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw false?0:new Error(D.apply(void 0,[R[e]].concat(n)).trim())}var T=function(){function e(e){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=e}var t=e.prototype;return t.indexOfGroup=function(e){for(var t=0,n=0;n<e;n++)t+=this.groupSizes[n];return t},t.insertRules=function(e,t){if(e>=this.groupSizes.length){for(var n=this.groupSizes,r=n.length,o=r;e>=o;)(o<<=1)<0&&j(16,""+e);this.groupSizes=new Uint32Array(o),this.groupSizes.set(n),this.length=o;for(var s=r;s<o;s++)this.groupSizes[s]=0}for(var i=this.indexOfGroup(e+1),a=0,c=t.length;a<c;a++)this.tag.insertRule(i,t[a])&&(this.groupSizes[e]++,i++)},t.clearGroup=function(e){if(e<this.length){var t=this.groupSizes[e],n=this.indexOfGroup(e),r=n+t;this.groupSizes[e]=0;for(var o=n;o<r;o++)this.tag.deleteRule(n)}},t.getGroup=function(e){var t="";if(e>=this.length||0===this.groupSizes[e])return t;for(var n=this.groupSizes[e],r=this.indexOfGroup(e),o=r+n,s=r;s<o;s++)t+=this.tag.getRule(s)+"/*!sc*/\n";return t},e}(),x=new Map,k=new Map,V=1,B=function(e){if(x.has(e))return x.get(e);for(;k.has(V);)V++;var t=V++;return true&&((0|t)<0||t>1<<30)&&j(16,""+t),x.set(e,t),k.set(t,e),t},z=function(e){return k.get(e)},M=function(e,t){t>=V&&(V=t+1),x.set(e,t),k.set(t,e)},G="style["+A+'][data-styled-version="5.3.6"]',L=new RegExp("^"+A+'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),F=function(e,t,n){for(var r,o=n.split(","),s=0,i=o.length;s<i;s++)(r=o[s])&&e.registerName(t,r)},Y=function(e,t){for(var n=(t.textContent||"").split("/*!sc*/\n"),r=[],o=0,s=n.length;o<s;o++){var i=n[o].trim();if(i){var a=i.match(L);if(a){var c=0|parseInt(a[1],10),u=a[2];0!==c&&(M(u,c),F(e,u,a[3]),e.getTag().insertRules(c,r)),r.length=0}else r.push(i)}}},q=function(){return true?__webpack_require__.nc:0},H=function(e){var t=document.head,n=e||t,r=document.createElement("style"),o=function(e){for(var t=e.childNodes,n=t.length;n>=0;n--){var r=t[n];if(r&&1===r.nodeType&&r.hasAttribute(A))return r}}(n),s=void 0!==o?o.nextSibling:null;r.setAttribute(A,"active"),r.setAttribute("data-styled-version","5.3.6");var i=q();return i&&r.setAttribute("nonce",i),n.insertBefore(r,s),r},$=function(){function e(e){var t=this.element=H(e);t.appendChild(document.createTextNode("")),this.sheet=function(e){if(e.sheet)return e.sheet;for(var t=document.styleSheets,n=0,r=t.length;n<r;n++){var o=t[n];if(o.ownerNode===e)return o}j(17)}(t),this.length=0}var t=e.prototype;return t.insertRule=function(e,t){try{return this.sheet.insertRule(t,e),this.length++,!0}catch(e){return!1}},t.deleteRule=function(e){this.sheet.deleteRule(e),this.length--},t.getRule=function(e){var t=this.sheet.cssRules[e];return void 0!==t&&"string"==typeof t.cssText?t.cssText:""},e}(),W=function(){function e(e){var t=this.element=H(e);this.nodes=t.childNodes,this.length=0}var t=e.prototype;return t.insertRule=function(e,t){if(e<=this.length&&e>=0){var n=document.createTextNode(t),r=this.nodes[e];return this.element.insertBefore(n,r||null),this.length++,!0}return!1},t.deleteRule=function(e){this.element.removeChild(this.nodes[e]),this.length--},t.getRule=function(e){return e<this.length?this.nodes[e].textContent:""},e}(),U=function(){function e(e){this.rules=[],this.length=0}var t=e.prototype;return t.insertRule=function(e,t){return e<=this.length&&(this.rules.splice(e,0,t),this.length++,!0)},t.deleteRule=function(e){this.rules.splice(e,1),this.length--},t.getRule=function(e){return e<this.length?this.rules[e]:""},e}(),J=I,X={isServer:!I,useCSSOMInjection:!P},Z=function(){function e(e,t,n){void 0===e&&(e=E),void 0===t&&(t={}),this.options=v({},X,{},e),this.gs=t,this.names=new Map(n),this.server=!!e.isServer,!this.server&&I&&J&&(J=!1,function(e){for(var t=document.querySelectorAll(G),n=0,r=t.length;n<r;n++){var o=t[n];o&&"active"!==o.getAttribute(A)&&(Y(e,o),o.parentNode&&o.parentNode.removeChild(o))}}(this))}e.registerId=function(e){return B(e)};var t=e.prototype;return t.reconstructWithOptions=function(t,n){return void 0===n&&(n=!0),new e(v({},this.options,{},t),this.gs,n&&this.names||void 0)},t.allocateGSInstance=function(e){return this.gs[e]=(this.gs[e]||0)+1},t.getTag=function(){return this.tag||(this.tag=(n=(t=this.options).isServer,r=t.useCSSOMInjection,o=t.target,e=n?new U(o):r?new $(o):new W(o),new T(e)));var e,t,n,r,o},t.hasNameForId=function(e,t){return this.names.has(e)&&this.names.get(e).has(t)},t.registerName=function(e,t){if(B(e),this.names.has(e))this.names.get(e).add(t);else{var n=new Set;n.add(t),this.names.set(e,n)}},t.insertRules=function(e,t,n){this.registerName(e,t),this.getTag().insertRules(B(e),n)},t.clearNames=function(e){this.names.has(e)&&this.names.get(e).clear()},t.clearRules=function(e){this.getTag().clearGroup(B(e)),this.clearNames(e)},t.clearTag=function(){this.tag=void 0},t.toString=function(){return function(e){for(var t=e.getTag(),n=t.length,r="",o=0;o<n;o++){var s=z(o);if(void 0!==s){var i=e.names.get(s),a=t.getGroup(o);if(i&&a&&i.size){var c=A+".g"+o+'[id="'+s+'"]',u="";void 0!==i&&i.forEach((function(e){e.length>0&&(u+=e+",")})),r+=""+a+c+'{content:"'+u+'"}/*!sc*/\n'}}}return r}(this)},e}(),K=/(a)(d)/gi,Q=function(e){return String.fromCharCode(e+(e>25?39:97))};function ee(e){var t,n="";for(t=Math.abs(e);t>52;t=t/52|0)n=Q(t%52)+n;return(Q(t%52)+n).replace(K,"$1-$2")}var te=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},ne=function(e){return te(5381,e)};function re(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(b(n)&&!N(n))return!1}return!0}var oe=ne("5.3.6"),se=function(){function e(e,t,n){this.rules=e,this.staticRulesId="",this.isStatic= false&&0,this.componentId=t,this.baseHash=te(oe,t),this.baseStyle=n,Z.registerId(t)}return e.prototype.generateAndInjectStyles=function(e,t,n){var r=this.componentId,o=[];if(this.baseStyle&&o.push(this.baseStyle.generateAndInjectStyles(e,t,n)),this.isStatic&&!n.hash)if(this.staticRulesId&&t.hasNameForId(r,this.staticRulesId))o.push(this.staticRulesId);else{var s=Ne(this.rules,e,t,n).join(""),i=ee(te(this.baseHash,s)>>>0);if(!t.hasNameForId(r,i)){var a=n(s,"."+i,void 0,r);t.insertRules(r,i,a)}o.push(i),this.staticRulesId=i}else{for(var c=this.rules.length,u=te(this.baseHash,n.hash),l="",d=0;d<c;d++){var h=this.rules[d];if("string"==typeof h)l+=h, true&&(u=te(u,h+d));else if(h){var p=Ne(h,e,t,n),f=Array.isArray(p)?p.join(""):p;u=te(u,f+d),l+=f}}if(l){var m=ee(u>>>0);if(!t.hasNameForId(r,m)){var y=n(l,"."+m,void 0,r);t.insertRules(r,m,y)}o.push(m)}}return o.join(" ")},e}(),ie=/^\s*\/\/.*$/gm,ae=[":","[",".","#"];function ce(e){var t,n,r,o,s=void 0===e?E:e,i=s.options,a=void 0===i?E:i,c=s.plugins,u=void 0===c?w:c,l=new _emotion_stylis__WEBPACK_IMPORTED_MODULE_3__.default(a),d=[],h=function(e){function t(t){if(t)try{e(t+"}")}catch(e){}}return function(n,r,o,s,i,a,c,u,l,d){switch(n){case 1:if(0===l&&64===r.charCodeAt(0))return e(r+";"),"";break;case 2:if(0===u)return r+"/*|*/";break;case 3:switch(u){case 102:case 112:return e(o[0]+r),"";default:return r+(0===d?"/*|*/":"")}case-2:r.split("/*|*/}").forEach(t)}}}((function(e){d.push(e)})),f=function(e,r,s){return 0===r&&-1!==ae.indexOf(s[n.length])||s.match(o)?e:"."+t};function m(e,s,i,a){void 0===a&&(a="&");var c=e.replace(ie,""),u=s&&i?i+" "+s+" { "+c+" }":c;return t=a,n=s,r=new RegExp("\\"+n+"\\b","g"),o=new RegExp("(\\"+n+"\\b){2,}"),l(i||!s?"":s,u)}return l.use([].concat(u,[function(e,t,o){2===e&&o.length&&o[0].lastIndexOf(n)>0&&(o[0]=o[0].replace(r,f))},h,function(e){if(-2===e){var t=d;return d=[],t}}])),m.hash=u.length?u.reduce((function(e,t){return t.name||j(15),te(e,t.name)}),5381).toString():"",m}var ue=react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),le=ue.Consumer,de=react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),he=(de.Consumer,new Z),pe=ce();function fe(){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ue)||he}function me(){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(de)||pe}function ye(e){var t=(0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(e.stylisPlugins),n=t[0],s=t[1],c=fe(),u=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((function(){var t=c;return e.sheet?t=e.sheet:e.target&&(t=t.reconstructWithOptions({target:e.target},!1)),e.disableCSSOMInjection&&(t=t.reconstructWithOptions({useCSSOMInjection:!1})),t}),[e.disableCSSOMInjection,e.sheet,e.target]),l=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((function(){return ce({options:{prefix:!e.disableVendorPrefixes},plugins:n})}),[e.disableVendorPrefixes,n]);return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)((function(){shallowequal__WEBPACK_IMPORTED_MODULE_2___default()(n,e.stylisPlugins)||s(e.stylisPlugins)}),[e.stylisPlugins]),react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ue.Provider,{value:u},react__WEBPACK_IMPORTED_MODULE_1___default().createElement(de.Provider,{value:l}, true?react__WEBPACK_IMPORTED_MODULE_1___default().Children.only(e.children):0))}var ve=function(){function e(e,t){var n=this;this.inject=function(e,t){void 0===t&&(t=pe);var r=n.name+t.hash;e.hasNameForId(n.id,r)||e.insertRules(n.id,r,t(n.rules,r,"@keyframes"))},this.toString=function(){return j(12,String(n.name))},this.name=e,this.id="sc-keyframes-"+e,this.rules=t}return e.prototype.getName=function(e){return void 0===e&&(e=pe),this.name+e.hash},e}(),ge=/([A-Z])/,Se=/([A-Z])/g,we=/^ms-/,Ee=function(e){return"-"+e.toLowerCase()};function be(e){return ge.test(e)?e.replace(Se,Ee).replace(we,"-ms-"):e}var _e=function(e){return null==e||!1===e||""===e};function Ne(e,n,r,o){if(Array.isArray(e)){for(var s,i=[],a=0,c=e.length;a<c;a+=1)""!==(s=Ne(e[a],n,r,o))&&(Array.isArray(s)?i.push.apply(i,s):i.push(s));return i}if(_e(e))return"";if(N(e))return"."+e.styledComponentId;if(b(e)){if("function"!=typeof(l=e)||l.prototype&&l.prototype.isReactComponent||!n)return e;var u=e(n);return true&&(0,react_is__WEBPACK_IMPORTED_MODULE_0__.isElement)(u)&&console.warn(_(e)+" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."),Ne(u,n,r,o)}var l;return e instanceof ve?r?(e.inject(r,o),e.getName(o)):e:S(e)?function e(t,n){var r,o,s=[];for(var i in t)t.hasOwnProperty(i)&&!_e(t[i])&&(Array.isArray(t[i])&&t[i].isCss||b(t[i])?s.push(be(i)+":",t[i],";"):S(t[i])?s.push.apply(s,e(t[i],i)):s.push(be(i)+": "+(r=i,null==(o=t[i])||"boolean"==typeof o||""===o?"":"number"!=typeof o||0===o||r in _emotion_unitless__WEBPACK_IMPORTED_MODULE_4__.default?String(o).trim():o+"px")+";"));return n?[n+" {"].concat(s,["}"]):s}(e):e.toString()}var Ae=function(e){return Array.isArray(e)&&(e.isCss=!0),e};function Ce(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return b(e)||S(e)?Ae(Ne(g(w,[e].concat(n)))):0===n.length&&1===e.length&&"string"==typeof e[0]?e:Ae(Ne(g(e,n)))}var Ie=/invalid hook call/i,Pe=new Set,Oe=function(e,t){if(true){var n="The component "+e+(t?' with the id of "'+t+'"':"")+" has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.",r=console.error;try{var o=!0;console.error=function(e){if(Ie.test(e))o=!1,Pe.delete(n);else{for(var t=arguments.length,s=new Array(t>1?t-1:0),i=1;i<t;i++)s[i-1]=arguments[i];r.apply(void 0,[e].concat(s))}},(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(),o&&!Pe.has(n)&&(console.warn(n),Pe.add(n))}catch(e){Ie.test(e.message)&&Pe.delete(n)}finally{console.error=r}}},Re=function(e,t,n){return void 0===n&&(n=E),e.theme!==n.theme&&e.theme||t||n.theme},De=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,je=/(^-|-$)/g;function Te(e){return e.replace(De,"-").replace(je,"")}var xe=function(e){return ee(ne(e)>>>0)};function ke(e){return"string"==typeof e&&( false||e.charAt(0)===e.charAt(0).toLowerCase())}var Ve=function(e){return"function"==typeof e||"object"==typeof e&&null!==e&&!Array.isArray(e)},Be=function(e){return"__proto__"!==e&&"constructor"!==e&&"prototype"!==e};function ze(e,t,n){var r=e[n];Ve(t)&&Ve(r)?Me(r,t):e[n]=t}function Me(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];for(var o=0,s=n;o<s.length;o++){var i=s[o];if(Ve(i))for(var a in i)Be(a)&&ze(e,i[a],a)}return e}var Ge=react__WEBPACK_IMPORTED_MODULE_1___default().createContext(),Le=Ge.Consumer;function Fe(e){var t=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),n=(0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)((function(){return function(e,t){if(!e)return j(14);if(b(e)){var n=e(t);return false||null!==n&&!Array.isArray(n)&&"object"==typeof n?n:j(7)}return Array.isArray(e)||"object"!=typeof e?j(8):t?v({},t,{},e):e}(e.theme,t)}),[e.theme,t]);return e.children?react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Ge.Provider,{value:n},e.children):null}var Ye={};function qe(e,t,n){var o=N(e),i=!ke(e),a=t.attrs,c=void 0===a?w:a,d=t.componentId,h=void 0===d?function(e,t){var n="string"!=typeof e?"sc":Te(e);Ye[n]=(Ye[n]||0)+1;var r=n+"-"+xe("5.3.6"+n+Ye[n]);return t?t+"-"+r:r}(t.displayName,t.parentComponentId):d,p=t.displayName,f=void 0===p?function(e){return ke(e)?"styled."+e:"Styled("+_(e)+")"}(e):p,g=t.displayName&&t.componentId?Te(t.displayName)+"-"+t.componentId:t.componentId||h,S=o&&e.attrs?Array.prototype.concat(e.attrs,c).filter(Boolean):c,A=t.shouldForwardProp;o&&e.shouldForwardProp&&(A=t.shouldForwardProp?function(n,r,o){return e.shouldForwardProp(n,r,o)&&t.shouldForwardProp(n,r,o)}:e.shouldForwardProp);var C,I=new se(n,g,o?e.componentStyle:void 0),P=I.isStatic&&0===c.length,O=function(e,t){return function(e,t,n,r){var o=e.attrs,i=e.componentStyle,a=e.defaultProps,c=e.foldedComponentIds,d=e.shouldForwardProp,h=e.styledComponentId,p=e.target; true&&(0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(h);var f=function(e,t,n){void 0===e&&(e=E);var r=v({},t,{theme:e}),o={};return n.forEach((function(e){var t,n,s,i=e;for(t in b(i)&&(i=i(r)),i)r[t]=o[t]="className"===t?(n=o[t],s=i[t],n&&s?n+" "+s:n||s):i[t]})),[r,o]}(Re(t,(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),a)||E,t,o),y=f[0],g=f[1],S=function(e,t,n,r){var o=fe(),s=me(),i=t?e.generateAndInjectStyles(E,o,s):e.generateAndInjectStyles(n,o,s);return true&&(0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(i), true&&!t&&r&&r(i),i}(i,r,y, true?e.warnTooManyClasses:0),w=n,_=g.$as||t.$as||g.as||t.as||p,N=ke(_),A=g!==t?v({},t,{},g):t,C={};for(var I in A)"$"!==I[0]&&"as"!==I&&("forwardedAs"===I?C.as=A[I]:(d?d(I,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__.default,_):!N||(0,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_5__.default)(I))&&(C[I]=A[I]));return t.style&&g.style!==t.style&&(C.style=v({},t.style,{},g.style)),C.className=Array.prototype.concat(c,h,S!==h?S:null,t.className,g.className).filter(Boolean).join(" "),C.ref=w,(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(_,C)}(C,e,t,P)};return O.displayName=f,(C=react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef(O)).attrs=S,C.componentStyle=I,C.displayName=f,C.shouldForwardProp=A,C.foldedComponentIds=o?Array.prototype.concat(e.foldedComponentIds,e.styledComponentId):w,C.styledComponentId=g,C.target=o?e.target:e,C.withComponent=function(e){var r=t.componentId,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(t,["componentId"]),s=r&&r+"-"+(ke(e)?e:Te(_(e)));return qe(e,v({},o,{attrs:S,componentId:s}),n)},Object.defineProperty(C,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(t){this._foldedDefaultProps=o?Me({},e.defaultProps,t):t}}), true&&(Oe(f,g),C.warnTooManyClasses=function(e,t){var n={},r=!1;return function(o){if(!r&&(n[o]=!0,Object.keys(n).length>=200)){var s=t?' with the id of "'+t+'"':"";console.warn("Over 200 classes were generated for component "+e+s+".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"),r=!0,n={}}}}(f,g)),C.toString=function(){return"."+C.styledComponentId},i&&hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default()(C,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0,withComponent:!0}),C}var He=function(e){return function e(t,r,o){if(void 0===o&&(o=E),!(0,react_is__WEBPACK_IMPORTED_MODULE_0__.isValidElementType)(r))return j(1,String(r));var s=function(){return t(r,o,Ce.apply(void 0,arguments))};return s.withConfig=function(n){return e(t,r,v({},o,{},n))},s.attrs=function(n){return e(t,r,v({},o,{attrs:Array.prototype.concat(o.attrs,n).filter(Boolean)}))},s}(qe,e)};["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","textPath","tspan"].forEach((function(e){He[e]=He(e)}));var $e=function(){function e(e,t){this.rules=e,this.componentId=t,this.isStatic=re(e),Z.registerId(this.componentId+1)}var t=e.prototype;return t.createStyles=function(e,t,n,r){var o=r(Ne(this.rules,t,n,r).join(""),""),s=this.componentId+e;n.insertRules(s,s,o)},t.removeStyles=function(e,t){t.clearRules(this.componentId+e)},t.renderStyles=function(e,t,n,r){e>2&&Z.registerId(this.componentId+e),this.removeStyles(e,n),this.createStyles(e,t,n,r)},e}();function We(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];var i=Ce.apply(void 0,[e].concat(n)),a="sc-global-"+xe(JSON.stringify(i)),u=new $e(i,a);function l(e){var t=fe(),n=me(),o=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),l=(0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(t.allocateGSInstance(a)).current;return true&&react__WEBPACK_IMPORTED_MODULE_1___default().Children.count(e.children)&&console.warn("The global style component "+a+" was given child JSX. createGlobalStyle does not render children."), true&&i.some((function(e){return"string"==typeof e&&-1!==e.indexOf("@import")}))&&console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."),t.server&&h(l,e,t,o,n),(0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)((function(){if(!t.server)return h(l,e,t,o,n),function(){return u.removeStyles(l,t)}}),[l,e,t,o,n]),null}function h(e,t,n,r,o){if(u.isStatic)u.renderStyles(e,O,n,o);else{var s=v({},t,{theme:Re(t,r,l.defaultProps)});u.renderStyles(e,s,n,o)}}return true&&Oe(a),react__WEBPACK_IMPORTED_MODULE_1___default().memo(l)}function Ue(e){ true&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var o=Ce.apply(void 0,[e].concat(n)).join(""),s=xe(o);return new ve(s,o)}var Je=function(){function e(){var e=this;this._emitSheetCSS=function(){var t=e.instance.toString();if(!t)return"";var n=q();return"<style "+[n&&'nonce="'+n+'"',A+'="true"','data-styled-version="5.3.6"'].filter(Boolean).join(" ")+">"+t+"</style>"},this.getStyleTags=function(){return e.sealed?j(2):e._emitSheetCSS()},this.getStyleElement=function(){var t;if(e.sealed)return j(2);var n=((t={})[A]="",t["data-styled-version"]="5.3.6",t.dangerouslySetInnerHTML={__html:e.instance.toString()},t),o=q();return o&&(n.nonce=o),[react__WEBPACK_IMPORTED_MODULE_1___default().createElement("style",v({},n,{key:"sc-0-0"}))]},this.seal=function(){e.sealed=!0},this.instance=new Z({isServer:!0}),this.sealed=!1}var t=e.prototype;return t.collectStyles=function(e){return this.sealed?j(2):react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ye,{sheet:this.instance},e)},t.interleaveWithNodeStream=function(e){return j(3)},e}(),Xe=function(e){var t=react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((function(t,n){var o=(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge),i=e.defaultProps,a=Re(t,o,i);return true&&void 0===a&&console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "'+_(e)+'"'),react__WEBPACK_IMPORTED_MODULE_1___default().createElement(e,v({},t,{theme:a,ref:n}))}));return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_6___default()(t,e),t.displayName="WithTheme("+_(e)+")",t},Ze=function(){return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Ge)},Ke={StyleSheet:Z,masterSheet:he}; true&&"undefined"!=typeof navigator&&"ReactNative"===navigator.product&&console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), true&&"undefined"!=typeof window&&(window["__styled-components-init__"]=window["__styled-components-init__"]||0,1===window["__styled-components-init__"]&&console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."),window["__styled-components-init__"]+=1);/* harmony default export */ __webpack_exports__["default"] = (He);
//# sourceMappingURL=styled-components.browser.esm.js.map


/***/ }),

/***/ "./contents/blog lazy recursive ^\\.\\/.*$":
/*!*******************************************************!*\
  !*** ./contents/blog/ lazy ^\.\/.*$ namespace object ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md": "./contents/blog/aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md",
	"./ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md": "./contents/blog/ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md",
	"./etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md": "./contents/blog/etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md",
	"./etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md": "./contents/blog/etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md",
	"./frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md": "./contents/blog/frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md",
	"./frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md": "./contents/blog/frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md",
	"./frontend/2021-01-01-WAS와 웹서버.md": "./contents/blog/frontend/2021-01-01-WAS와 웹서버.md",
	"./frontend/2022-02-22-요것이웹팩이다.md": "./contents/blog/frontend/2022-02-22-요것이웹팩이다.md",
	"./frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md": "./contents/blog/frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md",
	"./frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md": "./contents/blog/frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md",
	"./jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md": "./contents/blog/jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md",
	"./jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md": "./contents/blog/jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md",
	"./jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md": "./contents/blog/jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md",
	"./jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md": "./contents/blog/jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md",
	"./language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md": "./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md",
	"./language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md": "./contents/blog/language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md",
	"./language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md": "./contents/blog/language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md",
	"./language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md": "./contents/blog/language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md",
	"./language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md": "./contents/blog/language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md",
	"./language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md": "./contents/blog/language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md",
	"./language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md": "./contents/blog/language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md",
	"./language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md": "./contents/blog/language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md",
	"./language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md": "./contents/blog/language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md",
	"./language/javascript/2022-04-07-javascript-정수만-입력받기.md": "./contents/blog/language/javascript/2022-04-07-javascript-정수만-입력받기.md",
	"./language/typescript/2021-04-14-Typescript-시작하기.md": "./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md",
	"./language/typescript/2021-04-27-Typescript-실습퀴즈.md": "./contents/blog/language/typescript/2021-04-27-Typescript-실습퀴즈.md",
	"./react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md": "./contents/blog/react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md",
	"./react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md": "./contents/blog/react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md",
	"./react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md": "./contents/blog/react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md",
	"./react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md": "./contents/blog/react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md",
	"./react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md": "./contents/blog/react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md",
	"./testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md": "./contents/blog/testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md",
	"./vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md": "./contents/blog/vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md",
	"./vuejs/2021-03-12-Vuex를 알아보자.md": "./contents/blog/vuejs/2021-03-12-Vuex를 알아보자.md",
	"./면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md": "./contents/blog/면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md",
	"./번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md": "./contents/blog/번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md",
	"./번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md": "./contents/blog/번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md",
	"./번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md": "./contents/blog/번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md",
	"./요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md": "./contents/blog/요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md",
	"./요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md": "./contents/blog/요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md"
};

function webpackAsyncContext(req) {
	return Promise.resolve().then(function() {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}

		var id = map[req];
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = function() { return Object.keys(map); };
webpackAsyncContext.id = "./contents/blog lazy recursive ^\\.\\/.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./contents/blog sync recursive ^\\.\\/.*$":
/*!**************************************!*\
  !*** ./contents/blog/ sync ^\.\/.*$ ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md": "./contents/blog/aws/2021-05-28-AWS-EC2-한국어-도메인-연결하기.md",
	"./ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md": "./contents/blog/ci-cd/2021-09-02-CI-CD-기초개념에-대해-알아보자.md",
	"./etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md": "./contents/blog/etc/2021-08-07-윈도우-가상-데스크톱-듀얼모니터-활용-극대화-하는법.md",
	"./etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md": "./contents/blog/etc/2021-08-18-구글-애널리틱스로-jekyll로-만든-내-블로그-방문자-행동패턴-파악하는-방법.md",
	"./frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md": "./contents/blog/frontend/2020-12-16-개발자를 괴롭히지만 없어서는 안되는 CORS.md",
	"./frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md": "./contents/blog/frontend/2020-12-16-우리가 항상 쓰는 HTTP 프로토콜이 뭘까.md",
	"./frontend/2021-01-01-WAS와 웹서버.md": "./contents/blog/frontend/2021-01-01-WAS와 웹서버.md",
	"./frontend/2022-02-22-요것이웹팩이다.md": "./contents/blog/frontend/2022-02-22-요것이웹팩이다.md",
	"./frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md": "./contents/blog/frontend/2022-10-12-자바스크립트-ASSETS관리-라이브러리-추천.md",
	"./frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md": "./contents/blog/frontend/2022-10-14-FEconf-2022-Rescript같이해요-정미량.md",
	"./jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md": "./contents/blog/jekyll/2020-12-17-jekyll-Blog-만드는게-글쓰는-것보다-힘든-사람들에게.md",
	"./jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md": "./contents/blog/jekyll/2020-12-17-jekyll-Blog에-포스팅-하는법-이미지넣기.md",
	"./jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md": "./contents/blog/jekyll/2020-12-17-jekyll-Next-테마-자세히-알아보기.md",
	"./jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md": "./contents/blog/jekyll/2021-01-05-Jekyll-블로그-조회수-뱃지-달기---HITS.md",
	"./language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md": "./contents/blog/language/javascript/2021-03-31-Javascript-자주쓰는-내장-함수-복습하기.md",
	"./language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md": "./contents/blog/language/javascript/2021-08-03-ES2021-최신자바스크립트-새롭게추가된-기능.md",
	"./language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md": "./contents/blog/language/javascript/2021-08-04-자바스크립트-프로처럼-쓰기.md",
	"./language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md": "./contents/blog/language/javascript/2021-08-09-자바스크립트-var-let-const-진짜-차이점-구별하기.md",
	"./language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md": "./contents/blog/language/javascript/2021-08-17-자바스크립트-async-await-초스피드-핵심체크.md",
	"./language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md": "./contents/blog/language/javascript/2021-08-26-자바스크립트-완전히-새로운함수-제너레이터를-알아보자.md",
	"./language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md": "./contents/blog/language/javascript/2021-08-30-자바스크립트-iterable과-iterator에-대해-알아보자.md",
	"./language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md": "./contents/blog/language/javascript/2021-09-16-javascript-즉시실행함수-일단-알아보자.md",
	"./language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md": "./contents/blog/language/javascript/2022-03-24-nodejs버전10x-14x로-올리기.md",
	"./language/javascript/2022-04-07-javascript-정수만-입력받기.md": "./contents/blog/language/javascript/2022-04-07-javascript-정수만-입력받기.md",
	"./language/typescript/2021-04-14-Typescript-시작하기.md": "./contents/blog/language/typescript/2021-04-14-Typescript-시작하기.md",
	"./language/typescript/2021-04-27-Typescript-실습퀴즈.md": "./contents/blog/language/typescript/2021-04-27-Typescript-실습퀴즈.md",
	"./react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md": "./contents/blog/react/2021-04-28-실전-리액트-프로그래밍-section1.-리액트-프로젝트-시작하기.md",
	"./react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md": "./contents/blog/react/2021-05-04-리액트-디자인-패턴-1.-Container+Presenter.md",
	"./react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md": "./contents/blog/react/2022-03-23-react-rewired-사용해서-eject없이-CRA에babel설정-추가하기.md",
	"./react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md": "./contents/blog/react/2022-04-01-cra없이-리액트-프로젝트-설정하기.md",
	"./react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md": "./contents/blog/react/2022-10-07-리액트-콘솔창-에러-그대로-놔두고-계신가요.md",
	"./testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md": "./contents/blog/testing/2022-07-08-Jest로-리액트에서-유닛-테스트하기.md",
	"./vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md": "./contents/blog/vuejs/2021-02-09-Vuejs에서 AWS Lambda와 SES를 사용해서 메일 보내기.md",
	"./vuejs/2021-03-12-Vuex를 알아보자.md": "./contents/blog/vuejs/2021-03-12-Vuex를 알아보자.md",
	"./면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md": "./contents/blog/면접/2021-06-02-2021-프론트엔드-개발자-직접-받은-기술-면접-질문-리스트.md",
	"./번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md": "./contents/blog/번역/2021-01-10-45년동안-개발자로-일하며-배운것들.md",
	"./번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md": "./contents/blog/번역/2021-08-14-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_1편.md",
	"./번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md": "./contents/blog/번역/2021-08-22-처음부터-끝까지-상세히-알아보자- HTTP3에-대한-A-TO-Z_2편.md",
	"./요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md": "./contents/blog/요즘 느끼는 것들/2022-08-15-좋은개발자란-무엇일까.md",
	"./요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md": "./contents/blog/요즘 느끼는 것들/2022-08-28-요즘들어-개발자도-커뮤니케이션-능력이-중요하다고-느끼는-이유.md"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./contents/blog sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "?aa6d":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ // runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app.tsx!"), __webpack_exec__("./.yarn/__virtual__/next-virtual-77d0572bfd/0/cache/next-npm-11.0.1-c40bc7f380-c6b4747f1a.zip/node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvYW1wLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvYW1wLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL2hlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvc2lkZS1lZmZlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL19hcHAudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2FjY291bnQudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2NoZXZyb24vZG93bi50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvaWNvbnMvY2hldnJvbi9pbmRleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9jaGV2cm9uL2xlZnQudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2NoZXZyb24vcmlnaHQudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2NoZXZyb24vdXAudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2Nsb3NlLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9lbGxpcHNpcy50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvaWNvbnMvZXh0ZW5zaW9ucy50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hc3NldHMvaWNvbnMvZmlsZXMudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL2luZGV4LnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL3J1bi1uLWRlYnVnLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9zZWFyY2gudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL3NldHRpbmdzLWdlYXIudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvYXNzZXRzL2ljb25zL3NvdXJjZS1jb250cm9sLnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL2FjY29yZGlvbi1zZWN0aW9uL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL3Njcm9sbC1wYWdlbmF0aW9uL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY29tbW9uL3RhZy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2NvbW1vbi90aGVtZS1zd2l0Y2hlci9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb25zdGFudHMvcGFsZXR0ZS50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL2FwcC9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy90aGVtZS9jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvdGhlbWUvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy90aGVtZS9wcm92aWRlci50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL2d0YWcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9oZWxwZXJzL2luZGV4LnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvaGVscGVycy9tYXJrZG93bi5oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy9pbmRleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUNhbnZhc0NvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VEcmFnLnRzIiwid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlUmVzaXplRGV0ZWN0b3IudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2FjdGl2aXR5LWJhci9hY3Rpb24taXRlbS9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2FjdGl2aXR5LWJhci9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2V4cGxvcmVyLXNlY3Rpb24vZmlsZS10cmVlL2NsYXNzZXMvVHJlZUl0ZW0uY2xhc3MudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2V4cGxvcmVyLXNlY3Rpb24vZmlsZS10cmVlL2NsYXNzZXMvVHJlZVZpZXcuY2xhc3MudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2V4cGxvcmVyLXNlY3Rpb24vZmlsZS10cmVlL2NsYXNzZXMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2V4cGxvcmVyLXNlY3Rpb24vZmlsZS10cmVlL2ZpbGUtdHJlZS1pdGVtL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvYmxvZy1sYXlvdXQvZXhwbG9yZXItc2VjdGlvbi9maWxlLXRyZWUvaW5kZXgudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvbGF5b3V0cy9ibG9nLWxheW91dC9leHBsb3Jlci1zZWN0aW9uL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvYmxvZy1sYXlvdXQvZXhwbG9yZXItc2VjdGlvbi9vcGVuLXBvc3QtbGlzdC9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2V4cGxvcmVyLXNlY3Rpb24vb3Blbi1wb3N0LWxpc3Qvb3Blbi1wb3N0LWxpc3QtaXRlbS9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvYmxvZy1sYXlvdXQvbG9nLXNlY3Rpb24vaW5kZXgudHN4Iiwid2VicGFjazovL19OX0UvLi9zcmMvbGF5b3V0cy9ibG9nLWxheW91dC9sb2ctc2VjdGlvbi9sb2ctaXRlbS50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L3NlYXJjaC1zZWN0aW9uL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvYmxvZy1sYXlvdXQvc2VhcmNoLXNlY3Rpb24vdGFncy9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9sYXlvdXRzL2Jsb2ctbGF5b3V0L3NpZGUtYmFyL2luZGV4LnRzeCIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xheW91dHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9wb3N0LnNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvdGhlbWUudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy90aGVtZXMvZGFyay50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3RoZW1lcy9pbmRleC50cyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3RoZW1lcy9saWdodC50cyIsIndlYnBhY2s6Ly9fTl9FLyIsIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0eWxlcy9nbG9iYWwuY3NzP2Y2YjMiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvcG9zdC5jc3M/NmNmMiIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzIiwid2VicGFjazovL19OX0UvLi9zcmMvc3R5bGVzL2dsb2JhbC5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvcG9zdC5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2F3cy8yMDIxLTA1LTI4LUFXUy1FQzIt7ZWc6rWt7Ja0LeuPhOuplOyduC3sl7DqsrDtlZjquLAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvY2ktY2QvMjAyMS0wOS0wMi1DSS1DRC3quLDstIjqsJzrhZDsl5At64yA7ZW0LeyVjOyVhOuztOyekC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9ldGMvMjAyMS0wOC0wNy3snIjrj4TsmrAt6rCA7IOBLeuNsOyKpO2BrO2GsS3rk4Dslrzrqqjri4jthLAt7Zmc7JqpLeq3ueuMgO2ZlC3tlZjripTrspUubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvZXRjLzIwMjEtMDgtMTgt6rWs6riALeyVoOuEkOumrO2LseyKpOuhnC1qZWt5bGzroZwt66eM65OgLeuCtC3ruJTroZzqt7gt67Cp66y47J6QLe2WieuPme2MqO2EtC3tjIzslYXtlZjripQt67Cp67KVLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjAtMTItMTYt6rCc67Cc7J6Q66W8IOq0tOuhre2eiOyngOunjCDsl4bslrTshJzripQg7JWI65CY64qUIENPUlMubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMC0xMi0xNi3smrDrpqzqsIAg7ZWt7IOBIOyTsOuKlCBIVFRQIO2UhOuhnO2GoOy9nOydtCDrrZjquYwubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMS0wMS0wMS1XQVPsmYAg7Ju57ISc67KELm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjItMDItMjIt7JqU6rKD7J207Ju57Yyp7J2064ukLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjItMTAtMTIt7J6Q67CU7Iqk7YGs66a97Yq4LUFTU0VUU+q0gOumrC3rnbzsnbTruIzrn6zrpqwt7LaU7LKcLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjItMTAtMTQtRkVjb25mLTIwMjItUmVzY3JpcHTqsJnsnbTtlbTsmpQt7KCV66+465+JLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1CbG9nLeunjOuTnOuKlOqyjC3quIDsk7DripQt6rKD67O064ukLe2emOuToC3sgqzrnozrk6Tsl5DqsowubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2fsl5At7Y+s7Iqk7YyFLe2VmOuKlOuylS3snbTrr7jsp4DrhKPquLAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLU5leHQt7YWM66eILeyekOyEuO2eiC3slYzslYTrs7TquLAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjEtMDEtMDUtSmVreWxsLeu4lOuhnOq3uC3sobDtmozsiJgt67GD7KeALeuLrOq4sC0tLUhJVFMubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTAzLTMxLUphdmFzY3JpcHQt7J6Q7KO87JOw64qULeuCtOyepS3tlajsiJgt67O17Iq17ZWY6riwLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wOC0wMy1FUzIwMjEt7LWc7Iug7J6Q67CU7Iqk7YGs66a97Yq4LeyDiOuhreqyjOy2lOqwgOuQnC3quLDriqUubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTA0LeyekOuwlOyKpO2BrOumve2KuC3tlITroZzsspjrn7wt7JOw6riwLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wOC0wOS3snpDrsJTsiqTtgazrpr3tirgtdmFyLWxldC1jb25zdC3sp4Tsp5wt7LCo7J207KCQLeq1rOuzhO2VmOq4sC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMTct7J6Q67CU7Iqk7YGs66a97Yq4LWFzeW5jLWF3YWl0Ley0iOyKpO2UvOuTnC3tlbXsi6zssrTtgawubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTI2LeyekOuwlOyKpO2BrOumve2KuC3smYTsoITtnogt7IOI66Gc7Jq07ZWo7IiYLeygnOuEiOugiOydtO2EsOulvC3slYzslYTrs7TsnpAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTMwLeyekOuwlOyKpO2BrOumve2KuC1pdGVyYWJsZeqzvC1pdGVyYXRvcuyXkC3rjIDtlbQt7JWM7JWE67O07J6QLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wOS0xNi1qYXZhc2NyaXB0LeymieyLnOyLpO2Wie2VqOyImC3snbzri6gt7JWM7JWE67O07J6QLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMi0wMy0yNC1ub2RlanPrsoTsoIQxMHgtMTR466GcLeyYrOumrOq4sC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjItMDQtMDctamF2YXNjcmlwdC3soJXsiJjrp4wt7J6F66Cl67Cb6riwLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL3R5cGVzY3JpcHQvMjAyMS0wNC0xNC1UeXBlc2NyaXB0LeyLnOyeke2VmOq4sC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy9sYW5ndWFnZS90eXBlc2NyaXB0LzIwMjEtMDQtMjctVHlwZXNjcmlwdC3si6TsirXtgLTspogubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvcmVhY3QvMjAyMS0wNC0yOC3si6TsoIQt66as7JWh7Yq4Le2UhOuhnOq3uOuemOuwjS1zZWN0aW9uMS4t66as7JWh7Yq4Le2UhOuhnOygne2KuC3si5zsnpHtlZjquLAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvcmVhY3QvMjAyMS0wNS0wNC3rpqzslaHtirgt65SU7J6Q7J24Le2MqO2EtC0xLi1Db250YWluZXIrUHJlc2VudGVyLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL3JlYWN0LzIwMjItMDMtMjMtcmVhY3QtcmV3aXJlZC3sgqzsmqntlbTshJwtZWplY3Tsl4bsnbQtQ1JB7JeQYmFiZWzshKTsoJUt7LaU6rCA7ZWY6riwLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL3JlYWN0LzIwMjItMDQtMDEtY3Jh7JeG7J20LeumrOyVoe2KuC3tlITroZzsoJ3tirgt7ISk7KCV7ZWY6riwLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL3JlYWN0LzIwMjItMTAtMDct66as7JWh7Yq4Ley9mOyGlOywvS3sl5Drn6wt6re464yA66GcLeuGlOuRkOqzoC3qs4Tsi6DqsIDsmpQubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvdGVzdGluZy8yMDIyLTA3LTA4LUplc3TroZwt66as7JWh7Yq47JeQ7IScLeycoOuLmy3thYzsiqTtirjtlZjquLAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cvdnVlanMvMjAyMS0wMi0wOS1WdWVqc+yXkOyEnCBBV1MgTGFtYmRh7JmAIFNFU+ulvCDsgqzsmqntlbTshJwg66mU7J28IOuztOuCtOq4sC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy92dWVqcy8yMDIxLTAzLTEyLVZ1ZXjrpbwg7JWM7JWE67O07J6QLm1kIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nL+uptOygkS8yMDIxLTA2LTAyLTIwMjEt7ZSE66Gg7Yq47JeU65OcLeqwnOuwnOyekC3sp4HsoJEt67Cb7J2ALeq4sOyIoC3rqbTsoJEt7KeI66y4LeumrOyKpO2KuC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy/rsojsl60vMjAyMS0wMS0xMC00NeuFhOuPmeyViC3qsJzrsJzsnpDroZwt7J287ZWY66mwLeuwsOyatOqyg+uTpC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy/rsojsl60vMjAyMS0wOC0xNC3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMe2OuC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy/rsojsl60vMjAyMS0wOC0yMi3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMu2OuC5tZCIsIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudHMvYmxvZy/smpTsppgg64qQ64G864qUIOqyg+uTpC8yMDIyLTA4LTE1Leyii+ydgOqwnOuwnOyekOuegC3rrLTsl4fsnbzquYwubWQiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2cv7JqU7KaYIOuKkOuBvOuKlCDqsoPrk6QvMjAyMi0wOC0yOC3smpTsppjrk6TslrQt6rCc67Cc7J6Q64+ELey7pOuupOuLiOy8gOydtOyFmC3riqXroKXsnbQt7KSR7JqU7ZWY64uk6rOgLeuKkOuBvOuKlC3snbTsnKAubWQiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AYmFiZWwtcnVudGltZS1ucG0tNy4xMi41LWIzZWRiOGVlOGUtNjQ5NjRhMGZkMS56aXAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGJhYmVsLXJ1bnRpbWUtbnBtLTcuMTIuNS1iM2VkYjhlZThlLTY0OTY0YTBmZDEuemlwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BiYWJlbC1ydW50aW1lLW5wbS03LjEyLjUtYjNlZGI4ZWU4ZS02NDk2NGEwZmQxLnppcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BlbW90aW9uLWlzLXByb3AtdmFsaWQtbnBtLTEuMi4wLTMzMmQzNDNlM2QtY2M3YTE5ODUwYS56aXAvbm9kZV9tb2R1bGVzL0BlbW90aW9uL2lzLXByb3AtdmFsaWQvZGlzdC9lbW90aW9uLWlzLXByb3AtdmFsaWQuZXNtLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9AZW1vdGlvbi1tZW1vaXplLW5wbS0wLjguMC1jNWRkNDUxODI4LWM4N2JiMTEwYjguemlwL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9tZW1vaXplL2Rpc3QvZW1vdGlvbi1tZW1vaXplLmVzbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvQGVtb3Rpb24tc3R5bGlzLW5wbS0wLjguNS0zZTlkYjg5NTlmLTY3ZmY1OTU4NDQuemlwL25vZGVfbW9kdWxlcy9AZW1vdGlvbi9zdHlsaXMvZGlzdC9zdHlsaXMuYnJvd3Nlci5lc20uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL0BlbW90aW9uLXVuaXRsZXNzLW5wbS0wLjcuNS0xNGUxMTcxNjQwLWY5NzZlNTM0NWIuemlwL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L3VuaXRsZXNzLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9iYXNlNjQtanMtbnBtLTEuNS4xLWIyZjcyNzU2NDEtNjY5NjMyZWIzNy56aXAvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvYnVmZmVyLW5wbS01LjYuMC1lMTQ5NDY5M2JmLWQ2NTk0OTRjNTAuemlwL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2VzcHJpbWEtbnBtLTQuMC4xLTEwODRlOTg3NzgtYjQ1YmM4MDVhNi56aXAvbm9kZV9tb2R1bGVzL2VzcHJpbWEvZGlzdC9lc3ByaW1hLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9leHRlbmQtc2hhbGxvdy1ucG0tMi4wLjEtZTZlZjUyYjI5Yy04ZmI1OGQ5ZDdhLnppcC9ub2RlX21vZHVsZXMvZXh0ZW5kLXNoYWxsb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2dyYXktbWF0dGVyLW5wbS00LjAuMy04NTJhZTRmMzRjLTM3NzE3YmQ0MjQuemlwL25vZGVfbW9kdWxlcy9ncmF5LW1hdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvZ3JheS1tYXR0ZXItbnBtLTQuMC4zLTg1MmFlNGYzNGMtMzc3MTdiZDQyNC56aXAvbm9kZV9tb2R1bGVzL2dyYXktbWF0dGVyL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvZ3JheS1tYXR0ZXItbnBtLTQuMC4zLTg1MmFlNGYzNGMtMzc3MTdiZDQyNC56aXAvbm9kZV9tb2R1bGVzL2dyYXktbWF0dGVyL2xpYi9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2dyYXktbWF0dGVyLW5wbS00LjAuMy04NTJhZTRmMzRjLTM3NzE3YmQ0MjQuemlwL25vZGVfbW9kdWxlcy9ncmF5LW1hdHRlci9saWIvZW5naW5lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvZ3JheS1tYXR0ZXItbnBtLTQuMC4zLTg1MmFlNGYzNGMtMzc3MTdiZDQyNC56aXAvbm9kZV9tb2R1bGVzL2dyYXktbWF0dGVyL2xpYi9leGNlcnB0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9ncmF5LW1hdHRlci1ucG0tNC4wLjMtODUyYWU0ZjM0Yy0zNzcxN2JkNDI0LnppcC9ub2RlX21vZHVsZXMvZ3JheS1tYXR0ZXIvbGliL3BhcnNlLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9ncmF5LW1hdHRlci1ucG0tNC4wLjMtODUyYWU0ZjM0Yy0zNzcxN2JkNDI0LnppcC9ub2RlX21vZHVsZXMvZ3JheS1tYXR0ZXIvbGliL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvZ3JheS1tYXR0ZXItbnBtLTQuMC4zLTg1MmFlNGYzNGMtMzc3MTdiZDQyNC56aXAvbm9kZV9tb2R1bGVzL2dyYXktbWF0dGVyL2xpYi90by1maWxlLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9ncmF5LW1hdHRlci1ucG0tNC4wLjMtODUyYWU0ZjM0Yy0zNzcxN2JkNDI0LnppcC9ub2RlX21vZHVsZXMvZ3JheS1tYXR0ZXIvbGliL3V0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy1ucG0tMy4zLjItZTdiNzA5ZTZjMS1iMTUzODI3MDQyLnppcC9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2llZWU3NTQtbnBtLTEuMi4xLWZiNjNiM2NhZWItNTE0NGMwYzk4MS56aXAvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2lzLWV4dGVuZGFibGUtbnBtLTAuMS4xLTMyMmI0NjQ5ZWMtMzg3NTU3MWQyMC56aXAvbm9kZV9tb2R1bGVzL2lzLWV4dGVuZGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvY29tbW9uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9kdW1wZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL2V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvbG9hZGVyLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9tYXJrLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9jb3JlLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZGVmYXVsdF9zYWZlLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3NjaGVtYS9qc29uLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9ib29sLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL2ludC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvanMvdW5kZWZpbmVkLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL21hcC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9tZXJnZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9udWxsLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL29tYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvcGFpcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvc2VxLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9qcy15YW1sLW5wbS0zLjE0LjEtYjk2OGM2MDk1ZS1iZWYxNDYwODVmLnppcC9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvanMteWFtbC90eXBlL3NldC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvanMteWFtbC1ucG0tMy4xNC4xLWI5NjhjNjA5NWUtYmVmMTQ2MDg1Zi56aXAvbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL2pzLXlhbWwtbnBtLTMuMTQuMS1iOTY4YzYwOTVlLWJlZjE0NjA4NWYuemlwL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9raW5kLW9mLW5wbS02LjAuMy1hYjE1ZjM2MjIwLTNhYjAxZTdiMWQuemlwL25vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9tYXJrZWQtbnBtLTIuMC42LWQzNzVjMGRhODUtZjkwODhkMzNmOC56aXAvbm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9wcmlzbWpzLW5wbS0xLjI5LjAtNmZhYTViMDRiOC0wMDdhODg2OWQ0LnppcC9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWJhc2guanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3ByaXNtanMtbnBtLTEuMjkuMC02ZmFhNWIwNGI4LTAwN2E4ODY5ZDQuemlwL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9wcmlzbWpzLW5wbS0xLjI5LjAtNmZhYTViMDRiOC0wMDdhODg2OWQ0LnppcC9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWphdmFzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3ByaXNtanMtbnBtLTEuMjkuMC02ZmFhNWIwNGI4LTAwN2E4ODY5ZDQuemlwL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanNvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcHJpc21qcy1ucG0tMS4yOS4wLTZmYWE1YjA0YjgtMDA3YTg4NjlkNC56aXAvbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qc3guanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3ByaXNtanMtbnBtLTEuMjkuMC02ZmFhNWIwNGI4LTAwN2E4ODY5ZDQuemlwL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwLXRlbXBsYXRpbmcuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3ByaXNtanMtbnBtLTEuMjkuMC02ZmFhNWIwNGI4LTAwN2E4ODY5ZDQuemlwL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHN4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9wcmlzbWpzLW5wbS0xLjI5LjAtNmZhYTViMDRiOC0wMDdhODg2OWQ0LnppcC9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3ByaXNtanMtbnBtLTEuMjkuMC02ZmFhNWIwNGI4LTAwN2E4ODY5ZDQuemlwL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20teWFtbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vY2FjaGUvcHJpc21qcy1ucG0tMS4yOS4wLTZmYWE1YjA0YjgtMDA3YTg4NjlkNC56aXAvbm9kZV9tb2R1bGVzL3ByaXNtanMvcHJpc20uanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3Byb2Nlc3MtbnBtLTAuMTEuMTAtYWViM2I2NDFhZS1iZmNjZTQ5ODE0LnppcC9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9yZWFjdC1pcy1ucG0tMTYuMTMuMS1hOWI5MzgyYjRmLWY3YTE5YWMzNDkuemlwL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3JlYWN0LWlzLW5wbS0xNi4xMy4xLWE5YjkzODJiNGYtZjdhMTlhYzM0OS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9yZWFjdC1ucG0tMTcuMC4yLTk5YmEzN2Q5MzEtYjI1NGNjMTdjZS56aXAvbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3JlYWN0LW5wbS0xNy4wLjItOTliYTM3ZDkzMS1iMjU0Y2MxN2NlLnppcC9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9zZWN0aW9uLW1hdHRlci1ucG0tMS4wLjAtMmY3OWZkNTlkNi0zY2M0MTMxNzA1LnppcC9ub2RlX21vZHVsZXMvc2VjdGlvbi1tYXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL2NhY2hlL3NoYWxsb3dlcXVhbC1ucG0tMS4xLjAtNjY4OGQ0MTljYi1mNGMxZGUwODM3LnppcC9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi9jYWNoZS9zdHJpcC1ib20tc3RyaW5nLW5wbS0xLjAuMC1hYTZjYjU0OGQxLTU2MzVhMzY1NmQuemlwL25vZGVfbW9kdWxlcy9zdHJpcC1ib20tc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi8ueWFybi91bnBsdWdnZWQvc3R5bGVkLWNvbXBvbmVudHMtdmlydHVhbC00MTE4Njk1MDYzL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmJyb3dzZXIuZXNtLmpzIiwid2VicGFjazovL19OX0UvLi9jb250ZW50cy9ibG9nfGxhenl8L14vLiokL3xncm91cE9wdGlvbnM6IHt9fG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRlbnRzL2Jsb2d8c3luY3wvXi8uKiQiLCJ3ZWJwYWNrOi8vX05fRS9pZ25vcmVkfEM6XFxVc2Vyc1xcc3VuZ2tvb2tcXERvY3VtZW50c1xcZGV2XFx2c2NvZGUtdGhlbWVcXC55YXJuXFxjYWNoZVxcZ3JheS1tYXR0ZXItbnBtLTQuMC4zLTg1MmFlNGYzNGMtMzc3MTdiZDQyNC56aXBcXG5vZGVfbW9kdWxlc1xcZ3JheS1tYXR0ZXJ8ZnMiXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiZXhwb3J0cyIsIl9yZWFjdCIsIl9yb3V0ZXIiLCJfcm91dGVyMiIsIl91c2VJbnRlcnNlY3Rpb24iLCJwcmVmZXRjaGVkIiwicHJlZmV0Y2giLCJyb3V0ZXIiLCJocmVmIiwiYXMiLCJvcHRpb25zIiwiaXNMb2NhbFVSTCIsImVyciIsImN1ckxvY2FsZSIsImxvY2FsZSIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwiaW5kZXhPZiIsIkxpbmsiLCJwcm9wcyIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiXyIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsInBhc3NIcmVmIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJwIiwidXNlUm91dGVyIiwidXNlTWVtbyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImNoaWxkcmVuIiwiY3JlYXRlRWxlbWVudCIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwiY2hpbGRSZWYiLCJyZWYiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290TWFyZ2luIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVzZUVmZmVjdCIsInNob3VsZFByZWZldGNoIiwiaXNQcmVmZXRjaGVkIiwiY2hpbGRQcm9wcyIsIm9uQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwib25Nb3VzZUVudGVyIiwicHJpb3JpdHkiLCJ0eXBlIiwibG9jYWxlRG9tYWluIiwiaXNMb2NhbGVEb21haW4iLCJnZXREb21haW5Mb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImNsb25lRWxlbWVudCIsIl9kZWZhdWx0IiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidW5vYnNlcnZlIiwidXNlU3RhdGUiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJvYnNlcnZlIiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImVsZW1lbnQiLCJjYWxsYmFjayIsImNyZWF0ZU9ic2VydmVyIiwiaWQiLCJvYnNlcnZlciIsImVsZW1lbnRzIiwic2V0Iiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJvYnNlcnZlcnMiLCJNYXAiLCJpbnN0YW5jZSIsImdldCIsImVudHJpZXMiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsIkFtcFN0YXRlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImlzSW5BbXBNb2RlIiwidXNlQW1wIiwiX2FtcENvbnRleHQiLCJhbXBGaXJzdCIsImh5YnJpZCIsImhhc1F1ZXJ5IiwidXNlQ29udGV4dCIsImRlZmF1bHRIZWFkIiwiX3NpZGVFZmZlY3QiLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX2FtcCIsIl9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSIsIldlYWtNYXAiLCJjYWNoZSIsImhhcyIsIm5ld09iaiIsImhhc1Byb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVzYyIsImluQW1wTW9kZSIsImhlYWQiLCJjaGFyU2V0IiwicHVzaCIsIm5hbWUiLCJjb250ZW50Iiwib25seVJlYWN0RWxlbWVudCIsImxpc3QiLCJGcmFnbWVudCIsImNvbmNhdCIsInRvQXJyYXkiLCJyZWR1Y2UiLCJmcmFnbWVudExpc3QiLCJmcmFnbWVudENoaWxkIiwiTUVUQVRZUEVTIiwidW5pcXVlIiwiU2V0IiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwic2xpY2UiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJyZWR1Y2VDb21wb25lbnRzIiwiaGVhZEVsZW1lbnRzIiwiaGVhZEVsZW1lbnQiLCJoZWFkRWxlbWVudENoaWxkcmVuIiwicmV2ZXJzZSIsImZpbHRlciIsIm1hcCIsImMiLCJIZWFkIiwiYW1wU3RhdGUiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNTZXJ2ZXIiLCJfaGFzSGVhZE1hbmFnZXIiLCJlbWl0Q2hhbmdlIiwidXBkYXRlSGVhZCIsIm1vdW50ZWRJbnN0YW5jZXMiLCJDb21wb25lbnQiLCJNeUFwcCIsInBhZ2VQcm9wcyIsInBvc3RzIiwiaGFuZGxlUm91dGVDaGFuZ2UiLCJ1cmwiLCJ0aXRsZSIsIndpbmRvdyIsImRvY3VtZW50IiwibG9jYXRpb24iLCJndGFnIiwiZXZlbnRzIiwib24iLCJvZmYiLCJnZXRJbml0aWFsUHJvcHMiLCJQb3N0U2VydmljZSIsIkFjY291bnRJY29uIiwic3R5bGUiLCJmaWxsIiwidXNlVGhlbWUiLCJjb2xvcnMiLCJ3aWR0aCIsImhlaWdodCIsInNjaGVtZSIsIiR3aGl0ZSIsIlJlYWN0IiwiQ2hldnJvbkRvd25JY29uIiwiQ2hldnJvbkxlZnRJY29uIiwiQ2hldnJvblVwSWNvbiIsIkNsb3NlSWNvbiIsImNsYXNzTmFtZSIsIkVsbGlwc2lzSWNvbiIsIkV4dGVuc2lvbnNJY29uIiwiRmlsZXNJY29uIiwiUnVuQW5kRGVidWdJY29uIiwiU2VhcmNoSWNvbiIsIlNldHRpbmdzR2Vhckljb24iLCJTb3VyY2VDb250cm9sSWNvbiIsIkFjY29yZGlvblNlY3Rpb24iLCJkZWZhdWx0RXhwYW5kZWQiLCJoYXNMaW5lIiwibWF4SGVpZ2h0IiwiaXNFeHBhbmRlZCIsInNldElzRXhwYW5kZWQiLCJoYW5kbGVIZWFkZXJDbGljayIsIkNoZXZyb25JY29uIiwiQ2hldnJvblJpZ2h0SWNvbiIsIkhlYWRlciIsInN0eWxlZCIsIlRpdGxlIiwiaGlkZVNjcm9sbGJhciIsImNzcyIsIkNvbnRlbnQiLCJERUZBVUxUX1BBR0VfU0laRSIsIlNjcm9sbFBhZ2VuYXRpb24iLCJpbml0aWFsRGF0YSIsImRhdGEiLCJwYWdlU2l6ZSIsInJlbmRlckl0ZW0iLCJ3cmFwcGVyUmVmIiwic2V0RGF0YSIsImhhc01vcmUiLCJzZXRIYXNNb3JlIiwiaGFuZGxlU2Nyb2xsIiwic2Nyb2xsVG9wIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsQm90dG9tIiwibG9hZE1vcmUiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0TmV4dERhdGEiLCJvZmZzZXQiLCJsaW1pdCIsInByZXZEYXRhIiwibmV4dERhdGEiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXRlbSIsIldyYXBwZXIiLCJNb3JlIiwiVGFnIiwiY291bnQiLCJjbGlja2FibGUiLCJ0YWdEZWZhdWx0IiwidGhlbWUiLCIkdGFnRm9udENvbG9yIiwiJGdyYXkzMDAiLCIkZ3JheTQwMCIsIkNvdW50IiwiJGdyYXkxMDAiLCJUaGVtZVN3aXRjaGVyIiwidXNlVGhlbWVDb250ZXh0Iiwic3RhdGUiLCJ0b2dnbGVUaGVtZSIsImFjdGlvbiIsImhhbmRsZUNsaWNrIiwiaGFuZGxlS2V5RG93biIsImluY2x1ZGVzIiwiQkxBQ0siLCJXSElURSIsIkNpcmNsZSIsIm1vZGUiLCJEUkFDVUxBUl9CQUNLR1JPVU5EX0xJR0hUX0RBUksiLCJEUkFDVUxBUl9CQUNLR1JPVU5EX0RFRVBfREFSSyIsIllFTExPVyIsIkJMVUUiLCJQSU5LIiwiT1JBTkdFIiwiR1JFRU4iLCJQVVJQTEUiLCJQVVJQTEVfREFSSyIsIkdSQVlfMTAwIiwiR1JBWV8yMDAiLCJHUkFZXzMwMCIsIkdSQVlfNDAwIiwiR1JBWV81MDAiLCJHUkFZXzYwMCIsIkxJR0hUX0dSQVlfMTAwIiwiTElHSFRfR1JBWV8yMDAiLCJMSUdIVF9HUkFZXzMwMCIsIkxJR0hUX0dSQVlfNDAwIiwiQXBwQ29udGV4dCIsInVzZUFwcENvbnRleHQiLCJBcHBDb250ZXh0UHJvdmlkZXIiLCJvcGVuUG9zdHMiLCJzZXRPcGVuUG9zdHMiLCJjdXJyZW50UG9zdElkIiwic2V0Q3VycmVudFBvc3RJZCIsInNlbGVjdFBvc3QiLCJmaW5kIiwicG9zdCIsInRhcmdldFBvc3QiLCJjbG9zZVBvc3QiLCJuZXdPcGVuUG9zdHMiLCJhcHBTdG9yZSIsIlRoZW1lQ29udGV4dCIsIlRoZW1lQ29udGV4dFByb3ZpZGVyIiwiZGVmYXVsdFRoZW1lIiwic2V0VGhlbWUiLCJ0aGVtZVN0b3JlIiwibGlnaHQiLCJkYXJrIiwiR0FfVFJBQ0tJTkdfSUQiLCJwcm9jZXNzIiwiZW52IiwiR0FfTUVBU1VSRU1FTlRfSUQiLCJwYWdldmlldyIsImxhYmVsIiwidmFsdWUiLCJtYXJrZWQiLCJoaWdobGlnaHQiLCJjb2RlIiwibGFuZyIsInByaXNtIiwicGFyc2VNYXJrZG93biIsInRleHQiLCJ1c2VDYW52YXNDb250ZXh0IiwiY2FudmFzUmVmIiwiY29udGV4dCIsInNldENvbnRleHQiLCJjdHgiLCJnZXRDb250ZXh0IiwidXNlRHJhZyIsIm9uRHJhZyIsImlzRHJhZ2dpbmciLCJzZXRJc0RyYWdnaW5nIiwieCIsInkiLCJzdGFydCIsInNldFN0YXJ0IiwiaGFuZGxlTW91c2VNb3ZlIiwiY2xpZW50WCIsImNsaWVudFkiLCJoYW5kbGVNb3VzZVVwIiwic3RhcnREcmFnIiwidXNlUmVzaXplRGV0ZWN0b3IiLCJzZXRTaXplIiwiY29udGVudFJlY3QiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiQWN0aW9uSXRlbSIsIkljb24iLCJpc1NlbGVjdGVkIiwib25LZXlEb3duIiwiaGVpZ3RoIiwiR0lUSFVCX1VSTCIsIkFDVElWSVRZX0JBUl9XSURUSCIsIkFDVElPTl9JVEVNUyIsIkFjdGl2aXR5QmFyIiwiY3VycmVudEFjdGlvbkl0ZW0iLCJvbkN1cnJlbnRBY3Rpb25JdGVtQ2hhbmdlIiwiaXRlbXNSZWYiLCJoYW5kbGVJdGVtQ2xpY2siLCJpbmRleCIsInNldEZvY3VzVG9QcmV2aW91c0l0ZW0iLCJwcmV2SXRlbUlkeCIsImZvY3VzIiwic2V0Rm9jdXNUb05leHRJdGVtIiwibmV4dEl0ZW5JZHgiLCJoYW5kbGVJdGVtS2V5RG93biIsIm9wZW5HaXRodWJMaW5rIiwib3BlbiIsIlVsIiwiVHJlZUl0ZW0iLCJfcGF0aCIsIl9kYXRhIiwiX25hbWUiLCJzcGxpdCIsIkZpbGUiLCJGb2xkZXIiLCJ0cmVlSXRlbSIsIl9jaGlsZHJlbiIsInBhdGgiLCJ2IiwiaXNGb2xkZXIiLCJUcmVlVmlldyIsIm1hcEZpbGVQYXRoIiwiY3JlYXRlVHJlZSIsImFkZEZpbGUiLCJwYXRocyIsInNwbGl0UGF0aCIsImxlYWZGb2xkZXJQYXRoIiwiam9pbiIsImFjY2Vzc1RvRm9sZGVyIiwicm9vdCIsImN1cnJlbnRSb290IiwiY3VycmVudFBhdGgiLCJjdXJyZW50Rm9sZXIiLCJGaWxlVHJlZUl0ZW0iLCJ0b2dnbGVFeHBhbmQiLCJMaSIsImlzRmlsZSIsIiRncmF5MjAwIiwiRmlsZVRyZWUiLCJzb3J0Q2hpbGRyZW4iLCJzb3J0IiwiYSIsImIiLCJyZW5kZXJDaGlsZHJlbiIsIm1ldGEiLCJNQVhfVklTSUJMRV9JVEVNIiwiRXhwbG9yZXJTZWN0aW9uIiwiT1BFTl9QT1NUX0xJU1RfSVRFTV9IRUlHSFQiLCJPcGVuUG9zdExpc3QiLCJ3aGl0ZVNwYWNlIiwiT3BlblBvc3RMaXN0SXRlbSIsImVtb2ppIiwib25DbG9zZSIsInNob3dDbG9zZUJ1dHRvbiIsImlzSG92ZXJlZCIsInNldElzSG92ZXJlZCIsImlzQ2xvc2VWaXNpYmxlIiwiaGFuZGxlQ2xvc2VDbGljayIsInN0b3BQcm9wYWdhdGlvbiIsIm1pbldpZHRoIiwidmlzaWJpbGl0eSIsIkJsb2dMYXlvdXQiLCJzZXRDdXJyZW50QWN0aW9uSXRlbSIsInNpZGVCYXJSZWYiLCJoYW5kbGVBY3Rpdml0eUJhcktleURvd24iLCJzZW1hbnRpY1NjaGVtZSIsIm1haW5CZyIsIlJvdyIsIk1haW4iLCJGb290ZXIiLCJMb2dTZWN0aW9uIiwic29ydGVkUG9zdHMiLCJkYXRlIiwibG9jYWxlQ29tcGFyZSIsIml0ZW1FbGVtIiwiY2xvc2VzdCIsImRhdGFzZXQiLCJjdXJyIiwicHJldiIsIkxvZ0l0ZW0iLCJjdXJyUG9zdCIsInByZXZQb3N0IiwiY3VyckRhdGUiLCJEYXRlIiwicHJldkRhdGUiLCJzaG93WWVhciIsImdldEZ1bGxZZWFyIiwic2hvd01vbnRoIiwiZ2V0TW9udGgiLCJzaG93RGF0ZSIsImdldERhdGUiLCJnZXRNb250aFRleHQiLCJ0b0xvY2FsZVN0cmluZyIsIm1vbnRoIiwicmVuZGVyWWVhciIsIlllYXJXcmFwcGVyIiwiaXNGaXJzdCIsIlllYXIiLCJNb250aCIsIl9EYXRlIiwiUGluIiwiTGluZSIsIkRvdCIsIlNlYXJjaFNlY3Rpb24iLCJUYWdzU2VjdGlvbiIsImFjYyIsInRhZyIsIklOSVRJQUxfV0lEVEgiLCJNSU5fV0lEVEgiLCJTaWRlQmFyIiwiZm9yd2FyZFJlZiIsInNldFdpZHRoIiwibW92ZW1lbnQiLCJuZXh0V2lkdGgiLCJzaWRlQmFyQmciLCJicmVha3BvaW50cyIsIlRpdGxlV3JhcHBlciIsIl9DbG9zZUljb24iLCJhdHRycyIsIkNvbnRlbnRXcmFwcGVyIiwiRHJhZ2dhYmxlTGluZSIsImZpbHRlclBvc3RzIiwiZmlsdGVyZWRQb3N0cyIsImdldFBvc3RzIiwiUHJvbWlzZSIsImFsbCIsImdldFBvc3QiLCJtYXJrZG93biIsIm1hdHRlciIsImRlc2NyaXB0aW9uIiwiaHRtbCIsInNtYWxsIiwibWVkaXVtIiwibGFyZ2UiLCJmcmVlemUiLCIkZ3JheTUwMCIsIiRncmF5NjAwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7Ozs7OztBQUFBLElBQUlBLHVCQUF1QixHQUFDQyxtQkFBTyxDQUFDLHNMQUFELENBQW5DOztBQUFxRkMsa0JBQUEsR0FBbUIsSUFBbkI7QUFBd0JBLGVBQUEsR0FBZ0IsS0FBSyxDQUFyQjs7QUFBdUIsSUFBSUMsTUFBTSxHQUFDSCx1QkFBdUIsQ0FBQ0MsbUJBQU8sQ0FBQyxtR0FBRCxDQUFSLENBQWxDOztBQUFxRCxJQUFJRyxPQUFPLEdBQUNILG1CQUFPLENBQUMsK0xBQUQsQ0FBbkI7O0FBQXdELElBQUlJLFFBQVEsR0FBQ0osbUJBQU8sQ0FBQyx1SkFBRCxDQUFwQjs7QUFBaUMsSUFBSUssZ0JBQWdCLEdBQUNMLG1CQUFPLENBQUMsMktBQUQsQ0FBNUI7O0FBQW1ELElBQU1NLFVBQVUsR0FBQyxFQUFqQjs7QUFBb0IsU0FBU0MsUUFBVCxDQUFrQkMsTUFBbEIsRUFBeUJDLElBQXpCLEVBQThCQyxFQUE5QixFQUFpQ0MsT0FBakMsRUFBeUM7QUFBQyxNQUFHLFVBQTZCLENBQUNILE1BQWpDLEVBQXdDO0FBQU8sTUFBRyxDQUFDLENBQUMsR0FBRUwsT0FBTyxDQUFDUyxVQUFYLEVBQXVCSCxJQUF2QixDQUFKLEVBQWlDLE9BQWpGLENBQXdGO0FBQ3ZlO0FBQ0E7QUFDQTs7QUFDQUQsUUFBTSxDQUFDRCxRQUFQLENBQWdCRSxJQUFoQixFQUFxQkMsRUFBckIsRUFBd0JDLE9BQXhCLFdB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxRUFBcUU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxNQUFNO0FBQ047QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsZ0NBQWdDLGdDQUFtQjs7QUFFbkQ7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxvQkFBb0IsZ0NBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGdDQUFnQyxnQ0FBbUI7O0FBRW5EO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0QsZ0JBQWdCLGdDQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQkFBMkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDJCQUEyQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw2QkFBNkI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZCQUE2QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixlQUFlO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsY0FBYztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0VBQW9FO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsK0JBQStCO0FBQy9CLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU0sSUFBSSxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0IsaUJBQWlCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUMsS0FBSztBQUMxQyxxQ0FBcUM7QUFDckMscUNBQXFDLEtBQUs7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0QsZ0JBQWdCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLGNBQWMsZUFBZTtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsR0FBRyx5QkFBeUI7QUFDNUIsc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBLDRFQUE0RTtBQUM1RSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLCtDQUErQztBQUN2RDs7QUFFQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUCw0REFBNEQsc0JBQXNCO0FBQ2xGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVCxtRUFBbUU7O0FBRW5FLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBLE9BQU87QUFDUCw4REFBOEQ7O0FBRTlELE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLEtBQUs7QUFDTCxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLCtDQUErQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDs7QUFFQSxHQUFHO0FBQ0g7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUN2RkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDcUc7QUFDdkcsQ0FBQyxxQkFBcUI7O0FBRXRCO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsZ0RBQWdEO0FBQ2hEO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsc0JBQXNCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVW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QSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVyxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7OztBQ3ZM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Q0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiwyREFBMkQsU0FBUztBQUNwRSx5QkFBeUIsU0FBUztBQUNsQztBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRTtBQUNBLHFDOzs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFOzs7Ozs7Ozs7O0FDN0RBLGUiLCJmaWxlIjoic3RhdGljL2NodW5rcy9wYWdlcy9fYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7dmFyIF9yb3V0ZXI9cmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyXCIpO3ZhciBfcm91dGVyMj1yZXF1aXJlKFwiLi9yb3V0ZXJcIik7dmFyIF91c2VJbnRlcnNlY3Rpb249cmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtjb25zdCBwcmVmZXRjaGVkPXt9O2Z1bmN0aW9uIHByZWZldGNoKHJvdXRlcixocmVmLGFzLG9wdGlvbnMpe2lmKHR5cGVvZiB3aW5kb3c9PT0ndW5kZWZpbmVkJ3x8IXJvdXRlcilyZXR1cm47aWYoISgwLF9yb3V0ZXIuaXNMb2NhbFVSTCkoaHJlZikpcmV0dXJuOy8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbi8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbi8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG5yb3V0ZXIucHJlZmV0Y2goaHJlZixhcyxvcHRpb25zKS5jYXRjaChlcnI9PntpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7Ly8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xudGhyb3cgZXJyO319KTtjb25zdCBjdXJMb2NhbGU9b3B0aW9ucyYmdHlwZW9mIG9wdGlvbnMubG9jYWxlIT09J3VuZGVmaW5lZCc/b3B0aW9ucy5sb2NhbGU6cm91dGVyJiZyb3V0ZXIubG9jYWxlOy8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG5wcmVmZXRjaGVkW2hyZWYrJyUnK2FzKyhjdXJMb2NhbGU/JyUnK2N1ckxvY2FsZTonJyldPXRydWU7fWZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCl7Y29uc3R7dGFyZ2V0fT1ldmVudC5jdXJyZW50VGFyZ2V0O3JldHVybiB0YXJnZXQmJnRhcmdldCE9PSdfc2VsZid8fGV2ZW50Lm1ldGFLZXl8fGV2ZW50LmN0cmxLZXl8fGV2ZW50LnNoaWZ0S2V5fHxldmVudC5hbHRLZXl8fC8vIHRyaWdnZXJzIHJlc291cmNlIGRvd25sb2FkXG5ldmVudC5uYXRpdmVFdmVudCYmZXZlbnQubmF0aXZlRXZlbnQud2hpY2g9PT0yO31mdW5jdGlvbiBsaW5rQ2xpY2tlZChlLHJvdXRlcixocmVmLGFzLHJlcGxhY2Usc2hhbGxvdyxzY3JvbGwsbG9jYWxlKXtjb25zdHtub2RlTmFtZX09ZS5jdXJyZW50VGFyZ2V0O2lmKG5vZGVOYW1lPT09J0EnJiYoaXNNb2RpZmllZEV2ZW50KGUpfHwhKDAsX3JvdXRlci5pc0xvY2FsVVJMKShocmVmKSkpey8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxucmV0dXJuO31lLnByZXZlbnREZWZhdWx0KCk7Ly8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG5pZihzY3JvbGw9PW51bGwmJmFzLmluZGV4T2YoJyMnKT49MCl7c2Nyb2xsPWZhbHNlO30vLyByZXBsYWNlIHN0YXRlIGluc3RlYWQgb2YgcHVzaCBpZiBwcm9wIGlzIHByZXNlbnRcbnJvdXRlcltyZXBsYWNlPydyZXBsYWNlJzoncHVzaCddKGhyZWYsYXMse3NoYWxsb3csbG9jYWxlLHNjcm9sbH0pO31mdW5jdGlvbiBMaW5rKHByb3BzKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7ZnVuY3Rpb24gY3JlYXRlUHJvcEVycm9yKGFyZ3Mpe3JldHVybiBuZXcgRXJyb3IoYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmArKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz9cIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCI6JycpKTt9Ly8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbmNvbnN0IHJlcXVpcmVkUHJvcHNHdWFyZD17aHJlZjp0cnVlfTtjb25zdCByZXF1aXJlZFByb3BzPU9iamVjdC5rZXlzKHJlcXVpcmVkUHJvcHNHdWFyZCk7cmVxdWlyZWRQcm9wcy5mb3JFYWNoKGtleT0+e2lmKGtleT09PSdocmVmJyl7aWYocHJvcHNba2V5XT09bnVsbHx8dHlwZW9mIHByb3BzW2tleV0hPT0nc3RyaW5nJyYmdHlwZW9mIHByb3BzW2tleV0hPT0nb2JqZWN0Jyl7dGhyb3cgY3JlYXRlUHJvcEVycm9yKHtrZXksZXhwZWN0ZWQ6J2BzdHJpbmdgIG9yIGBvYmplY3RgJyxhY3R1YWw6cHJvcHNba2V5XT09PW51bGw/J251bGwnOnR5cGVvZiBwcm9wc1trZXldfSk7fX1lbHNley8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jb25zdCBfPWtleTt9fSk7Ly8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbmNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZD17YXM6dHJ1ZSxyZXBsYWNlOnRydWUsc2Nyb2xsOnRydWUsc2hhbGxvdzp0cnVlLHBhc3NIcmVmOnRydWUscHJlZmV0Y2g6dHJ1ZSxsb2NhbGU6dHJ1ZX07Y29uc3Qgb3B0aW9uYWxQcm9wcz1PYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO29wdGlvbmFsUHJvcHMuZm9yRWFjaChrZXk9Pntjb25zdCB2YWxUeXBlPXR5cGVvZiBwcm9wc1trZXldO2lmKGtleT09PSdhcycpe2lmKHByb3BzW2tleV0mJnZhbFR5cGUhPT0nc3RyaW5nJyYmdmFsVHlwZSE9PSdvYmplY3QnKXt0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe2tleSxleHBlY3RlZDonYHN0cmluZ2Agb3IgYG9iamVjdGAnLGFjdHVhbDp2YWxUeXBlfSk7fX1lbHNlIGlmKGtleT09PSdsb2NhbGUnKXtpZihwcm9wc1trZXldJiZ2YWxUeXBlIT09J3N0cmluZycpe3Rocm93IGNyZWF0ZVByb3BFcnJvcih7a2V5LGV4cGVjdGVkOidgc3RyaW5nYCcsYWN0dWFsOnZhbFR5cGV9KTt9fWVsc2UgaWYoa2V5PT09J3JlcGxhY2UnfHxrZXk9PT0nc2Nyb2xsJ3x8a2V5PT09J3NoYWxsb3cnfHxrZXk9PT0ncGFzc0hyZWYnfHxrZXk9PT0ncHJlZmV0Y2gnKXtpZihwcm9wc1trZXldIT1udWxsJiZ2YWxUeXBlIT09J2Jvb2xlYW4nKXt0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe2tleSxleHBlY3RlZDonYGJvb2xlYW5gJyxhY3R1YWw6dmFsVHlwZX0pO319ZWxzZXsvLyBUeXBlU2NyaXB0IHRyaWNrIGZvciB0eXBlLWd1YXJkaW5nOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuY29uc3QgXz1rZXk7fX0pOy8vIFRoaXMgaG9vayBpcyBpbiBhIGNvbmRpdGlvbmFsIGJ1dCB0aGF0IGlzIG9rIGJlY2F1c2UgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBuZXZlciBjaGFuZ2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbmNvbnN0IGhhc1dhcm5lZD1fcmVhY3QuZGVmYXVsdC51c2VSZWYoZmFsc2UpO2lmKHByb3BzLnByZWZldGNoJiYhaGFzV2FybmVkLmN1cnJlbnQpe2hhc1dhcm5lZC5jdXJyZW50PXRydWU7Y29uc29sZS53YXJuKCdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCcpO319Y29uc3QgcD1wcm9wcy5wcmVmZXRjaCE9PWZhbHNlO2NvbnN0IHJvdXRlcj0oMCxfcm91dGVyMi51c2VSb3V0ZXIpKCk7Y29uc3R7aHJlZixhc309X3JlYWN0LmRlZmF1bHQudXNlTWVtbygoKT0+e2NvbnN0W3Jlc29sdmVkSHJlZixyZXNvbHZlZEFzXT0oMCxfcm91dGVyLnJlc29sdmVIcmVmKShyb3V0ZXIscHJvcHMuaHJlZix0cnVlKTtyZXR1cm57aHJlZjpyZXNvbHZlZEhyZWYsYXM6cHJvcHMuYXM/KDAsX3JvdXRlci5yZXNvbHZlSHJlZikocm91dGVyLHByb3BzLmFzKTpyZXNvbHZlZEFzfHxyZXNvbHZlZEhyZWZ9O30sW3JvdXRlcixwcm9wcy5ocmVmLHByb3BzLmFzXSk7bGV0e2NoaWxkcmVuLHJlcGxhY2Usc2hhbGxvdyxzY3JvbGwsbG9jYWxlfT1wcm9wczsvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbmlmKHR5cGVvZiBjaGlsZHJlbj09PSdzdHJpbmcnKXtjaGlsZHJlbj0vKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIixudWxsLGNoaWxkcmVuKTt9Ly8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG5sZXQgY2hpbGQ7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT0nZGV2ZWxvcG1lbnQnKXt0cnl7Y2hpbGQ9X3JlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO31jYXRjaChlcnIpe3Rocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBwYXNzZWQgdG8gPExpbms+IHdpdGggXFxgaHJlZlxcYCBvZiBcXGAke3Byb3BzLmhyZWZ9XFxgIGJ1dCBvbmx5IG9uZSBjaGlsZCBpcyBzdXBwb3J0ZWQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbGluay1tdWx0aXBsZS1jaGlsZHJlbmArKHR5cGVvZiB3aW5kb3chPT0ndW5kZWZpbmVkJz9cIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCI6JycpKTt9fWVsc2V7Y2hpbGQ9X3JlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO31jb25zdCBjaGlsZFJlZj1jaGlsZCYmdHlwZW9mIGNoaWxkPT09J29iamVjdCcmJmNoaWxkLnJlZjtjb25zdFtzZXRJbnRlcnNlY3Rpb25SZWYsaXNWaXNpYmxlXT0oMCxfdXNlSW50ZXJzZWN0aW9uLnVzZUludGVyc2VjdGlvbikoe3Jvb3RNYXJnaW46JzIwMHB4J30pO2NvbnN0IHNldFJlZj1fcmVhY3QuZGVmYXVsdC51c2VDYWxsYmFjayhlbD0+e3NldEludGVyc2VjdGlvblJlZihlbCk7aWYoY2hpbGRSZWYpe2lmKHR5cGVvZiBjaGlsZFJlZj09PSdmdW5jdGlvbicpY2hpbGRSZWYoZWwpO2Vsc2UgaWYodHlwZW9mIGNoaWxkUmVmPT09J29iamVjdCcpe2NoaWxkUmVmLmN1cnJlbnQ9ZWw7fX19LFtjaGlsZFJlZixzZXRJbnRlcnNlY3Rpb25SZWZdKTsoMCxfcmVhY3QudXNlRWZmZWN0KSgoKT0+e2NvbnN0IHNob3VsZFByZWZldGNoPWlzVmlzaWJsZSYmcCYmKDAsX3JvdXRlci5pc0xvY2FsVVJMKShocmVmKTtjb25zdCBjdXJMb2NhbGU9dHlwZW9mIGxvY2FsZSE9PSd1bmRlZmluZWQnP2xvY2FsZTpyb3V0ZXImJnJvdXRlci5sb2NhbGU7Y29uc3QgaXNQcmVmZXRjaGVkPXByZWZldGNoZWRbaHJlZisnJScrYXMrKGN1ckxvY2FsZT8nJScrY3VyTG9jYWxlOicnKV07aWYoc2hvdWxkUHJlZmV0Y2gmJiFpc1ByZWZldGNoZWQpe3ByZWZldGNoKHJvdXRlcixocmVmLGFzLHtsb2NhbGU6Y3VyTG9jYWxlfSk7fX0sW2FzLGhyZWYsaXNWaXNpYmxlLGxvY2FsZSxwLHJvdXRlcl0pO2NvbnN0IGNoaWxkUHJvcHM9e3JlZjpzZXRSZWYsb25DbGljazplPT57aWYoY2hpbGQucHJvcHMmJnR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrPT09J2Z1bmN0aW9uJyl7Y2hpbGQucHJvcHMub25DbGljayhlKTt9aWYoIWUuZGVmYXVsdFByZXZlbnRlZCl7bGlua0NsaWNrZWQoZSxyb3V0ZXIsaHJlZixhcyxyZXBsYWNlLHNoYWxsb3csc2Nyb2xsLGxvY2FsZSk7fX19O2NoaWxkUHJvcHMub25Nb3VzZUVudGVyPWU9PntpZighKDAsX3JvdXRlci5pc0xvY2FsVVJMKShocmVmKSlyZXR1cm47aWYoY2hpbGQucHJvcHMmJnR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXI9PT0nZnVuY3Rpb24nKXtjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSk7fXByZWZldGNoKHJvdXRlcixocmVmLGFzLHtwcmlvcml0eTp0cnVlfSk7fTsvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbi8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuaWYocHJvcHMucGFzc0hyZWZ8fGNoaWxkLnR5cGU9PT0nYScmJiEoJ2hyZWYnaW4gY2hpbGQucHJvcHMpKXtjb25zdCBjdXJMb2NhbGU9dHlwZW9mIGxvY2FsZSE9PSd1bmRlZmluZWQnP2xvY2FsZTpyb3V0ZXImJnJvdXRlci5sb2NhbGU7Ly8gd2Ugb25seSByZW5kZXIgZG9tYWluIGxvY2FsZXMgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiBhIGRvbWFpbiBsb2NhbGVcbi8vIHNvIHRoYXQgbG9jYWxlIGxpbmtzIGFyZSBzdGlsbCB2aXNpdGFibGUgaW4gZGV2ZWxvcG1lbnQvcHJldmlldyBlbnZzXG5jb25zdCBsb2NhbGVEb21haW49cm91dGVyJiZyb3V0ZXIuaXNMb2NhbGVEb21haW4mJigwLF9yb3V0ZXIuZ2V0RG9tYWluTG9jYWxlKShhcyxjdXJMb2NhbGUscm91dGVyJiZyb3V0ZXIubG9jYWxlcyxyb3V0ZXImJnJvdXRlci5kb21haW5Mb2NhbGVzKTtjaGlsZFByb3BzLmhyZWY9bG9jYWxlRG9tYWlufHwoMCxfcm91dGVyLmFkZEJhc2VQYXRoKSgoMCxfcm91dGVyLmFkZExvY2FsZSkoYXMsY3VyTG9jYWxlLHJvdXRlciYmcm91dGVyLmRlZmF1bHRMb2NhbGUpKTt9cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCxjaGlsZFByb3BzKTt9dmFyIF9kZWZhdWx0PUxpbms7ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLnVzZUludGVyc2VjdGlvbj11c2VJbnRlcnNlY3Rpb247dmFyIF9yZWFjdD1yZXF1aXJlKFwicmVhY3RcIik7dmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrPXJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtjb25zdCBoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcj10eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIhPT0ndW5kZWZpbmVkJztmdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24oe3Jvb3RNYXJnaW4sZGlzYWJsZWR9KXtjb25zdCBpc0Rpc2FibGVkPWRpc2FibGVkfHwhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7Y29uc3QgdW5vYnNlcnZlPSgwLF9yZWFjdC51c2VSZWYpKCk7Y29uc3RbdmlzaWJsZSxzZXRWaXNpYmxlXT0oMCxfcmVhY3QudXNlU3RhdGUpKGZhbHNlKTtjb25zdCBzZXRSZWY9KDAsX3JlYWN0LnVzZUNhbGxiYWNrKShlbD0+e2lmKHVub2JzZXJ2ZS5jdXJyZW50KXt1bm9ic2VydmUuY3VycmVudCgpO3Vub2JzZXJ2ZS5jdXJyZW50PXVuZGVmaW5lZDt9aWYoaXNEaXNhYmxlZHx8dmlzaWJsZSlyZXR1cm47aWYoZWwmJmVsLnRhZ05hbWUpe3Vub2JzZXJ2ZS5jdXJyZW50PW9ic2VydmUoZWwsaXNWaXNpYmxlPT5pc1Zpc2libGUmJnNldFZpc2libGUoaXNWaXNpYmxlKSx7cm9vdE1hcmdpbn0pO319LFtpc0Rpc2FibGVkLHJvb3RNYXJnaW4sdmlzaWJsZV0pOygwLF9yZWFjdC51c2VFZmZlY3QpKCgpPT57aWYoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKXtpZighdmlzaWJsZSl7Y29uc3QgaWRsZUNhbGxiYWNrPSgwLF9yZXF1ZXN0SWRsZUNhbGxiYWNrLnJlcXVlc3RJZGxlQ2FsbGJhY2spKCgpPT5zZXRWaXNpYmxlKHRydWUpKTtyZXR1cm4oKT0+KDAsX3JlcXVlc3RJZGxlQ2FsbGJhY2suY2FuY2VsSWRsZUNhbGxiYWNrKShpZGxlQ2FsbGJhY2spO319fSxbdmlzaWJsZV0pO3JldHVybltzZXRSZWYsdmlzaWJsZV07fWZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCxjYWxsYmFjayxvcHRpb25zKXtjb25zdHtpZCxvYnNlcnZlcixlbGVtZW50c309Y3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7ZWxlbWVudHMuc2V0KGVsZW1lbnQsY2FsbGJhY2spO29ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7cmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpe2VsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7Ly8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuaWYoZWxlbWVudHMuc2l6ZT09PTApe29ic2VydmVyLmRpc2Nvbm5lY3QoKTtvYnNlcnZlcnMuZGVsZXRlKGlkKTt9fTt9Y29uc3Qgb2JzZXJ2ZXJzPW5ldyBNYXAoKTtmdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKXtjb25zdCBpZD1vcHRpb25zLnJvb3RNYXJnaW58fCcnO2xldCBpbnN0YW5jZT1vYnNlcnZlcnMuZ2V0KGlkKTtpZihpbnN0YW5jZSl7cmV0dXJuIGluc3RhbmNlO31jb25zdCBlbGVtZW50cz1uZXcgTWFwKCk7Y29uc3Qgb2JzZXJ2ZXI9bmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXM9PntlbnRyaWVzLmZvckVhY2goZW50cnk9Pntjb25zdCBjYWxsYmFjaz1lbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtjb25zdCBpc1Zpc2libGU9ZW50cnkuaXNJbnRlcnNlY3Rpbmd8fGVudHJ5LmludGVyc2VjdGlvblJhdGlvPjA7aWYoY2FsbGJhY2smJmlzVmlzaWJsZSl7Y2FsbGJhY2soaXNWaXNpYmxlKTt9fSk7fSxvcHRpb25zKTtvYnNlcnZlcnMuc2V0KGlkLGluc3RhbmNlPXtpZCxvYnNlcnZlcixlbGVtZW50c30pO3JldHVybiBpbnN0YW5jZTt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW50ZXJzZWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuQW1wU3RhdGVDb250ZXh0PXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iail7cmV0dXJuIG9iaiYmb2JqLl9fZXNNb2R1bGU/b2JqOntkZWZhdWx0Om9ian07fWNvbnN0IEFtcFN0YXRlQ29udGV4dD0vKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dCh7fSk7ZXhwb3J0cy5BbXBTdGF0ZUNvbnRleHQ9QW1wU3RhdGVDb250ZXh0O2lmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWU9J0FtcFN0YXRlQ29udGV4dCc7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1wLWNvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5pc0luQW1wTW9kZT1pc0luQW1wTW9kZTtleHBvcnRzLnVzZUFtcD11c2VBbXA7dmFyIF9yZWFjdD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7dmFyIF9hbXBDb250ZXh0PXJlcXVpcmUoXCIuL2FtcC1jb250ZXh0XCIpO2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKXtyZXR1cm4gb2JqJiZvYmouX19lc01vZHVsZT9vYmo6e2RlZmF1bHQ6b2JqfTt9ZnVuY3Rpb24gaXNJbkFtcE1vZGUoe2FtcEZpcnN0PWZhbHNlLGh5YnJpZD1mYWxzZSxoYXNRdWVyeT1mYWxzZX09e30pe3JldHVybiBhbXBGaXJzdHx8aHlicmlkJiZoYXNRdWVyeTt9ZnVuY3Rpb24gdXNlQW1wKCl7Ly8gRG9uJ3QgYXNzaWduIHRoZSBjb250ZXh0IHZhbHVlIHRvIGEgdmFyaWFibGUgdG8gc2F2ZSBieXRlc1xucmV0dXJuIGlzSW5BbXBNb2RlKF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FtcENvbnRleHQuQW1wU3RhdGVDb250ZXh0KSk7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdEhlYWQ9ZGVmYXVsdEhlYWQ7ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7dmFyIF9zaWRlRWZmZWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2lkZS1lZmZlY3RcIikpO3ZhciBfYW1wQ29udGV4dD1yZXF1aXJlKFwiLi9hbXAtY29udGV4dFwiKTt2YXIgX2hlYWRNYW5hZ2VyQ29udGV4dD1yZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTt2YXIgX2FtcD1yZXF1aXJlKFwiLi9hbXBcIik7ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmope3JldHVybiBvYmomJm9iai5fX2VzTW9kdWxlP29iajp7ZGVmYXVsdDpvYmp9O31mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKXtpZih0eXBlb2YgV2Vha01hcCE9PVwiZnVuY3Rpb25cIilyZXR1cm4gbnVsbDt2YXIgY2FjaGU9bmV3IFdlYWtNYXAoKTtfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGU9ZnVuY3Rpb24oKXtyZXR1cm4gY2FjaGU7fTtyZXR1cm4gY2FjaGU7fWZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iail7aWYob2JqJiZvYmouX19lc01vZHVsZSl7cmV0dXJuIG9iajt9aWYob2JqPT09bnVsbHx8dHlwZW9mIG9iaiE9PVwib2JqZWN0XCImJnR5cGVvZiBvYmohPT1cImZ1bmN0aW9uXCIpe3JldHVybntkZWZhdWx0Om9ian07fXZhciBjYWNoZT1fZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtpZihjYWNoZSYmY2FjaGUuaGFzKG9iaikpe3JldHVybiBjYWNoZS5nZXQob2JqKTt9dmFyIG5ld09iaj17fTt2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGtleSBpbiBvYmope2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSl7dmFyIGRlc2M9aGFzUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLGtleSk6bnVsbDtpZihkZXNjJiYoZGVzYy5nZXR8fGRlc2Muc2V0KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaixrZXksZGVzYyk7fWVsc2V7bmV3T2JqW2tleV09b2JqW2tleV07fX19bmV3T2JqLmRlZmF1bHQ9b2JqO2lmKGNhY2hlKXtjYWNoZS5zZXQob2JqLG5ld09iaik7fXJldHVybiBuZXdPYmo7fWZ1bmN0aW9uIGRlZmF1bHRIZWFkKGluQW1wTW9kZT1mYWxzZSl7Y29uc3QgaGVhZD1bLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIse2NoYXJTZXQ6XCJ1dGYtOFwifSldO2lmKCFpbkFtcE1vZGUpe2hlYWQucHVzaCgvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIix7bmFtZTpcInZpZXdwb3J0XCIsY29udGVudDpcIndpZHRoPWRldmljZS13aWR0aFwifSkpO31yZXR1cm4gaGVhZDt9ZnVuY3Rpb24gb25seVJlYWN0RWxlbWVudChsaXN0LGNoaWxkKXsvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuaWYodHlwZW9mIGNoaWxkPT09J3N0cmluZyd8fHR5cGVvZiBjaGlsZD09PSdudW1iZXInKXtyZXR1cm4gbGlzdDt9Ly8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuaWYoY2hpbGQudHlwZT09PV9yZWFjdC5kZWZhdWx0LkZyYWdtZW50KXtyZXR1cm4gbGlzdC5jb25jYXQoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKChmcmFnbWVudExpc3QsZnJhZ21lbnRDaGlsZCk9PntpZih0eXBlb2YgZnJhZ21lbnRDaGlsZD09PSdzdHJpbmcnfHx0eXBlb2YgZnJhZ21lbnRDaGlsZD09PSdudW1iZXInKXtyZXR1cm4gZnJhZ21lbnRMaXN0O31yZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTt9LFtdKSk7fXJldHVybiBsaXN0LmNvbmNhdChjaGlsZCk7fWNvbnN0IE1FVEFUWVBFUz1bJ25hbWUnLCdodHRwRXF1aXYnLCdjaGFyU2V0JywnaXRlbVByb3AnXTsvKlxuIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgZmlsdGVyaW5nIGhlYWQgY2hpbGQgZWxlbWVudHNcbiB3aGljaCBzaG91bGRuJ3QgYmUgZHVwbGljYXRlZCwgbGlrZSA8dGl0bGUvPlxuIEFsc28gYWRkcyBzdXBwb3J0IGZvciBkZWR1cGxpY2F0ZWQgYGtleWAgcHJvcGVydGllc1xuKi9mdW5jdGlvbiB1bmlxdWUoKXtjb25zdCBrZXlzPW5ldyBTZXQoKTtjb25zdCB0YWdzPW5ldyBTZXQoKTtjb25zdCBtZXRhVHlwZXM9bmV3IFNldCgpO2NvbnN0IG1ldGFDYXRlZ29yaWVzPXt9O3JldHVybiBoPT57bGV0IGlzVW5pcXVlPXRydWU7bGV0IGhhc0tleT1mYWxzZTtpZihoLmtleSYmdHlwZW9mIGgua2V5IT09J251bWJlcicmJmgua2V5LmluZGV4T2YoJyQnKT4wKXtoYXNLZXk9dHJ1ZTtjb25zdCBrZXk9aC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpKzEpO2lmKGtleXMuaGFzKGtleSkpe2lzVW5pcXVlPWZhbHNlO31lbHNle2tleXMuYWRkKGtleSk7fX0vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG5zd2l0Y2goaC50eXBlKXtjYXNlJ3RpdGxlJzpjYXNlJ2Jhc2UnOmlmKHRhZ3MuaGFzKGgudHlwZSkpe2lzVW5pcXVlPWZhbHNlO31lbHNle3RhZ3MuYWRkKGgudHlwZSk7fWJyZWFrO2Nhc2UnbWV0YSc6Zm9yKGxldCBpPTAsbGVuPU1FVEFUWVBFUy5sZW5ndGg7aTxsZW47aSsrKXtjb25zdCBtZXRhdHlwZT1NRVRBVFlQRVNbaV07aWYoIWgucHJvcHMuaGFzT3duUHJvcGVydHkobWV0YXR5cGUpKWNvbnRpbnVlO2lmKG1ldGF0eXBlPT09J2NoYXJTZXQnKXtpZihtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSl7aXNVbmlxdWU9ZmFsc2U7fWVsc2V7bWV0YVR5cGVzLmFkZChtZXRhdHlwZSk7fX1lbHNle2NvbnN0IGNhdGVnb3J5PWgucHJvcHNbbWV0YXR5cGVdO2NvbnN0IGNhdGVnb3JpZXM9bWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdfHxuZXcgU2V0KCk7aWYoKG1ldGF0eXBlIT09J25hbWUnfHwhaGFzS2V5KSYmY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKXtpc1VuaXF1ZT1mYWxzZTt9ZWxzZXtjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7bWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdPWNhdGVnb3JpZXM7fX19YnJlYWs7fXJldHVybiBpc1VuaXF1ZTt9O30vKipcbiAqXG4gKiBAcGFyYW0gaGVhZEVsZW1lbnRzIExpc3Qgb2YgbXVsdGlwbGUgPEhlYWQ+IGluc3RhbmNlc1xuICovZnVuY3Rpb24gcmVkdWNlQ29tcG9uZW50cyhoZWFkRWxlbWVudHMscHJvcHMpe3JldHVybiBoZWFkRWxlbWVudHMucmVkdWNlKChsaXN0LGhlYWRFbGVtZW50KT0+e2NvbnN0IGhlYWRFbGVtZW50Q2hpbGRyZW49X3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4udG9BcnJheShoZWFkRWxlbWVudC5wcm9wcy5jaGlsZHJlbik7cmV0dXJuIGxpc3QuY29uY2F0KGhlYWRFbGVtZW50Q2hpbGRyZW4pO30sW10pLnJlZHVjZShvbmx5UmVhY3RFbGVtZW50LFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKHByb3BzLmluQW1wTW9kZSkpLmZpbHRlcih1bmlxdWUoKSkucmV2ZXJzZSgpLm1hcCgoYyxpKT0+e2NvbnN0IGtleT1jLmtleXx8aTtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdkZXZlbG9wbWVudCcmJnByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyYmIXByb3BzLmluQW1wTW9kZSl7aWYoYy50eXBlPT09J2xpbmsnJiZjLnByb3BzWydocmVmJ10mJi8vIFRPRE8ocHJhdGVla2JoQCk6IFJlcGxhY2UgdGhpcyB3aXRoIGNvbnN0IGZyb20gYGNvbnN0YW50c2Agd2hlbiB0aGUgdHJlZSBzaGFraW5nIHdvcmtzLlxuWydodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzcycsJ2h0dHBzOi8vdXNlLnR5cGVraXQubmV0LyddLnNvbWUodXJsPT5jLnByb3BzWydocmVmJ10uc3RhcnRzV2l0aCh1cmwpKSl7Y29uc3QgbmV3UHJvcHM9ey4uLihjLnByb3BzfHx7fSl9O25ld1Byb3BzWydkYXRhLWhyZWYnXT1uZXdQcm9wc1snaHJlZiddO25ld1Byb3BzWydocmVmJ109dW5kZWZpbmVkOy8vIEFkZCB0aGlzIGF0dHJpYnV0ZSB0byBtYWtlIGl0IGVhc3kgdG8gaWRlbnRpZnkgb3B0aW1pemVkIHRhZ3Ncbm5ld1Byb3BzWydkYXRhLW9wdGltaXplZC1mb250cyddPXRydWU7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjLG5ld1Byb3BzKTt9fXJldHVybi8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoYyx7a2V5fSk7fSk7fS8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi9mdW5jdGlvbiBIZWFkKHtjaGlsZHJlbn0pe2NvbnN0IGFtcFN0YXRlPSgwLF9yZWFjdC51c2VDb250ZXh0KShfYW1wQ29udGV4dC5BbXBTdGF0ZUNvbnRleHQpO2NvbnN0IGhlYWRNYW5hZ2VyPSgwLF9yZWFjdC51c2VDb250ZXh0KShfaGVhZE1hbmFnZXJDb250ZXh0LkhlYWRNYW5hZ2VyQ29udGV4dCk7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3NpZGVFZmZlY3QuZGVmYXVsdCx7cmVkdWNlQ29tcG9uZW50c1RvU3RhdGU6cmVkdWNlQ29tcG9uZW50cyxoZWFkTWFuYWdlcjpoZWFkTWFuYWdlcixpbkFtcE1vZGU6KDAsX2FtcC5pc0luQW1wTW9kZSkoYW1wU3RhdGUpfSxjaGlsZHJlbik7fXZhciBfZGVmYXVsdD1IZWFkO2V4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3JlYWN0PXJlcXVpcmUoXCJyZWFjdFwiKTtjb25zdCBpc1NlcnZlcj10eXBlb2Ygd2luZG93PT09J3VuZGVmaW5lZCc7Y2xhc3MgX2RlZmF1bHQgZXh0ZW5kcyBfcmVhY3QuQ29tcG9uZW50e2NvbnN0cnVjdG9yKHByb3BzKXtzdXBlcihwcm9wcyk7dGhpcy5faGFzSGVhZE1hbmFnZXI9dm9pZCAwO3RoaXMuZW1pdENoYW5nZT0oKT0+e2lmKHRoaXMuX2hhc0hlYWRNYW5hZ2VyKXt0aGlzLnByb3BzLmhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQodGhpcy5wcm9wcy5yZWR1Y2VDb21wb25lbnRzVG9TdGF0ZShbLi4udGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzXSx0aGlzLnByb3BzKSk7fX07dGhpcy5faGFzSGVhZE1hbmFnZXI9dGhpcy5wcm9wcy5oZWFkTWFuYWdlciYmdGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzO2lmKGlzU2VydmVyJiZ0aGlzLl9oYXNIZWFkTWFuYWdlcil7dGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKTt0aGlzLmVtaXRDaGFuZ2UoKTt9fWNvbXBvbmVudERpZE1vdW50KCl7aWYodGhpcy5faGFzSGVhZE1hbmFnZXIpe3RoaXMucHJvcHMuaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcy5hZGQodGhpcyk7fXRoaXMuZW1pdENoYW5nZSgpO31jb21wb25lbnREaWRVcGRhdGUoKXt0aGlzLmVtaXRDaGFuZ2UoKTt9Y29tcG9uZW50V2lsbFVubW91bnQoKXtpZih0aGlzLl9oYXNIZWFkTWFuYWdlcil7dGhpcy5wcm9wcy5oZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZSh0aGlzKTt9dGhpcy5lbWl0Q2hhbmdlKCk7fXJlbmRlcigpe3JldHVybiBudWxsO319ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lkZS1lZmZlY3QuanMubWFwIiwiaW1wb3J0IEhlYWQgZnJvbSBcIm5leHQvaGVhZFwiO1xyXG5pbXBvcnQgdHlwZSB7IEFwcFByb3BzIH0gZnJvbSBcIm5leHQvYXBwXCI7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmltcG9ydCB7IFRoZW1lQ29udGV4dFByb3ZpZGVyIH0gZnJvbSBcIkBzcmMvY29udGV4dHMvdGhlbWVcIjtcclxuaW1wb3J0IHsgQXBwQ29udGV4dFByb3ZpZGVyIH0gZnJvbSBcIkBzcmMvY29udGV4dHMvYXBwXCI7XHJcbmltcG9ydCAqIGFzIGd0YWcgZnJvbSBcIkBzcmMvaGVscGVycy9ndGFnXCI7XHJcbmltcG9ydCBQb3N0U2VydmljZSBmcm9tIFwiQHNyYy9zZXJ2aWNlcy9wb3N0LnNlcnZpY2VcIjtcclxuaW1wb3J0IHsgUG9zdCB9IGZyb20gXCJAc3JjL3R5cGVzL3Bvc3QudHlwZVwiO1xyXG5cclxuaW1wb3J0IHsgQmxvZ0xheW91dCB9IGZyb20gXCJAc3JjL2xheW91dHNcIjtcclxuXHJcbmltcG9ydCBcIkBzcmMvc3R5bGVzL2dsb2JhbC5jc3NcIjtcclxuaW1wb3J0IFwiQHNyYy9zdHlsZXMvcG9zdC5jc3NcIjtcclxuXHJcbmV4cG9ydCB0eXBlIE15QXBwUHJvcHMgPSBBcHBQcm9wcyAmIHtcclxuICBwb3N0czogUG9zdFtdO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcywgcG9zdHMgfTogTXlBcHBQcm9wcykge1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlUm91dGVDaGFuZ2UgPSAodXJsOiBVUkwpID0+IHtcclxuICAgICAgY29uc3QgeyB0aXRsZSB9ID0gd2luZG93LmRvY3VtZW50O1xyXG4gICAgICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvbjtcclxuXHJcbiAgICAgIGd0YWcucGFnZXZpZXcoeyB1cmwsIHRpdGxlLCBocmVmIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICByb3V0ZXIuZXZlbnRzLm9uKFwicm91dGVDaGFuZ2VDb21wbGV0ZVwiLCBoYW5kbGVSb3V0ZUNoYW5nZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICByb3V0ZXIuZXZlbnRzLm9mZihcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgaGFuZGxlUm91dGVDaGFuZ2UpO1xyXG4gICAgfTtcclxuICB9LCBbcm91dGVyLmV2ZW50c10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPEhlYWQ+XHJcbiAgICAgICAgPHRpdGxlPntgRnJvbnRlbmQgRGV2IHwgbGlrZWxpb25TdW5nR3VrIEJsb2dgfTwvdGl0bGU+XHJcbiAgICAgICAgPG1ldGEgbmFtZT1cImRlc2NyaXB0aW9uXCIgY29udGVudD1cIkZyb250ZW5kIERldiBsaWtlbGlvblN1bmdHdWsgQmxvZ1wiIC8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvZmF2aWNvbi5pY29cIiAvPlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxUaGVtZUNvbnRleHRQcm92aWRlciBkZWZhdWx0VGhlbWU9XCJkYXJrXCI+XHJcbiAgICAgICAgPEFwcENvbnRleHRQcm92aWRlciBwb3N0cz17cG9zdHN9PlxyXG4gICAgICAgICAgPEJsb2dMYXlvdXQ+XHJcbiAgICAgICAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cclxuICAgICAgICAgIDwvQmxvZ0xheW91dD5cclxuICAgICAgICA8L0FwcENvbnRleHRQcm92aWRlcj5cclxuICAgICAgPC9UaGVtZUNvbnRleHRQcm92aWRlcj5cclxuICAgIDwvPlxyXG4gICk7XHJcbn1cclxuXHJcbk15QXBwLmdldEluaXRpYWxQcm9wcyA9IGFzeW5jICgpID0+IHtcclxuICBjb25zdCBwb3N0cyA9IGF3YWl0IFBvc3RTZXJ2aWNlLmdldFBvc3RzKCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHBvc3RzLFxyXG4gIH07XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNeUFwcDtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgSWNvblByb3BzIH0gZnJvbSBcIi5cIjtcclxuXHJcbmZ1bmN0aW9uIEFjY291bnRJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNHJlbVwiLCBoZWlnaHQ6IFwiMS40cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMTYgMTZcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGggZD1cIk0xNiA3Ljk5MkMxNiAzLjU4IDEyLjQxNiAwIDggMFMwIDMuNTggMCA3Ljk5MmMwIDIuNDMgMS4xMDQgNC42MiAyLjgzMiA2LjA5LjAxNi4wMTYuMDMyLjAxNi4wMzIuMDMyLjE0NC4xMTIuMjg4LjIyNC40NDguMzM2LjA4LjA0OC4xNDQuMTExLjIyNC4xNzVBNy45OCA3Ljk4IDAgMCAwIDguMDE2IDE2YTcuOTggNy45OCAwIDAgMCA0LjQ4LTEuMzc1Yy4wOC0uMDQ4LjE0NC0uMTExLjIyNC0uMTYuMTQ0LS4xMTEuMzA0LS4yMjMuNDQ4LS4zMzUuMDE2LS4wMTYuMDMyLS4wMTYuMDMyLS4wMzIgMS42OTYtMS40ODcgMi44LTMuNjc2IDIuOC02LjEwNnptLTggNy4wMDFjLTEuNTA0IDAtMi44OC0uNDgtNC4wMTYtMS4yNzkuMDE2LS4xMjguMDQ4LS4yNTUuMDgtLjM4M2E0LjE3IDQuMTcgMCAwIDEgLjQxNi0uOTkxYy4xNzYtLjMwNC4zODQtLjU3Ni42NC0uODE2LjI0LS4yNC41MjgtLjQ2My44MTYtLjYzOS4zMDQtLjE3Ni42MjQtLjMwNC45NzYtLjRBNC4xNSA0LjE1IDAgMCAxIDggMTAuMzQyYTQuMTg1IDQuMTg1IDAgMCAxIDIuOTI4IDEuMTY2Yy4zNjguMzY4LjY1Ni44Ljg2NCAxLjI5NS4xMTIuMjg4LjE5Mi41OTIuMjQuOTExQTcuMDMgNy4wMyAwIDAgMSA4IDE0Ljk5M3ptLTIuNDQ4LTcuNGEyLjQ5IDIuNDkgMCAwIDEtLjIwOC0xLjAyNGMwLS4zNTEuMDY0LS43MDMuMjA4LTEuMDIzLjE0NC0uMzIuMzM2LS42MDcuNTc2LS44NDcuMjQtLjI0LjUyOC0uNDMxLjg0OC0uNTc1LjMyLS4xNDQuNjcyLS4yMDggMS4wMjQtLjIwOC4zNjggMCAuNzA0LjA2NCAxLjAyNC4yMDguMzIuMTQ0LjYwOC4zMzYuODQ4LjU3NS4yNC4yNC40MzIuNTI4LjU3Ni44NDcuMTQ0LjMyLjIwOC42NzIuMjA4IDEuMDIzIDAgLjM2OC0uMDY0LjcwNC0uMjA4IDEuMDIzYTIuODQgMi44NCAwIDAgMS0uNTc2Ljg0OCAyLjg0IDIuODQgMCAwIDEtLjg0OC41NzUgMi43MTUgMi43MTUgMCAwIDEtMi4wNjQgMCAyLjg0IDIuODQgMCAwIDEtLjg0OC0uNTc1IDIuNTI2IDIuNTI2IDAgMCAxLS41Ni0uODQ4em03LjQyNCA1LjMwNmMwLS4wMzItLjAxNi0uMDQ4LS4wMTYtLjA4YTUuMjIgNS4yMiAwIDAgMC0uNjg4LTEuNDA2IDQuODgzIDQuODgzIDAgMCAwLTEuMDg4LTEuMTM1IDUuMjA3IDUuMjA3IDAgMCAwLTEuMDQtLjYwOCAyLjgyIDIuODIgMCAwIDAgLjQ2NC0uMzgzIDQuMiA0LjIgMCAwIDAgLjYyNC0uNzg0IDMuNjI0IDMuNjI0IDAgMCAwIC41MjgtMS45MzQgMy43MSAzLjcxIDAgMCAwLS4yODgtMS40NyAzLjc5OSAzLjc5OSAwIDAgMC0uODE2LTEuMTk5IDMuODQ1IDMuODQ1IDAgMCAwLTEuMi0uOCAzLjcyIDMuNzIgMCAwIDAtMS40NzItLjI4NyAzLjcyIDMuNzIgMCAwIDAtMS40NzIuMjg4IDMuNjMxIDMuNjMxIDAgMCAwLTEuMi44MTUgMy44NCAzLjg0IDAgMCAwLS44IDEuMTk5IDMuNzEgMy43MSAwIDAgMC0uMjg4IDEuNDdjMCAuMzUyLjA0OC42ODguMTQ0IDEuMDA3LjA5Ni4zMzYuMjI0LjY0LjQuOTI3LjE2LjI4OC4zODQuNTQ0LjYyNC43ODQuMTQ0LjE0NC4zMDQuMjcxLjQ4LjM4M2E1LjEyIDUuMTIgMCAwIDAtMS4wNC42MjRjLS40MTYuMzItLjc4NC43MDMtMS4wODggMS4xMTlhNC45OTkgNC45OTkgMCAwIDAtLjY4OCAxLjQwNmMtLjAxNi4wMzItLjAxNi4wNjQtLjAxNi4wOEMxLjc3NiAxMS42MzYuOTkyIDkuOTEuOTkyIDcuOTkyLjk5MiA0LjE0IDQuMTQ0Ljk5MSA4IC45OTFzNy4wMDggMy4xNDkgNy4wMDggNy4wMDFhNi45NiA2Ljk2IDAgMCAxLTIuMDMyIDQuOTA3elwiIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKEFjY291bnRJY29uKTtcclxuIiwiaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEljb25Qcm9wcyB9IGZyb20gXCIuLlwiO1xyXG5cclxuZnVuY3Rpb24gQ2hldnJvbkRvd25JY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNnJlbVwiLCBoZWlnaHQ6IFwiMS42cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMTYgMTZcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGhcclxuICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxyXG4gICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgZD1cIk03Ljk3NiAxMC4wNzJsNC4zNTctNC4zNTcuNjIuNjE4TDguMjg0IDExaC0uNjE4TDMgNi4zMzNsLjYxOS0uNjE4IDQuMzU3IDQuMzU3elwiXHJcbiAgICAgIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGV2cm9uRG93bkljb247XHJcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hldnJvblVwSWNvbiB9IGZyb20gXCIuL3VwXCI7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2hldnJvbkRvd25JY29uIH0gZnJvbSBcIi4vZG93blwiO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENoZXZyb25MZWZ0SWNvbiB9IGZyb20gXCIuL2xlZnRcIjtcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGV2cm9uUmlnaHRJY29uIH0gZnJvbSBcIi4vcmlnaHRcIjtcclxuIiwiaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEljb25Qcm9wcyB9IGZyb20gXCIuLlwiO1xyXG5cclxuZnVuY3Rpb24gQ2hldnJvbkxlZnRJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNnJlbVwiLCBoZWlnaHQ6IFwiMS42cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMTYgMTZcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGhcclxuICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxyXG4gICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgZD1cIk01LjkyOCA3Ljk3Nmw0LjM1NyA0LjM1Ny0uNjE4LjYyTDUgOC4yODR2LS42MThMOS42NjcgM2wuNjE4LjYxOS00LjM1NyA0LjM1N3pcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ2hldnJvbkxlZnRJY29uO1xyXG4iLCJpbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgSWNvblByb3BzIH0gZnJvbSBcIi4uXCI7XHJcblxyXG5mdW5jdGlvbiBDaGV2cm9uVXBJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNnJlbVwiLCBoZWlnaHQ6IFwiMS42cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMTYgMTZcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGhcclxuICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxyXG4gICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgZD1cIk0xMC4wNzIgOC4wMjRMNS43MTUgMy42NjdsLjYxOC0uNjJMMTEgNy43MTZ2LjYxOEw2LjMzMyAxM2wtLjYxOC0uNjE5IDQuMzU3LTQuMzU3elwiXHJcbiAgICAgIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGV2cm9uVXBJY29uO1xyXG4iLCJpbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5pbXBvcnQgeyBJY29uUHJvcHMgfSBmcm9tIFwiLi5cIjtcclxuXHJcbmZ1bmN0aW9uIENoZXZyb25VcEljb24oeyBzdHlsZSwgZmlsbCB9OiBJY29uUHJvcHMpIHtcclxuICBjb25zdCB7IGNvbG9ycyB9ID0gdXNlVGhlbWUoKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMS42cmVtXCIsIGhlaWdodDogXCIxLjZyZW1cIiwgLi4uc3R5bGUgfX1cclxuICAgICAgdmlld0JveD1cIjAgMCAxNiAxNlwiXHJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG4gICAgICBmaWxsPXtmaWxsIHx8IGNvbG9ycy5zY2hlbWUuJHdoaXRlfVxyXG4gICAgPlxyXG4gICAgICA8cGF0aFxyXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgY2xpcFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICBkPVwiTTguMDI0IDUuOTI4bC00LjM1NyA0LjM1Ny0uNjItLjYxOEw3LjcxNiA1aC42MThMMTMgOS42NjdsLS42MTkuNjE4LTQuMzU3LTQuMzU3elwiXHJcbiAgICAgIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGV2cm9uVXBJY29uO1xyXG4iLCJpbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgSWNvblByb3BzIH0gZnJvbSBcIi5cIjtcclxuXHJcbmZ1bmN0aW9uIENsb3NlSWNvbih7IHN0eWxlLCBmaWxsLCBvbkNsaWNrLCBjbGFzc05hbWUgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxyXG4gICAgICBzdHlsZT17eyB3aWR0aDogXCIxLjZyZW1cIiwgaGVpZ2h0OiBcIjEuNnJlbVwiLCAuLi5zdHlsZSB9fVxyXG4gICAgICB2aWV3Qm94PVwiMCAwIDE2IDE2XCJcclxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcbiAgICAgIGZpbGw9e2ZpbGwgfHwgY29sb3JzLnNjaGVtZS4kd2hpdGV9XHJcbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XHJcbiAgICA+XHJcbiAgICAgIDxwYXRoXHJcbiAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICBjbGlwUnVsZT1cImV2ZW5vZGRcIlxyXG4gICAgICAgIGQ9XCJNOCA4LjcwN2wzLjY0NiAzLjY0Ny43MDgtLjcwN0w4LjcwNyA4bDMuNjQ3LTMuNjQ2LS43MDctLjcwOEw4IDcuMjkzIDQuMzU0IDMuNjQ2bC0uNzA3LjcwOEw3LjI5MyA4bC0zLjY0NiAzLjY0Ni43MDcuNzA4TDggOC43MDd6XCJcclxuICAgICAgLz5cclxuICAgIDwvc3ZnPlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENsb3NlSWNvbjtcclxuIiwiaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEljb25Qcm9wcyB9IGZyb20gXCIuXCI7XHJcblxyXG5mdW5jdGlvbiBFbGxpcHNpc0ljb24oeyBzdHlsZSwgZmlsbCB9OiBJY29uUHJvcHMpIHtcclxuICBjb25zdCB7IGNvbG9ycyB9ID0gdXNlVGhlbWUoKTtcclxuICByZXR1cm4gKFxyXG4gICAgPHN2Z1xyXG4gICAgICBzdHlsZT17eyB3aWR0aDogXCIxLjZyZW1cIiwgaGVpZ2h0OiBcIjEuNnJlbVwiLCAuLi5zdHlsZSB9fVxyXG4gICAgICB3aWR0aD1cIjE2XCJcclxuICAgICAgaGVpZ2h0PVwiMTZcIlxyXG4gICAgICB2aWV3Qm94PVwiMCAwIDE2IDE2XCJcclxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXHJcbiAgICAgIGZpbGw9e2ZpbGwgfHwgY29sb3JzLnNjaGVtZS4kd2hpdGV9XHJcbiAgICA+XHJcbiAgICAgIDxwYXRoIGQ9XCJNNCA4YTEgMSAwIDEgMS0yIDAgMSAxIDAgMCAxIDIgMHptNSAwYTEgMSAwIDEgMS0yIDAgMSAxIDAgMCAxIDIgMHptNSAwYTEgMSAwIDEgMS0yIDAgMSAxIDAgMCAxIDIgMHpcIiAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRWxsaXBzaXNJY29uO1xyXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVRoZW1lIH0gZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBJY29uUHJvcHMgfSBmcm9tIFwiLlwiO1xyXG5cclxuZnVuY3Rpb24gRXh0ZW5zaW9uc0ljb24oeyBzdHlsZSwgZmlsbCB9OiBJY29uUHJvcHMpIHtcclxuICBjb25zdCB7IGNvbG9ycyB9ID0gdXNlVGhlbWUoKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMS40cmVtXCIsIGhlaWdodDogXCIxLjRyZW1cIiwgLi4uc3R5bGUgfX1cclxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXHJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG4gICAgICBmaWxsPXtmaWxsIHx8IGNvbG9ycy5zY2hlbWUuJHdoaXRlfVxyXG4gICAgPlxyXG4gICAgICA8cGF0aFxyXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgY2xpcFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICBkPVwiTTEzLjUgMS41TDE1IDBoNy41TDI0IDEuNVY5bC0xLjUgMS41SDE1TDEzLjUgOVYxLjV6bTEuNSAwVjloNy41VjEuNUgxNXpNMCAxNVY2bDEuNS0xLjVIOUwxMC41IDZ2Ny41SDE4bDEuNSAxLjV2Ny41TDE4IDI0SDEuNUwwIDIyLjVWMTV6bTktMS41VjZIMS41djcuNUg5ek05IDE1SDEuNXY3LjVIOVYxNXptMS41IDcuNUgxOFYxNWgtNy41djcuNXpcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhFeHRlbnNpb25zSWNvbik7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEljb25Qcm9wcyB9IGZyb20gXCIuXCI7XHJcblxyXG5mdW5jdGlvbiBGaWxlc0ljb24oeyBzdHlsZSwgZmlsbCB9OiBJY29uUHJvcHMpIHtcclxuICBjb25zdCB7IGNvbG9ycyB9ID0gdXNlVGhlbWUoKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMS40cmVtXCIsIGhlaWdodDogXCIxLjRyZW1cIiwgLi4uc3R5bGUgfX1cclxuICAgICAgdmlld0JveD1cIjAgMCAxNiAxNlwiXHJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG4gICAgICBmaWxsPXtmaWxsIHx8IGNvbG9ycy5zY2hlbWUuJHdoaXRlfVxyXG4gICAgPlxyXG4gICAgICA8cGF0aFxyXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgY2xpcFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICBkPVwiTTEzLjcxIDQuMjlsLTMtM0wxMCAxSDRMMyAydjEybDEgMWg5bDEtMVY1bC0uMjktLjcxek0xMyAxNEg0VjJoNXY0aDR2OHptLTMtOVYybDMgM2gtM3pcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhGaWxlc0ljb24pO1xyXG4iLCJpbXBvcnQgUmVhY3QsIHsgTW91c2VFdmVudEhhbmRsZXIgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEljb25Qcm9wcyA9IHtcclxuICBzdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXM7XHJcbiAgZmlsbD86IHN0cmluZztcclxuICBvbkNsaWNrPzogTW91c2VFdmVudEhhbmRsZXI8U1ZHU1ZHRWxlbWVudD47XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFjdGl2aXR5IEJhciBJY29uc1xyXG4gKi9cclxuZXhwb3J0ICogZnJvbSBcIi4vY2hldnJvblwiO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFjY291bnRJY29uIH0gZnJvbSBcIi4vYWNjb3VudFwiO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIENsb3NlSWNvbiB9IGZyb20gXCIuL2Nsb3NlXCI7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRWxsaXBzaXNJY29uIH0gZnJvbSBcIi4vZWxsaXBzaXNcIjtcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBFeHRlbnNpb25zSWNvbiB9IGZyb20gXCIuL2V4dGVuc2lvbnNcIjtcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaWxlc0ljb24gfSBmcm9tIFwiLi9maWxlc1wiO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bkFuZERlYnVnSWNvbiB9IGZyb20gXCIuL3J1bi1uLWRlYnVnXCI7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VhcmNoSWNvbiB9IGZyb20gXCIuL3NlYXJjaFwiO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNldHRpbmdzR2Vhckljb24gfSBmcm9tIFwiLi9zZXR0aW5ncy1nZWFyXCI7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU291cmNlQ29udHJvbEljb24gfSBmcm9tIFwiLi9zb3VyY2UtY29udHJvbFwiO1xyXG4iLCJpbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XHJcblxyXG5pbXBvcnQgeyBJY29uUHJvcHMgfSBmcm9tIFwiLlwiO1xyXG5cclxuZnVuY3Rpb24gUnVuQW5kRGVidWdJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNHJlbVwiLCBoZWlnaHQ6IFwiMS40cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGggZD1cIk0xMC45NCAxMy41bC0xLjMyIDEuMzJhMy43MyAzLjczIDAgMCAwLTcuMjQgMEwxLjA2IDEzLjUgMCAxNC41NmwxLjcyIDEuNzItLjIyLjIyVjE4SDB2MS41aDEuNXYuMDhjLjA3Ny40ODkuMjE0Ljk2Ni40MSAxLjQyTDAgMjIuOTQgMS4wNiAyNGwxLjY1LTEuNjVBNC4zMDggNC4zMDggMCAwIDAgNiAyNGE0LjMxIDQuMzEgMCAwIDAgMy4yOS0xLjY1TDEwLjk0IDI0IDEyIDIyLjk0IDEwLjA5IDIxYy4xOTgtLjQ2NC4zMzYtLjk1MS40MS0xLjQ1di0uMUgxMlYxOGgtMS41di0xLjVsLS4yMi0uMjJMMTIgMTQuNTZsLTEuMDYtMS4wNnpNNiAxMy41YTIuMjUgMi4yNSAwIDAgMSAyLjI1IDIuMjVoLTQuNUEyLjI1IDIuMjUgMCAwIDEgNiAxMy41em0zIDZhMy4zMyAzLjMzIDAgMCAxLTMgMyAzLjMzIDMuMzMgMCAwIDEtMy0zdi0yLjI1aDZ2Mi4yNXptMTQuNzYtOS45djEuMjZMMTMuNSAxNy4zN1YxNS42bDguNS01LjM3TDkgMnY5LjQ2YTUuMDcgNS4wNyAwIDAgMC0xLjUtLjcyVi42M0w4LjY0IDBsMTUuMTIgOS42elwiIC8+XHJcbiAgICA8L3N2Zz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSZWFjdC5tZW1vKFJ1bkFuZERlYnVnSWNvbik7XHJcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEljb25Qcm9wcyB9IGZyb20gXCIuXCI7XHJcblxyXG5mdW5jdGlvbiBTZWFyY2hJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNHJlbVwiLCBoZWlnaHQ6IFwiMS40cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGggZD1cIk0xNS4yNSAwYTguMjUgOC4yNSAwIDAgMC02LjE4IDEzLjcyTDEgMjIuODhsMS4xMiAxIDguMDUtOS4xMkE4LjI1MSA4LjI1MSAwIDEgMCAxNS4yNS4wMVYwem0wIDE1YTYuNzUgNi43NSAwIDEgMSAwLTEzLjUgNi43NSA2Ljc1IDAgMCAxIDAgMTMuNXpcIiAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhTZWFyY2hJY29uKTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgSWNvblByb3BzIH0gZnJvbSBcIi5cIjtcclxuXHJcbmZ1bmN0aW9uIFNldHRpbmdzR2Vhckljb24oeyBzdHlsZSwgZmlsbCB9OiBJY29uUHJvcHMpIHtcclxuICBjb25zdCB7IGNvbG9ycyB9ID0gdXNlVGhlbWUoKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxzdmdcclxuICAgICAgc3R5bGU9e3sgd2lkdGg6IFwiMS40cmVtXCIsIGhlaWdodDogXCIxLjRyZW1cIiwgLi4uc3R5bGUgfX1cclxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXHJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxyXG4gICAgICBmaWxsPXtmaWxsIHx8IGNvbG9ycy5zY2hlbWUuJHdoaXRlfVxyXG4gICAgPlxyXG4gICAgICA8cGF0aFxyXG4gICAgICAgIGZpbGxSdWxlPVwiZXZlbm9kZFwiXHJcbiAgICAgICAgY2xpcFJ1bGU9XCJldmVub2RkXCJcclxuICAgICAgICBkPVwiTTE5Ljg1IDguNzVsNC4xNS44M3Y0Ljg0bC00LjE1LjgzIDIuMzUgMy41Mi0zLjQzIDMuNDMtMy41Mi0yLjM1LS44MyA0LjE1SDkuNThsLS44My00LjE1LTMuNTIgMi4zNS0zLjQzLTMuNDMgMi4zNS0zLjUyTDAgMTQuNDJWOS41OGw0LjE1LS44M0wxLjggNS4yMyA1LjIzIDEuOGwzLjUyIDIuMzVMOS41OCAwaDQuODRsLjgzIDQuMTUgMy41Mi0yLjM1IDMuNDMgMy40My0yLjM1IDMuNTJ6bS0xLjU3IDUuMDdsNC0uODF2LTJsLTQtLjgxLS41NC0xLjMgMi4yOS0zLjQzLTEuNDMtMS40My0zLjQzIDIuMjktMS4zLS41NC0uODEtNGgtMmwtLjgxIDQtMS4zLjU0LTMuNDMtMi4yOS0xLjQzIDEuNDNMNi4zOCA4LjlsLS41NCAxLjMtNCAuODF2Mmw0IC44MS41NCAxLjMtMi4yOSAzLjQzIDEuNDMgMS40MyAzLjQzLTIuMjkgMS4zLjU0LjgxIDRoMmwuODEtNCAxLjMtLjU0IDMuNDMgMi4yOSAxLjQzLTEuNDMtMi4yOS0zLjQzLjU0LTEuM3ptLTguMTg2LTQuNjcyQTMuNDMgMy40MyAwIDAgMSAxMiA4LjU3IDMuNDQgMy40NCAwIDAgMSAxNS40MyAxMmEzLjQzIDMuNDMgMCAxIDEtNS4zMzYtMi44NTJ6bS45NTYgNC4yNzRjLjI4MS4xODguNjEyLjI4OC45NS4yODhBMS43IDEuNyAwIDAgMCAxMy43MSAxMmExLjcxIDEuNzEgMCAxIDAtMi42NiAxLjQyMnpcIlxyXG4gICAgICAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhTZXR0aW5nc0dlYXJJY29uKTtcclxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgSWNvblByb3BzIH0gZnJvbSBcIi5cIjtcclxuXHJcbmZ1bmN0aW9uIFNvdXJjZUNvbnRyb2xJY29uKHsgc3R5bGUsIGZpbGwgfTogSWNvblByb3BzKSB7XHJcbiAgY29uc3QgeyBjb2xvcnMgfSA9IHVzZVRoZW1lKCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8c3ZnXHJcbiAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNHJlbVwiLCBoZWlnaHQ6IFwiMS40cmVtXCIsIC4uLnN0eWxlIH19XHJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxyXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcclxuICAgICAgZmlsbD17ZmlsbCB8fCBjb2xvcnMuc2NoZW1lLiR3aGl0ZX1cclxuICAgID5cclxuICAgICAgPHBhdGggZD1cIk0yMS4wMDcgOC4yMjJBMy43MzggMy43MzggMCAwIDAgMTUuMDQ1IDUuMmEzLjczNyAzLjczNyAwIDAgMCAxLjE1NiA2LjU4MyAyLjk4OCAyLjk4OCAwIDAgMS0yLjY2OCAxLjY3aC0yLjk5YTQuNDU2IDQuNDU2IDAgMCAwLTIuOTg5IDEuMTY1VjcuNGEzLjczNyAzLjczNyAwIDEgMC0xLjQ5NCAwdjkuMTE3YTMuNzc2IDMuNzc2IDAgMSAwIDEuODE2LjA5OSAyLjk5IDIuOTkgMCAwIDEgMi42NjgtMS42NjdoMi45OWE0LjQ4NCA0LjQ4NCAwIDAgMCA0LjIyMy0zLjAzOSAzLjczNiAzLjczNiAwIDAgMCAzLjI1LTMuNjg3ek00LjU2NSAzLjczOGEyLjI0MiAyLjI0MiAwIDEgMSA0LjQ4NCAwIDIuMjQyIDIuMjQyIDAgMCAxLTQuNDg0IDB6bTQuNDg0IDE2LjQ0MWEyLjI0MiAyLjI0MiAwIDEgMS00LjQ4NCAwIDIuMjQyIDIuMjQyIDAgMCAxIDQuNDg0IDB6bTguMjIxLTkuNzE1YTIuMjQyIDIuMjQyIDAgMSAxIDAtNC40ODUgMi4yNDIgMi4yNDIgMCAwIDEgMCA0LjQ4NXpcIiAvPlxyXG4gICAgPC9zdmc+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhTb3VyY2VDb250cm9sSWNvbik7XHJcbiIsImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZWQsIHsgY3NzIH0gZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBDaGV2cm9uRG93bkljb24sIENoZXZyb25SaWdodEljb24gfSBmcm9tIFwiQHNyYy9hc3NldHMvaWNvbnNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEFjY29yZGlvblNlY3Rpb25Qcm9wcyA9IHtcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XHJcbiAgZGVmYXVsdEV4cGFuZGVkPzogYm9vbGVhbjtcclxuICBoYXNMaW5lPzogYm9vbGVhbjtcclxuICBoZWlnaHQ/OiBzdHJpbmc7XHJcbiAgbWF4SGVpZ2h0Pzogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWNjb3JkaW9uU2VjdGlvbih7XHJcbiAgdGl0bGUsXHJcbiAgY2hpbGRyZW4sXHJcbiAgZGVmYXVsdEV4cGFuZGVkLFxyXG4gIGhhc0xpbmUsXHJcbiAgaGVpZ2h0LFxyXG4gIG1heEhlaWdodCxcclxufTogQWNjb3JkaW9uU2VjdGlvblByb3BzKSB7XHJcbiAgY29uc3QgW2lzRXhwYW5kZWQsIHNldElzRXhwYW5kZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oISFkZWZhdWx0RXhwYW5kZWQpO1xyXG5cclxuICBjb25zdCBoYW5kbGVIZWFkZXJDbGljayA9ICgpID0+IHtcclxuICAgIHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IENoZXZyb25JY29uID0gaXNFeHBhbmRlZCA/IENoZXZyb25Eb3duSWNvbiA6IENoZXZyb25SaWdodEljb247XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8PlxyXG4gICAgICA8SGVhZGVyIG9uQ2xpY2s9e2hhbmRsZUhlYWRlckNsaWNrfSBoYXNMaW5lPXtoYXNMaW5lfT5cclxuICAgICAgICA8Q2hldnJvbkljb24gc3R5bGU9e3sgd2lkdGg6IFwiMXJlbVwiLCBoZWlnaHQ6IFwiMXJlbVwiIH19IC8+XHJcbiAgICAgICAgPFRpdGxlPnt0aXRsZX08L1RpdGxlPlxyXG4gICAgICA8L0hlYWRlcj5cclxuICAgICAgPENvbnRlbnQgaXNFeHBhbmRlZD17aXNFeHBhbmRlZH0gaGVpZ2h0PXtoZWlnaHR9IG1heEhlaWdodD17bWF4SGVpZ2h0fT5cclxuICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIDwvQ29udGVudD5cclxuICAgIDwvPlxyXG4gICk7XHJcbn1cclxuXHJcbmNvbnN0IEhlYWRlciA9IHN0eWxlZC5kaXY8UGljazxBY2NvcmRpb25TZWN0aW9uUHJvcHMsIFwiaGFzTGluZVwiPj5gXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gIHBhZGRpbmc6IDAuNHJlbSAwLjJyZW07XHJcbiAgJHsoeyBoYXNMaW5lIH0pID0+XHJcbiAgICBoYXNMaW5lICYmIFwiYm9yZGVyLXRvcDoxcHggc29saWQgcmdiYSgyMDQsIDIwNCwgMjA0LCAwLjIpO1wifVxyXG5gO1xyXG5cclxuY29uc3QgVGl0bGUgPSBzdHlsZWQuYmBcclxuICBmb250LXNpemU6IDAuOHJlbTtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG5cclxuICBwYWRkaW5nLWxlZnQ6IDAuNHJlbTtcclxuYDtcclxuXHJcbmNvbnN0IGhpZGVTY3JvbGxiYXIgPSBjc3NgXHJcbiAgJjo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG4gICAgLyogQ2hyb21lLCBTYWZhcmkgYW5kIE9wZXJhICovXHJcbiAgICBkaXNwbGF5OiBub25lO1xyXG4gIH1cclxuXHJcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAvKiBJRSBhbmQgRWRnZSAqL1xyXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgLyogRmlyZWZveCAqL1xyXG5gO1xyXG5cclxuY29uc3QgQ29udGVudCA9IHN0eWxlZC5kaXY8e1xyXG4gIGlzRXhwYW5kZWQ6IGJvb2xlYW47XHJcbiAgaGVpZ2h0Pzogc3RyaW5nO1xyXG4gIG1heEhlaWdodD86IHN0cmluZztcclxufT5gXHJcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xyXG4gIG92ZXJmbG93LXk6IGF1dG87XHJcblxyXG4gICR7KHsgaXNFeHBhbmRlZCwgaGVpZ2h0IH0pID0+XHJcbiAgICBoZWlnaHRcclxuICAgICAgPyBgaGVpZ2h0OiR7aXNFeHBhbmRlZCA/IGhlaWdodCA6IDB9O2BcclxuICAgICAgOiBgZmxleDoke2lzRXhwYW5kZWQgPyAxIDogMH07YH1cclxuICAkeyh7IG1heEhlaWdodCB9KSA9PiAobWF4SGVpZ2h0ID8gYG1heC1oZWlnaHQ6ICR7bWF4SGVpZ2h0fTtgIDogXCJcIil9O1xyXG5cclxuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dDtcclxuXHJcbiAgJHtoaWRlU2Nyb2xsYmFyfVxyXG5gO1xyXG4iLCJpbXBvcnQgeyBSZWFjdEVsZW1lbnQsIHVzZVN0YXRlLCBNb3VzZUV2ZW50LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuY29uc3QgREVGQVVMVF9QQUdFX1NJWkUgPSAyMDtcclxuXHJcbnR5cGUgU2Nyb2xsUGFnZW5hdGlvblByb3BzPFREYXRhID0gYW55PiA9IHtcclxuICBkYXRhOiBURGF0YVtdO1xyXG4gIHBhZ2VTaXplPzogbnVtYmVyO1xyXG4gIHJlbmRlckl0ZW06IChjdXJyOiBURGF0YSwgcHJldj86IFREYXRhKSA9PiBSZWFjdEVsZW1lbnQ8SFRNTExJRWxlbWVudD47XHJcbiAgb25DbGljaz86IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gU2Nyb2xsUGFnZW5hdGlvbih7XHJcbiAgZGF0YTogaW5pdGlhbERhdGEsXHJcbiAgcGFnZVNpemUgPSBERUZBVUxUX1BBR0VfU0laRSxcclxuICByZW5kZXJJdGVtLFxyXG4gIG9uQ2xpY2ssXHJcbn06IFNjcm9sbFBhZ2VuYXRpb25Qcm9wcykge1xyXG4gIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VSZWY8SFRNTFVMaXN0RWxlbWVudD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlKGluaXRpYWxEYXRhLnNsaWNlKDAsIHBhZ2VTaXplKSk7XHJcbiAgY29uc3QgW2hhc01vcmUsIHNldEhhc01vcmVdID0gdXNlU3RhdGUodHJ1ZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBzZXREYXRhKGluaXRpYWxEYXRhLnNsaWNlKDAsIHBhZ2VTaXplKSk7XHJcbiAgfSwgW2luaXRpYWxEYXRhLCBwYWdlU2l6ZV0pO1xyXG5cclxuICBjb25zdCBoYW5kbGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICBpZiAoIXdyYXBwZXJSZWYuY3VycmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxIZWlnaHQgfSA9IHdyYXBwZXJSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHNjcm9sbFRvcCArIGNsaWVudEhlaWdodDtcclxuICAgIC8vIOuqqOuToCDsiqTtgazroaTsnYQg64K066C47J2EIOuVjFxyXG4gICAgaWYgKHNjcm9sbEJvdHRvbSA+PSBzY3JvbGxIZWlnaHQpIHtcclxuICAgICAgbG9hZE1vcmUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCF3cmFwcGVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHdyYXBwZXJSZWYuY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW3dyYXBwZXJSZWZdKTtcclxuXHJcbiAgY29uc3QgZ2V0TmV4dERhdGEgPSAoe1xyXG4gICAgb2Zmc2V0LFxyXG4gICAgbGltaXQsXHJcbiAgfToge1xyXG4gICAgb2Zmc2V0OiBudW1iZXI7XHJcbiAgICBsaW1pdDogbnVtYmVyO1xyXG4gIH0pID0+IHtcclxuICAgIHJldHVybiBpbml0aWFsRGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBsb2FkTW9yZSA9ICgpID0+IHtcclxuICAgIGlmIChoYXNNb3JlKSB7XHJcbiAgICAgIHNldERhdGEoKHByZXZEYXRhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBnZXROZXh0RGF0YSh7XHJcbiAgICAgICAgICBvZmZzZXQ6IHByZXZEYXRhLmxlbmd0aCxcclxuICAgICAgICAgIGxpbWl0OiBwYWdlU2l6ZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmV4dERhdGEubGVuZ3RoIDwgcGFnZVNpemUpIHtcclxuICAgICAgICAgIHNldEhhc01vcmUoZmFsc2UpO1xyXG4gICAgICAgICAgd3JhcHBlclJlZi5jdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gWy4uLnByZXZEYXRhLCAuLi5uZXh0RGF0YV07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8V3JhcHBlciByZWY9e3dyYXBwZXJSZWZ9IG9uQ2xpY2s9e29uQ2xpY2t9PlxyXG4gICAgICB7ZGF0YS5tYXAoKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSA9PT0gMCA/IG51bGwgOiBkYXRhW2kgLSAxXSkpfVxyXG4gICAgPC9XcmFwcGVyPlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFBhZ2VuYXRpb247XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLnVsYFxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcblxyXG4gIG92ZXJmbG93LXk6IGF1dG87XHJcbmA7XHJcblxyXG5jb25zdCBNb3JlID0gc3R5bGVkLmRpdmBcclxuICB3aWR0aDogMTAwJTtcclxuICBoZWlnaHQ6IDJyZW07XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XHJcbmA7XHJcbiIsImltcG9ydCB7IFJlYWN0Tm9kZSwgQW5jaG9ySFRNTEF0dHJpYnV0ZXMgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5cclxudHlwZSBUYWdQcm9wcyA9IHtcclxuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xyXG4gIGNvdW50PzogbnVtYmVyO1xyXG4gIC8qKiBAZGVmYXVsdCB0cnVlICovXHJcbiAgY2xpY2thYmxlPzogYm9vbGVhbjtcclxufSAmIEFuY2hvckhUTUxBdHRyaWJ1dGVzPEhUTUxBbmNob3JFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRhZyh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgY291bnQsXHJcbiAgY2xpY2thYmxlID0gdHJ1ZSxcclxuICBocmVmLFxyXG4gIC4uLnByb3BzXHJcbn06IFRhZ1Byb3BzKSB7XHJcbiAgY29uc3QgdGFnRGVmYXVsdCA9IChcclxuICAgIDxXcmFwcGVyIHsuLi5wcm9wc30gY2xpY2thYmxlPXtjbGlja2FibGV9PlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICAgIHtjb3VudCAhPSBudWxsICYmIDxDb3VudD57Y291bnR9PC9Db3VudD59XHJcbiAgICA8L1dyYXBwZXI+XHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIGhyZWYgPyAoXHJcbiAgICA8TGluayBocmVmPXtocmVmfSBwYXNzSHJlZj5cclxuICAgICAge3RhZ0RlZmF1bHR9XHJcbiAgICA8L0xpbms+XHJcbiAgKSA6IChcclxuICAgIHRhZ0RlZmF1bHRcclxuICApO1xyXG59XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmE8UGljazxUYWdQcm9wcywgXCJjbGlja2FibGVcIj4+YFxyXG4gIG1hcmdpbjogMCAwLjhyZW0gMC44cmVtIDA7XHJcbiAgcGFkZGluZzogMC4ycmVtIDAuNnJlbTtcclxuICBib3JkZXItcmFkaXVzOiAwLjhyZW07XHJcblxyXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xyXG4gIGNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmNvbG9ycy5zY2hlbWUuJHRhZ0ZvbnRDb2xvcn07O1xyXG4gIGJhY2tncm91bmQtY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLnNjaGVtZS4kZ3JheTMwMH07XHJcblxyXG4gICR7KHApID0+XHJcbiAgICBwLmNsaWNrYWJsZSAmJlxyXG4gICAgYFxyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgJjpob3ZlciB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7cC50aGVtZS5jb2xvcnMuc2NoZW1lLiRncmF5NDAwfTtcclxuICAgIH1cclxuICBgfVxyXG5gO1xyXG5cclxuY29uc3QgQ291bnQgPSBzdHlsZWQuc3BhbmBcclxuICBtYXJnaW4tbGVmdDogMC40cmVtO1xyXG5cclxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuc2NoZW1lLiRncmF5MTAwfTtcclxuYDtcclxuIiwiaW1wb3J0IHsgS2V5Ym9hcmRFdmVudCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgQkxBQ0ssIFdISVRFIH0gZnJvbSBcIkBzcmMvY29uc3RhbnRzL3BhbGV0dGVcIjtcclxuXHJcbmltcG9ydCB7IHVzZVRoZW1lQ29udGV4dCB9IGZyb20gXCJAc3JjL2NvbnRleHRzL3RoZW1lXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUaGVtZVN3aXRjaGVyKCkge1xyXG4gIGNvbnN0IHtcclxuICAgIHN0YXRlOiB7IHRoZW1lIH0sXHJcbiAgICBhY3Rpb246IHsgdG9nZ2xlVGhlbWUgfSxcclxuICB9ID0gdXNlVGhlbWVDb250ZXh0KCk7XHJcblxyXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gKCkgPT4ge1xyXG4gICAgdG9nZ2xlVGhlbWUoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgIGlmIChbXCJFbnRlclwiLCBcIiBcIl0uaW5jbHVkZXMoZS5rZXkpKSB7XHJcbiAgICAgIGhhbmRsZUNsaWNrKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxXcmFwcGVyIHRhYkluZGV4PXswfSBvbkNsaWNrPXtoYW5kbGVDbGlja30gb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufT5cclxuICAgICAgPHNwYW4+8J+MnTwvc3Bhbj5cclxuICAgICAgPHNwYW4+8J+Mnjwvc3Bhbj5cclxuICAgICAgPENpcmNsZSBtb2RlPXt0aGVtZX0gLz5cclxuICAgIDwvV3JhcHBlcj5cclxuICApO1xyXG59XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdmBcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcblxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuXHJcbiAgd2lkdGg6IDEuMnJlbTtcclxuICBoZWlnaHQ6IDIuOHJlbTtcclxuICBib3JkZXItcmFkaXVzOiAwLjZyZW07XHJcblxyXG4gIGJhY2tncm91bmQtY29sb3I6ICR7QkxBQ0t9O1xyXG5cclxuICBvdXRsaW5lOiAycHggc29saWQgJHtCTEFDS307XHJcblxyXG4gICY6Zm9jdXMge1xyXG4gICAgb3V0bGluZTogMnB4IHNvbGlkICR7V0hJVEV9O1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IENpcmNsZSA9IHN0eWxlZC5kaXY8eyBtb2RlOiBcImxpZ2h0XCIgfCBcImRhcmtcIiB9PmBcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgJHsoeyBtb2RlIH0pID0+IChtb2RlID09PSBcImxpZ2h0XCIgPyBcInRvcDogMDtcIiA6IFwiYm90dG9tOiAwO1wiKX07XHJcblxyXG4gIHdpZHRoOiAxLjJyZW07XHJcbiAgaGVpZ2h0OiAxLjJyZW07XHJcblxyXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuXHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJHtXSElURX07XHJcblxyXG4gIHRyYW5zaXRpb246IGFsbCAwLjJzO1xyXG5cclxuICB1c2VyLXNlbGVjdDogYXV0bztcclxuYDtcclxuIiwiZXhwb3J0IGNvbnN0IFdISVRFID0gXCIjRkZGXCI7XHJcbmV4cG9ydCBjb25zdCBCTEFDSyA9IFwiIzAwMFwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERSQUNVTEFSX0JBQ0tHUk9VTkRfTElHSFRfREFSSyA9IFwiIzM4M2E1OVwiO1xyXG5leHBvcnQgY29uc3QgRFJBQ1VMQVJfQkFDS0dST1VORF9ERUVQX0RBUksgPSBcIiMyODJhMzZcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBZRUxMT1cgPSBcIiNGMUZBOENcIjtcclxuZXhwb3J0IGNvbnN0IEJMVUUgPSBcIiM4QkU5RkRcIjtcclxuZXhwb3J0IGNvbnN0IFBJTksgPSBcIiNGRjc5QzZcIjtcclxuZXhwb3J0IGNvbnN0IE9SQU5HRSA9IFwiI0ZGQjg2Q1wiO1xyXG5leHBvcnQgY29uc3QgR1JFRU4gPSBcIiMzZWU2NjhcIjtcclxuZXhwb3J0IGNvbnN0IFBVUlBMRSA9IFwiI0JEOTNGOVwiO1xyXG5leHBvcnQgY29uc3QgUFVSUExFX0RBUksgPSBcIiMyNTI1M0FcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBHUkFZXzEwMCA9IFwiIzdhN2E3YVwiO1xyXG5leHBvcnQgY29uc3QgR1JBWV8yMDAgPSBcIiM1MDUwNTBcIjtcclxuZXhwb3J0IGNvbnN0IEdSQVlfMzAwID0gXCIjM2MzYzNjXCI7XHJcbmV4cG9ydCBjb25zdCBHUkFZXzQwMCA9IFwiIzMzMzMzM1wiO1xyXG5leHBvcnQgY29uc3QgR1JBWV81MDAgPSBcIiMyNTI1MjZcIjtcclxuZXhwb3J0IGNvbnN0IEdSQVlfNjAwID0gXCIjMWUxZTFlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgTElHSFRfR1JBWV8xMDAgPSBcIiNGM0YzRjNcIjtcclxuZXhwb3J0IGNvbnN0IExJR0hUX0dSQVlfMjAwID0gXCIjRUFFQUVBXCI7XHJcbmV4cG9ydCBjb25zdCBMSUdIVF9HUkFZXzMwMCA9IFwiI0UxRTFFMVwiO1xyXG5leHBvcnQgY29uc3QgTElHSFRfR1JBWV80MDAgPSBcIiNENkQ2RDZcIjtcclxuIiwiaW1wb3J0IHsgdXNlU3RhdGUsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9yb3V0ZXJcIjtcclxuXHJcbmltcG9ydCB7IFBvc3QgfSBmcm9tIFwiQHNyYy90eXBlcy9wb3N0LnR5cGVcIjtcclxuXHJcbmltcG9ydCB7IElBcHBDb250ZXh0IH0gZnJvbSBcIi4vSUFwcENvbnRleHRcIjtcclxuXHJcbmNvbnN0IEFwcENvbnRleHQgPSBjcmVhdGVDb250ZXh0PElBcHBDb250ZXh0Pih1bmRlZmluZWQhKTtcclxuXHJcbmNvbnN0IHVzZUFwcENvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xyXG5cclxudHlwZSBBcHBDb250ZXh0UHJvdmlkZXJQcm9wcyA9IHtcclxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xyXG4gIHBvc3RzOiBQb3N0W107XHJcbn07XHJcblxyXG5jb25zdCBBcHBDb250ZXh0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgcG9zdHMgfTogQXBwQ29udGV4dFByb3ZpZGVyUHJvcHMpID0+IHtcclxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcclxuXHJcbiAgY29uc3QgW29wZW5Qb3N0cywgc2V0T3BlblBvc3RzXSA9IHVzZVN0YXRlPFBvc3RbXT4oW10pO1xyXG4gIGNvbnN0IFtjdXJyZW50UG9zdElkLCBzZXRDdXJyZW50UG9zdElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoY3VycmVudFBvc3RJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJvdXRlci5wdXNoKGN1cnJlbnRQb3N0SWQgPyBgL2Jsb2cvJHtjdXJyZW50UG9zdElkfWAgOiBcIi9ibG9nXCIpO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gIH0sIFtjdXJyZW50UG9zdElkXSk7XHJcblxyXG4gIGNvbnN0IHNlbGVjdFBvc3QgPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgc2V0Q3VycmVudFBvc3RJZChpZCk7XHJcblxyXG4gICAgaWYgKG9wZW5Qb3N0cy5maW5kKChwb3N0KSA9PiBwb3N0LmlkID09PSBpZCkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0UG9zdCA9IHBvc3RzLmZpbmQoKHBvc3QpID0+IHBvc3QuaWQgPT09IGlkKTtcclxuICAgIHRhcmdldFBvc3QgJiYgc2V0T3BlblBvc3RzKFsuLi5vcGVuUG9zdHMsIHRhcmdldFBvc3RdKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBjbG9zZVBvc3QgPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgbmV3T3BlblBvc3RzID0gb3BlblBvc3RzLmZpbHRlcigocG9zdCkgPT4gcG9zdC5pZCAhPT0gaWQpO1xyXG4gICAgc2V0T3BlblBvc3RzKG5ld09wZW5Qb3N0cyk7XHJcblxyXG4gICAgaWYgKG5ld09wZW5Qb3N0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgc2V0Q3VycmVudFBvc3RJZChudWxsKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpZCA9PT0gY3VycmVudFBvc3RJZCkge1xyXG4gICAgICBzZXRDdXJyZW50UG9zdElkKG5ld09wZW5Qb3N0c1tuZXdPcGVuUG9zdHMubGVuZ3RoIC0gMV0uaWQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGFwcFN0b3JlOiBJQXBwQ29udGV4dCA9IHtcclxuICAgIHN0YXRlOiB7XHJcbiAgICAgIHBvc3RzLFxyXG4gICAgICBvcGVuUG9zdHMsXHJcbiAgICAgIGN1cnJlbnRQb3N0SWQsXHJcbiAgICB9LFxyXG4gICAgYWN0aW9uOiB7XHJcbiAgICAgIHNlbGVjdFBvc3QsXHJcbiAgICAgIGNsb3NlUG9zdCxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIDxBcHBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthcHBTdG9yZX0+e2NoaWxkcmVufTwvQXBwQ29udGV4dC5Qcm92aWRlcj47XHJcbn07XHJcblxyXG5leHBvcnQgeyBBcHBDb250ZXh0UHJvdmlkZXIsIHVzZUFwcENvbnRleHQgfTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuZXhwb3J0IHR5cGUgVGhlbWVUeXBlID0gXCJkYXJrXCIgfCBcImxpZ2h0XCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUaGVtZUNvbnRleHQge1xyXG4gIHN0YXRlOiB7XHJcbiAgICB0aGVtZTogVGhlbWVUeXBlO1xyXG4gIH07XHJcbiAgYWN0aW9uOiB7XHJcbiAgICB0b2dnbGVUaGVtZTogKCkgPT4gdm9pZDtcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxJVGhlbWVDb250ZXh0Pih1bmRlZmluZWQhKTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VUaGVtZUNvbnRleHQgPSAoKSA9PiB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XHJcbiIsImV4cG9ydCAqIGZyb20gXCIuL2NvbnRleHRcIjtcclxuXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGhlbWVDb250ZXh0UHJvdmlkZXIgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xyXG4iLCJpbXBvcnQgeyBSZWFjdE5vZGUsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IFRoZW1lUHJvdmlkZXIgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IGxpZ2h0LCBkYXJrIH0gZnJvbSBcIkBzcmMvdGhlbWVzXCI7XHJcblxyXG5pbXBvcnQgeyBJVGhlbWVDb250ZXh0LCBUaGVtZUNvbnRleHQsIFRoZW1lVHlwZSB9IGZyb20gXCIuL2NvbnRleHRcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFRoZW1lQ29udGV4dFByb3ZpZGVyUHJvcHMgPSB7XHJcbiAgZGVmYXVsdFRoZW1lOiBUaGVtZVR5cGU7XHJcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRoZW1lQ29udGV4dFByb3ZpZGVyKHtcclxuICBkZWZhdWx0VGhlbWUsXHJcbiAgY2hpbGRyZW4sXHJcbn06IFRoZW1lQ29udGV4dFByb3ZpZGVyUHJvcHMpIHtcclxuICBjb25zdCBbdGhlbWUsIHNldFRoZW1lXSA9IHVzZVN0YXRlPFRoZW1lVHlwZT4oZGVmYXVsdFRoZW1lKTtcclxuXHJcbiAgY29uc3QgdG9nZ2xlVGhlbWUgPSAoKSA9PiB7XHJcbiAgICBzZXRUaGVtZSh0aGVtZSA9PT0gXCJsaWdodFwiID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHRoZW1lU3RvcmU6IElUaGVtZUNvbnRleHQgPSB7XHJcbiAgICBzdGF0ZToge1xyXG4gICAgICB0aGVtZSxcclxuICAgIH0sXHJcbiAgICBhY3Rpb246IHtcclxuICAgICAgdG9nZ2xlVGhlbWUsXHJcbiAgICB9LFxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8VGhlbWVQcm92aWRlciB0aGVtZT17eyBjb2xvcnM6IHRoZW1lID09PSBcImxpZ2h0XCIgPyBsaWdodCA6IGRhcmsgfX0+XHJcbiAgICAgIDxUaGVtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3RoZW1lU3RvcmV9PlxyXG4gICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgPC9UaGVtZUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICA8L1RoZW1lUHJvdmlkZXI+XHJcbiAgKTtcclxufVxyXG4iLCJleHBvcnQgY29uc3QgR0FfVFJBQ0tJTkdfSUQgPSBwcm9jZXNzLmVudi5HQV9NRUFTVVJFTUVOVF9JRCB8fCBcIlwiO1xyXG5cclxudHlwZSBHVGFnUGFnZXZpZXcgPSB7XHJcbiAgdXJsOiBVUkw7XHJcbiAgdGl0bGU/OiBzdHJpbmc7XHJcbiAgaHJlZj86IHN0cmluZztcclxufTtcclxuXHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9ndGFnanMvcGFnZXNcclxuZXhwb3J0IGNvbnN0IHBhZ2V2aWV3ID0gKHsgdXJsLCB0aXRsZSwgaHJlZiB9OiBHVGFnUGFnZXZpZXcpID0+IHtcclxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgJiZcclxuICAgIHdpbmRvdy5ndGFnKFwiY29uZmlnXCIsIEdBX1RSQUNLSU5HX0lELCB7XHJcbiAgICAgIHBhZ2VfcGF0aDogdXJsLFxyXG4gICAgICBwYWdlX3RpdGxlOiB0aXRsZSxcclxuICAgICAgcGFnZV9sb2NhdGlvbjogaHJlZixcclxuICAgIH0pO1xyXG59O1xyXG5cclxudHlwZSBHVGFnRXZlbnQgPSB7XHJcbiAgYWN0aW9uOiBzdHJpbmc7XHJcbiAgY2F0ZWdvcnk6IHN0cmluZztcclxuICBsYWJlbDogc3RyaW5nO1xyXG4gIHZhbHVlOiBudW1iZXI7XHJcbn07XHJcblxyXG4vLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9hbmFseXRpY3MvZGV2Z3VpZGVzL2NvbGxlY3Rpb24vZ3RhZ2pzL2V2ZW50c1xyXG5leHBvcnQgY29uc3QgZXZlbnQgPSAoeyBhY3Rpb24sIGNhdGVnb3J5LCBsYWJlbCwgdmFsdWUgfTogR1RhZ0V2ZW50KSA9PiB7XHJcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiICYmXHJcbiAgICB3aW5kb3cuZ3RhZyhcImV2ZW50XCIsIGFjdGlvbiwge1xyXG4gICAgICBldmVudF9jYXRlZ29yeTogY2F0ZWdvcnksXHJcbiAgICAgIGV2ZW50X2xhYmVsOiBsYWJlbCxcclxuICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgfSk7XHJcbn07XHJcbiIsImV4cG9ydCAqIGZyb20gXCIuL21hcmtkb3duLmhlbHBlclwiO1xyXG4iLCJpbXBvcnQgbWFya2VkIGZyb20gXCJtYXJrZWRcIjtcclxuaW1wb3J0IHByaXNtIGZyb20gXCJwcmlzbWpzXCI7XHJcblxyXG5pbXBvcnQgXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwLXRlbXBsYXRpbmdcIjtcclxuaW1wb3J0IFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzc1wiO1xyXG5pbXBvcnQgXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanNvblwiO1xyXG5pbXBvcnQgXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YXNjcmlwdFwiO1xyXG5pbXBvcnQgXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHlwZXNjcmlwdFwiO1xyXG5pbXBvcnQgXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanN4XCI7XHJcbmltcG9ydCBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS10c3hcIjtcclxuaW1wb3J0IFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWJhc2hcIjtcclxuaW1wb3J0IFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXlhbWxcIjtcclxuXHJcbm1hcmtlZC5zZXRPcHRpb25zKHtcclxuICBoaWdobGlnaHQ6IChjb2RlLCBsYW5nKSA9PiB7XHJcbiAgICBpZiAocHJpc20ubGFuZ3VhZ2VzW2xhbmddKSB7XHJcbiAgICAgIHJldHVybiBwcmlzbS5oaWdobGlnaHQoY29kZSwgcHJpc20ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhcnNlTWFya2Rvd24gPSAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICByZXR1cm4gbWFya2VkLnBhcnNlKHRleHQpO1xyXG59O1xyXG4iLCJleHBvcnQgKiBmcm9tIFwiLi91c2VDYW52YXNDb250ZXh0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3VzZURyYWdcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vdXNlUmVzaXplRGV0ZWN0b3JcIjtcclxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQ2FudmFzQ29udGV4dCA9ICgpID0+IHtcclxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG5cclxuICBjb25zdCBbY29udGV4dCwgc2V0Q29udGV4dF0gPSB1c2VTdGF0ZTxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsPigpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcblxyXG4gICAgc2V0Q29udGV4dChjdHgpO1xyXG4gIH0sIFtjYW52YXNSZWZdKTtcclxuXHJcbiAgcmV0dXJuIHsgY2FudmFzUmVmLCBjb250ZXh0IH07XHJcbn07XHJcbiIsImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIE1vdXNlRXZlbnRIYW5kbGVyIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5leHBvcnQgdHlwZSBDb29yZGluYXRlID0geyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuZXhwb3J0IHR5cGUgT25EcmFnID0gKG1vdmVtZW50OiBDb29yZGluYXRlKSA9PiB2b2lkO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZURyYWcgPSAob25EcmFnOiBPbkRyYWcpID0+IHtcclxuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW3N0YXJ0LCBzZXRTdGFydF0gPSB1c2VTdGF0ZTxDb29yZGluYXRlPih7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgIG9uRHJhZyh7IHg6IGUuY2xpZW50WCAtIHN0YXJ0LngsIHk6IGUuY2xpZW50WSAtIHN0YXJ0LnkgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9ICgpID0+IHtcclxuICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XHJcbiAgICAgIHNldFN0YXJ0KHsgeDogMCwgeTogMCB9KTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGlzRHJhZ2dpbmcpIHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZU1vdXNlVXApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBoYW5kbGVNb3VzZVVwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8g7KO87J2YIDogb25EcmFn6rCAIGRlcGVuZGVuY2llcyDrsLDsl7Tsl5Ag65Ok7Ja06rCA66m0IOyYpOyekeuPme2VnOuLpC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICB9LCBbaXNEcmFnZ2luZywgc3RhcnRdKTtcclxuXHJcbiAgY29uc3Qgc3RhcnREcmFnOiBNb3VzZUV2ZW50SGFuZGxlciA9IChlKSA9PiB7XHJcbiAgICBzZXRJc0RyYWdnaW5nKHRydWUpO1xyXG4gICAgc2V0U3RhcnQoeyB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WSB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4geyBpc0RyYWdnaW5nLCBzdGFydERyYWcgfTtcclxufTtcclxuIiwiaW1wb3J0IHsgUmVmT2JqZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbnR5cGUgU2l6ZVR5cGUgPSB7XHJcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICBoZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VSZXNpemVEZXRlY3RvciA9IDxUID0gYW55PigpOiBTaXplVHlwZSAmIHtcclxuICByZWY6IFJlZk9iamVjdDxUPjtcclxufSA9PiB7XHJcbiAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KG51bGwpO1xyXG5cclxuICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSB1c2VTdGF0ZTxTaXplVHlwZT4oe1xyXG4gICAgd2lkdGg6IHVuZGVmaW5lZCxcclxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxyXG4gIH0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY2FsbGJhY2s6IFJlc2l6ZU9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xyXG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSAoZW50cnkgJiYgZW50cnkuY29udGVudFJlY3QpIHx8IHt9O1xyXG4gICAgICAgIHNldFNpemUoeyB3aWR0aCwgaGVpZ2h0IH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spO1xyXG4gICAgcmVmLmN1cnJlbnQgJiYgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWYuY3VycmVudCBhcyBhbnkpO1xyXG4gICAgcmV0dXJuICgpID0+IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIHJldHVybiB7IHdpZHRoOiBzaXplLndpZHRoLCBoZWlnaHQ6IHNpemUuaGVpZ2h0LCByZWYgfTtcclxufTtcclxuIiwiaW1wb3J0IFJlYWN0LCB7IEVsZW1lbnRUeXBlLCBLZXlib2FyZEV2ZW50LCBGb3J3YXJkZWRSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEdSQVlfMTAwLCBXSElURSB9IGZyb20gXCJAc3JjL2NvbnN0YW50cy9wYWxldHRlXCI7XHJcblxyXG5leHBvcnQgdHlwZSBBY3Rpb25JdGVtUHJvcHMgPSB7XHJcbiAgSWNvbjogRWxlbWVudFR5cGU7XHJcbiAgaXNTZWxlY3RlZD86IGJvb2xlYW47XHJcbiAgb25DbGljazogKCkgPT4gdm9pZDtcclxuICBvbktleURvd24/OiAoZTogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcclxufTtcclxuXHJcbmNvbnN0IEFjdGlvbkl0ZW0gPSBSZWFjdC5mb3J3YXJkUmVmKFxyXG4gIChcclxuICAgIHtcclxuICAgICAgSWNvbixcclxuICAgICAgaXNTZWxlY3RlZCA9IGZhbHNlLFxyXG4gICAgICBvbkNsaWNrLFxyXG4gICAgICBvbktleURvd24gPSAoKSA9PiBudWxsLFxyXG4gICAgfTogQWN0aW9uSXRlbVByb3BzLFxyXG4gICAgcmVmOiBGb3J3YXJkZWRSZWY8SFRNTExJRWxlbWVudD5cclxuICApID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxXcmFwcGVyXHJcbiAgICAgICAgcmVmPXtyZWZ9XHJcbiAgICAgICAgdGFiSW5kZXg9ezB9XHJcbiAgICAgICAgb25DbGljaz17b25DbGlja31cclxuICAgICAgICBvbktleURvd249e29uS2V5RG93bn1cclxuICAgICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxyXG4gICAgICA+XHJcbiAgICAgICAgPEljb25cclxuICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiBcIjEuNHJlbVwiLCBoZWlndGg6IFwiMS40cmVtXCIgfX1cclxuICAgICAgICAgIGZpbGw9e2lzU2VsZWN0ZWQgPyBXSElURSA6IEdSQVlfMTAwfVxyXG4gICAgICAgIC8+XHJcbiAgICAgIDwvV3JhcHBlcj5cclxuICAgICk7XHJcbiAgfVxyXG4pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWN0aW9uSXRlbTtcclxuXHJcbmNvbnN0IFdyYXBwZXIgPSBzdHlsZWQubGk8eyBpc1NlbGVjdGVkPzogYm9vbGVhbiB9PmBcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gIHdpZHRoOiAzcmVtO1xyXG4gIGhlaWdodDogM3JlbTtcclxuICAkeyh7IGlzU2VsZWN0ZWQgfSkgPT5cclxuICAgIGBib3JkZXItbGVmdDogMC4xNnJlbSBzb2xpZCAke2lzU2VsZWN0ZWQgPyBXSElURSA6IFwidHJhbnNwYXJlbnRcIn1gfTtcclxuYDtcclxuIiwiaW1wb3J0IHsgRWxlbWVudFR5cGUsIFJlYWN0Tm9kZSwgS2V5Ym9hcmRFdmVudCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQge1xyXG4gIEZpbGVzSWNvbixcclxuICBTZWFyY2hJY29uLFxyXG4gIFNvdXJjZUNvbnRyb2xJY29uLFxyXG4gIFJ1bkFuZERlYnVnSWNvbixcclxuICBFeHRlbnNpb25zSWNvbixcclxuICBBY2NvdW50SWNvbixcclxuICBTZXR0aW5nc0dlYXJJY29uLFxyXG59IGZyb20gXCJAc3JjL2Fzc2V0cy9pY29uc1wiO1xyXG5pbXBvcnQgeyBEUkFDVUxBUl9CQUNLR1JPVU5EX0xJR0hUX0RBUkssIEdSQVlfNDAwIH0gZnJvbSBcIkBzcmMvY29uc3RhbnRzL3BhbGV0dGVcIjtcclxuaW1wb3J0IFRoZW1lU3dpdGNoZXIgZnJvbSBcIkBzcmMvY29tcG9uZW50cy9jb21tb24vdGhlbWUtc3dpdGNoZXJcIjtcclxuXHJcbmltcG9ydCBFeHBsb3JlclNlY3Rpb24gZnJvbSBcIi4uL2V4cGxvcmVyLXNlY3Rpb25cIjtcclxuaW1wb3J0IExvZ1NlY3Rpb24gZnJvbSBcIi4uL2xvZy1zZWN0aW9uXCI7XHJcbmltcG9ydCBTZWFyY2hTZWN0aW9uIGZyb20gXCIuLi9zZWFyY2gtc2VjdGlvblwiO1xyXG5cclxuaW1wb3J0IEFjdGlvbkl0ZW0gZnJvbSBcIi4vYWN0aW9uLWl0ZW1cIjtcclxuXHJcbmNvbnN0IEdJVEhVQl9VUkwgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9saWtlbGlvblN1bmdHdWtcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBBQ1RJVklUWV9CQVJfV0lEVEggPSBcIjNyZW1cIjtcclxuXHJcbmV4cG9ydCB0eXBlIEFjdGlvbkl0ZW1UeXBlID0ge1xyXG4gIGxhYmVsOiBzdHJpbmc7XHJcbiAgSWNvbjogRWxlbWVudFR5cGU7XHJcbiAgY29udGVudD86IFJlYWN0Tm9kZTtcclxuICBocmVmPzogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFDVElPTl9JVEVNUzogQWN0aW9uSXRlbVR5cGVbXSA9IFtcclxuICB7XHJcbiAgICBsYWJlbDogXCJFWFBMT1JFUlwiLFxyXG4gICAgSWNvbjogRmlsZXNJY29uLFxyXG4gICAgY29udGVudDogPEV4cGxvcmVyU2VjdGlvbiAvPixcclxuICB9LFxyXG4gIHtcclxuICAgIGxhYmVsOiBcIlNFQVJDSFwiLFxyXG4gICAgSWNvbjogU2VhcmNoSWNvbixcclxuICAgIGNvbnRlbnQ6IDxTZWFyY2hTZWN0aW9uIC8+LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgbGFiZWw6IFwiUE9TVElORyBMT0dcIixcclxuICAgIEljb246IFNvdXJjZUNvbnRyb2xJY29uLFxyXG4gICAgY29udGVudDogPExvZ1NlY3Rpb24gLz4sXHJcbiAgfSxcclxuICB7XHJcbiAgICBsYWJlbDogXCJSVU4gQU5EIERFQlVHXCIsXHJcbiAgICBJY29uOiBSdW5BbmREZWJ1Z0ljb24sXHJcbiAgICBjb250ZW50OiBcIlJVTiBBTkQgREVCVUdcIixcclxuICB9LFxyXG4gIHtcclxuICAgIGxhYmVsOiBcIkVYVEVOU0lPTlNcIixcclxuICAgIEljb246IEV4dGVuc2lvbnNJY29uLFxyXG4gICAgY29udGVudDogXCJFWFRFTlNJT05TXCIsXHJcbiAgfSxcclxuXTtcclxuXHJcbnR5cGUgQWN0aXZpdHlCYXJQcm9wcyA9IHtcclxuICBjdXJyZW50QWN0aW9uSXRlbTogbnVtYmVyIHwgbnVsbDtcclxuICBvbkN1cnJlbnRBY3Rpb25JdGVtQ2hhbmdlOiAoaW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XHJcbiAgb25LZXlEb3duOiAoZTogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFjdGl2aXR5QmFyKHtcclxuICBjdXJyZW50QWN0aW9uSXRlbSxcclxuICBvbkN1cnJlbnRBY3Rpb25JdGVtQ2hhbmdlLFxyXG4gIG9uS2V5RG93bixcclxufTogQWN0aXZpdHlCYXJQcm9wcykge1xyXG4gIGNvbnN0IGl0ZW1zUmVmID0gdXNlUmVmPChIVE1MTElFbGVtZW50IHwgbnVsbClbXT4oW10pO1xyXG5cclxuICBjb25zdCBoYW5kbGVJdGVtQ2xpY2sgPSAoaW5kZXg6IG51bWJlcikgPT4gKCkgPT4ge1xyXG4gICAgb25DdXJyZW50QWN0aW9uSXRlbUNoYW5nZShpbmRleCA9PT0gY3VycmVudEFjdGlvbkl0ZW0gPyBudWxsIDogaW5kZXgpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNldEZvY3VzVG9QcmV2aW91c0l0ZW0gPSAoaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcHJldkl0ZW1JZHggPVxyXG4gICAgICBpbmRleCA9PT0gMCA/IEFDVElPTl9JVEVNUy5sZW5ndGggLSAxIDogKGluZGV4IC0gMSkgJSBBQ1RJT05fSVRFTVMubGVuZ3RoO1xyXG4gICAgaXRlbXNSZWYuY3VycmVudFtwcmV2SXRlbUlkeF0/LmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2V0Rm9jdXNUb05leHRJdGVtID0gKGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IG5leHRJdGVuSWR4ID0gKGluZGV4ICsgMSkgJSBBQ1RJT05fSVRFTVMubGVuZ3RoO1xyXG4gICAgaXRlbXNSZWYuY3VycmVudFtuZXh0SXRlbklkeF0/LmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlSXRlbUtleURvd24gPSAoaW5kZXg6IG51bWJlcikgPT4gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgIHN3aXRjaCAoZS5rZXkpIHtcclxuICAgICAgY2FzZSBcIiBcIjpcclxuICAgICAgY2FzZSBcIkVudGVyXCI6XHJcbiAgICAgICAgaGFuZGxlSXRlbUNsaWNrKGluZGV4KSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgY2FzZSBcIlVwXCI6XHJcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XHJcbiAgICAgICAgc2V0Rm9jdXNUb1ByZXZpb3VzSXRlbShpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBjYXNlIFwiRG93blwiOlxyXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XHJcbiAgICAgICAgc2V0Rm9jdXNUb05leHRJdGVtKGluZGV4KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgb3BlbkdpdGh1YkxpbmsgPSAoKSA9PiB7XHJcbiAgICB3aW5kb3cub3BlbihHSVRIVUJfVVJMLCBcIl9ibGFua1wiKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFdyYXBwZXIgb25LZXlEb3duPXtvbktleURvd259PlxyXG4gICAgICA8VWw+XHJcbiAgICAgICAge0FDVElPTl9JVEVNUy5tYXAoKHsgbGFiZWwsIEljb24gfSwgaW5kZXgpID0+IChcclxuICAgICAgICAgIDxBY3Rpb25JdGVtXHJcbiAgICAgICAgICAgIHJlZj17KGVsKSA9PiAoaXRlbXNSZWYuY3VycmVudFtpbmRleF0gPSBlbCl9XHJcbiAgICAgICAgICAgIGtleT17bGFiZWx9XHJcbiAgICAgICAgICAgIEljb249e0ljb259XHJcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ9e2luZGV4ID09PSBjdXJyZW50QWN0aW9uSXRlbX1cclxuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlSXRlbUNsaWNrKGluZGV4KX1cclxuICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVJdGVtS2V5RG93bihpbmRleCl9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICkpfVxyXG4gICAgICA8L1VsPlxyXG4gICAgICA8VWw+XHJcbiAgICAgICAgPFRoZW1lU3dpdGNoZXIgLz5cclxuICAgICAgICA8QWN0aW9uSXRlbSBJY29uPXtBY2NvdW50SWNvbn0gb25DbGljaz17b3BlbkdpdGh1Ykxpbmt9IC8+XHJcbiAgICAgICAgPEFjdGlvbkl0ZW0gSWNvbj17U2V0dGluZ3NHZWFySWNvbn0gb25DbGljaz17KCkgPT4gbnVsbH0gLz5cclxuICAgICAgPC9VbD5cclxuICAgIDwvV3JhcHBlcj5cclxuICApO1xyXG59XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLm5hdmBcclxuICBmbGV4LXNocmluazogMDtcclxuXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuXHJcbiAgd2lkdGg6ICR7QUNUSVZJVFlfQkFSX1dJRFRIfTtcclxuXHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJHtEUkFDVUxBUl9CQUNLR1JPVU5EX0xJR0hUX0RBUkt9O1xyXG5gO1xyXG5cclxuY29uc3QgVWwgPSBzdHlsZWQudWxgXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblxyXG4gID4gOm5vdCg6bGFzdC1jaGlsZCkge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMC40cmVtO1xyXG4gIH1cclxuXHJcbiAgPiBsaSB7XHJcbiAgICAmOmhvdmVyIHtcclxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgfVxyXG4gIH1cclxuYDtcclxuIiwiZXhwb3J0IGNsYXNzIFRyZWVJdGVtPFREYXRhID0gdW5rbm93bj4ge1xyXG4gIHByaXZhdGUgX25hbWU6IHN0cmluZztcclxuICBwcml2YXRlIF9wYXRoOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfZGF0YT86IFREYXRhO1xyXG5cclxuICBjb25zdHJ1Y3RvcihfcGF0aDogc3RyaW5nID0gXCJcIiwgX2RhdGE/OiBURGF0YSkge1xyXG4gICAgdGhpcy5fbmFtZSA9IF9wYXRoLnNwbGl0KFwiL1wiKS5yZXZlcnNlKClbMF07XHJcbiAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICB0aGlzLl9kYXRhID0gX2RhdGE7XHJcbiAgfVxyXG5cclxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgcGF0aCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdGg7XHJcbiAgfVxyXG5cclxuICBnZXQgZGF0YSgpOiBURGF0YSB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlPFREYXRhID0gdW5rbm93bj4gZXh0ZW5kcyBUcmVlSXRlbTxURGF0YT4ge31cclxuXHJcbmV4cG9ydCBjbGFzcyBGb2xkZXI8VERhdGEgPSB1bmtub3duPiBleHRlbmRzIFRyZWVJdGVtPFREYXRhPiB7XHJcbiAgcHJpdmF0ZSBfY2hpbGRyZW46IEFycmF5PFRyZWVJdGVtPFREYXRhPj4gPSBbXTtcclxuXHJcbiAgYWRkKHRyZWVJdGVtOiBUcmVlSXRlbTxURGF0YT4pOiBGb2xkZXI8VERhdGE+IHtcclxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godHJlZUl0ZW0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBmaW5kKHBhdGg6IHN0cmluZyk6IFRyZWVJdGVtPFREYXRhPiB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZmluZCgodikgPT4gdi5wYXRoID09PSBwYXRoKTtcclxuICB9XHJcblxyXG4gIGdldCBjaGlsZHJlbigpOiBBcnJheTxUcmVlSXRlbTxURGF0YT4+IHtcclxuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBpc0ZvbGRlciA9IChpdGVtOiBUcmVlSXRlbSk6IGl0ZW0gaXMgRm9sZGVyID0+IHtcclxuICByZXR1cm4gKGl0ZW0gYXMgRm9sZGVyKS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBGb2xkZXIsIEZpbGUgfSBmcm9tIFwiLi9UcmVlSXRlbS5jbGFzc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJlZVZpZXc8VERhdGEgPSB1bmtub3duPiB7XHJcbiAgcm9vdDogRm9sZGVyPFREYXRhPiA9IG5ldyBGb2xkZXI8VERhdGE+KFwicm9vdFwiKTtcclxuICBwcml2YXRlIG1hcEZpbGVQYXRoOiAoKHZhbHVlOiBURGF0YSkgPT4gc3RyaW5nKSB8IHVuZGVmaW5lZDtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBkYXRhOiBzdHJpbmdbXSB8IFREYXRhW10sXHJcbiAgICBtYXBGaWxlUGF0aD86ICh2YWx1ZTogVERhdGEpID0+IHN0cmluZ1xyXG4gICkge1xyXG4gICAgdGhpcy5tYXBGaWxlUGF0aCA9IG1hcEZpbGVQYXRoO1xyXG4gICAgdGhpcy5jcmVhdGVUcmVlKGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlVHJlZShkYXRhOiBzdHJpbmdbXSB8IFREYXRhW10pIHtcclxuICAgIGRhdGEubWFwKCh2OiBzdHJpbmcgfCBURGF0YSkgPT5cclxuICAgICAgdGhpcy5tYXBGaWxlUGF0aFxyXG4gICAgICAgID8gdGhpcy5hZGRGaWxlKHRoaXMubWFwRmlsZVBhdGgodiBhcyBURGF0YSksIHYgYXMgVERhdGEpXHJcbiAgICAgICAgOiB0aGlzLmFkZEZpbGUodiBhcyBzdHJpbmcpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzcGxpdFBhdGgocGF0aDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKCh2KSA9PiAhIXYpO1xyXG4gIH1cclxuXHJcbiAgYWRkRmlsZShwYXRoOiBzdHJpbmcsIGRhdGE/OiBURGF0YSkge1xyXG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLnNwbGl0UGF0aChwYXRoKTtcclxuICAgIGNvbnN0IGxlYWZGb2xkZXJQYXRoID0gcGF0aHMuc2xpY2UoMCwgcGF0aHMubGVuZ3RoIC0gMSkuam9pbihcIi9cIik7XHJcbiAgICB0aGlzLmFjY2Vzc1RvRm9sZGVyKGxlYWZGb2xkZXJQYXRoKS5hZGQobmV3IEZpbGU8VERhdGE+KHBhdGgsIGRhdGEpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgYWNjZXNzVG9Gb2xkZXIocGF0aDogc3RyaW5nKSB7XHJcbiAgICBpZiAoIXBhdGggfHwgcGF0aCA9PT0gXCIvXCIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucm9vdDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXRocyA9IHRoaXMuc3BsaXRQYXRoKHBhdGgpO1xyXG4gICAgcmV0dXJuIHBhdGhzLnJlZHVjZSgoY3VycmVudFJvb3QsIF8sIGkpID0+IHtcclxuICAgICAgY29uc3QgY3VycmVudFBhdGggPSBwYXRocy5zbGljZSgwLCBpICsgMSkuam9pbihcIi9cIik7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2xlciA9IGN1cnJlbnRSb290LmZpbmQoY3VycmVudFBhdGgpO1xyXG4gICAgICByZXR1cm4gY3VycmVudEZvbGVyID09IG51bGxcclxuICAgICAgICA/IChjdXJyZW50Um9vdFxyXG4gICAgICAgICAgICAuYWRkKG5ldyBGb2xkZXI8VERhdGE+KGN1cnJlbnRQYXRoKSlcclxuICAgICAgICAgICAgLmZpbmQoY3VycmVudFBhdGgpIGFzIEZvbGRlcjxURGF0YT4pXHJcbiAgICAgICAgOiAoY3VycmVudEZvbGVyIGFzIEZvbGRlcjxURGF0YT4pO1xyXG4gICAgfSwgdGhpcy5yb290KTtcclxuICB9XHJcbn1cclxuIiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmVlVmlldyB9IGZyb20gXCIuL1RyZWVWaWV3LmNsYXNzXCI7XHJcblxyXG5leHBvcnQgKiBmcm9tIFwiLi9UcmVlSXRlbS5jbGFzc1wiO1xyXG4iLCJpbXBvcnQgeyBQcm9wc1dpdGhDaGlsZHJlbiwgdXNlU3RhdGUsIEVsZW1lbnRUeXBlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBDaGV2cm9uRG93bkljb24sIENoZXZyb25SaWdodEljb24gfSBmcm9tIFwiQHNyYy9hc3NldHMvaWNvbnNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEZpbGVUcmVlSXRlbVByb3BzID0gUHJvcHNXaXRoQ2hpbGRyZW48e1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgaXNTZWxlY3RlZD86IGJvb2xlYW47XHJcbiAgZGVmYXVsdEV4cGFuZGVkPzogYm9vbGVhbjtcclxuICBvbkNsaWNrPzogKCkgPT4gdm9pZDtcclxufT47XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGaWxlVHJlZUl0ZW0oe1xyXG4gIHRpdGxlLFxyXG4gIGNoaWxkcmVuLFxyXG4gIGlzU2VsZWN0ZWQsXHJcbiAgZGVmYXVsdEV4cGFuZGVkLFxyXG4gIG9uQ2xpY2ssXHJcbn06IEZpbGVUcmVlSXRlbVByb3BzKSB7XHJcbiAgY29uc3QgW2lzRXhwYW5kZWQsIHNldElzRXhwYW5kZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oISFkZWZhdWx0RXhwYW5kZWQpO1xyXG5cclxuICBpZiAoIWNoaWxkcmVuKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8TGkgaXNTZWxlY3RlZD17aXNTZWxlY3RlZH0gb25DbGljaz17b25DbGlja30gaXNGaWxlPlxyXG4gICAgICAgIDxUaXRsZT7wn5OdIHt0aXRsZX08L1RpdGxlPlxyXG4gICAgICA8L0xpPlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRvZ2dsZUV4cGFuZCA9ICgpID0+IHtcclxuICAgIHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IENoZXZyb25JY29uOiBFbGVtZW50VHlwZSA9IGlzRXhwYW5kZWRcclxuICAgID8gQ2hldnJvbkRvd25JY29uXHJcbiAgICA6IENoZXZyb25SaWdodEljb247XHJcbiAgcmV0dXJuIChcclxuICAgIDxXcmFwcGVyPlxyXG4gICAgICA8TGkgb25DbGljaz17dG9nZ2xlRXhwYW5kfT5cclxuICAgICAgICA8Q2hldnJvbkljb24gc3R5bGU9e3sgd2lkdGg6IFwiMXJlbVwiLCBoZWlnaHQ6IFwiMXJlbVwiIH19IC8+XHJcbiAgICAgICAgPFRpdGxlPvCfk4Ige3RpdGxlfTwvVGl0bGU+XHJcbiAgICAgIDwvTGk+XHJcbiAgICAgIHtpc0V4cGFuZGVkICYmIDxVbD57Y2hpbGRyZW59PC9VbD59XHJcbiAgICA8L1dyYXBwZXI+XHJcbiAgKTtcclxufVxyXG5cclxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5saWBcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbmA7XHJcblxyXG5jb25zdCBMaSA9IHN0eWxlZC5saTx7IGlzU2VsZWN0ZWQ/OiBib29sZWFuOyBpc0ZpbGU/OiBib29sZWFuIH0+YFxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuXHJcbiAgcGFkZGluZzogMC40cmVtIDAuMnJlbTtcclxuICAkeyh7IGlzRmlsZSB9KSA9PiAoaXNGaWxlID8gXCJwYWRkaW5nLWxlZnQ6IDEuNHJlbTtcIiA6IFwiXCIpfTtcclxuXHJcbiAgJHsoeyB0aGVtZSB9KSA9PlxyXG4gICAgYCY6aG92ZXIgeyBcclxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLnNjaGVtZS4kZ3JheTMwMH07XHJcbiAgICAgICB9YH1cclxuICAkeyh7IGlzU2VsZWN0ZWQsIHRoZW1lIH0pID0+XHJcbiAgICBpc1NlbGVjdGVkID8gYGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLnNjaGVtZS4kZ3JheTIwMH07YCA6IGBgfTtcclxuXHJcbiAgJjpob3ZlciB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgVGl0bGUgPSBzdHlsZWQucGBcclxuICBmb250LXNpemU6IDAuOHJlbTtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG5cclxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcclxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbmA7XHJcblxyXG5jb25zdCBVbCA9IHN0eWxlZC51bGBcclxuICBtYXJnaW4tbGVmdDogMC42cmVtO1xyXG4gICR7KHsgdGhlbWUgfSkgPT4gYGJvcmRlci1sZWZ0OiAwLjRweCBzb2xpZCAke3RoZW1lLmNvbG9ycy5zY2hlbWUuJGdyYXkyMDB9YH07XHJcbmA7XHJcbiIsImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBQb3N0IH0gZnJvbSBcIkBzcmMvdHlwZXMvcG9zdC50eXBlXCI7XHJcblxyXG5pbXBvcnQgRmlsZVRyZWVJdGVtIGZyb20gXCIuL2ZpbGUtdHJlZS1pdGVtXCI7XHJcbmltcG9ydCB7IGlzRm9sZGVyLCBUcmVlSXRlbSwgVHJlZVZpZXcgfSBmcm9tIFwiLi9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBGaWxlVHJlZVByb3BzID0ge1xyXG4gIHBvc3RzOiBQb3N0W107XHJcbiAgY3VycmVudFBvc3RJZD86IHN0cmluZyB8IG51bGw7XHJcbiAgc2VsZWN0UG9zdDogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGaWxlVHJlZSh7XHJcbiAgcG9zdHMsXHJcbiAgY3VycmVudFBvc3RJZCA9IG51bGwsXHJcbiAgc2VsZWN0UG9zdCxcclxufTogRmlsZVRyZWVQcm9wcykge1xyXG4gIGNvbnN0IHJvb3QgPSBuZXcgVHJlZVZpZXc8UG9zdD4ocG9zdHMsIChwb3N0KSA9PiBwb3N0LmlkKS5yb290O1xyXG5cclxuICBjb25zdCBzb3J0Q2hpbGRyZW4gPSAoY2hpbGRyZW46IFRyZWVJdGVtPFBvc3Q+W10pID0+IHtcclxuICAgIHJldHVybiBjaGlsZHJlbi5zb3J0KChhLCBiKSA9PiAoaXNGb2xkZXIoYSkgJiYgIWlzRm9sZGVyKGIpID8gLTEgOiAwKSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVuZGVyQ2hpbGRyZW4gPSAoY2hpbGRyZW46IFRyZWVJdGVtPFBvc3Q+W10pID0+XHJcbiAgICBzb3J0Q2hpbGRyZW4oY2hpbGRyZW4pLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgICBpZiAoaXNGb2xkZXIoaXRlbSkpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPEZpbGVUcmVlSXRlbSBrZXk9e2l0ZW0ubmFtZX0gdGl0bGU9e2l0ZW0ubmFtZX0+XHJcbiAgICAgICAgICAgIHtyZW5kZXJDaGlsZHJlbihpdGVtLmNoaWxkcmVuIGFzIFRyZWVJdGVtPFBvc3Q+W10pfVxyXG4gICAgICAgICAgPC9GaWxlVHJlZUl0ZW0+XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICA8RmlsZVRyZWVJdGVtXHJcbiAgICAgICAgICBrZXk9e2l0ZW0ubmFtZX1cclxuICAgICAgICAgIHRpdGxlPXtpdGVtLmRhdGE/Lm1ldGEudGl0bGUgPz8gXCJcIn1cclxuICAgICAgICAgIGlzU2VsZWN0ZWQ9e2l0ZW0ucGF0aCA9PT0gY3VycmVudFBvc3RJZH1cclxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNlbGVjdFBvc3QoaXRlbS5wYXRoKX1cclxuICAgICAgICAvPlxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gIHJldHVybiA8V3JhcHBlcj57cmVuZGVyQ2hpbGRyZW4ocm9vdC5jaGlsZHJlbil9PC9XcmFwcGVyPjtcclxufVxyXG5cclxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgbWFyZ2luLWxlZnQ6IDAuNnJlbTtcclxuICAkeyh7IHRoZW1lIH0pID0+IGBib3JkZXItbGVmdDogMC40cHggc29saWQgJHt0aGVtZS5jb2xvcnMuc2NoZW1lLiRncmF5MjAwfWB9O1xyXG5gO1xyXG4iLCJpbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IEFjY29yZGlvblNlY3Rpb24gZnJvbSBcIkBzcmMvY29tcG9uZW50cy9jb21tb24vYWNjb3JkaW9uLXNlY3Rpb25cIjtcclxuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gXCJAc3JjL2NvbnRleHRzL2FwcFwiO1xyXG5cclxuaW1wb3J0IHsgT1BFTl9QT1NUX0xJU1RfSVRFTV9IRUlHSFQgfSBmcm9tIFwiLi9vcGVuLXBvc3QtbGlzdC9vcGVuLXBvc3QtbGlzdC1pdGVtXCI7XHJcbmltcG9ydCBPcGVuUG9zdExpc3QgZnJvbSBcIi4vb3Blbi1wb3N0LWxpc3RcIjtcclxuaW1wb3J0IEZpbGVUcmVlIGZyb20gXCIuL2ZpbGUtdHJlZVwiO1xyXG5cclxuY29uc3QgTUFYX1ZJU0lCTEVfSVRFTSA9IDQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeHBsb3JlclNlY3Rpb24oKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgc3RhdGU6IHsgcG9zdHMsIG9wZW5Qb3N0cywgY3VycmVudFBvc3RJZCB9LFxyXG4gICAgYWN0aW9uOiB7IHNlbGVjdFBvc3QsIGNsb3NlUG9zdCB9LFxyXG4gIH0gPSB1c2VBcHBDb250ZXh0KCk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8V3JhcHBlcj5cclxuICAgICAgPEFjY29yZGlvblNlY3Rpb25cclxuICAgICAgICB0aXRsZT1cIk9QRU4gUE9TVFNcIlxyXG4gICAgICAgIGhlaWdodD17YGNhbGMoJHtPUEVOX1BPU1RfTElTVF9JVEVNX0hFSUdIVH0gKiAke29wZW5Qb3N0cy5sZW5ndGh9KWB9XHJcbiAgICAgICAgbWF4SGVpZ2h0PXtgY2FsYygke09QRU5fUE9TVF9MSVNUX0lURU1fSEVJR0hUfSAqICR7TUFYX1ZJU0lCTEVfSVRFTX0pYH1cclxuICAgICAgICBkZWZhdWx0RXhwYW5kZWRcclxuICAgICAgPlxyXG4gICAgICAgIDxPcGVuUG9zdExpc3RcclxuICAgICAgICAgIG9wZW5Qb3N0cz17b3BlblBvc3RzfVxyXG4gICAgICAgICAgY3VycmVudFBvc3RJZD17Y3VycmVudFBvc3RJZH1cclxuICAgICAgICAgIHNlbGVjdFBvc3Q9e3NlbGVjdFBvc3R9XHJcbiAgICAgICAgICBjbG9zZVBvc3Q9e2Nsb3NlUG9zdH1cclxuICAgICAgICAvPlxyXG4gICAgICA8L0FjY29yZGlvblNlY3Rpb24+XHJcbiAgICAgIDxBY2NvcmRpb25TZWN0aW9uIHRpdGxlPVwiQkxPRyBQT1NUU1wiIGRlZmF1bHRFeHBhbmRlZD5cclxuICAgICAgICA8RmlsZVRyZWVcclxuICAgICAgICAgIHBvc3RzPXtwb3N0c31cclxuICAgICAgICAgIGN1cnJlbnRQb3N0SWQ9e2N1cnJlbnRQb3N0SWR9XHJcbiAgICAgICAgICBzZWxlY3RQb3N0PXtzZWxlY3RQb3N0fVxyXG4gICAgICAgIC8+XHJcbiAgICAgIDwvQWNjb3JkaW9uU2VjdGlvbj5cclxuICAgIDwvV3JhcHBlcj5cclxuICApO1xyXG59XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmRpdmBcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG5gO1xyXG4iLCJpbXBvcnQgeyBQb3N0IH0gZnJvbSBcIkBzcmMvdHlwZXMvcG9zdC50eXBlXCI7XHJcblxyXG5pbXBvcnQgT3BlblBvc3RMaXN0SXRlbSBmcm9tIFwiLi9vcGVuLXBvc3QtbGlzdC1pdGVtXCI7XHJcblxyXG5leHBvcnQgdHlwZSBPcGVuUG9zdExpc3RQcm9wcyA9IHtcclxuICBvcGVuUG9zdHM6IFBvc3RbXTtcclxuICBjdXJyZW50UG9zdElkPzogc3RyaW5nIHwgbnVsbDtcclxuICBzZWxlY3RQb3N0OiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICBjbG9zZVBvc3Q6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gT3BlblBvc3RMaXN0KHByb3BzOiBPcGVuUG9zdExpc3RQcm9wcykge1xyXG4gIGNvbnN0IHsgb3BlblBvc3RzLCBjdXJyZW50UG9zdElkLCBzZWxlY3RQb3N0LCBjbG9zZVBvc3QgfSA9IHByb3BzO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPHVsIHN0eWxlPXt7IHdoaXRlU3BhY2U6IFwibm93cmFwXCIgfX0+XHJcbiAgICAgIHtvcGVuUG9zdHMubWFwKCh7IGlkLCBtZXRhIH0pID0+IChcclxuICAgICAgICA8T3BlblBvc3RMaXN0SXRlbVxyXG4gICAgICAgICAga2V5PXtpZH1cclxuICAgICAgICAgIHRpdGxlPXttZXRhLnRpdGxlfVxyXG4gICAgICAgICAgaXNTZWxlY3RlZD17Y3VycmVudFBvc3RJZCA9PT0gaWR9XHJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZWxlY3RQb3N0KGlkKX1cclxuICAgICAgICAgIG9uQ2xvc2U9eygpID0+IGNsb3NlUG9zdChpZCl9XHJcbiAgICAgICAgICBzaG93Q2xvc2VCdXR0b25cclxuICAgICAgICAvPlxyXG4gICAgICApKX1cclxuICAgIDwvdWw+XHJcbiAgKTtcclxufVxyXG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSwgTW91c2VFdmVudCB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IHsgQ2xvc2VJY29uIH0gZnJvbSBcIkBzcmMvYXNzZXRzL2ljb25zXCI7XHJcblxyXG5leHBvcnQgY29uc3QgT1BFTl9QT1NUX0xJU1RfSVRFTV9IRUlHSFQgPSBcIjJyZW1cIjtcclxuXHJcbmV4cG9ydCB0eXBlIE9wZW5Qb3N0TGlzdEl0ZW1Qcm9wcyA9IHtcclxuICBlbW9qaT86IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGlzU2VsZWN0ZWQ/OiBib29sZWFuO1xyXG4gIG9uQ2xpY2s/OiAoKSA9PiB2b2lkO1xyXG4gIG9uQ2xvc2U/OiAoKSA9PiB2b2lkO1xyXG4gIHNob3dDbG9zZUJ1dHRvbj86IGJvb2xlYW47XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPcGVuUG9zdExpc3RJdGVtKHtcclxuICBlbW9qaSA9IFwi8J+TnVwiLFxyXG4gIHRpdGxlLFxyXG4gIGlzU2VsZWN0ZWQgPSBmYWxzZSxcclxuICBvbkNsaWNrID0gKCkgPT4gbnVsbCxcclxuICBvbkNsb3NlID0gKCkgPT4gbnVsbCxcclxuICBzaG93Q2xvc2VCdXR0b24gPSBmYWxzZSxcclxufTogT3BlblBvc3RMaXN0SXRlbVByb3BzKSB7XHJcbiAgY29uc3QgW2lzSG92ZXJlZCwgc2V0SXNIb3ZlcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBpc0Nsb3NlVmlzaWJsZSA9IHNob3dDbG9zZUJ1dHRvbiAmJiAoaXNTZWxlY3RlZCB8fCBpc0hvdmVyZWQpO1xyXG5cclxuICBjb25zdCBoYW5kbGVDbG9zZUNsaWNrID0gKGU6IE1vdXNlRXZlbnQ8U1ZHU1ZHRWxlbWVudD4pID0+IHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgb25DbG9zZSgpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8V3JhcHBlclxyXG4gICAgICBoZWlnaHQ9e09QRU5fUE9TVF9MSVNUX0lURU1fSEVJR0hUfVxyXG4gICAgICBpc1NlbGVjdGVkPXtpc1NlbGVjdGVkfVxyXG4gICAgICBvbkNsaWNrPXtvbkNsaWNrfVxyXG4gICAgICBvbk1vdXNlT3Zlcj17KCkgPT4gc2V0SXNIb3ZlcmVkKHRydWUpfVxyXG4gICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHNldElzSG92ZXJlZChmYWxzZSl9XHJcbiAgICA+XHJcbiAgICAgIDxDbG9zZUljb25cclxuICAgICAgICBzdHlsZT17e1xyXG4gICAgICAgICAgbWluV2lkdGg6IFwiMXJlbVwiLFxyXG4gICAgICAgICAgd2lkdGg6IFwiMXJlbVwiLFxyXG4gICAgICAgICAgaGVpZ2h0OiBcIjFyZW1cIixcclxuICAgICAgICAgIHZpc2liaWxpdHk6IGlzQ2xvc2VWaXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiLFxyXG4gICAgICAgIH19XHJcbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xvc2VDbGlja31cclxuICAgICAgLz5cclxuICAgICAgPFRpdGxlPlxyXG4gICAgICAgIHtlbW9qaX0ge3RpdGxlfVxyXG4gICAgICA8L1RpdGxlPlxyXG4gICAgPC9XcmFwcGVyPlxyXG4gICk7XHJcbn1cclxuXHJcbmNvbnN0IFdyYXBwZXIgPSBzdHlsZWQubGk8eyBpc1NlbGVjdGVkOiBib29sZWFuOyBoZWlnaHQ6IHN0cmluZyB9PmBcclxuICAkeyh7IGhlaWdodCwgaXNTZWxlY3RlZCwgdGhlbWUgfSkgPT4gYFxyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBSb3c7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG5cclxuICAgIGhlaWdodDogJHtoZWlnaHR9O1xyXG4gICAgcGFkZGluZzogMCAxLjJyZW07XHJcblxyXG4gICAgJHtcclxuICAgICAgaXNTZWxlY3RlZFxyXG4gICAgICAgID8gYGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLnNjaGVtZS4kZ3JheTIwMH07YFxyXG4gICAgICAgIDogYCY6aG92ZXIgeyBcclxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5zY2hlbWUuJGdyYXkzMDB9O1xyXG4gICAgICAgICAgfWBcclxuICAgIH1cclxuICBgfVxyXG4gICY6aG92ZXIge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IFRpdGxlID0gc3R5bGVkLnBgXHJcbiAgcGFkZGluZy1sZWZ0OiAwLjRyZW07XHJcbiAgZm9udC1zaXplOiAwLjhyZW07XHJcbiAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XHJcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICBvdmVyZmxvdzogaGlkZGVuO1xyXG5gO1xyXG4iLCJpbXBvcnQgeyBSZWFjdE5vZGUsIHVzZVJlZiwgdXNlU3RhdGUsIEtleWJvYXJkRXZlbnQgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCB7IEJMVUUsIEdSQVlfMTAwLCBHUkFZXzMwMCwgR1JBWV82MDAgfSBmcm9tIFwiQHNyYy9jb25zdGFudHMvcGFsZXR0ZVwiO1xyXG5cclxuaW1wb3J0IEFjdGl2aXR5QmFyLCB7IEFDVElPTl9JVEVNUyB9IGZyb20gXCIuL2FjdGl2aXR5LWJhclwiO1xyXG5pbXBvcnQgU2lkZUJhciBmcm9tIFwiLi9zaWRlLWJhclwiO1xyXG5cclxuZXhwb3J0IHR5cGUgQmxvZ0xheW91dFByb3BzID0ge1xyXG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCbG9nTGF5b3V0KHsgY2hpbGRyZW4gfTogQmxvZ0xheW91dFByb3BzKSB7XHJcbiAgY29uc3QgW2N1cnJlbnRBY3Rpb25JdGVtLCBzZXRDdXJyZW50QWN0aW9uSXRlbV0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihcclxuICAgIG51bGxcclxuICApO1xyXG5cclxuICBjb25zdCBzaWRlQmFyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlQWN0aXZpdHlCYXJLZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgIGlmIChbXCJBcnJvd1JpZ2h0XCIsIFwiUmlnaHRcIl0uaW5jbHVkZXMoZS5rZXkpKSB7XHJcbiAgICAgIHNpZGVCYXJSZWYuY3VycmVudD8uZm9jdXMoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPFdyYXBwZXI+XHJcbiAgICAgIDxIZWFkZXIgLz5cclxuICAgICAgPFJvdz5cclxuICAgICAgICA8QWN0aXZpdHlCYXJcclxuICAgICAgICAgIGN1cnJlbnRBY3Rpb25JdGVtPXtjdXJyZW50QWN0aW9uSXRlbX1cclxuICAgICAgICAgIG9uQ3VycmVudEFjdGlvbkl0ZW1DaGFuZ2U9e3NldEN1cnJlbnRBY3Rpb25JdGVtfVxyXG4gICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVBY3Rpdml0eUJhcktleURvd259XHJcbiAgICAgICAgLz5cclxuICAgICAgICB7Y3VycmVudEFjdGlvbkl0ZW0gIT0gbnVsbCAmJiAoXHJcbiAgICAgICAgICA8U2lkZUJhclxyXG4gICAgICAgICAgICByZWY9e3NpZGVCYXJSZWZ9XHJcbiAgICAgICAgICAgIGxhYmVsPXtBQ1RJT05fSVRFTVNbY3VycmVudEFjdGlvbkl0ZW1dLmxhYmVsfVxyXG4gICAgICAgICAgICBjb250ZW50PXtBQ1RJT05fSVRFTVNbY3VycmVudEFjdGlvbkl0ZW1dLmNvbnRlbnR9XHJcbiAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldEN1cnJlbnRBY3Rpb25JdGVtKG51bGwpfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApfVxyXG4gICAgICAgIDxNYWluPntjaGlsZHJlbn08L01haW4+XHJcbiAgICAgIDwvUm93PlxyXG4gICAgICA8Rm9vdGVyIC8+XHJcbiAgICA8L1dyYXBwZXI+XHJcbiAgKTtcclxufVxyXG5cclxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG5cclxuICB3aWR0aDogMTAwdnc7XHJcbiAgaGVpZ2h0OiAxMDB2aDtcclxuXHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuc2VtYW50aWNTY2hlbWUubWFpbkJnfTtcclxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuc2NoZW1lLiR3aGl0ZX07XHJcbmA7XHJcblxyXG5jb25zdCBIZWFkZXIgPSBzdHlsZWQuaGVhZGVyYFxyXG4gIGZsZXgtc2hyaW5rOiAwO1xyXG5cclxuICBoZWlnaHQ6IDEuNnJlbTtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAke0dSQVlfMzAwfTtcclxuYDtcclxuXHJcbmNvbnN0IFJvdyA9IHN0eWxlZC5kaXZgXHJcbiAgZmxleDogMTtcclxuXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xyXG5cclxuICBvdmVyZmxvdzogaGlkZGVuO1xyXG5gO1xyXG5cclxuY29uc3QgTWFpbiA9IHN0eWxlZC5tYWluYFxyXG4gIGZsZXg6IDE7XHJcblxyXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcclxuICBvdmVyZmxvdy15OiBoaWRkZW47XHJcblxyXG4gIGJhY2tncm91bmQtY29sb3I6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuY29sb3JzLnNlbWFudGljU2NoZW1lLm1haW5CZ307XHJcbmA7XHJcblxyXG5jb25zdCBGb290ZXIgPSBzdHlsZWQuZm9vdGVyYFxyXG4gIGZsZXgtc2hyaW5rOiAwO1xyXG5cclxuICBoZWlnaHQ6IDEuNnJlbTtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAke0dSQVlfNjAwfTtcclxuYDtcclxuIiwiaW1wb3J0IHsgdXNlTWVtbywgTW91c2VFdmVudCB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gXCJAc3JjL2NvbnRleHRzL2FwcFwiO1xyXG5pbXBvcnQgeyBQb3N0IH0gZnJvbSBcIkBzcmMvdHlwZXMvcG9zdC50eXBlXCI7XHJcblxyXG5pbXBvcnQgU2Nyb2xsUGFnZW5hdGlvbiBmcm9tIFwiQHNyYy9jb21wb25lbnRzL2NvbW1vbi9zY3JvbGwtcGFnZW5hdGlvblwiO1xyXG5cclxuaW1wb3J0IExvZ0l0ZW0gZnJvbSBcIi4vbG9nLWl0ZW1cIjtcclxuXHJcbmZ1bmN0aW9uIExvZ1NlY3Rpb24oKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgc3RhdGU6IHsgcG9zdHMgfSxcclxuICAgIGFjdGlvbjogeyBzZWxlY3RQb3N0IH0sXHJcbiAgfSA9IHVzZUFwcENvbnRleHQoKTtcclxuXHJcbiAgY29uc3Qgc29ydGVkUG9zdHM6IFBvc3RbXSA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgLy8g7LWc7Iug7IicIOygleugrFxyXG4gICAgcmV0dXJuIFsuLi5wb3N0c10uc29ydCgoYSwgYikgPT4gYi5tZXRhLmRhdGUubG9jYWxlQ29tcGFyZShhLm1ldGEuZGF0ZSkpO1xyXG4gIH0sIFtwb3N0c10pO1xyXG5cclxuICBjb25zdCBoYW5kbGVDbGljayA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCBpdGVtRWxlbTogSFRNTEVsZW1lbnQgfCBudWxsID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5jbG9zZXN0KFxyXG4gICAgICBcIi5sb2dJdGVtXCJcclxuICAgICk7XHJcbiAgICBpZiAoaXRlbUVsZW0gJiYgaXRlbUVsZW0uZGF0YXNldC5pZCkge1xyXG4gICAgICBzZWxlY3RQb3N0KGl0ZW1FbGVtLmRhdGFzZXQuaWQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8U2Nyb2xsUGFnZW5hdGlvblxyXG4gICAgICBkYXRhPXtzb3J0ZWRQb3N0c31cclxuICAgICAgcmVuZGVySXRlbT17KGN1cnIsIHByZXYpID0+IChcclxuICAgICAgICA8TG9nSXRlbSBrZXk9e2N1cnIuaWR9IGN1cnJQb3N0PXtjdXJyfSBwcmV2UG9zdD17cHJldn0gLz5cclxuICAgICAgKX1cclxuICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XHJcbiAgICAvPlxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IExvZ1NlY3Rpb247XHJcbiIsImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBCTFVFLCBHUkVFTiB9IGZyb20gXCJAc3JjL2NvbnN0YW50cy9wYWxldHRlXCI7XHJcbmltcG9ydCB7IFBvc3QgfSBmcm9tIFwiQHNyYy90eXBlcy9wb3N0LnR5cGVcIjtcclxuXHJcbmV4cG9ydCB0eXBlIExvZ0l0ZW1Qcm9wcyA9IHtcclxuICBjdXJyUG9zdDogUGljazxQb3N0LCBcImlkXCIgfCBcIm1ldGFcIj47XHJcbiAgcHJldlBvc3Q6IFBpY2s8UG9zdCwgXCJpZFwiIHwgXCJtZXRhXCI+IHwgbnVsbDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIExvZ0l0ZW0oeyBjdXJyUG9zdCwgcHJldlBvc3QgfTogTG9nSXRlbVByb3BzKSB7XHJcbiAgY29uc3QgY3VyckRhdGUgPSBuZXcgRGF0ZShjdXJyUG9zdC5tZXRhLmRhdGUpO1xyXG4gIGNvbnN0IHByZXZEYXRlID0gcHJldlBvc3QgPyBuZXcgRGF0ZShwcmV2UG9zdC5tZXRhLmRhdGUpIDogbnVsbDtcclxuXHJcbiAgY29uc3Qgc2hvd1llYXIgPSBwcmV2RGF0ZT8uZ2V0RnVsbFllYXIoKSAhPT0gY3VyckRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICBjb25zdCBzaG93TW9udGggPSBwcmV2RGF0ZT8uZ2V0TW9udGgoKSAhPT0gY3VyckRhdGUuZ2V0TW9udGgoKTtcclxuICBjb25zdCBzaG93RGF0ZSA9IHByZXZEYXRlPy5nZXREYXRlKCkgIT09IGN1cnJEYXRlLmdldERhdGUoKTtcclxuXHJcbiAgY29uc3QgZ2V0TW9udGhUZXh0ID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIGN1cnJEYXRlLnRvTG9jYWxlU3RyaW5nKFwiZGVmYXVsdFwiLCB7IG1vbnRoOiBcInNob3J0XCIgfSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgcmVuZGVyWWVhciA9ICgpID0+IChcclxuICAgIDxZZWFyV3JhcHBlciBpc0ZpcnN0PXshcHJldlBvc3R9PlxyXG4gICAgICA8WWVhcj57Y3VyckRhdGUuZ2V0RnVsbFllYXIoKX08L1llYXI+XHJcbiAgICA8L1llYXJXcmFwcGVyPlxyXG4gICk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8PlxyXG4gICAgICB7c2hvd1llYXIgJiYgcmVuZGVyWWVhcigpfVxyXG4gICAgICA8V3JhcHBlciBjbGFzc05hbWU9XCJsb2dJdGVtXCIgZGF0YS1pZD17Y3VyclBvc3QuaWR9PlxyXG4gICAgICAgIDxNb250aD57c2hvd01vbnRoID8gZ2V0TW9udGhUZXh0KCkgOiBcIlwifTwvTW9udGg+XHJcbiAgICAgICAgPF9EYXRlPntzaG93RGF0ZSA/IGN1cnJEYXRlLmdldERhdGUoKSA6IFwiXCJ9PC9fRGF0ZT5cclxuICAgICAgICA8UGluPlxyXG4gICAgICAgICAgPExpbmUgLz5cclxuICAgICAgICAgIDxEb3QgLz5cclxuICAgICAgICA8L1Bpbj5cclxuICAgICAgICA8VGl0bGU+e2N1cnJQb3N0Lm1ldGEudGl0bGV9PC9UaXRsZT5cclxuICAgICAgPC9XcmFwcGVyPlxyXG4gICAgPC8+XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTG9nSXRlbTtcclxuXHJcbmNvbnN0IFllYXJXcmFwcGVyID0gc3R5bGVkLmxpPHsgaXNGaXJzdDogYm9vbGVhbiB9PmBcclxuICBmbGV4LXNocmluazogMDtcclxuXHJcbiAgd2lkdGg6IDEwMCU7XHJcblxyXG4gIHBhZGRpbmc6IDAgMC44cmVtO1xyXG4gIG1hcmdpbi1ib3R0b206IDAuNHJlbTtcclxuXHJcbiAgJHsoeyBpc0ZpcnN0IH0pID0+ICFpc0ZpcnN0ICYmIGBtYXJnaW4tdG9wOiAwLjhyZW07YH07XHJcbmA7XHJcblxyXG5jb25zdCBZZWFyID0gc3R5bGVkLmJgXHJcbiAgZm9udC1zaXplOiAxLjRyZW07XHJcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbmA7XHJcblxyXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLmxpYFxyXG4gIGZsZXgtc2hyaW5rOiAwO1xyXG5cclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuXHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OiAycmVtO1xyXG5cclxuICBwYWRkaW5nOiAwIDAuOHJlbTtcclxuXHJcbiAgJjpob3ZlciB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyh7IHRoZW1lIH0pID0+IGAke3RoZW1lLmNvbG9ycy5zY2hlbWUuJGdyYXkzMDB9YH07XHJcbiAgfVxyXG5gO1xyXG5cclxuY29uc3QgTW9udGggPSBzdHlsZWQuYmBcclxuICBmbGV4LXNocmluazogMDtcclxuICB3aWR0aDogM3JlbTtcclxuXHJcbiAgZm9udC1zaXplOiAxLjJyZW07XHJcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XHJcbmA7XHJcblxyXG5jb25zdCBfRGF0ZSA9IHN0eWxlZC5zcGFuYFxyXG4gIGZsZXgtc2hyaW5rOiAwO1xyXG4gIHdpZHRoOiAxLjRyZW07XHJcblxyXG4gIGZvbnQtc2l6ZTogMC44cmVtO1xyXG5gO1xyXG5cclxuY29uc3QgVGl0bGUgPSBzdHlsZWQuc3BhbmBcclxuICBmbGV4OiAxO1xyXG5cclxuICBtYXJnaW4tbGVmdDogMC44cmVtO1xyXG5cclxuICBmb250LXNpemU6IDAuOHJlbTtcclxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcclxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbmA7XHJcblxyXG5jb25zdCBQaW4gPSBzdHlsZWQuZGl2YFxyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHJcbiAgZmxleC1zaHJpbms6IDA7XHJcbiAgd2lkdGg6IDEuNnJlbTtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbmA7XHJcblxyXG5jb25zdCBMaW5lID0gc3R5bGVkLmRpdmBcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgbGVmdDogNTAlO1xyXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcclxuXHJcbiAgd2lkdGg6IDAuMXJlbTtcclxuICBoZWlnaHQ6IDEwMCU7XHJcblxyXG4gIGJhY2tncm91bmQtY29sb3I6ICR7R1JFRU59O1xyXG5gO1xyXG5cclxuY29uc3QgRG90ID0gc3R5bGVkLmRpdmBcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgdG9wOiA1MCU7XHJcbiAgbGVmdDogNTAlO1xyXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCk7XHJcblxyXG4gIHdpZHRoOiAwLjZyZW07XHJcbiAgaGVpZ2h0OiAwLjZyZW07XHJcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG5cclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAke0dSRUVOfTtcclxuYDtcclxuIiwiaW1wb3J0IHN0eWxlZCBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcclxuXHJcbmltcG9ydCBUYWdzU2VjdGlvbiBmcm9tIFwiLi90YWdzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZWFyY2hTZWN0aW9uKCkge1xyXG4gIHJldHVybiAoXHJcbiAgICA8V3JhcHBlcj5cclxuICAgICAgPFRhZ3NTZWN0aW9uIC8+XHJcbiAgICA8L1dyYXBwZXI+XHJcbiAgKTtcclxufVxyXG5cclxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIGhlaWdodDogMTAwJTtcclxuYDtcclxuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xyXG5cclxuaW1wb3J0IEFjY29yZGlvblNlY3Rpb24gZnJvbSBcIkBzcmMvY29tcG9uZW50cy9jb21tb24vYWNjb3JkaW9uLXNlY3Rpb25cIjtcclxuaW1wb3J0IFRhZyBmcm9tIFwiQHNyYy9jb21wb25lbnRzL2NvbW1vbi90YWdcIjtcclxuaW1wb3J0IHsgdXNlQXBwQ29udGV4dCB9IGZyb20gXCJAc3JjL2NvbnRleHRzL2FwcFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFnc1NlY3Rpb24oKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgc3RhdGU6IHsgcG9zdHMgfSxcclxuICB9ID0gdXNlQXBwQ29udGV4dCgpO1xyXG5cclxuICBjb25zdCB0YWdzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICByZXR1cm4gcG9zdHMucmVkdWNlKChhY2MsIHsgbWV0YTogeyB0YWdzIH0gfSkgPT4ge1xyXG4gICAgICB0YWdzPy5mb3JFYWNoKCh0YWcpID0+IHtcclxuICAgICAgICBpZiAoYWNjW3RhZ10gPT0gbnVsbCkge1xyXG4gICAgICAgICAgYWNjW3RhZ10gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY2NbdGFnXSArPSAxO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4pO1xyXG4gIH0sIFtwb3N0c10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEFjY29yZGlvblNlY3Rpb24gdGl0bGU9XCJUYWdzXCIgZGVmYXVsdEV4cGFuZGVkPlxyXG4gICAgICA8V3JhcHBlcj5cclxuICAgICAgICB7T2JqZWN0LmVudHJpZXModGFncykubWFwKChba2V5LCB2YWx1ZV0pID0+IChcclxuICAgICAgICAgIDxUYWcga2V5PXtrZXl9IGNvdW50PXt2YWx1ZX0gaHJlZj17YC9wb3N0cz90YWc9JHtrZXl9YH0+XHJcbiAgICAgICAgICAgIHtrZXl9XHJcbiAgICAgICAgICA8L1RhZz5cclxuICAgICAgICApKX1cclxuICAgICAgPC9XcmFwcGVyPlxyXG4gICAgPC9BY2NvcmRpb25TZWN0aW9uPlxyXG4gICk7XHJcbn1cclxuXHJcbmNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICBmbGV4LXdyYXA6IHdyYXA7XHJcbiAgcGFkZGluZzogMC44cmVtO1xyXG5gO1xyXG4iLCJpbXBvcnQgUmVhY3QsIHsgUmVhY3ROb2RlLCB1c2VTdGF0ZSwgZm9yd2FyZFJlZiwgRm9yd2FyZGVkUmVmIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XHJcblxyXG5pbXBvcnQgeyBDbG9zZUljb24gYXMgX0Nsb3NlSWNvbiB9IGZyb20gXCJAc3JjL2Fzc2V0cy9pY29uc1wiO1xyXG5pbXBvcnQgeyBCTFVFIH0gZnJvbSBcIkBzcmMvY29uc3RhbnRzL3BhbGV0dGVcIjtcclxuaW1wb3J0IHsgdXNlRHJhZyB9IGZyb20gXCJAc3JjL2hvb2tzXCI7XHJcbmltcG9ydCB7IGJyZWFrcG9pbnRzIH0gZnJvbSBcIkBzcmMvc3R5bGVzL3RoZW1lXCI7XHJcblxyXG5pbXBvcnQgeyBBQ1RJVklUWV9CQVJfV0lEVEggfSBmcm9tIFwiLi4vYWN0aXZpdHktYmFyXCI7XHJcblxyXG5jb25zdCBJTklUSUFMX1dJRFRIID0gMzIwO1xyXG5jb25zdCBNSU5fV0lEVEggPSA4MDtcclxuXHJcbmV4cG9ydCB0eXBlIFNpZGVCYXJQcm9wcyA9IHtcclxuICBsYWJlbDogc3RyaW5nO1xyXG4gIGNvbnRlbnQ6IFJlYWN0Tm9kZTtcclxuICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xyXG59O1xyXG5cclxuY29uc3QgU2lkZUJhciA9IGZvcndhcmRSZWYoXHJcbiAgKFxyXG4gICAgeyBsYWJlbCwgY29udGVudCwgb25DbG9zZSB9OiBTaWRlQmFyUHJvcHMsXHJcbiAgICByZWY6IEZvcndhcmRlZFJlZjxIVE1MRGl2RWxlbWVudD5cclxuICApID0+IHtcclxuICAgIGNvbnN0IFt3aWR0aCwgc2V0V2lkdGhdID0gdXNlU3RhdGUoSU5JVElBTF9XSURUSCk7XHJcbiAgICBjb25zdCB7IGlzRHJhZ2dpbmcsIHN0YXJ0RHJhZyB9ID0gdXNlRHJhZygobW92ZW1lbnQpID0+IHtcclxuICAgICAgY29uc3QgbmV4dFdpZHRoID0gd2lkdGggKyBtb3ZlbWVudC54O1xyXG4gICAgICBpZiAobmV4dFdpZHRoIDw9IE1JTl9XSURUSCkge1xyXG4gICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICBzZXRXaWR0aChJTklUSUFMX1dJRFRIKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgc2V0V2lkdGgobmV4dFdpZHRoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxXcmFwcGVyIHJlZj17cmVmfSB0YWJJbmRleD17MH0gd2lkdGg9e3dpZHRofT5cclxuICAgICAgICA8VGl0bGVXcmFwcGVyPlxyXG4gICAgICAgICAgPFRpdGxlPntsYWJlbH08L1RpdGxlPlxyXG4gICAgICAgICAgPENsb3NlSWNvbiBvbkNsaWNrPXtvbkNsb3NlfSAvPlxyXG4gICAgICAgIDwvVGl0bGVXcmFwcGVyPlxyXG4gICAgICAgIDxDb250ZW50V3JhcHBlcj57Y29udGVudH08L0NvbnRlbnRXcmFwcGVyPlxyXG4gICAgICAgIDxEcmFnZ2FibGVMaW5lIG9uTW91c2VEb3duPXtzdGFydERyYWd9IGlzVmlzaWJsZT17aXNEcmFnZ2luZ30gLz5cclxuICAgICAgPC9XcmFwcGVyPlxyXG4gICAgKTtcclxuICB9XHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaWRlQmFyO1xyXG5cclxuY29uc3QgV3JhcHBlciA9IHN0eWxlZC5zZWN0aW9uPHsgd2lkdGg6IG51bWJlciB9PmBcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcblxyXG4gIGZsZXgtc2hyaW5rOiAwO1xyXG5cclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcblxyXG4gIHdpZHRoOiAkeyhwcm9wcykgPT4gcHJvcHMud2lkdGh9cHg7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuc2VtYW50aWNTY2hlbWUuc2lkZUJhckJnfTtcclxuXHJcbiAgJHticmVha3BvaW50cy5zbWFsbH0ge1xyXG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtICR7QUNUSVZJVFlfQkFSX1dJRFRIfSk7XHJcbiAgICB6LWluZGV4OiAxO1xyXG4gIH1cclxuYDtcclxuXHJcbmNvbnN0IFRpdGxlV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgZmxleC1zaHJpbms6IDA7XHJcblxyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcblxyXG4gIGhlaWdodDogMi40cmVtO1xyXG4gIHBhZGRpbmc6IDAgMC44cmVtO1xyXG5gO1xyXG5cclxuY29uc3QgVGl0bGUgPSBzdHlsZWQuaDJgXHJcbiAgZm9udC1zaXplOiAwLjhyZW07XHJcbiAgZm9udC13ZWlnaHQ6IDQwMDtcclxuICBjb2xvcjogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS5jb2xvcnMuc2NoZW1lLiRncmF5MTAwfTtcclxuYDtcclxuXHJcbmNvbnN0IENsb3NlSWNvbiA9IHN0eWxlZChfQ2xvc2VJY29uKS5hdHRycyh7XHJcbiAgc3R5bGU6IHsgd2lkdGg6IFwiMS4ycmVtXCIsIGhlaWdodDogXCIxLjJyZW1cIiB9LFxyXG59KWBcclxuICBkaXNwbGF5OiBub25lO1xyXG5cclxuICAke2JyZWFrcG9pbnRzLnNtYWxsfSB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcbmA7XHJcblxyXG5jb25zdCBDb250ZW50V3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgZmxleDogMTtcclxuXHJcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuYDtcclxuXHJcbmNvbnN0IERyYWdnYWJsZUxpbmUgPSBzdHlsZWQuZGl2PHsgaXNWaXNpYmxlOiBib29sZWFuIH0+YFxyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICB0b3A6IDA7XHJcbiAgcmlnaHQ6IDA7XHJcblxyXG4gIHdpZHRoOiAwLjJyZW07XHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG5cclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyh7IGlzVmlzaWJsZSB9KSA9PiAoaXNWaXNpYmxlID8gQkxVRSA6IFwidHJhbnNwYXJlbnRcIil9O1xyXG5cclxuICAmOmhvdmVyIHtcclxuICAgIGN1cnNvcjogY29sLXJlc2l6ZTtcclxuICB9XHJcbmA7XHJcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQmxvZ0xheW91dCB9IGZyb20gXCIuL2Jsb2ctbGF5b3V0XCI7XHJcbiIsImltcG9ydCBtYXR0ZXIgZnJvbSBcImdyYXktbWF0dGVyXCI7XHJcblxyXG5pbXBvcnQgeyBwYXJzZU1hcmtkb3duIH0gZnJvbSBcIi4uL2hlbHBlcnNcIjtcclxuXHJcbmltcG9ydCB7IFBvc3QsIFBvc3RNZXRhIH0gZnJvbSBcIi4uL3R5cGVzL3Bvc3QudHlwZVwiO1xyXG5cclxudHlwZSBQb3N0RmlsdGVyID0ge1xyXG4gIHRhZz86IHN0cmluZztcclxufTtcclxuXHJcbmNvbnN0IGZpbHRlclBvc3RzID0gKHBvc3RzOiBQb3N0W10sIGZpbHRlcjogUG9zdEZpbHRlcik6IFBvc3RbXSA9PiB7XHJcbiAgaWYgKCFmaWx0ZXIpIHtcclxuICAgIHJldHVybiBwb3N0cztcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgdGFnIH0gPSBmaWx0ZXI7XHJcblxyXG4gIGxldCBmaWx0ZXJlZFBvc3RzID0gcG9zdHM7XHJcblxyXG4gIGlmICh0YWcpIHtcclxuICAgIGZpbHRlcmVkUG9zdHMgPSBmaWx0ZXJlZFBvc3RzLmZpbHRlcigocG9zdCkgPT5cclxuICAgICAgcG9zdC5tZXRhLnRhZ3M/LmluY2x1ZGVzKHRhZylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmlsdGVyZWRQb3N0cztcclxufTtcclxuXHJcbmNvbnN0IGdldFBvc3RzID0gYXN5bmMgKGZpbHRlcj86IFBvc3RGaWx0ZXIpOiBQcm9taXNlPFBvc3RbXT4gPT4ge1xyXG4gIC8vIHJlcXVlc3Qgb25seSBtYXJrZG93biBmaWxlcyB3aGljaCBpcyBlbmRpbmcgd2l0aCAubWRcclxuICBjb25zdCBjb250ZXh0ID0gcmVxdWlyZS5jb250ZXh0KFwiY29udGVudHMvYmxvZ1wiLCB0cnVlKTtcclxuXHJcbiAgbGV0IHBvc3RzOiBQb3N0W10gPSBbXTtcclxuICBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgIGNvbnRleHQua2V5cygpLm1hcChhc3luYyAoa2V5KSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhdGggPSBrZXkuc2xpY2UoMik7IC8vIOunqCDslZ4gJy4vJyDrrLjsnpDsl7Qg7KCc6rGwXHJcbiAgICAgIGNvbnN0IHBvc3QgPSBhd2FpdCBnZXRQb3N0KHBhdGgpO1xyXG4gICAgICBwb3N0cy5wdXNoKHBvc3QpO1xyXG4gICAgfSlcclxuICApO1xyXG5cclxuICByZXR1cm4gZmlsdGVyID8gZmlsdGVyUG9zdHMocG9zdHMsIGZpbHRlcikgOiBwb3N0cztcclxufTtcclxuXHJcbmNvbnN0IGdldFBvc3QgPSBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8UG9zdD4gPT4ge1xyXG4gIGNvbnN0IHsgZGVmYXVsdDogbWFya2Rvd24gfSA9IGF3YWl0IGltcG9ydChgY29udGVudHMvYmxvZy8ke2lkfWApO1xyXG4gIGNvbnN0IHsgZGF0YSwgY29udGVudCB9ID0gbWF0dGVyKG1hcmtkb3duKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkLFxyXG4gICAgbWV0YToge1xyXG4gICAgICAuLi4oZGF0YSBhcyBQb3N0TWV0YSksXHJcbiAgICAgIGRlc2NyaXB0aW9uOlxyXG4gICAgICAgIGRhdGEuZGVzY3JpcHRpb24gPz8gY29udGVudC5zcGxpdChcIlxcblwiKS5zbGljZSgwLCA0KS5qb2luKFwiIFwiKSxcclxuICAgIH0sXHJcbiAgICBodG1sOiBwYXJzZU1hcmtkb3duKGNvbnRlbnQpLFxyXG4gIH07XHJcbn07XHJcblxyXG5jb25zdCBQb3N0U2VydmljZSA9IHtcclxuICBnZXRQb3N0cyxcclxuICBnZXRQb3N0LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUG9zdFNlcnZpY2U7XHJcbiIsImNvbnN0IGJyZWFrcG9pbnRzID0ge1xyXG4gIHNtYWxsOiBcIkBtZWRpYSAobWF4LXdpZHRoOiA2MDBweClcIixcclxuICBtZWRpdW06IFwiQG1lZGlhIChtYXgtd2lkdGg6IDc2OHB4KVwiLFxyXG4gIGxhcmdlOiBcIkBtZWRpYSAobWluLXdpZHRoOiA3NjlweClcIixcclxufTtcclxuXHJcbmV4cG9ydCB7IGJyZWFrcG9pbnRzIH07XHJcbiIsImltcG9ydCB7XHJcbiAgR1JBWV8xMDAsXHJcbiAgR1JBWV8yMDAsXHJcbiAgR1JBWV8zMDAsXHJcbiAgR1JBWV80MDAsXHJcbiAgR1JBWV81MDAsXHJcbiAgR1JBWV82MDAsXHJcbiAgV0hJVEUsXHJcbiAgRFJBQ1VMQVJfQkFDS0dST1VORF9ERUVQX0RBUkssXHJcbiAgUFVSUExFX0RBUkssXHJcbiAgR1JFRU5cclxufSBmcm9tIFwiQHNyYy9jb25zdGFudHMvcGFsZXR0ZVwiO1xyXG5cclxuaW1wb3J0IHsgQ29sb3JUaGVtZSB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZGFyazogUmVhZG9ubHk8Q29sb3JUaGVtZT4gPSBPYmplY3QuZnJlZXplKHtcclxuICBzY2hlbWU6IHtcclxuICAgICR3aGl0ZTogV0hJVEUsXHJcblxyXG4gICAgJGdyYXkxMDA6IEdSQVlfMTAwLFxyXG4gICAgJGdyYXkyMDA6IEdSQVlfMjAwLFxyXG4gICAgJGdyYXkzMDA6IEdSQVlfMzAwLFxyXG4gICAgJGdyYXk0MDA6IEdSQVlfNDAwLFxyXG4gICAgJGdyYXk1MDA6IEdSQVlfNTAwLFxyXG4gICAgJGdyYXk2MDA6IEdSQVlfNjAwLFxyXG4gICAgJHRhZ0ZvbnRDb2xvcjogR1JFRU5cclxuICB9LFxyXG4gIHNlbWFudGljU2NoZW1lOiB7XHJcbiAgICBzaWRlQmFyQmc6IFBVUlBMRV9EQVJLLFxyXG4gICAgbWFpbkJnOiBEUkFDVUxBUl9CQUNLR1JPVU5EX0RFRVBfREFSSyxcclxuICB9LFxyXG59KTtcclxuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlnaHRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZGFya1wiO1xyXG4iLCJpbXBvcnQge1xyXG4gIEdSQVlfMTAwLFxyXG4gIEdSQVlfNjAwLFxyXG4gIExJR0hUX0dSQVlfMTAwLFxyXG4gIExJR0hUX0dSQVlfMjAwLFxyXG4gIExJR0hUX0dSQVlfMzAwLFxyXG4gIExJR0hUX0dSQVlfNDAwLFxyXG4gIFBVUlBMRV9EQVJLLFxyXG4gIFdISVRFLFxyXG59IGZyb20gXCJAc3JjL2NvbnN0YW50cy9wYWxldHRlXCI7XHJcblxyXG5pbXBvcnQgeyBDb2xvclRoZW1lIH0gZnJvbSBcIi4vdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBsaWdodDogUmVhZG9ubHk8Q29sb3JUaGVtZT4gPSBPYmplY3QuZnJlZXplKHtcclxuICBzY2hlbWU6IHtcclxuICAgICR3aGl0ZTogR1JBWV82MDAsXHJcblxyXG4gICAgJGdyYXkxMDA6IEdSQVlfMTAwLFxyXG4gICAgJGdyYXkyMDA6IExJR0hUX0dSQVlfNDAwLFxyXG4gICAgJGdyYXkzMDA6IExJR0hUX0dSQVlfMzAwLFxyXG4gICAgJGdyYXk0MDA6IExJR0hUX0dSQVlfMjAwLFxyXG4gICAgJGdyYXk1MDA6IExJR0hUX0dSQVlfMTAwLFxyXG4gICAgJGdyYXk2MDA6IFdISVRFLFxyXG4gICAgJHRhZ0ZvbnRDb2xvcjogUFVSUExFX0RBUktcclxuICB9LFxyXG4gIHNlbWFudGljU2NoZW1lOiB7XHJcbiAgICBzaWRlQmFyQmc6IExJR0hUX0dSQVlfMTAwLFxyXG4gICAgbWFpbkJnOiBXSElURSxcclxuICB9LFxyXG59KTtcclxuIiwiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHAudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAiLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNl0udXNlWzFdIS4uLy4uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNl0udXNlWzJdIS4vZ2xvYmFsLmNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpey8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxudmFyIGFuY2hvckVsZW1lbnQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO3ZhciBwYXJlbnROb2RlPWFuY2hvckVsZW1lbnQucGFyZW50Tm9kZTsvLyBOb3JtYWxseSA8aGVhZD5cbi8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCxhbmNob3JFbGVtZW50KTt9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLGIsaXNOYW1lZEV4cG9ydCl7aWYoIWEmJmJ8fGEmJiFiKXtyZXR1cm4gZmFsc2U7fWxldCBwO2ZvcihwIGluIGEpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKGFbcF0hPT1iW3BdKXtyZXR1cm4gZmFsc2U7fX1mb3IocCBpbiBiKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZighYVtwXSl7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNl0udXNlWzFdIS4uLy4uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0ub25lT2ZbNl0udXNlWzJdIS4vZ2xvYmFsLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsxXSEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsyXSEuL2dsb2JhbC5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsxXSEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsyXSEuL3Bvc3QuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCl7Ly8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4vLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG52YXIgYW5jaG9yRWxlbWVudD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7dmFyIHBhcmVudE5vZGU9YW5jaG9yRWxlbWVudC5wYXJlbnROb2RlOy8vIE5vcm1hbGx5IDxoZWFkPlxuLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4vLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4vLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LGFuY2hvckVsZW1lbnQpO307XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsYixpc05hbWVkRXhwb3J0KXtpZighYSYmYnx8YSYmIWIpe3JldHVybiBmYWxzZTt9bGV0IHA7Zm9yKHAgaW4gYSl7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoYVtwXSE9PWJbcF0pe3JldHVybiBmYWxzZTt9fWZvcihwIGluIGIpe2lmKGlzTmFtZWRFeHBvcnQmJnA9PT0nZGVmYXVsdCcpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuY29udGludWU7fWlmKCFhW3BdKXtyZXR1cm4gZmFsc2U7fX1yZXR1cm4gdHJ1ZTt9O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls2XS51c2VbMV0hLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS5vbmVPZls2XS51c2VbMl0hLi9wb3N0LmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsxXSEuLi8uLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtNzdkMDU3MmJmZC8wL2NhY2hlL25leHQtbnBtLTExLjAuMS1jNDBiYzdmMzgwLWM2YjQ3NDdmMWEuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLm9uZU9mWzZdLnVzZVsyXSEuL3Bvc3QuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO2NvbnN0IGlzT2xkSUU9ZnVuY3Rpb24gaXNPbGRJRSgpe2xldCBtZW1vO3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpe2lmKHR5cGVvZiBtZW1vPT09J3VuZGVmaW5lZCcpey8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4vLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4vLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4vLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbi8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xubWVtbz1Cb29sZWFuKHdpbmRvdyYmZG9jdW1lbnQmJmRvY3VtZW50LmFsbCYmIXdpbmRvdy5hdG9iKTt9cmV0dXJuIG1lbW87fTt9KCk7Y29uc3QgZ2V0VGFyZ2V0PWZ1bmN0aW9uIGdldFRhcmdldCgpe2NvbnN0IG1lbW89e307cmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCl7aWYodHlwZW9mIG1lbW9bdGFyZ2V0XT09PSd1bmRlZmluZWQnKXtsZXQgc3R5bGVUYXJnZXQ9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOy8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5pZih3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQmJnN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KXt0cnl7Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbi8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5zdHlsZVRhcmdldD1zdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDt9Y2F0Y2goZSl7Ly8gaXN0YW5idWwgaWdub3JlIG5leHRcbnN0eWxlVGFyZ2V0PW51bGw7fX1tZW1vW3RhcmdldF09c3R5bGVUYXJnZXQ7fXJldHVybiBtZW1vW3RhcmdldF07fTt9KCk7Y29uc3Qgc3R5bGVzSW5Eb209W107ZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcil7bGV0IHJlc3VsdD0tMTtmb3IobGV0IGk9MDtpPHN0eWxlc0luRG9tLmxlbmd0aDtpKyspe2lmKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXI9PT1pZGVudGlmaWVyKXtyZXN1bHQ9aTticmVhazt9fXJldHVybiByZXN1bHQ7fWZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LG9wdGlvbnMpe2NvbnN0IGlkQ291bnRNYXA9e307Y29uc3QgaWRlbnRpZmllcnM9W107Zm9yKGxldCBpPTA7aTxsaXN0Lmxlbmd0aDtpKyspe2NvbnN0IGl0ZW09bGlzdFtpXTtjb25zdCBpZD1vcHRpb25zLmJhc2U/aXRlbVswXStvcHRpb25zLmJhc2U6aXRlbVswXTtjb25zdCBjb3VudD1pZENvdW50TWFwW2lkXXx8MDtjb25zdCBpZGVudGlmaWVyPWlkKycgJytjb3VudC50b1N0cmluZygpO2lkQ291bnRNYXBbaWRdPWNvdW50KzE7Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7Y29uc3Qgb2JqPXtjc3M6aXRlbVsxXSxtZWRpYTppdGVtWzJdLHNvdXJjZU1hcDppdGVtWzNdfTtpZihpbmRleCE9PS0xKXtzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO3N0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7fWVsc2V7c3R5bGVzSW5Eb20ucHVzaCh7aWRlbnRpZmllcjppZGVudGlmaWVyLHVwZGF0ZXI6YWRkU3R5bGUob2JqLG9wdGlvbnMpLHJlZmVyZW5jZXM6MX0pO31pZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO31yZXR1cm4gaWRlbnRpZmllcnM7fWZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKXtjb25zdCBzdHlsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO2NvbnN0IGF0dHJpYnV0ZXM9b3B0aW9ucy5hdHRyaWJ1dGVzfHx7fTtpZih0eXBlb2YgYXR0cmlidXRlcy5ub25jZT09PSd1bmRlZmluZWQnKXtjb25zdCBub25jZT0vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbnR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyE9PSd1bmRlZmluZWQnP19fd2VicGFja19ub25jZV9fOm51bGw7aWYobm9uY2Upe2F0dHJpYnV0ZXMubm9uY2U9bm9uY2U7fX1PYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7c3R5bGUuc2V0QXR0cmlidXRlKGtleSxhdHRyaWJ1dGVzW2tleV0pO30pO2lmKHR5cGVvZiBvcHRpb25zLmluc2VydD09PSdmdW5jdGlvbicpe29wdGlvbnMuaW5zZXJ0KHN0eWxlKTt9ZWxzZXtjb25zdCB0YXJnZXQ9Z2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0fHwnaGVhZCcpO2lmKCF0YXJnZXQpe3Rocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7fXRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7fXJldHVybiBzdHlsZTt9ZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKXsvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbmlmKHN0eWxlLnBhcmVudE5vZGU9PT1udWxsKXtyZXR1cm4gZmFsc2U7fXN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO30vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9jb25zdCByZXBsYWNlVGV4dD1mdW5jdGlvbiByZXBsYWNlVGV4dCgpe2NvbnN0IHRleHRTdG9yZT1bXTtyZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCxyZXBsYWNlbWVudCl7dGV4dFN0b3JlW2luZGV4XT1yZXBsYWNlbWVudDtyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTt9O30oKTtmdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLGluZGV4LHJlbW92ZSxvYmope2NvbnN0IGNzcz1yZW1vdmU/Jyc6b2JqLm1lZGlhPydAbWVkaWEgJytvYmoubWVkaWErJyB7JytvYmouY3NzKyd9JzpvYmouY3NzOy8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9cmVwbGFjZVRleHQoaW5kZXgsY3NzKTt9ZWxzZXtjb25zdCBjc3NOb2RlPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7Y29uc3QgY2hpbGROb2Rlcz1zdHlsZS5jaGlsZE5vZGVzO2lmKGNoaWxkTm9kZXNbaW5kZXhdKXtzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7fWlmKGNoaWxkTm9kZXMubGVuZ3RoKXtzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSxjaGlsZE5vZGVzW2luZGV4XSk7fWVsc2V7c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7fX19ZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSxvcHRpb25zLG9iail7bGV0IGNzcz1vYmouY3NzO2NvbnN0IG1lZGlhPW9iai5tZWRpYTtjb25zdCBzb3VyY2VNYXA9b2JqLnNvdXJjZU1hcDtpZihtZWRpYSl7c3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsbWVkaWEpO31lbHNle3N0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTt9aWYoc291cmNlTWFwJiZ0eXBlb2YgYnRvYSE9PSd1bmRlZmluZWQnKXtjc3MrPSdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSsnICovJzt9Ly8gRm9yIG9sZCBJRVxuLyogaXN0YW5idWwgaWdub3JlIGlmICAqL2lmKHN0eWxlLnN0eWxlU2hlZXQpe3N0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dD1jc3M7fWVsc2V7d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7fXN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO319bGV0IHNpbmdsZXRvbj1udWxsO2xldCBzaW5nbGV0b25Db3VudGVyPTA7ZnVuY3Rpb24gYWRkU3R5bGUob2JqLG9wdGlvbnMpe2xldCBzdHlsZTtsZXQgdXBkYXRlO2xldCByZW1vdmU7aWYob3B0aW9ucy5zaW5nbGV0b24pe2NvbnN0IHN0eWxlSW5kZXg9c2luZ2xldG9uQ291bnRlcisrO3N0eWxlPXNpbmdsZXRvbnx8KHNpbmdsZXRvbj1pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO3VwZGF0ZT1hcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCxzdHlsZSxzdHlsZUluZGV4LGZhbHNlKTtyZW1vdmU9YXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsc3R5bGUsc3R5bGVJbmRleCx0cnVlKTt9ZWxzZXtzdHlsZT1pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7dXBkYXRlPWFwcGx5VG9UYWcuYmluZChudWxsLHN0eWxlLG9wdGlvbnMpO3JlbW92ZT1mdW5jdGlvbigpe3JlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7fTt9dXBkYXRlKG9iaik7cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iail7aWYobmV3T2JqKXtpZihuZXdPYmouY3NzPT09b2JqLmNzcyYmbmV3T2JqLm1lZGlhPT09b2JqLm1lZGlhJiZuZXdPYmouc291cmNlTWFwPT09b2JqLnNvdXJjZU1hcCl7cmV0dXJuO311cGRhdGUob2JqPW5ld09iaik7fWVsc2V7cmVtb3ZlKCk7fX07fW1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGxpc3Qsb3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zfHx7fTsvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbmlmKCFvcHRpb25zLnNpbmdsZXRvbiYmdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uIT09J2Jvb2xlYW4nKXtvcHRpb25zLnNpbmdsZXRvbj1pc09sZElFKCk7fWxpc3Q9bGlzdHx8W107bGV0IGxhc3RJZGVudGlmaWVycz1tb2R1bGVzVG9Eb20obGlzdCxvcHRpb25zKTtyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3Qpe25ld0xpc3Q9bmV3TGlzdHx8W107aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpIT09J1tvYmplY3QgQXJyYXldJyl7cmV0dXJuO31mb3IobGV0IGk9MDtpPGxhc3RJZGVudGlmaWVycy5sZW5ndGg7aSsrKXtjb25zdCBpZGVudGlmaWVyPWxhc3RJZGVudGlmaWVyc1tpXTtjb25zdCBpbmRleD1nZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO31jb25zdCBuZXdMYXN0SWRlbnRpZmllcnM9bW9kdWxlc1RvRG9tKG5ld0xpc3Qsb3B0aW9ucyk7Zm9yKGxldCBpPTA7aTxsYXN0SWRlbnRpZmllcnMubGVuZ3RoO2krKyl7Y29uc3QgaWRlbnRpZmllcj1sYXN0SWRlbnRpZmllcnNbaV07Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7aWYoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXM9PT0wKXtzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO3N0eWxlc0luRG9tLnNwbGljZShpbmRleCwxKTt9fWxhc3RJZGVudGlmaWVycz1uZXdMYXN0SWRlbnRpZmllcnM7fTt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ezc2MjpmdW5jdGlvbihuKXtuLmV4cG9ydHM9ZnVuY3Rpb24obil7dmFyIHQ9W107dC50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbih0KXt2YXIgcj1jc3NXaXRoTWFwcGluZ1RvU3RyaW5nKHQsbik7aWYodFsyXSl7cmV0dXJuXCJAbWVkaWEgXCIuY29uY2F0KHRbMl0sXCIge1wiKS5jb25jYXQocixcIn1cIil9cmV0dXJuIHJ9KS5qb2luKFwiXCIpfTt0Lmk9ZnVuY3Rpb24obixyLG8pe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7bj1bW251bGwsbixcIlwiXV19dmFyIGU9e307aWYobyl7Zm9yKHZhciBhPTA7YTx0aGlzLmxlbmd0aDthKyspe3ZhciBjPXRoaXNbYV1bMF07aWYoYyE9bnVsbCl7ZVtjXT10cnVlfX19Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciB1PVtdLmNvbmNhdChuW2ldKTtpZihvJiZlW3VbMF1dKXtjb250aW51ZX1pZihyKXtpZighdVsyXSl7dVsyXT1yfWVsc2V7dVsyXT1cIlwiLmNvbmNhdChyLFwiIGFuZCBcIikuY29uY2F0KHVbMl0pfX10LnB1c2godSl9fTtyZXR1cm4gdH07ZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhuLHQpe3ZhciByPW5bMV18fFwiXCI7dmFyIG89blszXTtpZighbyl7cmV0dXJuIHJ9aWYodCYmdHlwZW9mIGJ0b2E9PT1cImZ1bmN0aW9uXCIpe3ZhciBlPXRvQ29tbWVudChvKTt2YXIgYT1vLnNvdXJjZXMubWFwKGZ1bmN0aW9uKG4pe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoby5zb3VyY2VSb290fHxcIlwiKS5jb25jYXQobixcIiAqL1wiKX0pO3JldHVybltyXS5jb25jYXQoYSkuY29uY2F0KFtlXSkuam9pbihcIlxcblwiKX1yZXR1cm5bcl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiB0b0NvbW1lbnQobil7dmFyIHQ9YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobikpKSk7dmFyIHI9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQodCk7cmV0dXJuXCIvKiMgXCIuY29uY2F0KHIsXCIgKi9cIil9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXtpZih0W3JdKXtyZXR1cm4gdFtyXS5leHBvcnRzfXZhciBvPXRbcl09e2V4cG9ydHM6e319O3ZhciBlPXRydWU7dHJ5e25bcl0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7ZT1mYWxzZX1maW5hbGx5e2lmKGUpZGVsZXRlIHRbcl19cmV0dXJuIG8uZXhwb3J0c31fX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXyg3NjIpfSgpOyIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC03N2QwNTcyYmZkLzAvY2FjaGUvbmV4dC1ucG0tMTEuMC4xLWM0MGJjN2YzODAtYzZiNDc0N2YxYS56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCB7XFxyXFxuICBmb250LWZhbWlseTogXFxcIlNwb3FhIEhhbiBTYW5zIE5lb1xcXCIsIFxcXCJzYW5zLXNlcmlmXFxcIjtcXHJcXG4gIGZvbnQtc2l6ZTogMTZweDtcXHJcXG59XFxyXFxuXFxyXFxuaHRtbCxcXHJcXG5ib2R5IHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuYm9keSB7XFxyXFxuICBmb250LXNpemU6IDFyZW07XFxyXFxufVxcclxcblxcclxcbiosXFxyXFxuOjphZnRlcixcXHJcXG46OmJlZm9yZSB7XFxyXFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbn1cXHJcXG5cXHJcXG5oMSxcXHJcXG5oMixcXHJcXG5oMyxcXHJcXG5oNCxcXHJcXG5oNSxcXHJcXG5oNixcXHJcXG5wLFxcclxcbnVsLFxcclxcbm9sLFxcclxcbmxpIHtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHBhZGRpbmc6IDA7XFxyXFxufVxcclxcblxcclxcbnVsLFxcclxcbm9sIHtcXHJcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuYSB7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG59XFxyXFxuXFxyXFxuaW5wdXQge1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1heC13aWR0aDogNjAwcHgpIHtcXHJcXG4gIGh0bWwge1xcclxcbiAgICBmb250LXNpemU6IDE1cHg7XFxyXFxuICB9XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvc3R5bGVzL2dsb2JhbC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSwrQ0FBK0M7RUFDL0MsZUFBZTtBQUNqQjs7QUFFQTs7RUFFRSxTQUFTO0VBQ1QsVUFBVTtFQUNWLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBOzs7RUFLRSxzQkFBc0I7QUFDeEI7O0FBRUE7Ozs7Ozs7Ozs7RUFVRSxTQUFTO0VBQ1QsVUFBVTtBQUNaOztBQUVBOztFQUVFLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLHFCQUFxQjtFQUNyQixjQUFjO0FBQ2hCOztBQUVBO0VBQ0Usd0JBQXdCO0VBQ3hCLHdCQUF3QjtBQUMxQjs7QUFFQTtFQUNFO0lBQ0UsZUFBZTtFQUNqQjtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImh0bWwge1xcclxcbiAgZm9udC1mYW1pbHk6IFxcXCJTcG9xYSBIYW4gU2FucyBOZW9cXFwiLCBcXFwic2Fucy1zZXJpZlxcXCI7XFxyXFxuICBmb250LXNpemU6IDE2cHg7XFxyXFxufVxcclxcblxcclxcbmh0bWwsXFxyXFxuYm9keSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbmJvZHkge1xcclxcbiAgZm9udC1zaXplOiAxcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4qLFxcclxcbjo6YWZ0ZXIsXFxyXFxuOjpiZWZvcmUge1xcclxcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG59XFxyXFxuXFxyXFxuaDEsXFxyXFxuaDIsXFxyXFxuaDMsXFxyXFxuaDQsXFxyXFxuaDUsXFxyXFxuaDYsXFxyXFxucCxcXHJcXG51bCxcXHJcXG5vbCxcXHJcXG5saSB7XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICBwYWRkaW5nOiAwO1xcclxcbn1cXHJcXG5cXHJcXG51bCxcXHJcXG5vbCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbmEge1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgY29sb3I6IGluaGVyaXQ7XFxyXFxufVxcclxcblxcclxcbmlucHV0IHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogMDtcXHJcXG59XFxyXFxuXFxyXFxuQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxyXFxuICBodG1sIHtcXHJcXG4gICAgZm9udC1zaXplOiAxNXB4O1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTc3ZDA1NzJiZmQvMC9jYWNoZS9uZXh0LW5wbS0xMS4wLjEtYzQwYmM3ZjM4MC1jNmI0NzQ3ZjFhLnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIucG9zdENvbnRlbnRzIHtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjc7XFxyXFxuICBmb250LXNpemU6IDFyZW07XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgaDEsXFxyXFxuLnBvc3RDb250ZW50cyBoMixcXHJcXG4ucG9zdENvbnRlbnRzIGgzLFxcclxcbi5wb3N0Q29udGVudHMgaDQsXFxyXFxuLnBvc3RDb250ZW50cyBoNSxcXHJcXG4ucG9zdENvbnRlbnRzIGg2IHtcXHJcXG4gIG1hcmdpbi10b3A6IDJyZW07XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcclxcblxcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgaDEge1xcclxcbiAgZm9udC1zaXplOiAyLjJyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgaDIge1xcclxcbiAgZm9udC1zaXplOiAxLjhyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgaDMge1xcclxcbiAgZm9udC1zaXplOiAxLjZyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgaDQge1xcclxcbiAgZm9udC1zaXplOiAxLjNyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgaDUge1xcclxcbiAgZm9udC1zaXplOiAxLjJyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgaDYge1xcclxcbiAgZm9udC1zaXplOiAxLjFyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgcCB7XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG4gIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcXHJcXG4gIG92ZXJmbG93LXdyYXA6IGFueXdoZXJlO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIHN0cm9uZyxcXHJcXG4ucG9zdENvbnRlbnRzIGIge1xcclxcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyBjb2RlOm5vdChbY2xhc3MqPVxcXCJsYW5ndWFnZVxcXCJdKSxcXHJcXG4ucG9zdENvbnRlbnRzIHN0cm9uZyxcXHJcXG4ucG9zdENvbnRlbnRzIGIge1xcclxcbiAgbWFyZ2luOiAwIDAuMnJlbTtcXHJcXG4gIHBhZGRpbmc6IDAgMC4ycmVtO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC4ycmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGEge1xcclxcbiAgY29sb3I6ICMwMDdmZDQ7XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgdWwsXFxyXFxuLnBvc3RDb250ZW50cyBvbCB7XFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG4gIHBhZGRpbmctbGVmdDogMi40cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIHVsIHtcXHJcXG4gIGxpc3Qtc3R5bGUtdHlwZTogZGlzYztcXHJcXG59XFxyXFxuLnBvc3RDb250ZW50cyBvbCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IGRlY2ltYWw7XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgdWwgdWwsXFxyXFxuLnBvc3RDb250ZW50cyBvbCB1bCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IGNpcmNsZTtcXHJcXG4gIG1hcmdpbi10b3A6IDAuNHJlbTtcXHJcXG59XFxyXFxuLnBvc3RDb250ZW50cyBvbCBvbCxcXHJcXG4ucG9zdENvbnRlbnRzIHVsIG9sIHtcXHJcXG4gIGxpc3Qtc3R5bGUtdHlwZTogbG93ZXItbGF0aW47XFxyXFxuICBtYXJnaW4tdG9wOiAwLjRyZW07XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgbGkge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMC40cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGltZyB7XFxyXFxuICBtYXgtd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgaHIge1xcclxcbiAgbWFyZ2luOiAycmVtIDA7XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgcHJlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzMzMzMzM7XFxyXFxuXFxyXFxuICBtYXJnaW46IDFyZW0gMDtcXHJcXG4gIHBhZGRpbmc6IDFyZW07XFxyXFxuICBib3JkZXItcmFkaXVzOiAwLjhyZW07XFxyXFxuXFxyXFxuICBvdmVyZmxvdy14OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIC50YWJsZS13cmFwcGVyIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgb3ZlcmZsb3cteDogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyB0YWJsZSB7XFxyXFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL3N0eWxlcy9wb3N0LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGdCQUFnQjtFQUNoQixlQUFlO0FBQ2pCOztBQUVBOzs7Ozs7RUFNRSxnQkFBZ0I7RUFDaEIsbUJBQW1COztFQUVuQixnQkFBZ0I7RUFDaEIsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsaUJBQWlCO0FBQ25CO0FBQ0E7RUFDRSxpQkFBaUI7QUFDbkI7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsY0FBYztFQUNkLHFCQUFxQjtFQUNyQix1QkFBdUI7QUFDekI7O0FBRUE7O0VBRUUsbUJBQW1CO0FBQ3JCOztBQUVBOzs7RUFHRSxnQkFBZ0I7RUFDaEIsaUJBQWlCO0VBQ2pCLHFCQUFxQjtBQUN2Qjs7QUFFQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7O0VBRUUsY0FBYztFQUNkLG9CQUFvQjtBQUN0Qjs7QUFFQTtFQUNFLHFCQUFxQjtBQUN2QjtBQUNBO0VBQ0Usd0JBQXdCO0FBQzFCO0FBQ0E7O0VBRUUsdUJBQXVCO0VBQ3ZCLGtCQUFrQjtBQUNwQjtBQUNBOztFQUVFLDRCQUE0QjtFQUM1QixrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxxQkFBcUI7QUFDdkI7O0FBRUE7RUFDRSxlQUFlO0FBQ2pCOztBQUVBO0VBQ0UsY0FBYztBQUNoQjs7QUFFQTtFQUNFLHlCQUF5Qjs7RUFFekIsY0FBYztFQUNkLGFBQWE7RUFDYixxQkFBcUI7O0VBRXJCLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSx5QkFBeUI7QUFDM0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnBvc3RDb250ZW50cyB7XFxyXFxuICBsaW5lLWhlaWdodDogMS43O1xcclxcbiAgZm9udC1zaXplOiAxcmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGgxLFxcclxcbi5wb3N0Q29udGVudHMgaDIsXFxyXFxuLnBvc3RDb250ZW50cyBoMyxcXHJcXG4ucG9zdENvbnRlbnRzIGg0LFxcclxcbi5wb3N0Q29udGVudHMgaDUsXFxyXFxuLnBvc3RDb250ZW50cyBoNiB7XFxyXFxuICBtYXJnaW4tdG9wOiAycmVtO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXHJcXG5cXHJcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxuICBsaW5lLWhlaWdodDogMS41O1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGgxIHtcXHJcXG4gIGZvbnQtc2l6ZTogMi4ycmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIGgyIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS44cmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIGgzIHtcXHJcXG4gIGZvbnQtc2l6ZTogMS42cmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIGg0IHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4zcmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIGg1IHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4ycmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIGg2IHtcXHJcXG4gIGZvbnQtc2l6ZTogMS4xcmVtO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIHAge1xcclxcbiAgbWFyZ2luOiAxcmVtIDA7XFxyXFxuICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7XFxyXFxuICBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyBzdHJvbmcsXFxyXFxuLnBvc3RDb250ZW50cyBiIHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgY29kZTpub3QoW2NsYXNzKj1cXFwibGFuZ3VhZ2VcXFwiXSksXFxyXFxuLnBvc3RDb250ZW50cyBzdHJvbmcsXFxyXFxuLnBvc3RDb250ZW50cyBiIHtcXHJcXG4gIG1hcmdpbjogMCAwLjJyZW07XFxyXFxuICBwYWRkaW5nOiAwIDAuMnJlbTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDAuMnJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyBhIHtcXHJcXG4gIGNvbG9yOiAjMDA3ZmQ0O1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIHVsLFxcclxcbi5wb3N0Q29udGVudHMgb2wge1xcclxcbiAgbWFyZ2luOiAxcmVtIDA7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDIuNHJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyB1bCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IGRpc2M7XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgb2wge1xcclxcbiAgbGlzdC1zdHlsZS10eXBlOiBkZWNpbWFsO1xcclxcbn1cXHJcXG4ucG9zdENvbnRlbnRzIHVsIHVsLFxcclxcbi5wb3N0Q29udGVudHMgb2wgdWwge1xcclxcbiAgbGlzdC1zdHlsZS10eXBlOiBjaXJjbGU7XFxyXFxuICBtYXJnaW4tdG9wOiAwLjRyZW07XFxyXFxufVxcclxcbi5wb3N0Q29udGVudHMgb2wgb2wsXFxyXFxuLnBvc3RDb250ZW50cyB1bCBvbCB7XFxyXFxuICBsaXN0LXN0eWxlLXR5cGU6IGxvd2VyLWxhdGluO1xcclxcbiAgbWFyZ2luLXRvcDogMC40cmVtO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGxpIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuNHJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyBpbWcge1xcclxcbiAgbWF4LXdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIGhyIHtcXHJcXG4gIG1hcmdpbjogMnJlbSAwO1xcclxcbn1cXHJcXG5cXHJcXG4ucG9zdENvbnRlbnRzIHByZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzMzMzO1xcclxcblxcclxcbiAgbWFyZ2luOiAxcmVtIDA7XFxyXFxuICBwYWRkaW5nOiAxcmVtO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMC44cmVtO1xcclxcblxcclxcbiAgb3ZlcmZsb3cteDogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLnBvc3RDb250ZW50cyAudGFibGUtd3JhcHBlciB7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIG92ZXJmbG93LXg6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi5wb3N0Q29udGVudHMgdGFibGUge1xcclxcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L25leHQtc2VydmVyL2xpYi9oZWFkJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJBV1MgRUMyIO2VnOq4gCDrj4TrqZTsnbgg7Jew6rKw7ZWY6riwXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLTA1LTI4XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSBBV1NcXHJcXG4gIC0gRUMyXFxyXFxuICAtIHJvdXRlNTNcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIEFXUyBFQzIg7ZWc6riAIOuPhOuplOyduCDsl7DqsrDtlZjquLBcXHJcXG5cXHJcXG5BV1MgRUMy7JmAIFJPVVRFNTPsnLzroZwg64+E66mU7J24IOyXsOqysOyXkCDqtIDtlbTshJzripQg66eO7J2AIOygleuztOqwgCDsnojri6QuIFxcclxcblxcclxcbu2VmOyngOunjCDtlZzquIAg64+E66mU7J247J2EIOyXsOqysO2VtOuztOuLpOqwgCDrnLvrsJbsl5Ag66y47KCc7IOB7Zmp7JeQIOu2gOuUqu2YlOuNmCDqsr3tl5jsnbQg7J6I7Ja0IOydtOulvCDqs7XsnKDtlZjroKQg7ZWc64ukLlxcclxcblxcclxcbiFbMjAyMTA1MjhfMjEyNDExXSguLi8uLi8uLi9hc3NldHMvaW1nLzIwMjEwNTI4XzIxMjQxMS5wbmcpXFxyXFxuXFxyXFxu7JyEIOydtOuvuOyngOyZgCDqsJnsnbQg64+E66mU7J24IOydtOumhOyXkCDtlZzquIDrj4TrqZTsnbjsnYQg64Sj7Jy866m0IGDsp4Dsm5DrkJjsp4Ag7JWK64qUIOusuOyekOqwgCDsnojsirXri4jri6QuYOudvOupsCDqsbDrtoDtlZzri6QuXFxyXFxuXFxyXFxu7ZWY7KeA66eMIOuCmOuKlCDsnbTrr7gg7ZWc6riAIOuPhOuplOyduOydhCDqtazrp6TtlbTrhqjri6TrqbQuLi4/XFxyXFxuXFxyXFxu7J2065WMIO2ZnOyaqe2VoCDsiJgg7J6I64qUIOqyg+ydtCDrsJTroZwgYCoq7ZOo64uI7L2U65OcKipgIOydtOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMg7ZOo64uI7L2U65OcXFxyXFxuXFxyXFxuPiAqKu2VnOq4gCDrj4TrqZTsnbjsnYQg7IKs7Jqp7ZWY7IukIOqyveyasOyXkCBETlPqsIAg7ZWc6riA7J2EIOyymOumrO2VmOq4sCDsnITtlZjsl6wg7JiB7Ja0LCDsiKvsnpAsIO2VmOydtO2UiCgtKeycvOuhnCDsnbTro6jslrTsp4Qg7ZOo64uI7L2U65OcKFB1bnljb2RlKeydmCDtmJXtg5zroZwg67OA7ZmY65CcIO2bhCwgRE5TIOyEnOuyhOyXkCDsoITri6wsIOyggOyepeuPseuLiOuLpC4g65Sw65287IScIOyEnOu5hOyKpOyXkCDrj4TrqZTsnbjsnYQg65Ox66Gd7ZWY7IukIOqyveyasCDtk6jri4jsvZTrk5wg67OA7ZmY6riw66W8IO2Gte2VmOyXrCBcXFwieG4tLVxcXCLroZwg7Iuc7J6R7ZWY64qUIO2TqOuLiOy9lOuTnOuhnCDrs4DtmZjrkJwg6rCS7J2EIOuTseuhne2VmOyFlOyVvOunjCDtlanri4jri6QqKlxcclxcblxcclxcblxcclxcblxcclxcbu2TqOuLiOy9lOuTnCDrs4DtmZjquLDripQg6rWs6riA7JeQIOqygOyDie2VmOuptCDsj5/slYTsoLgg64KY7Jik64uIIOqzqOudvOyEnCDsk7DrqbQg65Cc64ukLiBcXHJcXG5cXHJcXG7rgpjripQg7JWE656YIOyCrOydtO2KuOulvCDtmZzsmqntlZjsmIDri6QuXFxyXFxuXFxyXFxuW0tJU0Eg7ZOo64uI7L2U65OcIOuzgO2ZmCDsgqzsnbTtirhdKGh0dHBzOi8veG4tLWM3OWFzODlhajBlMjliNzd6LnhuLS0zZTBiNzA3ZS9pZG5jb252L2lkbmNvbnYuZG8pXFxyXFxuXFxyXFxuIVsyMDIxMDUyOF8yMTI0MThdKC4uLy4uLy4uLy9hc3NldHMvaW1nLzIwMjEwNTI4XzIxMjQxOC5wbmcpXFxyXFxuXFxyXFxuIVsyMDIxMDUyOF8yMTI0NTZdKC4uLy4uLy4uLy9hc3NldHMvaW1nLzIwMjEwNTI4XzIxMjQ1Ni5wbmcpXFxyXFxuXFxyXFxu7IKs7J207Yq4IOyeheugpeywveyXkOyEnCDrj4TrqZTsnbgg7J2066aE7J2EIOyekeyEse2VmOqzoCBgKirrs4DtmZgqKmDrsoTtirzsnYQg64iE66W066m0IOyVhOuemCBPVVRQVVTsnbQg64KY7Jio64ukLlxcclxcblxcclxcbmB4bi0tYmowYiB+fn5gIOydtCDqsJLsnbQg67OA7ZmY65CcIOqwkuydtOuLpC5cXHJcXG5cXHJcXG5BV1MgUk9VVEU1M+yXkOyEnCDri6Tsi5wg7J20IE9VVFBVVOydhCDsnoXroKXtlbTspIDri6QuXFxyXFxuXFxyXFxuIVsyMDIxMDUyOF8yMTMxMTddKC4uLy4uLy4uLy9hc3NldHMvaW1nLzIwMjEwNTI4XzIxMzExNy5wbmcpXFxyXFxuXFxyXFxu7Jik66WY6rCAIOuCmOyngCDslYrripTri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu64GdLlxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJDSS9DRCDqsJzrhZDsl5Ag64yA7ZW0IOyVjOyVhOuztOyekFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS0wOC0zMFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gamF2YXNjcmlwdFxcclxcbiAgLSBpdGVyYWJsZVxcclxcbiAgLSBpdGVyYXRvclxcclxcbiAgLSBFUzZcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIENJL0NEIOqwnOuFkOydhCDruaDrpbTqsowg7JWM7JWE67O07J6QIVxcclxcblxcclxcbuycoO2KnOu4jCDssYTrhJAgYOuTnOumvOy9lOuUqSBieSDsl5jrpqxgIOyXkCDsl4XroZzrk5zrkJwg64K07Jqp7J2EIOygleumrO2VtOuztOyVmOyKteuLiOuLpC4g66eB7YGs64qUIO2VmOuLqOyXkCDsnojsnLzri4gg7KeB7KCRIOuztOyLnOuKlOqxuCDstpTsspzrk5zrpr3ri4jri6QuXFxyXFxuXFxyXFxuIyMgQ0kvQ0TrnoA/IFxcclxcblxcclxcbj4gQ0k6IENvbnRpbnVvdXMgSW50ZWdyYXRpb24gXFxyXFxuPiBDRDogQ29udGludW91cyBEZWxpdmVyeSAoIG9yIERlcGxveW1lbnQpXFxyXFxuXFxyXFxuQ0kvQ0TrnoAg7Iuc7J6l6rO8IOqzoOqwneydmCDsmpTqtazsl5Ag67mg66W06rKMIOunnuy2sCDqsJzrsJwg67Cw7Y+sIO2UhOuhnOyEuOyKpOulvCDruaDrpbTqsowg7ZWgIOyImCDsnojrj4TroZ0g7Ya17ZWp7KCB7J206rOgKENvbnRpbnVvdXMgbnRlZ3JhdGlvbikg7KeA7IaN7KCB7J24IOqwnOuwnCAtIOuwsO2PrCDtlITroZzshLjsiqQoQ0Qp66W8IOunkO2VqeuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgQ0kg7KeA7IaN7KCB7J24IO2Gte2VqVxcclxcblxcclxcbuyDiOuhnOyatCDquLDriqXsnYQg6rCc67Cc7ZWY6rOgIGdpdCByZXBvc2l0b3J5IChHaXRodWIsIEdpdGxhYiwgQml0YnVja2V0IOuTsSnsl5AgcHVzaOuQmOuptCwgYGJ1aWxkYCAtPiBgbWVyZ2VgIC0+IGB0ZXN0YCDrkJjripQg6rO87KCV7J2EIOunkO2VqeuLiOuLpC5cXHJcXG5cXHJcXG4hW0dyYWR5IEJvb2NoXShodHRwczovL2ltYWdlLnNsaWRlc2VydmUuY29tLzg0NTkwOS9ncmFkeS1ib29jaC1wcm9ub3VuY2VkLWJvb3RjaC1sLmpwZylcXHJcXG5cXHJcXG5FeHRyZW1lIFByb2dyYW1taW5n7J2YIEdyYWR5IEJvb2No64qUIENJ7J2YIOuRkCDqsIDsp4Ag7Y+s7J247Yq466W8IOygnOyLnO2WiOuLpFxcclxcblxcclxcbjEuIOy9lOuTnCDrs4Dqsr3sgqztla3snYQgKio8dT7so7zquLDsoIE8L3U+KirsnLzroZwgKio8dT7ruYjrsojtlZjqsowg66i47KeAPC91Pioq7ZW07JW8IO2VnOuLpC5cXHJcXG4yLiAg7Ya17ZWp7J2EIOychO2VnCDri6jqs4QgKGDruYzrk5xgIC1g7YWM7Iqk7Yq4YCAtIGDrqLjsp4BgKeydmCAqKjx1PuyekOuPme2ZlDwvdT4qKlxcclxcblxcclxcblxcclxcblxcclxcbjHrsojsnZgg7KO86riw7KCB7J206rOgIOu5iOuyiO2VnCDrqLjsp4DripQsIOqwnOuwnOyekOuTpOydtCDsmKTrnpwg6riw6rCEIOqwnOuwnOydhCDtlZjqs6Ag64KY7IScIO2VnOywuCDrkqTsl5Ag7ISc66Gc7J2YIOy9lOuTnOulvCDrqLjsp4DtlZjroKTqs6Ag7ZWY66m0IOyLpOygnOuhnCDsvZTslrQg6riw64ql7J2EIOqwnOuwnO2VmOuKlCDspJHsmpTtlZwg6rKD67O064uk64qUIG1lcmdlIGNvbmZsaWN066W8IO2VtOqysO2VmOuKlCDrtoDsiJjsoIHsnbgg7J287JeQIO2bqOyUrCDrjZQg7Iuc6rCE7J2EIOunjuydtCDsk7DripQg64uo7KCQ7J2EIOunieq4sCDsnITtlZwg67Cp67KV7J2065286rOgIO2VqeuLiOuLpC5cXHJcXG5cXHJcXG4y67KI7J2YIOyekOuPme2ZlCDri6jqs4Tsl5DshJwg7KSR7JqU7ZWcIOygkOydgCDso7zquLDsoIHsnLzroZwgbWVyZ2XrkJwg7L2U65Oc6rCAIGJ1aWxkIOyDgeyXkCDrrLjsoJzripQg7JeG7JeI64qU7KeAIOyekOuPmeycvOuhnCDssrTtgaztlbTslbwg7ZWc64uk64qUIOygkOyeheuLiOuLpC4gQnVpbGTqsIAg66y47KCc7JeG7J20IOynhO2WieuQmOyXiOuLpOuptCDqt7gg64uk7J2M7JeQ64qUIOydtCDsvZTrk5zqsIAg7KCV7IOB7KCB7Jy866GcIOyekeuPme2VmOuKlOyngOulvCDsnpDrj5nsnLzroZwg7YWM7Iqk7Yq47ZWY64qUIOqyg+q5jOyngOqwgCBDSeydmCDspJHsmpTtlZwg7KCQ7J2065286rOgIOqwleyhsO2WiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5DSSDtlITroZzshLjsiqTrpbwg7Ya17ZW0IOyWu+ydhCDsiJgg7J6I64qUIOyepeygkOydgCDri6TsnYzqs7wg6rCZ7Iq164uI64ukLlxcclxcblxcclxcbjEuIOqwnOuwnCDsg53sgrDshLEg7Zal7IOBXFxyXFxuMi4g66y47KCc7KCQIOu5oOultOqyjCDrsJzqsqxcXHJcXG4zLiDrsoTqt7gg7IiY7KCVIOyaqeydtFxcclxcbjQuIOy9lOuTnCDtgITrpqzti7Ag7Zal7IOBXFxyXFxuXFxyXFxuQ0nrpbwg7J6Q64+Z7ZmUIO2VmOq4sCDsnITtlbTshJzripQg6rCc67Cc7J6Q65Ok7J20IOuqqOuRkCDsnKDri5vthYzsiqTtirjrpbwg7Y+s7ZWo7ZW07JW8IO2VmOq4sCDrlYzrrLjsl5Ag7J6Q7Jew7Iqk66CIIOy9lOuTnOydmCDtgITrpqzti7Ag7Zal7IOB6rmM7KeAIOq4sOuMgO2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyBDRCDsp4Dsho3soIHsnbgg7KCc6rO1L+uwsO2PrFxcclxcblxcclxcbuyWtOuWu+qyjCDtlZjrqbQg7J6Q64+Z7ZmU7ZW07IScIOyEnOu5hOyKpOulvCDrsLDtj6ztlaAg7IiYIOyeiOydhOq5jD9cXHJcXG5cXHJcXG4hW0NvbnRpbnVvdXMgRGVsaXZlcnldKC9hc3NldHMvaW1nL2NkMS5wbmcpXFxyXFxuXFxyXFxuIVtDb250aW51b3VzIERlcGxveW1lbnRdKC9hc3NldHMvaW1nL2NkMi5wbmcpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuUmVmLlxcclxcblxcclxcbltDSS9DRCA167aEIOqwnOuFkCDsoJXrpqwgKO2YhOyXheyXkOyEnCDsk7DripQg6rCc67CcIO2UhOuhnOyEuOyKpCkgLSDrk5zrprzsvZTrlKkgYnkg7JeY66asXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTBFbXE1RnlwaU1NKVxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLsnIjrj4TsmrDCoOuTgOyWvOuqqOuLiO2EsCDqsIDsg4Hrk5zshLjtgaztg5HCoCbCoOupgO2LsOuqqOuLiO2EsMKg66el7LKY65+8wqDrlLDroZzCoOuUsOuhnMKg7IKs7Jqp7ZWY6riwXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA4LjA3XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSB3aW5kb3dzIOuTgOyWvOuqqOuLiO2EsFxcclxcbiAgLSDqsIDsg4HrjbDsiqTtgazthrEg7ZmU66m06rOg7KCVXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyDsnIjrj4TsmrAg6rCA7IOBIOuNsOyKpO2BrO2GseqzvCDrk4Dslrzrqqjri4jthLAg7Zmc7JqpIOq3ueuMgO2ZlO2VmOq4sFxcclxcblxcclxcblxcclxcbj4g7JyI64+E7JqwwqBPU+yXkOyEnMKg65OA7Ja866qo64uI7YSwwqDsnbTsg4HCoOyCrOyaqe2VoMKg65WMwqDtlbTri7nCoOuqqOuLiO2EsOuzhOuhnMKg65Sw66GcwqDqtazrtoTtlbTshJzCoO2VnMKg7Kq97J2AwqDqs6DsoJXtmZTrqbTsnYTCoOudhOybjOuGk+qzoMKg64uk66W4wqDsqr3rp4zCoOuzgOqyve2VmOupsMKg7IKs7Jqp7ZWY6rOgwqDsi7bsl4jsnLzrgpjCoOuwqeuyleydhMKg66qo66W07IWo64uk66m0wqDslYTrnpjCoOuCtOyaqeydhMKg7ZmV7J247ZW067O07Iuc6ri4wqDstpTsspzrk5zrpr3ri4jri6QuXFxyXFxuXFxyXFxu6rKA7IOJ7ZW067O064uIwqDsnKDro4zCoOy2lOqwgMKg7JWx7J2EwqDsnbTsmqntlZjsp4DCoOyViuqzoOuPhMKg7JyI64+E7JqwwqDsnpDssrTquLDriqXsnLzroZzrj4TCoOydtMKg66y47KCc66W8wqDtlbTqsrDtlaDCoOyImMKg7J6I7Ja0wqDqs7XsnKDrk5zrpr3ri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgKirwn5KAwqDrgpjsnZjCoOusuOygnOyDge2ZqSoqXFxyXFxuXFxyXFxuLSDrk4DslrzCoOuqqOuLiO2EsMKg7IKs7JqpXFxyXFxuLSDsmbzsqr3rqbTsnYDCoOqzoOygle2ZlOuptOydhMKg652E7JuM64aT6rOgwqDqs4Tsho3CoOuztOqzoMKg7Iu27J2MXFxyXFxuLSDsmKTrpbjsqr3rqbTsnYDCoOyepuydgMKg7ZmU66m0wqDrs4DtmZjsnYTCoO2VmOqzoMKg7Iu27J2MLlxcclxcblxcclxcbjx2aWRlbyBzcmM9XFxcIi9hc3NldHMvaW1nL3ZkZWt0b3BfdmlkXzEubXA0XFxcIiB3aWR0aD1cXFwiMTAwJVxcXCIgYXV0b3BsYXkgY29udHJvbHMgbG9vcD48L3ZpZGVvPlxcclxcblxcclxcblxcclxcblxcclxcbuunpeu2geydhMKg7IKs7Jqp7ZWg65WM64qUwqDqsIDsg4HtmZjqsr3sl5DCoOuUsOudvMKg7Yq4656Z7Yyo65Oc66W8wqDsoozsmrDroZzCoO2cme2cmcKg7JO466m07IScwqDrqqjri4jthLDrs4TroZzCoOuUsOuhnMKg7IKs7Jqp7ZWgwqDsiJjCoOyeiOyWtOyEnMKg7KKL7JWY7JeI64qU642wwqDsnIjrj4TsmrDroZzCoOyekeyXheydhMKg7ZWY64uk67O064uIwqDqt7jrlYzsspjrn7zCoO2VmOugpOqzoMKg64uo7LaV7YKkwqBgQ3RybCtXaW4r67Cp7Zal7YKkKDwtwqBvcsKgLT4pYMKg66W8wqDsk7DrqbTCoOyijOyasMKg66qo65OgwqDtmZTrqbTsnbTCoOqwmeydtMKg64+M7JWE6rCA7IScwqDtlbTri7nCoOqwgOyDgeuNsOyKpO2BrO2DkeydhMKg66qo65OgwqDrqqjri4jthLDqsIDCoOqzteycoO2VtOuyhOumrOuKlMKg66y47KCc6rCAwqDsnojsl4jsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgKirwn5KhwqDslrTripDCoOygleuPhMKg7ZW06rKw7ZWgwqDrsKnrspXsnYTCoOywvuyVmOyKteuLiOuLpC4qKlxcclxcblxcclxcbuybkOumrOuKlMKg6rCA7IOB7ZmU66m0wqDsnpDssrTrpbzCoOuqqOuLiO2EsOuzhOuhnMKg67aE7ZmU7ZWY64qUwqDqsoPsnYDCoOyVhOuLiOqzoCzCoOuYkeqwmeydgMKg7LC97J2EwqDrqqjrk6DCoOqwgOyDgcKg642w7Iqk7YGs7Yax7JeQwqDqs6DsoJXsoIHsnLzroZzCoOudhOybjOuGk+uKlMKg67Cp67KV7J6F64uI64ukLlxcclxcblxcclxcbijslYTsib3sp4Drp4zCoOunpeu2geyymOufvMKg6rCA7IOBwqDrjbDsiqTtgaztg5HCoOyekOyytOulvMKg66qo64uI7YSw67OE66GcwqDrtoTtmZTtlbTshJzCoOyCrOyaqe2VmOuKlMKg67Cp67KV7J2AwqDslYTri5nri4jri6QuwqDsnbTrn7DCoOq4sOuKpeydhMKg7KCc6rO17ZWY64qUwqDsjajrk5ztjIzti7DCoOyVseydtMKg7J6I64qU642wwqDsnKDro4zrnbzripTCoOqyg8Kg6rCZ6rOgwqDrjbDrqqjrsoTsoITsnYTCoO2FjOyKpO2KuO2VtOuztOugpMKg7ZW064+EwqDsnbTqsoPsoIDqsoPCoOyeheugpe2VnMKg65KkwqDsgqzsmqnsmpTssq3snYTCoOuztOuCtOudvOqzoMKg7ZW07IScwqDqt4DssK7slYTshJzCoOq3uOuDpcKg7JWI7ZaI7Iq164uI64ukLilcXHJcXG5cXHJcXG4jIyMgKioxLsKgV2luwqArwqBUYWLCoO2CpOuhnMKg7Jes65+swqDtmZTrqbTsnYTCoO2VnMKg67KI7JeQwqDrnYTsm4Hri4jri6QuKipcXHJcXG5cXHJcXG4hW3ZkZWt0b3AxLnBuZ10oL2Fzc2V0cy9pbWcvdmRlc2t0b3AxLnBuZylcXHJcXG5cXHJcXG4jIyMgKioyLsKg6rOE7IaNwqDqs6DsoJXtlZjroKTripTCoOywvcKg66eI7Jqw7IqkwqDsmrDtgbTrpq3CoD7CoFxcXCLrqqjrk6DCoOuwlO2DlcKg7ZmU66m07JeQwqDsnbTCoOywvcKg7ZGc7IucXFxcIsKg7YG0KipcXHJcXG5cXHJcXG4hW3ZkZXNrdG9wMi5wbmddKC9hc3NldHMvaW1nL3ZkZXNrdG9wMi5wbmcpXFxyXFxuXFxyXFxu7YGs66Gs7LC97J2EIOyasO2BtOumre2VmOqzoCDsiqTsg7fssI3snLzroKQg7ZaI64qU642wIFdpbitUYWLsg4Htmansl5DshJwg7Iqk7IO37LCN6riw6rCAIOyJveyngOqwgCDslYrslYTshJwg7KKAIOyWtOq4i+uCrOyKteuLiOuLpCA7O1xcclxcblxcclxcbj4g7LC46rOg66GcICgxKeuqqOuToCDrsJTtg5XtmZTrqbTsl5Ag7J20IOywvSDtkZzsi5wg7ZWY6rOgICgyKeuqqOuToCDrsJTtg5XtmZTrqbTsl5Ag7J20IOyVseywvSDtkZzsi5zripQg7KGw6riIIOuLpOumheuLiOuLpC5cXHJcXG5cXHJcXG7qsJnsnYAg7YGs66Gs7LC97J207Ja064+EIOyXrOufrOqwnOuhnCDrgpjriITslrTsoLgg7J6I7Jy866m0ICAoMSnsnZgg6rK97JqwIOyEpOygle2VnCDtlZjrgpjsnZgg7YGs66Gs7LC966eM7J2EIOqzoOygle2VqeuLiOuLpC4g7ZWY7KeA66eMICgyKeydmCDqsr3smrAg7Jes65+s6rCc7J2YIO2BrOuhrOywveydhCDrqqjrkZAgXFxcIu2BrOuhrFxcXCLsnbTrnbzripQg7ZWY64KY7J2YIOyVseycvOuhnCDsnbjsi53tlZjsl6wg7JiI7IOB6rO864qUIOuLpOuluCDqsrDqs7zqsIAg64KY7JisIOyImCDsnojsnLzrr4DroZwgKipcXFwiKDEpIOuqqOuToCDrsJTtg5XtmZTrqbTsl5Ag7J20IOywvSDtkZzsi5xcXFwiKirrpbwg7LaU7LKc7ZWp64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyAqKjMuwqDrgpjrqLjsp4DCoOuzgO2ZmO2VmOupsMKg7IKs7Jqp7ZWY6rOgwqDsi7bsnYDCoOyVseuTpOydgMKg6rCB6rCB7J2YwqDqsIDsg4HCoOuNsOyKpO2BrO2DkTEswqAyLMKgM+ycvOuhnMKg64KY64ig7IScwqDrtoTrsLAqKlxcclxcblxcclxcbuyYiOulvMKg65Ok7Ja0wqDtgazroazssL3snYTCoOqzhOyGjcKg652E7JuM64aT6rOgwqDsi7bri6TrqbTCoGDtgazroazssL3CoOyasO2BtOumrcKgPsKgXFxcIuuqqOuToMKg67CU7YOVwqDtmZTrqbTsl5DCoOydtMKg7LC9wqDtkZzsi5xcXFwiYMKg7YG066atXFxyXFxuXFxyXFxu7J2065+s66m0wqDsnbTCoO2BrOuhrOywveydtMKg642w7Iqk7YGs7YORwqAxLMKgMizCoDPCoOuTseyXkMKg66qo65GQwqDrs7XsgqzqsIDCoOuQmOqzoMKg7ZWcwqDsqr3CoOuptOydhMKg7LCo7KeA7ZWY6rKMwqDrkKnri4jri6QuXFxyXFxuXFxyXFxuQ3RybCtXaW4r67Cp7Zal7YKkwqDri6jstpXtgqTrpbzCoO2ZnOyaqe2VtMKg642w7Iqk7YGs7YOR7J2EwqDrhJjrgpjCoOuTpOyWtOuPhMKg7ZWcwqDsqr3rqbTsl5DCoOqzoOygleuQnMKg7YGs66Gs7LC97J2AwqDqt7jCoOyekOumrOulvMKg6re464yA66GcwqDsp4DtgqTqs6DCoOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4jIyDwn5iOIOyggeyaqSDtm4Qg66qo7Iq1XFxyXFxuXFxyXFxuPHZpZGVvIHNyYz1cXFwiL2Fzc2V0cy9pbWcvdmRla3RvcF92aWRfMi5tcDRcXFwiIHdpZHRoPVxcXCIxMDAlXFxcIiBhdXRvcGxheSBjb250cm9scyBsb29wPjwvdmlkZW8+XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu6rCA7IOBwqDrjbDsiqTtgaztg5Hsl5DshJzCoOyVjO2DrcKg64iE66W06rGw64KYwqDqt7jrn6zrqbTCoOyigMKg7JWx65Ok7J20wqDrs7XsnqHtlbTsp4Dqs6DCoO2VtOyEnMKg66el66eM7YG87J2YwqDquZTrgZTtlajsnYDCoOyVhOuLiOyngOunjMKg7JuQ7ZWY642YwqDquLDriqXsnYTCoOyTuMKg7IiYwqDsnojslrTCoOyggOuKlMKg66ek7JqwwqDrp4zsobHtlanri4jri6QuwqDrqqjri4jthLDqsIDCoOunjuyVhOyngOuNlOudvOuPhMKg7J6YwqDtmZzsmqntlZjrqbTCoOq9pMKg7Jyg7Jqp7ZWgwqDqsoPCoOqwmeyKteuLiOuLpC5cXHJcXG5cXHJcXG7qsJDsgqztlanri4jri6TCoDopXFxyXFxuXFxyXFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcImpla3lsbCDqtazquIDslaDrhJDrpqzti7HsiqQoR0EpIOuLpOuKlCDrsKnrspUg7LSI6rCE64uoIOyVjOyVhOuztOq4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wOC4xOFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gamVreWxsXFxyXFxuICAtIGdvb2dsZSBhbmFseXRpY3NcXHJcXG4gIC0gR0FcXHJcXG4gIC0g6rWs6riA7JWg64SQ66as7Yux7IqkXFxyXFxuICAtIFVYXFxyXFxuICAtIOyCrOyaqeyekO2MqO2EtFxcclxcbi0tLVxcclxcblxcclxcbiMg6rWs6riAIOyVoOuEkOumrO2LseyKpOuhnCBqZWt5bGzroZwg66eM65OgIOuCtCDruJTroZzqt7gg67Cp66y47J6QIO2WieuPme2MqO2EtCDslYzslYTrs7TripQg67Cp67KVXFxyXFxuXFxyXFxuIyMgMS4g6rWs6riAIOyVoOuEkOumrO2LseyKpCDqsIDsnoXtlZjquLAgXFxyXFxuXFxyXFxu6re47IOIIOyYiOyghOyXkCDtlaAg65WM656RIOyigCDri6zrnbzsoLgg7J6I64Sk7JqULlxcclxcblxcclxcblxcclxcblxcclxcbiFbZ2FfMV0oL2Fzc2V0cy9pbWcvZ2FfMS5wbmcpXFxyXFxuXFxyXFxu6rWs6riAIOyVoOuEkOumrO2LseyKpCDqsoDsg4kg7ZuEIOygkeyGjVxcclxcblxcclxcblxcclxcblxcclxcbiFbZ2FfMl0oL2Fzc2V0cy9pbWcvZ2FfMi5wbmcpXFxyXFxuXFxyXFxuW1N0YXJ0IE1lYXN1cmluZ10g67KE7Yq8IO2BtOumrVxcclxcblxcclxcbiFbZ2FfM10oL2Fzc2V0cy9pbWcvZ2FfMy5wbmcpXFxyXFxuXFxyXFxu6rOE7KCVIOyEpOyglSDtm4Qg64KY66i47KeAIOyEpOygleydgCDslYzslYTshJwg7LK07YGsIO2bhCBOZXh0IVxcclxcblxcclxcbiFbZ2FfNF0oL2Fzc2V0cy9pbWcvZ2FfNC5wbmcpXFxyXFxuXFxyXFxu7Lm07YWM6rOg66asLCBidXNpbmVzcyBzaXplIOuTsSDslYzslYTshJwg7LK07YGsIO2bhCBDcmVhdGVcXHJcXG5cXHJcXG4hW2dhXzVdKC9hc3NldHMvaW1nL2dhXzUucG5nKVxcclxcblxcclxcbuuniOyngOunieycvOuhnCBBZ3JlZW1lbnQg7JeQIOuPmeydmCDtm4QgQWNjZXB07ZWY66m0IOq1rOq4gCDslaDrhJDrpqzti7HsiqQg7IOd7ISx7JmE66OMXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMi4gR0Eg7Yq4656Z7L2U65OcIGpla3lsbOyXkCDsi6zquLBcXHJcXG5cXHJcXG4hW0dB7LaU7KCB7L2U65OcXShodHRwczovL3JleHRhcnguZ2l0aHViLmlvL2Fzc2V0cy8yMDE3LTAyLTAzLUFwcGx5aW5nX0dvb2dsZV9BbmFseXRpY3NfdG9fYV9ibG9nX3VzaW5nX0pla3lsbC80LnBuZylcXHJcXG5cXHJcXG7rp4zslb0g7J20IOq0gOumrCDtjpjsnbTsp4Dsl5Ag65Ok7Ja07Jik7KeAIOuqu+2VmOyFqOuLpOuptCDsmbzsqr0g7ZWY64uo7JeQICoqW+q0gOumrF0gKiog67KE7Yq87J2EIO2BtOumre2VtOuztOyEuOyalC5cXHJcXG5cXHJcXG4hW2dhXzZdKC9hc3NldHMvaW1nL2dhXzYucG5nKVxcclxcblxcclxcblxcclxcblxcclxcbiFbZ2FfN10oL2Fzc2V0cy9pbWcvZ2FfNy5wbmcpXFxyXFxuXFxyXFxuIyMjICjsoJHsho0g6rK966GcKV9pbmNsdWRlcyA+IF90aGlyZF9wYXJ0eSA+IGFuYWx5dGljcyA+IGdvb2dsZS1hbmFseXRpY3MuaHRtbFxcclxcblxcclxcbuychCDqsr3roZzroZwg65Ok7Ja07JmA7IScIOq1rOq4gCDslaDrhJDrpqzti7HsiqQg7Y6Y7J207KeA7JeQIOyeiOuNmCDstpTsoIHsvZTrk5zrpbwg7Ius7Ja07KSN64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIDMuIF9jb25maWcueW1sIOyXkCDstpTsoIFJRCDstpTqsIDtlbTso7zquLBcXHJcXG5cXHJcXG4hW2dhXzhdKC9hc3NldHMvaW1nL2dhXzgucG5nKVxcclxcblxcclxcbmBfY29uZmlnLnltbCBgIO2MjOydvOyXkOyEnCBnb29nbGVfYW5hbHl0aWNz66W8IOywvuyVhOyEnCAqKlVBLU9PT09PT09PLTEqKiDqs7wg6rCZ7J2AIOy2lOyggSBJROulvCDstpTqsIDtlbTspI3ri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7Jes6riw6rmM7KeAIOyZhOujjOuQmOyXiOycvOuptCDrgZ0hXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgNC4g7JmE7ISx65CcIOuqqOyKtVxcclxcblxcclxcbiFbZ2FfOV0oL2Fzc2V0cy9pbWcvZ2FfOS5wbmcpXFxyXFxuXFxyXFxuIVtnYV8xMF0oL2Fzc2V0cy9pbWcvZ2FfMTAucG5nKVxcclxcblxcclxcbuyLnOqwhOydtCDsobDquIgg7KeA64KY6rOg64KY66m0Li4uV09XISBcXHJcXG5cXHJcXG7rk5zrlJTslrQg7Ja866eI64KYIOunjuydgCDsgqzsmqnsnpDrk6TsnbQg67Cp66y4LeydtO2DiO2WiOuKlOyngCDtlZwg64iI7JeQIOuzvCDsiJgg7J6I64qUIOuMgOyLnOuztOuTnOqwgCDrs7TsnoXri4jri6QhXFxyXFxuXFxyXFxu6re467CW7JeQ64+EIOyLpOyLnOqwhCDsgqzsmqnsnpDsl5Ag64yA7ZWcIOygleuztCwg7J6g7J6s6rOg6rCd7Li17JeQIOuMgO2VnCDsoJXrs7Trj4Qg7IK07Y6067O8IOyImCDsnojqs6Ag7Ja065akIO2OmOydtOyngOyXkCDslrzrp4jrgpgg66eO7J2AIOuwqeusuO2an+yImOqwgCDrgpjsmZTripTsp4Ag65Ox7JeQIOuMgO2VnCDri6TslpHtlZwg7KCV67O066W8IOyVjCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbkdB7JmAIO2VqOq7mCDrjZTsmrEg7Zqo6rO87KCB7Jy866GcIOu4lOuhnOq3uOulvCDsnpgg6r6466mw64KY6rCA7Iuc6ri4IOuwlOuejeuLiOuLpC4gXFxyXFxuXFxyXFxu6rCQ7IKs7ZWp64uI64ukLlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLqsJzrsJzsnpDrpbwg6rS066Gt7Z6I7KeA66eMIOyXhuyWtOyEnOuKlCDslYjrkJjripQgQ09SU1xcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMC4xMi4xNlxcXCJcXHJcXG50YWdzOlxcclxcbiAgLSBodHRwXFxyXFxuICAtIOybueqwnOuwnFxcclxcbiAgLSBDT1JTXFxyXFxuICAtIFNPUFxcclxcbiAgLSDrhKTtirjsm4ztgaxcXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nLCBDT1JTXFxyXFxuXFxyXFxuPiDsnbQg7Y+s7Iqk7YyF7J2AIOqwmeydtCDsiqTthLDrlJQg7ZaI642YIO2MgOybkCDsi6Dsg4Htm4jri5jsnZgg7Y+s7Iqk7YyF7J2EIOq4sOuwmOycvOuhnCDslb3qsITsnZgg7Y647KeR66eM7J2EIOuNlO2WiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyAwLiBDT1JT66W8IOydtO2VtO2VmOq4sCDsnITtlZwg67Cw6rK9XFxyXFxuXFxyXFxuKipDT1JT64qUIOybuSDqsJzrsJzsnpDrnbzrqbQg7ZWcIOuyiOyvpOydgCDrp4jso7ztlZjqsowg65CgIOygleyxheyeheuLiOuLpC4qKlxcclxcblxcclxcbk1vemlsbGHsnZggTUROIOyXkOyEnOuKlCBDT1JT66W8IOyVhOuemOyZgCDqsJnsnbQg7ISk66qF7ZWY6rOgIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4+IGDqtZDssKgg7Lac7LKYIOumrOyGjOyKpCDqs7XsnKBg64qUIOy2lOqwgCBgSFRUUCDtl6TrjZRg66W8IOyCrOyaqe2VmOyXrCwg7ZWcIGDstpzssphg7JeQ7IScIOyLpO2WiSDspJHsnbgg7Ju5IOyVoO2UjOumrOy8gOydtOyFmOydtCDri6Trpbgg7Lac7LKY7J2YIOyEoO2Dne2VnCDsnpDsm5Dsl5Ag7KCR6re87ZWgIOyImCDsnojripQg6raM7ZWc7J2EIOu2gOyXrO2VmOuPhOuhnSDruIzrnbzsmrDsoIDsl5Ag7JWM66Ck7KO864qUIOyytOygnOyeheuLiOuLpC4g7Ju5IOyVoO2UjOumrOy8gOydtOyFmOydgCDrpqzshozsiqTqsIAg7J6Q7Iug7J2YIOy2nOyymCjrj4TrqZTsnbgsIO2UhOuhnO2GoOy9nCwg7Y+s7Yq4KeyZgCDri6Trpbwg65WMIOq1kOywqCDstpzsspggSFRUUCDsmpTssq3snYQg7Iuk7ZaJ7ZWp64uI64ukLlxcclxcbj5cXHJcXG4+IOyJveqyjCDrp5DtlbQg6rWQ7LCoIOy2nOyymCDsnpDsm5Ag6rO17Jyg64qUIOybuSDtjpjsnbTsp4Ag7IOB7J2YIOygnO2VnOuQnCDrpqzshozsiqTrpbwg7LWc7LSIIOyekOybkOydtCDshJzruYTsiqTrkJwg64+E66mU7J24IOuwluydmCDri6Trpbgg64+E66mU7J247Jy866Gc67aA7YSwIOyalOyyre2VoCDsiJgg7J6I6rKMIO2XiOyaqe2VmOuKlCDqtazsobDsnoXri4jri6QuIENPUlPripQg6rWQ7LCoIOy2nOyymCDsmpTssq3snYQg7ZeI7Jqp7ZWY64qUIOqyg+ydtCDslYjsoITtlZzsp4Ag7JWE64uM7KeA66W8IO2MkOuzhO2VmOq4sCDsnITtlbQg67iM65287Jqw7KCA7JmAIOyEnOuyhOqwgCDsg4HtmLgg7Ya17Iug7ZWY64qUIO2VmOuCmOydmCDrsKnrspXsnYQg7KCV7J2Y7ZWp64uI64ukLlxcclxcblxcclxcbiMjIyAwLjEg7Iuc7J6RIOyghCDsp5Hqs6Ag64SY7Ja06rCIIOygkFxcclxcblxcclxcbi0gQ09SU+ulvCDsp4Hsl63tlZjri4ggYENyb3NzLU9yaWdpbmAg7J2EIGDqtZDssKgg7Lac7LKYYCDroZwg7ZW07ISd65CY7JeI64qU642wIGBcXFwi64uk66W4IOy2nOyymFxcXCJgIOuhnCDsg53qsIHtlZjripTqsowg7J207ZW07JeQIOuPhOybgOydtCDrkJzri6QuXFxyXFxuLSDspokgQ09SUyDripQgYOuLpOuluCDstpzsspjqsITsnZgg66as7IaM7IqkIOqzteycoGAg652864qUIOydmOuvuCAhXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMS4g6rCZ7J2AIOy2nOyymCwg64uk66W4IOy2nOyymOuKlCDrrLTsl4fsnYQg6riw7KSA7Jy866GcIOuCmOuJmOuKlOqwgD9cXHJcXG5cXHJcXG4jIyMgMS4xIOy2nOyymChPcmlnaW4pXFxyXFxuXFxyXFxuXFxyXFxuICoq7ISc67KE7J2YIOychOy5mOulvCDsnZjrr7jtlZjripQgVVJM7J2AIOyXrOufrCDqsJzsnZgg6rWs7ISxIOyalOyGjOuhnCDsnbTro6jslrTsoLgg7J6I7Iq164uI64ukLioqXFxyXFxuXFxyXFxuIVtdKC9hc3NldHMvaW1nL3NvdXJjZXMuSlBHKVxcclxcblxcclxcbi0g7Lac7LKY64qUIOychCDqt7jrprzqs7wg6rCZ7J20IGBQcm90b2NvbGAg6rO8IGBIb3N0YCDrk7EsIOq3uOumrOqzoCDqt7jrprzsl5Ag7JeG64qUIGA6NDQzYCDqs7wg6rCZ7J2AIO2PrO2KuCDrsojtmLjquYzsp4Ag66qo65GQIO2Vqey5nCDqsoPsnYQg7J2Y66+47ZWp64uI64ukLiDspoksIOyEnOuyhOydmCDsnITsuZjrpbwg7LC+7JWE6rCA6riwIOychO2VtCDtlYTsmpTtlZwg6rCA7J6lIOq4sOuzuOyggeyduCDqsoPrk6TsnYQg7ZWp7LOQ64aT7J2AIOqyg+ydtOyjoFxcclxcblxcclxcbi0g7Lac7LKYIOuCtOydmCDtj6ztirgg67KI7Zi464qUIOyDneueteydtCDqsIDriqXtlZzrjbAsIOydtOuKlCDqsIEg7Ju57JeQ7IScIOyCrOyaqe2VmOuKlCBgSFRUUGAsIGBIVFRQU2Ag7ZSE66Gc7Yag7L2c7J2YIOq4sOuzuCDtj6ztirgg67KI7Zi46rCAIOygle2VtOyguCDsnojquLAg65WM66y47J6F64uI64ukLiAo7KeA64KcIO2PrOyKpO2MheyXkOuPhCDslrjquIntlojrk6/snbQg6riw67O47KCB7Jy866GcIDgw7Y+s7Yq466W8IOyTsOqzoCDsnbTrlYzripQg7IOd6561IOqwgOuKpe2VqC4pXFxyXFxuLSDqt7jrn6zrgpgsIOunjOyVvSBgaHR0cHM6Ly9nb29nbGUuY29tOjQ0M2Ag6rO8IOqwmeydtCDstpzsspjsl5Ag7Y+s7Yq4IOuyiO2YuOqwgCDrqoXsi5zsoIHsnLzroZwg7Y+s7ZWo65Cc64uk66m0LCDsnbQg7Y+s7Yq4IOuyiO2YuOq5jOyngCDrqqjrkZAg7J287LmY7ZW07JW8IOqwmeydgCDstpzsspjrnbzqs6Ag7J247KCV65Cp64uI64ukLlxcclxcbiAgLSAo6re465+w642wIOydtCDsvIDsnbTsiqTsl5Ag64yA7ZWcIOuqhe2Zle2VnCDsoJXsnZjqsIAg7ZGc7KSA7Jy866GcIOygle2VtOynhCDqsoPsnYAg7JWE64uI7Ja07IScLCDslrTrlqQg6rK97Jqw7JeQ64qUIOuLpOuluCDstpzsspjroZwg7YyQ64uo65CgIOyImOuPhCDsnojri6TripTqsowg7ZWo7KCVKVxcclxcblxcclxcbi0tLVxcclxcblxcclxcblxcclxcblxcclxcbiMjIyAxLjIgU09QKFNhbWUtT3JpZ2luIFBvbGljeSkg64+Z7J287Lac7LKYIOygleyxhVxcclxcblxcclxcblxcclxcblxcclxcbioq7Ju5IOyEuOqzhOyXkOyEnCDri6Trpbgg7Lac7LKY66Gc7J2YIOumrOyGjOyKpCDsmpTssq3snYQg7KCc7ZWc7ZWY64qUIOqyg+qzvCDqtIDroKjrkJwg7KCV7LGF7J2AIOuRkCDqsIDsp4DsnbjrjbAsIO2VnCDqsIDsp4DripQg7JWe7IScIOyGjOqwnO2VnCBDT1JTLCDrgpjrqLjsp4Ag7ZWcIOqwgOyngOqwgCBgU09QYCDsnoXri4jri6QuKipcXHJcXG5cXHJcXG4qKlNPUOydmCDsnZjrr7ggOiBcXFwi6rCZ7J2AIOy2nOyymOyXkOyEnOunjCDrpqzshozsiqTrpbwg6rO17Jyg7ZWgIOyImCDsnojri6RcXFwiIOyduOuNsCwqKiDspokg7J20IOuPmeydvCDstpzsspgg7KCV7LGF7J2AIO2VnCDrj4TrqZTsnbjsnZggSmF2YVNjcmlwdCDsvZTrk5zrpbwg67aI65+s7Jik66m0IO2VtOuLuSDsvZTrk5wg7JWI7JeQ7IScIOuLpOuluCDrj4TrqZTsnbjsnZgg642w7J207YSw66W8IOyalOyyre2VoCDsiJgg7JeG64uk64qUIOqyg+ydhCDsnZjrr7jtlanri4jri6QuIFxcclxcblxcclxcbioq65Sw65287IScIENPUlPsmYDripQg67CY64yA65CY64qUIOydmOuvuOuhnCDrs7TsnbTsp4Drp4wg6riw67O47KCB7Jy866GcIENPUlPrmJDtlZwgU09Q7J2YIOydvO2ZmOycvOuhnCBg7KCB7Ja064+EIOydtOygleuPhOuKlCDsp4DtgqTrqbTshJwg6rWQ7LCo7Lac7LKYIOyalOyyreydhCDtlbTrnbwhYCDsnbTtlbTtlZjsi5zrqbQg65Cp64uI64ukLioqXFxyXFxuXFxyXFxu64yA7ZGc7KCB7Jy866GcIGBYTUxIdHRwUmVxdWVzdGDsmYAgW0ZldGNoIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0ZldGNoX0FQSSnripQg64+Z7J287Lac7LKY7KCV7LGFKFNPUCnsnYQg65Sw66aF64uI64ukLlxcclxcblxcclxcbuyXrOq4sOyEnCBgWE1MSHR0cFJlcXVlc3RgIOuKlCDruYTrj5nquLAg7Ju5IOq4sOyIoOyXkCDqtIDroKjrkJwg6rCd7LK07J206rOgKOuMgO2RnOyggeycvOuhnCBhamF4IOyalOyyrSksYGZldGNoYOuegCDsib3qsowg66eQ7ZW0IOybuSDrpqzshozsiqTrpbwg6rCA7KC47Jik64qUIOqzoOyImOykgCBhcGnrpbwg65y77ZWp64uI64ukLiBodG1s7J2YIGltZ+2DnOq3uOuCmCBzY2lwdCDtg5zqt7gsIGphdmFzY3JpcHQsY3NzIOydmCDrpqzshozsiqQg7KCR6re87JeQIOq0gO2VnCDsnbzrtoAgYXBp64+EIEZldGNo7J2YIOq1rO2YhOyytOyeheuLiOuLpC5cXHJcXG5cXHJcXG4qKu2VmOyngOunjCDstZzqt7zsl5DripQg7Ju57J20652864qUIOyYpO2UiOuQnCDtmZjqsr3sl5DshJwgYWpheOqwgCDrjIDspJHtmZTrkJjqs6AsIE9QRU4gQVBJIOuTsSA8dT7ri6Trpbgg7Lac7LKY7JeQIOyeiOuKlCDrpqzshozsiqTrpbwg6rCA7KC47JmAIO2ZnOyaqe2VmOuKlCDsnbzsnYAg66ek7JqwIO2dlO2VnCDsnbw8L3U+66GcIOustOyekeyglSDrp4nsnYQg7IiY64qUIOyXhuyKteuLiOuLpC4g6re4656Y7IScIOuqhyDqsIDsp4Ag7JiI7Jm4IOyhsO2VreydhCDrkZDqs6Ag7J20IOyhsO2VreyXkCDtlbTri7ntlZjripQg66as7IaM7IqkIOyalOyyreydgCDri6Trpbgg7Lac7LKY652864+EIO2XiOyaqe2VmOq4sOuhnCDtlojripTrjbAsIOq3uCDspJEg7ZWY64KY6rCAIGBDT1JTIOygleyxheydhCDsp4Dtgqgg66as7IaM7IqkIOyalOyyrWAg7J207KOgLioqXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLSDsmZwg7J2065+s7ZWcIOygleyxheydtCDrp4zrk6TslrQg7KGM7J2E6rmMID9cXHJcXG5cXHJcXG4+ICDstpzsspjqsIAg64uk66W4IOuRkCDqsJzsnZgg7Ja07ZSM66as7LyA7J207IWY7J20IOygnOyVveyXhuydtCDshozthrXtlaAg7IiYIOyeiOuKlCDtmZjqsr3snbQg7JyE7ZeY7ZWY6riwIOuVjOusuOydtOuLpC4g7Yq57Z6IIOybuSDslrTtlIzrpqzsvIDsnbTshZjsnZgg6rK97JqwIOu4jOudvOyasOyggOydmCDqsJzrsJzsnpAg64+E6rWs66eMIOyXtOyWtOuPhCDslrTrlqQg7ISc67KE7JmAIO2GteyLoO2VmOuKlOyngCwg66as7IaM7Iqk7J2YIOy2nOyymOuKlCDslrTrlJTsnbjsp4DsmYAg6rCZ7J2AIOqwgeyihSDsoJXrs7Trk6TsnYQg7JWE66y065+wIOygnOyerOyXhuydtCDsl7TrnoztlaAg7IiYIOyeiOuLpC4gXFxyXFxuPlxcclxcbj4gKOy1nOq3vOyXkOuKlCDsnpDrsJTsiqTtgazrpr3tirgg7IaM7IqkIOy9lOuTnOulvCDrgpzrj4XtmZTtlbQg7J296riwIOyWtOugteuLpOqzoOuKlCDtlZjsp4Drp4wgIOuCnOuPhe2ZlOuKlCDslZTtmLjtmZTqsIAg7JWE64uI66+A66GcLCDshozsiqQg7L2U65Oc66W8IOyngeygkSDrs7wg7IiYIOyeiOuLpOuKlCDqsoMg7J6Q7LK06rCAIOuztOyViOyggeycvOuhnCDsg4Hri7ntnogg7Leo7JW97ZWY64ukLiDri6Tsi5wg67O17Zi47ZmU7ZWY64qUIOyCrOydtO2KuOuPhCDsnojsnYwuIOyDgeuLue2eiCDsib3qsowg7YyM7Zu86rCAIOqwgOuKpe2VqC4pXFxyXFxuXFxyXFxu7J2065+wIO2ZmOqyveyXkOyEnCDslYTrrLTrn7Ag7KCc7JW97J20IOyhtOyerO2VmOyngCDslYrripTri6TrqbQsIOyVheydmOulvCDqsIDsp4Qg7IKs7Jqp7J6Q6rCAIOyGjOyKpCDsvZTrk5zrpbwg7JOxIOq1rOqyve2VnCDtm4QgW0NTUkYoQ3Jvc3MtU2l0ZSBSZXF1ZXN0IEZvcmdlcnkpXShodHRwczovL2tvLndpa2lwZWRpYS5vcmcvd2lraS/sgqzsnbTtirhf6rCEX+yalOyyrV/snITsobAp64KYIFtYU1MoQ3Jvc3MtU2l0ZSBTY3JpcHRpbmcpXShodHRwczovL2tvLndpa2lwZWRpYS5vcmcvd2lraS/sgqzsnbTtirhf6rCEX+yKpO2BrOumve2MhSnsmYAg6rCZ7J2AIOuwqeuyleydhCDsgqzsmqntlZjsl6wg7IKs7Jqp7J6Q7J2YIOyWtO2UjOumrOy8gOydtOyFmOyXkOyEnCDsvZTrk5zqsIAg7Iuk7ZaJ65CcIOqyg+yymOufvCDqvrjrqbDshJwg7IKs7Jqp7J6Q7J2YIOygleuztOulvCDtg4jst6jtlZjquLDqsIAg64SI66y064KY64+EIOyJrOybjOyngOuKlCDrrLjsoJzqsIAg7IOd6ri4IOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLSDspoksIOyasOumrOqwgCDri6Trpbgg7Lac7LKY66GcIOumrOyGjOyKpOulvCDsmpTssq3tlZjrqbQgU09QIOygleyxheydhCDsnITrsJjtlZjripQg6rKD7J206rOgLCBTT1DsnZgg7JiI7Jm4IOyhsO2VreyduCBDT1JTIOygleyxheq5jOyngCDsnITrsJjtlZzri6TrqbQg7JWE7JiIIOuLpOuluCDstpzsspjsnZgg66as7IaM7Iqk66W8IOyCrOyaqe2VoCDsiJgg7JeG6rKMIOuQmOuKlCDqsoPsnbTri6QuXFxyXFxuXFxyXFxuKirqsrDroaDsoIHsnLzroZwsIOuLpOuluCDstpzsspjroZwg66as7IaM7Iqk66W8IOyalOyyre2VmOq4sCDsnITtlbTshJzripQgU09Q7JeQ7IScIOygleydmOuQnCDsmIjsmbgg7KGw7ZWt6rO8IENPUlPrpbwg7IKs7Jqp7ZWgIOyImCDsnojripQg7LyA7J207Iqk66W8IOuUsOudvOyVvCDtlZzri6TripQg6rKD7J2064ukLioqXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIDEuMyDqsJnsnYAg7Lac7LKY7JmAIOuLpOuluCDstpzsspjsnZgg6rWs67aEXFxyXFxuXFxyXFxu6rKw66Gg67aA7YSwIOunkO2VmOyekOuptCwg65GQIFVSTOydmCDqtazshLEg7JqU7IaMIOykkSBgU2NoZW1lYCwgYEhvc3RgLCBgUG9ydGAg7J20IDPqsIDsp4Drp4wg64+Z7J287ZWY66m0IOuRkCDqsJzsnZgg7Lac7LKY6rCAIOyEnOuhnCDqsJnsirXri4jri6QuXFxyXFxuXFxyXFxuYGh0dHBzOi8vbWVuc2FuLXNhbmdodW4uZ2l0aHViLmlvOjgwYCDsnbTrnbzripQg7Lac7LKY66GcIOyYiOulvCDrk6TsnpDrqbQgYGh0dHBzOi8vYCDsnbTrnbzripQg7Iqk7YK07JeQIGBtZW5zYW4tc2FuZ2h1bi5naXRodWIuaW9gIO2YuOyKpO2KuOulvCDqsIDsp4Dqs6AgYDo4MGAg67KIIO2PrO2KuOulvCDsgqzsmqntlZjqs6Ag7J6I64uk64qUIOqyg+unjCDqsJnri6TrqbQsIOuCmOuouOyngOuKlCDsoITrtoAg64uk66W0642U652864+EIOqwmeydgCDstpzsspjroZwg7YyQ64uo65Cp64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbi0g7JiI7IucKOy2nOyymOqwgCBodHRwczovL21lbnNhbi1zYW5naHVuLmdpdGh1Yi5pbyDsnbwg65WMKVxcclxcblxcclxcbnwgVVJMICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IOqwmeydgCDstpzsspgg7Jes67aAIHwg7J207JygICAgICAgICAgICAgICAgICAgICAgICAgfFxcclxcbnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcXHJcXG58IGh0dHBzOi8vbWVuc2FuLXNhbmdodW4uZ2l0aHViLmlvL2Fib3V0ICAgICAgICAgfCBPICAgICAgICAgICAgICB8IOyKpO2CtCwg7Zi47Iqk7Yq4LCDtj6ztirjqsIAg64+Z7J28ICAgfFxcclxcbnwgaHR0cHM6Ly9tZW5zYW4tc2FuZ2h1bi5naXRodWIuaW8vYWJvdXQ/cT3sg4Htm4ggIHwgTyAgICAgICAgICAgICAgfCDsiqTtgrQsIO2YuOyKpO2KuCwg7Y+s7Yq46rCAIOuPmeydvCAgIHxcXHJcXG58IGh0dHBzOi8vdXNlcjpwYXNzd29yZEBtZW5zYW4tc2FuZ2h1bi5naXRodWIuaW8gfCBPICAgICAgICAgICAgICB8IOyKpO2CtCwg7Zi47Iqk7Yq4LCDtj6ztirjqsIAg64+Z7J28ICAgfFxcclxcbnwgaHR0cDovL21lbnNhbi1zYW5naHVuLmdpdGh1Yi5pbyAgICAgICAgICAgICAgICB8IFggICAgICAgICAgICAgIHwg7Iqk7YK07J20IOuLpOumhCAgICAgICAgICAgICAgICAgfFxcclxcbnwgaHR0cHM6Ly9hcGkuZ2l0aHViLmlvICAgICAgICAgICAgICAgICAgICAgICAgICB8IFggICAgICAgICAgICAgIHwg7Zi47Iqk7Yq46rCAIOuLpOumhCAgICAgICAgICAgICAgIHxcXHJcXG58IGh0dHBzOi8vbWVuc2FuLXNhbmdodW4ubmF2ZXIuY29tICAgICAgICAgICAgICAgfCBYICAgICAgICAgICAgICB8IO2YuOyKpO2KuOqwgCDri6TrpoQgICAgICAgICAgICAgICB8XFxyXFxufCBodHRwczovL21lbnNhbi1zYW5naHVuLmdpdGh1Yi5pbzo4MDAwICAgICAgICAgIHwgPyAgICAgICAgICAgICAgfCDruIzrnbzsmrDsoIDsnZgg6rWs7ZiE7JeQIOuUsOudvCDri6TrpoQgfFxcclxcblxcclxcbuunqCDrp4jsp4Drp4kg7LyA7J207Iqk7J2YIOqyveyasCwg66eM7JW9IOy2nOyymOyXkCBgaHR0cHM6Ly9tZW5zYW4tc2FuZ2h1bi5naXRodWIuaW86ODBgIOyymOufvCDtj6ztirgg67KI7Zi46rCAIOuqheyLnOuQmOyWtCDsnojri6TrqbQg64uk66W4IOy2nOyymOydtOyngOunjCwg7JiI7Iuc66GcIOuToCDstpzsspjsnZgg6rK97JqwIO2PrO2KuCDrsojtmLjqsIAg7Y+s7ZWo65CY7KeAIOyViuyVhCDtjJDri6jtlZjquLAg7JWg66ek7ZWp64uI64ukLlxcclxcblxcclxcbuydtOufsCDqsr3smrDsl5DripQg6rCBIOu4jOudvOyasOyggOuTpOydmCDrj4XsnpDsoIHsnbgg7Lac7LKYIOu5hOq1kCDroZzsp4HsnYQg65Sw65286rCR64uI64ukLlxcclxcblxcclxcbioq7Jes6riw7IScIOykkeyalO2VnCDsoJDsnYAsIOydtOugh+qyjCDstpzsspjrpbwg67mE6rWQ7ZWY64qUIOuhnOyngeydtCA8dT7shJzrsoTsl5Ag6rWs7ZiE65Cc6rKMIOyVhOuLiOudvCDruIzrnbzsmrDsoIDsl5Ag6rWs7ZiEPC91PuuQmOyWtCDsnojripQg7KCQ7J6F64uI64ukLioqXFxyXFxuXFxyXFxuKioh6re466CH6riwIOuVjOusuOyXkCwg7Jqw66as6rCAIENPUlMg7KCV7LGF7J2EIOychOuwmO2VmOuKlCDrpqzshozsiqQg7JqU7LKt7J2EIO2VtOuPhCwg7ZW064u5IOyEnOuyhOqwgCDqsJnsnYAg7Lac7LKY7JeQ7IScIOuztOuCuCDsmpTssq3rp4wg67Cb64qUIOuhnOyngeydhCDqsIDsp4Qg6rK97Jqw6rCAIOyVhOuLiOudvOuptCwg7ISc67KE64qUIOygleyDgeyggeycvOuhnCDsnZHri7XsnYQg7ZWY6rOgIOydtO2bhCDruIzrnbzsmrDsoIDsl5DshJzripQg7J20IOydkeuLteydhCDrtoTshJ3tlbQgQ09SUyDsoJXssYUg7JyE67CY7J2065286rOgIO2MkOuLqO2VmOqzoCDqt7gg7J2R64u17J2EIOyCrOyaqe2VmOyngCDslYrqs6Ag67KE66a964uI64ukLiAqKlxcclxcblxcclxcbi0+IOuUsOudvOyEnCDshJzrsoQg66Gc6re47JeQ64qUIGAyMDAgb2sgYOqwgCDrnKjsp4Drp4wg67iM65287Jqw7KCAIOqwnOuwnOyekCDrj4Tqtazsl5DripQgXFxcIkNPUlMg7Jik66WYXFxcIuqwgCDrlqDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuKirspoksIENPUlPripQg67iM65287Jqw7KCA7J2YIOq1rO2YhCDsiqTtjpnsl5Ag7Y+s7ZWo65CY64qUIOygleyxheydtOq4sCDrlYzrrLjsl5AsIOu4jOudvOyasOyggOulvCDthrXtlZjsp4Ag7JWK6rOgIOyEnOuyhCDqsIQg7Ya17Iug7J2EIO2VoCDrlYzripQg7J20IOygleyxheydtCDsoIHsmqnrkJjsp4Ag7JWK7Iq164uI64ukLiDrmJDtlZwgQ09SUyDsoJXssYXsnYQg7JyE67CY7ZWY64qUIOumrOyGjOyKpCDsmpTssq0g7JeQ65+s6rCAIOuwnOyDne2VtOuPhCwg7ISc67KEIOyqvSDroZzqt7jsl5DripQg7KCV7IOB7KCB7Jy866GcIOydkeuLteydhCDtlojri6TripQg66Gc6re46rCAIOuCqOyVhCDtmLzrnoDsnYQg7JW86riw7ZWgIOyImCDsnojsirXri4jri6QuKipcXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyAyLiBDT1JT7J2YIOuPmeyekVxcclxcblxcclxcbuq4sOuzuOyggeycvOuhnCDsm7kg7YG065287J207Ja47Yq4IOyWtO2UjOumrOy8gOydtOyFmOydtCDri6Trpbgg7Lac7LKY7J2YIOumrOyGjOyKpOulvCDsmpTssq3tlaAg65WM64qUIEhUVFAg7ZSE66Gc7Yag7L2c7J2EIOyCrOyaqe2VmOyXrCDsmpTssq3snYQg67O064K06rKMIOuQmOuKlOuNsCwg7J2065WMIOu4jOudvOyasOyggOuKlCDsmpTssq0g7Zek642U7JeQIGBPcmlnaW5gIOydtOudvOuKlCDtlYTrk5zsl5Ag7JqU7LKt7J2EIOuztOuCtOuKlCDstpzsspjrpbwg7ZWo6ruYIOuLtOyKteuLiOuLpFxcclxcblxcclxcbmBgYGh0dHBcXHJcXG4jIGh0dHBcXHJcXG5PcmlnaW46IGh0dHBzOi8vbWVuc2FuLXNhbmdodW4uZ2l0aHViLmlvXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J207ZuEIOyEnOuyhOqwgCDsnbQg7JqU7LKt7JeQIOuMgO2VnCDsnZHri7XsnYQg7ZWgIOuVjCDsnZHri7Ug7Zek642U7J2YIGBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5g7J20652864qUIOqwkuyXkCDigJzsnbQg66as7IaM7Iqk66W8IOygkeq3vO2VmOuKlCDqsoPsnbQg7ZeI7Jqp65CcIOy2nOyymOKAneulvCDrgrTroKTso7zqs6AsIOydtO2bhCDsnZHri7XsnYQg67Cb7J2AIOu4jOudvOyasOyggOuKlCDsnpDsi6DsnbQg67O064OI642YIOyalOyyreydmCBgT3JpZ2luYOqzvCDshJzrsoTqsIAg67O064K07KSAIOydkeuLteydmCBgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luYOydhCDruYTqtZDtlbTrs7gg7ZuEIOydtCDsnZHri7XsnbQg7Jyg7Zqo7ZWcIOydkeuLteyduOyngCDslYTri4zsp4Drpbwg6rKw7KCV7ZWp64uI64ukLlxcclxcblxcclxcbuq4sOuzuOyggSDtnZDrpoTsnYAg7J207JmAIOqwmeqzoCwgQ09SU+qwgCDrj5nsnpHtlZjripQg67Cp7Iud7J2AIOyEuCDqsIDsp4DsnZgg7Iuc64KY66as7Jik6rCAIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4jIyMgMi4xIENPUlPsnZgg7Iuc64KY66as7JikXFxyXFxuXFxyXFxuPiAxLiBzaW1wbGUgcmVxdWVzdFxcclxcbj4gMi4gcHJlZmxpZ2h0IHJlcXVlc3RcXHJcXG4+IDMuIGNyZWRlbnRpYWxlZCByZXF1ZXN0XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIyBTaW1wbGUgUmVxdWVzdCDsi5zrgpjrpqzsmKTrpbwg65Ok7Ja06rCA6riwIOyghOyXkFxcclxcblxcclxcbuydtCDsi5zrgpjrpqzsmKQg7LyA7J207Iqk7JeQIOuMgO2VnCDsoJXsi50g66qF7Lmt7J2AIOyXhuyngOunjCwgTURO7J2YIENPUlMg66y47ISc7JeQ7ISc64qUIOydtCDsi5zrgpjrpqzsmKTrpbwgW1NpbXBsZSBSZXF1ZXN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9IVFRQL0NPUlMj7KCR6re8X+ygnOyWtF/si5zrgpjrpqzsmKRf7JiI7KCcKeudvOqzoCDrtoDrpbTqs6Ag7J6I7Iq164uI64ukLlxcclxcblxcclxcblNpbXBsZSBSZXF1ZXN07J2YIOygleydmOyXkCDslZ7shJwgQ09SUyBQcmVmbGlnaHQg7JeQIOuMgO2VtCDrqLzsoIAg7KeR6rOgIOuEmOyWtOqwgOuKlOqyjCDsnbTtlbTtlZjquLDsl5Ag7KKL7Iq164uI64ukLiBcXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4jIyMjIFByZWZsaWdodCBSZXF1ZXN0KOyYiOu5hCDsmpTssq0g7Iuc64KY66as7JikKVxcclxcblxcclxcbmDtlITrpqztlIzrnbzsnbTtirgoUHJlZmxpZ2h0KWAg67Cp7Iud7J2AIOydvOuwmOyggeycvOuhnCDsmrDrpqzqsIAg7Ju5IOyWtO2UjOumrOy8gOydtOyFmOydhCDqsJzrsJztlaAg65WMIOqwgOyepSDsnpDso7wg66eI7KO87LmY64qUIOyLnOuCmOumrOyYpOyeheuLiOuLpC4g7J20IOyLnOuCmOumrOyYpOyXkCDtlbTri7ntlZjripQg7IOB7Zmp7J28IOuVjCDruIzrnbzsmrDsoIDripQg7JqU7LKt7J2EIO2VnOuyiOyXkCDrs7TrgrTsp4Ag7JWK6rOgICoq7JiI67mEIOyalOyyreqzvCDrs7gg7JqU7LKt7Jy866GcIOuCmOuIhOyWtOyEnCDshJzrsoTroZwg7KCE7IahKirtlanri4jri6QuXFxyXFxuXFxyXFxu7J2065WMIOu4jOudvOyasOyggOqwgCDrs7gg7JqU7LKt7J2EIOuztOuCtOq4sCDsoITsl5Ag67O064K064qUIOyYiOu5hCDsmpTssq3snYQgUHJlZmxpZ2h065286rOgIOu2gOultOuKlCDqsoPsnbTrqbAsIOydtCDsmIjruYQg7JqU7LKt7JeQ64qUIEhUVFAg66mU7IaM65OcIOykkSBgT1BUSU9OU2Ag66mU7IaM65Oc6rCAIOyCrOyaqeuQqeuLiOuLpC4g7JiI67mEIOyalOyyreydmCDsl63tlaDsnYAg67O4IOyalOyyreydhCDrs7TrgrTquLAg7KCE7JeQIOu4jOudvOyasOyggCDsiqTsiqTroZwg7J20IOyalOyyreydhCDrs7TrgrTripQg6rKD7J20IOyViOyghO2VnOyngCDtmZXsnbjtlZjripQg6rKD7J6F64uI64ukLlxcclxcblxcclxcbuyekOuwlOyKpO2BrOumve2KuOulvCDsmIjrpbwg65Ok7Ja0IOydtCDqs7zsoJXsnYQg6rCE64uo7ZWcIO2UjOuhnOyasCDssKjtirjroZwg64KY7YOA64K067O066m0IOuLpOydjOqzvCDqsJnsirXri4jri6QuXFxyXFxuXFxyXFxuIVtwcmVmbGlnaHRdKC9hc3NldHMvaW1nL1ByZWZsaWdodC5KUEcpXFxyXFxuXFxyXFxuPiDruIzrnbzsmrDsoIDripQg67O4IOyalOyyreydhCDrs7TrgrTquLAg7KCEIOyYiOu5hCDsmpTssq3snYQg66i87KCAIOuztOuCtOqzoCwg7JqU7LKt7J2YIOycoO2aqOyEseydhCDqsoDsgqztlZzri6QuXFxyXFxuXFxyXFxu7J6Q67CU7Iqk7YGs66a97Yq47J2YIGBmZXRjaCBBUElg66W8IOyCrOyaqe2VmOyXrCDruIzrnbzsmrDsoIDsl5Dqsowg66as7IaM7Iqk66W8IOuwm+yVhOyYpOudvOuKlCDrqoXroLnsnYQg64K066as66m0IOu4jOudvOyasOyggOuKlCDshJzrsoTsl5Ag7JiI67mEIOyalOyyreydhCDrqLzsoIAg67O064K06rOgLCDshJzrsoTripQg7J20IOyYiOu5hCDsmpTssq3sl5Ag64yA7ZWcIOydkeuLteycvOuhnCDtmITsnqwg7J6Q7Iug7J20IOyWtOuWpCDqsoPrk6TsnYQg7ZeI7Jqp7ZWY6rOgLCDslrTrlqQg6rKD65Ok7J2EIOq4iOyngO2VmOqzoCDsnojripTsp4Dsl5Ag64yA7ZWcIOygleuztOulvCDsnZHri7Ug7Zek642U7JeQIOuLtOyVhCDruIzrnbzsmrDsoIDsl5Dqsowg64uk7IucIOuztOuCtOyjvOqyjCDrkKnri4jri6QuXFxyXFxuXFxyXFxuPiAg7J207ZuEIOu4jOudvOyasOyggOuKlCDsnpDsi6DsnbQg67O064K4IOyYiOu5hCDsmpTssq3qs7wg7ISc67KE6rCAIOydkeuLteyXkCDri7TslYTspIAg7ZeI7JqpIOygleyxheydhCDruYTqtZDtlZwg7ZuELCDsnbQg7JqU7LKt7J2EIOuztOuCtOuKlCDqsoPsnbQg7JWI7KCE7ZWY64uk6rOgIO2MkOuLqOuQmOuptCDqsJnsnYAg7JeU65Oc7Y+s7J247Yq466GcIOuLpOyLnCDrs7gg7JqU7LKt7J2EIOuztOuCtOqyjCDrkJzri6QuIOydtO2bhCDshJzrsoTqsIAg7J20IOuzuCDsmpTssq3sl5Ag64yA7ZWcIOydkeuLteydhCDtlZjrqbQg67iM65287Jqw7KCA64qUIOy1nOyiheyggeycvOuhnCDsnbQg7J2R64u1IOuNsOydtO2EsOulvCDsnpDrsJTsiqTtgazrpr3tirjsl5Dqsowg64SY6rKo7KSA64ukLlxcclxcblxcclxcblxcclxcblxcclxcbi0tLVxcclxcblxcclxcbuyVhOuemCDtlIzroZzsmrDripQg64uk66W4IOqwnOuwnOyekOqwgCDsnqztmITtlZwg7JiI7KCc66W8IO2Gte2VtCDqs7XrtoDtlbTrs7TslZjri6QuXFxyXFxuXFxyXFxu7Lac7LKYOiBbQ09SU+uKlCDsmZwg7J2066CH6rKMIOyasOumrOulvCDtnpjrk6Tqsowg7ZWY64qU6rG46rmMP10oaHR0cHM6Ly9ldmFuLW1vb24uZ2l0aHViLmlvLzIwMjAvMDUvMjEvYWJvdXQtY29ycy8pXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuLSDsmIjsoJxcXHJcXG5cXHJcXG7qsJzrsJzsnpDsnZgg67iU66Gc6re4IO2ZmOqyveyXkOyEnCDqsJzrsJzsnpDsnZgg7Yuw7Iqk7Yag66asIOu4lOuhnOq3uOydmCBSU1Mg7YyM7J28IOumrOyGjOyKpOyXkCDsmpTssq3snYQg67O064K066m0IOu4jOudvOyasOyggOqwgCDrs7gg7JqU7LKt7J2EIOuztOuCtOq4sCDsoITsl5AgYE9QVElPTlNgIOuplOyGjOuTnOulvCDsgqzsmqntlZjsl6wg7JiI67mEIOyalOyyreydhCDrs7TrgrTripQg6rKD7J2EIO2ZleyduO2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbiFbcHJlZmxpZ2h0XzFdKC9hc3NldHMvaW1nL1ByZWZsaWdodF8xLkpQRylcXHJcXG5cXHJcXG7si6TsoJzroZwg67iM65287Jqw7KCA6rCAIOuztOuCuCDsmpTssq3snYQg67O066m0LCDri6jsiJztnoggYE9yaWdpbmDsl5Ag64yA7ZWcIOygleuztCDrv5Drp4wg7JWE64uI6528IOyekOyLoOydtCDsmIjruYQg7JqU7LKtIOydtO2bhOyXkCDrs7Trgrwg67O4IOyalOyyreyXkCDrjIDtlZwg64uk66W4IOygleuztOuTpOuPhCDtlajqu5gg7Y+s7ZWo65CY7Ja0IOyeiOuKlCDqsoPsnYQg67O8IOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu7JyEIOyYiOu5hCDsmpTssq3sl5DshJwg67iM65287Jqw7KCA64qUIGBBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNg66W8IOyCrOyaqe2VmOyXrCDsnpDsi6DsnbQg67O4IOyalOyyreyXkOyEnCBgQ29udGVudC1UeXBlYCDtl6TrjZTrpbwg7IKs7Jqp7ZWgIOqyg+ydhCDslYzroKTso7zqsbDrgpgsIGBBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZGDrpbwg7IKs7Jqp7ZWY7JesIOydtO2bhCBgR0VUYCDrqZTshozrk5zrpbwg7IKs7Jqp7ZWgIOqyg+ydhCDshJzrsoTsl5Dqsowg66+466asIOyVjOugpOyjvOqzoCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu7J207ZuELCDti7DsiqTthqDrpqwg7ISc67KE64qUIOyYiOu5hCDsmpTssq3sl5Ag64yA7ZWcIOydkeuLteydhCDrs7TrgrTspI3ri4jri6QuXFxyXFxuXFxyXFxuIVtwcmVmbGlnaHRfMl0oL2Fzc2V0cy9pbWcvUHJlZmxpZ2h0XzIuSlBHKVxcclxcblxcclxcbuyXrOq4sOyEnCDspJHsmpTtlZjqsowg67O8IOqyg+ydgCBgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luOiBodHRwczovL2V2YW5tb29uLnRpc3RvcnkuY29tYOudvOuKlCDqsJLsnoXri4jri6QuXFxyXFxuXFxyXFxu7Yuw7Iqk7Yag66asIOyEnOuyhOuKlCDsnbQg66as7IaM7Iqk7JeQIOygkeq3vOydtCDqsIDriqXtlZwg7Lac7LKY64qUIOyYpOyngSBgaHR0cHM6Ly9ldmFubW9vbi50aXN0b3J5LmNvbWAg67+Q7J2065286rOgIOu4jOudvOyasOyggOyXkOqyjCDsnbTslbzquLDtlbTspIAg6rKD7J206rOgLCDqsJzrsJzsnpDqsIAg7J20IOyalOyyreydhCDrs7Trgrgg7Lac7LKY64qUIGBodHRwczovL2V2YW4tbW9vbi5naXRodWIuaW9g7J2066+A66GcICoqPHU+7ISc67KE6rCAIO2XiOyaqe2VtOykgCDstpzsspjsmYDripQg64uk66W4IOy2nOyymDwvdT4qKuyeheuLiOuLpC5cXHJcXG5cXHJcXG7qsrDqta0g67iM65287Jqw7KCA64qUIOydtCDsmpTssq3snbQgQ09SUyDsoJXssYXsnYQg7JyE67CY7ZaI64uk6rOgIO2MkOuLqO2VmOqzoCDri6TsnYzqs7wg6rCZ7J2AIOyXkOufrOulvCDrs7TsnKDspI3ri4jri6QuXFxyXFxuXFxyXFxuIVtwcmVmbGlnaHRfM10oL2Fzc2V0cy9pbWcvUHJlZmxpZ2h0XzMuSlBHKVxcclxcblxcclxcbuyVnuyXkOyEnCDslpjquLDtlojrk68sIOychCDsmIjruYQg7JqU7LKt7JeQIOuMgO2VnCDsnZHri7Xsl5DshJwg7JeQ65+s6rCAIOuwnOyDne2VmOyngCDslYrqs6AgYDIwMGAg7J20IOygleyDgeyggeycvOuhnCDsnZHri7XrkJjsl4jripTrjbAsIOy9mOyGlCDssL3sl5DshJzripQg7JeQ65+s6rCAIO2RnOyLnOuQmOuKlCDrtoDrtoTsnbQg66eO7J2AIOqwnOuwnOyekOulvCDtl7fqsIjrpqzqsowg7ZWp64uI64ukLiAg65Sw65287IScIOykkeyalO2VnCDqsoPsnYAg7JiI67mEIOyalOyyreydmCDshLHqs7Uv7Iuk7YyoIOyXrOu2gOqwgCDslYTri4jrnbwg4oCc7J2R64u1IO2XpOuNlOyXkCDsnKDtmqjtlZwgYEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbmAg6rCS7J20IOyhtOyerO2VmOuKlOqwgOKAneyeheuLiOuLpC4g66eM7JW9IOyYiOu5hCDsmpTssq3snbQg7Iuk7Yyo7ZW07IScIGAyMDBg7J20IOyVhOuLjCDsg4Htg5wg7L2U65Oc6rCAIOuCtOugpOyYpOuNlOudvOuPhCDtl6TrjZTsl5Ag7KCAIOqwkuydtCDsoJzrjIDroZwg65Ok7Ja06rCA7J6I64uk66m0IENPUlMg7KCV7LGFIOychOuwmOydtCDslYTri4wg6rKD7J207KOgLlxcclxcblxcclxcbi0tLVxcclxcblxcclxcbiMjIyMgU2ltcGxlIFJlcXVlc3Qo64uo7IicIOyalOyyrSDsi5zrgpjrpqzsmKQpXFxyXFxuXFxyXFxu64yA67aA67aE7J2YIOqyveyasCBQcmVmbGlnaHQgUmVxdWVzdCDrsKnsi53snYQg7IKs7Jqp7ZW0IOyYiOu5hCDsmpTssq3qs7wg67O4IOyXrOyyreydhCDrgpjriITslrQg67O064K07KeA66eMLCDsmIjruYQg7JqU7LKt7JeG7J20IOuzuCDsmpTssq3rp4zsnLzroZwgQ09SUyDsoJXssYUg7JyE67CYIOyXrOu2gOulvCDqsoDsgqztlZjquLDrj4Qg7ZWp64uI64ukLlxcclxcblxcclxcbuydtCDsi5zrgpjrpqzsmKTripQgUHJlZmxpZ2h0IFJlcXVlc3Qg7Iuc64KY66as7Jik7JmAIOyghOuwmOyggeyduCDroZzsp4Eg7J6Q7LK064qUIOqwmeuQmCwg7JiI67mEIOyalOyyreydmCDsobTsnqwg7Jyg66y066eMIOuLpOumheuLiOuLpC5cXHJcXG5cXHJcXG7smIjruYQg7JqU7LKt7J2EIOuztOuCtOyngCDslYrqs6Ag67CU66GcIOyEnOuyhOyXkOqyjCDrs7gg7JqU7LKt7J2EIOuztOuCuCDtm4QsIOyEnOuyhOqwgCDsnbTsl5Ag64yA7ZWcIOydkeuLteydmCDtl6TrjZTsl5AgYEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbmDqs7wg6rCZ7J2AIOqwkuydhCDrs7TrgrTso7zrqbQg6re465WMIOu4jOudvOyasOyggOqwgCBDT1JTIOygleyxhSDsnITrsJgg7Jes67aA66W8IOqygOyCrO2VmOuKlCDrsKnsi53snoXri4jri6QuXFxyXFxuXFxyXFxuIVtzaW1wbGVdKC9hc3NldHMvaW1nL3NpbXBsZS5KUEcpXFxyXFxuXFxyXFxuPiDri6jsiJwg7JqU7LKt7J2AIOyYiOu5hCDsmpTssq3sl4bsnbQg67CU66GcIOuzuCDsmpTssq3snYQg67O064K464ukLlxcclxcblxcclxcbuuLpOunjCDri6jsiJwg7JqU7LKt7J2AIO2KueyglSDsobDqsbTsnYQg66eM7KGx7ZWY64qUIOqyveyasOyXkOunjCDqsIDriqXtlZjqs6AsIOydtCDsobDqsbTsnYAg6rmM64uk66Gc7Jq0IO2OuOydtOudvCDqsbDsnZgg6rK97ZeY7ZWY6riwIO2emOuToCDtjrjsnbTri6QuXFxyXFxuXFxyXFxuMS4g7JqU7LKt7J2YIOuplOyGjOuTnOuKlCBgR0VUYCwgYEhFQURgLCBgUE9TVGAg7KSRIO2VmOuCmOyXrOyVvCDtlaguXFxyXFxuMi4gYEFjY2VwdGAsIGBBY2NlcHQtTGFuZ3VhZ2VgLCBgQ29udGVudC1MYW5ndWFnZWAsIGBDb250ZW50LVR5cGVgLCBgRFBSYCwgYERvd25saW5rYCwgYFNhdmUtRGF0YWAsIGBWaWV3cG9ydC1XaWR0aGAsIGBXaWR0aGDrpbwg7KCc7Jm47ZWcIO2XpOuNlOulvCDsgqzsmqntlZjrqbQg7JWI65CoXFxyXFxuMy4g66eM7JW9IGBDb250ZW50LVR5cGVg66W8IOyCrOyaqe2VmOuKlCDqsr3smrDsl5DripQgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGAsIGBtdWx0aXBhcnQvZm9ybS1kYXRhYCwgYHRleHQvcGxhaW5g66eMIO2XiOyaqVxcclxcblxcclxcbjLrsogg7KGw6rG07JeQIOuqheyLnOuQnCDtl6TrjZTripQg66ek7JqwIOq4sOuzuOyggeyduCDtl6TrjZTrk6TsnbTqs6AsIGBBdXRob3JpemF0aW9uYCDtl6TrjZQg7KGw7LCoIOyggCDsobDqsbTsl5DripQg7Y+s7ZWo65CY7KeAIOyViuyKteuLiOuLpC4g65iQ7ZWcLCDrjIDrtoDrtoTsnZggSFRUUCBBUEnripQgYHRleHQveG1sYOydtOuCmCBgYXBwbGljYXRpb24vanNvbmAg7Luo7YWQ7LigIO2DgOyeheydhCDqsIDsp4Drj4TroZ0g7ISk6rOE65CY6riwIOuVjOusuOyXkCAz67KIIOyhsOqxtOydhCDrp4zsobHsi5ztgqTquLDrj4Qg66ek7JqwIOyWtOugteyKteuLiOuLpC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4jIyMjIENyZWRlbnRpYWxlZCBSZXF1ZXN0KOyduOymneuQnCDsmpTssq0g7Iuc64KY66as7JikKVxcclxcblxcclxcbuydtOuyiCDsi5zrgpjrpqzsmKTripQgQ09SU+ydmCDquLDrs7jsoIEg67Cp7Iud7J2065286riwIOuztOuLpCAqKuuLpOuluCDstpzsspgg6rCEIO2GteyLoOyXkOyEnCDrs7TslYjsnYQg7KKAIOuNlCDqsJXtmZTtlZjqs6Ag7Iu27J2EIOuVjCDsgqzsmqntlZjripQg67Cp67KVKirsnoXri4jri6QuXFxyXFxuXFxyXFxu6riw67O47KCB7Jy866GcIOu4jOudvOyasOyggOqwgCDsoJzqs7XtlZjripQg67mE64+Z6riwIOumrOyGjOyKpCDsmpTssq0gQVBJ7J24IGBYTUxIdHRwUmVxdWVzdGAg6rCd7LK064KYIGBmZXRjaCBBUElg64qUIOuzhOuPhOydmCDsmLXshZgg7JeG7J20IOu4jOudvOyasOyggOydmCDsv6DtgqQg7KCV67O064KYIOyduOymneqzvCDqtIDroKjrkJwg7Zek642U66W8IO2VqOu2gOuhnCDsmpTssq3sl5Ag64u07KeAIOyViuyKteuLiOuLpC4g7J2065WMIOyalOyyreyXkCDsnbjspp3qs7wg6rSA66Co65CcIOygleuztOulvCDri7TsnYQg7IiYIOyeiOqyjCDtlbTso7zripQg7Ji17IWY7J20IOuwlOuhnCBgY3JlZGVudGlhbHNgIOyYteyFmOyeheuLiOuLpC5cXHJcXG5cXHJcXG7snbQg7Ji17IWY7JeQIOyCrOyaqe2VoCDsiJgg7J6I64qUIOqwkuqzvCDsnZjrr7jripQg64uk7J2M6rO8IOqwmeyKteuLiOuLpC5cXHJcXG5cXHJcXG58IOyYteyFmCDqsJIgICAgICAgICAgICAgIHwg7ISk66qFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxufCAtLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcXHJcXG58IHNhbWUtb3JpZ2luICjquLDrs7jqsJIpIHwg6rCZ7J2AIOy2nOyymCDqsIQg7JqU7LKt7JeQ66eMIOyduOymnSDsoJXrs7Trpbwg64u07J2EIOyImCDsnojri6QuIHxcXHJcXG58IGluY2x1ZGUgICAgICAgICAgICAgIHwg66qo65OgIOyalOyyreyXkCDsnbjspp0g7KCV67O066W8IOuLtOydhCDsiJgg7J6I64ukLiAgICAgICAgICAgfFxcclxcbnwgb21pdCAgICAgICAgICAgICAgICAgfCDrqqjrk6Ag7JqU7LKt7JeQIOyduOymnSDsoJXrs7Trpbwg64u07KeAIOyViuuKlOuLpC4gICAgICAgICAgICB8XFxyXFxuXFxyXFxu66eM7JW9IGBzYW1lLW9yaWdpbmDsnbTrgpggYGluY2x1ZGVg7JmAIOqwmeydgCDsmLXshZjsnYQg7IKs7Jqp7ZWY7JesIOumrOyGjOyKpCDsmpTssq3sl5Ag7J247KadIOygleuztOqwgCDtj6ztlajrkJzri6TrqbQsIOu4jOudvOyasOyggOuKlCDri6Trpbgg7Lac7LKY7J2YIOumrOyGjOyKpOulvCDsmpTssq3tlaAg65WMIOuLqOyInO2eiCBgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luYOunjCDtmZXsnbjtlZjripQg6rKD7J20IOyVhOuLiOudvCDsooAg642UIOu5oeu5oe2VnCDqsoDsgqwg7KGw6rG07J2EIOy2lOqwgO2VmOqyjCDrkKnri4jri6QuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuLSDsmIjsoJxcXHJcXG5cXHJcXG7slZ7shKAg7JiI7KCc7J2YIOqwnOuwnOyekOydmCDroZzsu6ztmZjqsr3qs7wg67iU66Gc6re466W8IO2YuOyKpO2Mhe2VmOqzoCDsnojripQgR2l0aHViIOyEnOuyhOyZgOydmCDthrXsi6DsnYQg7Ya17ZW0LCDslrTrlqQg7KCc7JW97J20IOy2lOqwgOuQmOyXiOuKlOyngCDrs7Tsl6zso7zripQg7JiI7KCcXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu6rCc67Cc7J6Q7J2YIOu4lOuhnOq3uOuKlCBgQWxsb3ctQ29udHJvbC1BbGxvdy1PcmlnaW5gIOqwkuycvOuhnCDrqqjrk6Ag7Lac7LKY66W8IO2XiOyaqe2VnOuLpOuKlCDsnZjrr7jsnbggYCpg6rCAIOyEpOygleuQmOyWtOyeiOq4sCDrlYzrrLjsl5AsIOuLpOuluCDstpzsspjsl5DshJwg6rCc67Cc7J6Q7J2YIOu4lOuhnOq3uOuhnCDrpqzshozsiqTrpbwg7JqU7LKt7ZWgIOuVjCBDT1JTIOygleyxhSDsnITrsJjsnLzroZwg7J247ZWcIOygnOyVveydhCDrsJvsp4Ag7JWK7Iq164uI64ukLlxcclxcblxcclxcbuq3uOuemOyEnCBgaHR0cDovL2xvY2FsaG9zdDo4MDAwYOqzvCDqsJnsnYAg66Gc7Lus7J2YIOqwnOuwnCDtmZjqsr3sl5DshJzrj4QgYGZldGNoIEFQSWDrpbwg7IKs7Jqp7ZWY7JesIOuniOydjOuMgOuhnCDrpqzshozsiqTrpbwg7JqU7LKt7ZWY6rOgLCDrmJAg67Cb7JWE7JisIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuIVtjcmVkZW50aWFsMV0oL2Fzc2V0cy9pbWcvQ3JlZGVudGlhbGVkXzEuSlBHKVxcclxcblxcclxcbuq1rOq4gCDtgazroawg67iM65287Jqw7KCA7J2YIGBjcmVkZW50aWFsc2Ag6riw67O4IOqwkuydgCDqsJnsnYAg7Lac7LKYIOuCtOyXkOyEnOunjCDsnbjspp0g7KCV67O066W8IOyCrOyaqe2VmOqyoOuLpOuKlCBgc2FtZS1vcmlnaW5g7J206riwIOuVjOusuOyXkCwg66Gc7LusIO2ZmOqyveyXkOyEnCBgaHR0cHM6Ly9ldmFuLW1vb24uZ2l0aHViLmlvYOuhnCDrs7TrgrTripQg66as7IaM7IqkIOyalOyyreyXkOuKlCDri7nsl7Dtnogg67iM65287Jqw7KCA7J2YIOy/oO2CpOyZgCDqsJnsnYAg7J247KadIOygleuztOqwgCDtj6ztlajrkJjslrQg7J6I7KeAIOyViuyKteuLiOuLpC5cXHJcXG5cXHJcXG7qt7jroIfquLAg65WM66y47JeQIOu4jOudvOyasOyggOuKlCDri6jsiJztnoggYEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbjogKmDsnbTrnbzripQg6rCS7J2EIOuztOqzoCDigJzsnbQg7JqU7LKt7J2AIOyViOyghO2VmOuLpOKAneudvOuKlCDqsrDroaDsnYQg64K066as64qUIOqyg+ydtOuLpC4g6re465+s64KYIGBjcmVkZW50aWFsc2Ag7Ji17IWY7J2EIOuqqOuToCDsmpTssq3sl5Ag7J247KadIOygleuztOulvCDtj6ztlajtlZjqsqDri6TripQg7J2Y66+466W8IOqwgOynhCBgaW5jbHVkZWDroZwg67OA6rK97ZWY6rOgIOqwmeydgCDsmpTssq3snYQg67O064K066m0IOydtOuyiOyXkOuKlCDsg4HtmansnbQg7KGw6riIIOuLrOudvOyngOqyjCDrkKnri4jri6QuXFxyXFxuXFxyXFxuIVtjcmVkZW50aWFsMl0oL2Fzc2V0cy9pbWcvQ3JlZGVudGlhbGVkXzIuSlBHKVxcclxcblxcclxcbuu4lOuhnOq3uOulvCDtmLjsiqTtjIXtlZjqs6Ag7J6I64qUIEdpdGh1YiDshJzrsoTripQg7J2067KI7JeQ64+EIOuPmeydvO2VnCDsnZHri7XsnYQg67O064K07KO87JeI7KeA66eMLCDruIzrnbzsmrDsoIDsnZgg67CY7J2R7J2AIOuLpOultOyjoC5cXHJcXG5cXHJcXG4hW2NyZWRlbnRpYWwzXSgvYXNzZXRzL2ltZy9DcmVkZW50aWFsZWRfMy5KUEcpXFxyXFxuXFxyXFxu67iM65287Jqw7KCA64qUIOyduOymnSDrqqjrk5zqsIAgYGluY2x1ZGVg7J28IOqyveyasCwg66qo65OgIOyalOyyreydhCDtl4jsmqntlZzri6TripQg7J2Y66+47J2YIGAqYOulvCBgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luYCDtl6TrjZTsl5Ag7IKs7Jqp7ZWY66m0IOyViOuQnOuLpOqzoCDsnbTslbzquLDtlZjqs6Ag7J6I7Iq164uI64ukLlxcclxcblxcclxcbuydtOyymOufvCDsmpTssq3sl5Ag7J247KadIOygleuztOqwgCDri7TqsqjsnojripQg7IOB7YOc7JeQ7IScIOuLpOuluCDstpzsspjsnZgg66as7IaM7Iqk66W8IOyalOyyre2VmOqyjCDrkJjrqbQg67iM65287Jqw7KCA64qUIENPUlMg7KCV7LGFIOychOuwmCDsl6zrtoDrpbwg6rKA7IKs7ZWY64qUIOujsOyXkCDri6TsnYwg65GQIOqwgOyngOulvCDstpTqsIDtlZjqsowg65Cp64uI64ukLlxcclxcblxcclxcbjEuIGBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5g7JeQ64qUIGAqYOulvCDsgqzsmqntlaAg7IiYIOyXhuycvOupsCwg66qF7Iuc7KCB7J24IFVSTOydtOyWtOyVvO2VnOuLpC5cXHJcXG5cXHJcXG4yLiDsnZHri7Ug7Zek642U7JeQ64qUIOuwmOuTnOyLnCBgQWxsb3ctQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsczogdHJ1ZWDqsIAg7KG07J6s7ZW07JW87ZWc64ukLlxcclxcblxcclxcbi0tLVxcclxcblxcclxcblxcclxcblxcclxcbiMjIDMuIENPUlPrpbwg7ZW06rKw7ZWgIOyImCDsnojripQg67Cp67KVXFxyXFxuXFxyXFxu6re466CH64uk66m0IOydtCDrs7XsnqHtlZwg7KCV7LGFIENPUlPrpbwg7JyE67CY7ZWY7KeAIOyViuycvOugpOuptCDslrTrlrvqsowg7ZW07JW87ZWY64qU6rG06rCAP1xcclxcblxcclxcblxcclxcblxcclxcbiMjIyAzLjEgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luIOyEuO2Mhe2VmOq4sFxcclxcblxcclxcbkNPUlMg7KCV7LGFIOychOuwmOycvOuhnCDsnbjtlZwg66y47KCc66W8IO2VtOqysO2VmOuKlCDqsIDsnqUg64yA7ZGc7KCB7J206rOgIOygleyEneyggeyduCDrsKnrspXsnYAsIOq3uOuDpSDshJzrsoTsl5DshJwgYEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbmAg7Zek642U7JeQIOyVjOunnuydgCDqsJLsnYQg7IS47YyF7ZW07KO864qUIOqyg+yeheuLiOuLpC4gKOyduO2EsOuEt+ydhCDssL7slYTrs7TrqbQg66as67KE7IqkIO2UhOuhneyLsSDrk7Eg66qHIOqwgOyngCDqvLzsiJjqsIAg7J6I7KeA66eMIOuhnOy7rO2ZmOqyveqzvCDsi6TsoJwg7ISc67KEIO2ZmOqyveydtCDri6Trpbgg6rK97JqwIOyXkOufrOqwgCDrgpjquLAg7Im964ukLiDqt7jrn6zrr4DroZwg7KCV7ISd64yA66GcIO2VmOyekClcXHJcXG5cXHJcXG7snbTrlYwg7JmA7J2865Oc7Lm065Oc7J24IGAqYOydhCDsgqzsmqntlZjsl6wg7J20IO2XpOuNlOulvCDshLjtjIXtlZjqsowg65CY66m0IOuqqOuToCDstpzsspjsl5DshJwg7Jik64qUIOyalOyyreydhCDtl4jsmqntlZzri6TripQg7J2Y66+47J2066+A66GcICoq67O07JWI7KCB7Jy866GcIOyLrOqwge2VnCDsnbTsiojqsIAg67Cc7IOd7ZWgIOyImOuPhCDsnojsirXri4jri6QuKipcXHJcXG5cXHJcXG7qt7jrn6zrr4DroZwgYEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbjogaHR0cHM6Ly9ldmFuLmdpdGh1Yi5pb2DsmYAg6rCZ7J20IOy2nOyymOulvCDrqoXsi5ztlbTso7zrj4TroZ0g7ZWp64uI64ukLlxcclxcblxcclxcblNwcmluZywgRXhwcmVzcywgRGphbmdv7JmAIOqwmeydtCDsnbTrpoTsnojripQg67Cx7JeU65OcIO2UhOugiOyehOybjO2BrOydmCDqsr3smrDsl5DripQg66qo65GQIENPUlMg6rSA66CoIOyEpOygleydhCDsnITtlZwg7IS47YyF7J2064KYIOuvuOuTpOybqOyWtCDrnbzsnbTruIzrn6zrpqzrpbwg7KCc6rO17ZWY6rOgIOyeiOycvOuLiCDshLjtjIUg7J6Q7LK06rCAIOyWtOugteyngOuKlCDslYrsnYQg6rKD7J6F64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyMgRVgp7J6l6rOg7JeQ7IScIOyggeyaqe2VmOq4sFxcclxcblxcclxcbuuovOyggCDsnqXqs6Ag7Yyo7YKk7KeA66W8IOyEpOy5mO2VnOuLpC5cXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuPj4+IHBpcCBpbnN0YWxsIGRqYW5nby1jb3JzLWhlYWRlcnNcXHJcXG5gYGBcXHJcXG5cXHJcXG7shKTsuZjqsIAg7JmE66OM65CY66m0LCBgc2V0dGluZ3MucHlg7J2YIGBJTlNUQUxMRURfQVBQYOqzvCBgTUlERExFV0FSRWDsl5Ag7L2U65Oc66W8IOyeheugpe2VnOuLpC5cXHJcXG5cXHJcXG5gYGBkamFuZ29cXHJcXG5JTlNUQUxMRURfQVBQUyA9IFtcXHJcXG5cXHQnY29yc2hlYWRlcnMnLFxcclxcbl1cXHJcXG5cXHJcXG5NSURETEVXQVJFID0gW1xcclxcblxcdCdjb3JzaGVhZGVycy5taWRkbGV3YXJlLkNvcnNNaWRkbGV3YXJlJyxcXHJcXG5dXFxyXFxuYGBgXFxyXFxuXFxyXFxu66eI7KeA66eJ7Jy866GcIGBzZXR0aW5ncy5weWDsl5Ag7JWE656Y7JmAIOqwmeydgCDsvZTrk5zrpbwg7J6F66Cl7ZWY66m0IOuQnOuLpC4g7JWE656YIOyEpOygleyXkOyEnCBDT1JTX09SSUdJTl9BTExPV19BTEw9RmFsc2Xrpbwg7ZWY6rOgIENPUlNfT1JJR0lOX1dISVRFTElTVOulvCDsp4DsmrTri6TrqbQg66qo65OgIOyalOyyreydhCDtl4jsmqntlZjripQg7ZmY6rK9KO2FjOyKpO2KuO2ZmOqyveycvOuhnOuCmCDqsIDriqUpXFxyXFxuXFxyXFxuYGBgZGphbmdvXFxyXFxuIyNDT1JTXFxyXFxuQ09SU19PUklHSU5fQUxMT1dfQUxMPUZhbHNlXFxyXFxuQ09SU19PUklHSU5fV0hJVEVMSVNUID0gW1xcclxcblxcdCdnb29nbGUuY29tJyxcXHJcXG5cXHQnbG9jYWxob3N0OjgwMDAnLFxcclxcblxcdCcxMjcuMC4wLjE6OTAwMCcsXFxyXFxuXFx0J2hvc3RuYW1lLmV4YW1wbGUuY29tJyxcXHJcXG5dXFxyXFxuQ09SU19BTExPV19DUkVERU5USUFMUyA9IFRydWVcXHJcXG5cXHJcXG5DT1JTX0FMTE9XX01FVEhPRFMgPSAoXFxyXFxuICAgICdERUxFVEUnLFxcclxcbiAgICAnR0VUJyxcXHJcXG4gICAgJ09QVElPTlMnLFxcclxcbiAgICAnUEFUQ0gnLFxcclxcbiAgICAnUE9TVCcsXFxyXFxuICAgICdQVVQnLFxcclxcbilcXHJcXG5cXHJcXG5DT1JTX0FMTE9XX0hFQURFUlMgPSAoXFxyXFxuICAgICdhY2NlcHQnLFxcclxcbiAgICAnYWNjZXB0LWVuY29kaW5nJyxcXHJcXG4gICAgJ2F1dGhvcml6YXRpb24nLFxcclxcbiAgICAnY29udGVudC10eXBlJyxcXHJcXG4gICAgJ2RudCcsXFxyXFxuICAgICdvcmlnaW4nLFxcclxcbiAgICAndXNlci1hZ2VudCcsXFxyXFxuICAgICd4LWNzcmZ0b2tlbicsXFxyXFxuICAgICd4LXJlcXVlc3RlZC13aXRoJyxcXHJcXG4pXFxyXFxuYGBgXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuQ09SUyDsoJXssYUg7JyE67CY7J2AIOu4jOudvOyasOyggOydmCDqtaztmITsl5DshJwg67Cc7IOd7ZWY6riwIOuVjOusuOyXkCwg7ZSE66Gg7Yq47JeU65OcIOqwnOuwnOyekOqwgCDsnbTroZwg7J247ZWcIOusuOygnOulvCDqsqrripTri6QuIO2VmOyngOunjCDrrLjsoJwg7ZW06rKw7J2EIOychO2VtOyEnOuKlCDrsLHsl5Trk5wg6rCc67Cc7J6Q6rCAIOyEnOuyhCDslrTtlIzrpqzsvIDsnbTshZjsnZgg7J2R64u1IO2XpOuNlOyXkCDsmKzrsJTrpbggYEFjY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5g7J20IOuCtOugpOyYrCDsiJgg7J6I64+E66GdIOyEuO2Mhe2VtOykmOyVvCDtlanri4jri6QuXFxyXFxuXFxyXFxu6re465+s66+A66GcIO2UhOuhoO2KuOyXlOuTnCDqsJzrsJzsnpDroZzshJzrk6AsIOuwseyXlOuTnCDqsJzrsJzsnpDroZzshJzrk6Ag7J20IOygleyxheychOuwmCDrrLjsoJztlbTqsrDsl5Ag64yA7ZWcIOyngOyLneydhCDqsIDsp4Dqs6AsIOq8rSDtlZwg67KIIOyvpOydgCDqsr3tl5jtlbTrs7wg7ZWE7JqU6rCAIOyeiOuLpOqzoCDsg53qsIHtlanri4jri6QuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyMjIyBSZWZlcmVuY2VzXFxyXFxuXFxyXFxuW+q1kOywqCDstpzsspgg66as7IaM7IqkIOqzteycoCBNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0hUVFAvQ09SUylcXHJcXG5cXHJcXG5bRmV0Y2ggQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJKVxcclxcblxcclxcbltDT1JT64qUIOyZnCDsnbTroIfqsowg7Jqw66as66W8IO2emOuTpOqyjCDtlZjripTqsbjquYw/XShodHRwczovL2V2YW4tbW9vbi5naXRodWIuaW8vMjAyMC8wNS8yMS9hYm91dC1jb3JzLylcXHJcXG5cXHJcXG5bRGphbmdvLeuCtCDroZzsu6wg7ISc67KE7JeQ7IScIOyZuOu2gOygkeyGjSDtl4jsmqntlZjquLBdKGh0dHBzOi8vdmVsb2cuaW8vQGRldm1pbi9EamFuZ28tQ09SUy1TZXR0aW5nLWJhc2ljKVxcclxcblxcclxcbltEamFuZ28gQ09SUyDshKTsoJXqs7wgQVBJIOyXsOuPmV0oaHR0cHM6Ly9ibG9nLnRoZXJlaXMueHl6LzQxKVxcclxcblxcclxcblvqtZDssKgg7Lac7LKYIOumrOyGjOyKpCDqs7XsnKAg7JyE7YKk7ZS865SU7JWEXShodHRwczovL2tvLndpa2lwZWRpYS5vcmcvd2lraS8lRUElQjUlOTAlRUMlQjAlQThfJUVDJUI2JTlDJUVDJUIyJTk4XyVFQiVBNiVBQyVFQyU4NiU4QyVFQyU4QSVBNF8lRUElQjMlQjUlRUMlOUMlQTAjY2l0ZV9ub3RlLTYpXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIuyasOumrOqwgCDtla3sg4Eg7JOw64qUIEhUVFAg7ZSE66Gc7Yag7L2c7J20IOutmOq5jFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMC4xMi4xNlxcXCJcXHJcXG50YWdzOlxcclxcbi0gaHR0cFxcclxcbi0g7Ju56rCc67CcXFxyXFxuLSBDT1JTXFxyXFxuLSBTT1BcXHJcXG4tIO2UhOuhnO2GoOy9nFxcclxcbi0g64Sk7Yq47JuM7YGsXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyMgSFRUUOydmCDsoJXsnZhcXHJcXG5cXHJcXG4+ICoq7ZWY7J207Y287YWN7Iqk7Yq4IOyghOyGoSDtlITroZzthqDsvZwoSFRUUCkqKuydgCBIVE1M6rO8IOqwmeydgCDtlZjsnbTtjbzrr7jrlJTslrQg66y47ISc66W8IOyghOyGoe2VmOq4sOychO2VnCBb7JWg7ZSM66as7LyA7J207IWYIOugiOydtOyWtF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXBwbGljYXRpb25fTGF5ZXIpIO2UhOuhnO2GoOy9nOyeheuLiOuLpC5cXHJcXG4+XFxyXFxuPiDsnbzrsJjsoIHsnLzroZwg7JWI7KCV7KCB7J24IFvsoITshqEg66CI7J207Ja0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3BvcnRfTGF5ZXIp66GcIFVEUOyZgCDri6zrpqwg66mU7IS47KeA66W8IOyeg+yngCDslYrripQg7ZSE66Gc7Yag7L2c7J24IFRDUC9JUCDroIjsnbTslrTrpbwg6riw67CY7Jy866GcIOyCrOyaqSDtlanri4jri6QuXFxyXFxuPlxcclxcbj4g7Ju5IOu4jOudvOyasOyggOyZgCDsm7kg7ISc67KE6rCE7J2YIOy7pOuupOuLiOy8gOydtOyFmOydhOychO2VtCDrlJTsnpDsnbjrkJjsl4jsp4Drp4wsIOuLpOuluCDrqqnsoIHsnLzroZzrj4Qg7IKs7Jqp65CgIOyImCDsnojsirXri4jri6QuXFxyXFxuPlxcclxcbj4gW1VSSV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9HbG9zc2FyeS9VUkkp7J2YIOydvOu2gOuhnCwgXFxcImh0dHA6Ly9cXFwiIOuKlCBcXFwic2NoZW1hXFxcIiDrnbzqs6Drj4Qg67aI66as66mwLCDsnbzrsJjsoIHsnLzroZwg7KO87IaM7J2YIOyLnOyekSDrtoDrtoTsl5Ag7JyE7LmY7ZWp64uI64ukLiDsnbzroYDroZwgXFxcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnXFxcIiDrnbzripQg7KO87IaM64qUIEhUVFAg7ZSE66Gc7Yag7L2c7J2EIOyCrOyaqe2VmOyXrCDrrLjshJzrpbwg7JqU7LKt7ZWY64+E66GdIOu4jOudvOyasOyggOyXkCDrqoXsi5ztlZzri6TripQg6rKD7J2EIOydmOuvuO2VqeuLiOuLpC4g7J20IOqyveyasCBodHRwc+uKlCBIVFRQIO2UhOuhnO2GoOy9nOydmCDrs7TslYgg67KE7KCE7J24IFtTU0xdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvR2xvc3NhcnkvU1NMKSDrpbwg64KY7YOA64OF64uI64ukIChUTFPrnbzqs6Drj4Qg67aA66W07KOgKS5cXHJcXG4+XFxyXFxuPiBIVFRQIO2FjeyKpO2KuCDquLDrsJggKOuqqOuToCDthrXsi6DsnYAg7J2867CYIO2FjeyKpO2KuOuhnCDsiJjtlonrkKnri4jri6QpIOydtOupsCBzdGF0ZWxlc3MgKOydtOyghOydmCDthrXsi6DsnYQg7J247Iud7ZWY7KeAIOyViuyKteuLiOuLpCkg7J6F64uI64ukLiDsnbQg7IaN7ISx7J2AIHd3dyDsg4Hsl5DshJwg7J246rCE7J20IOusuOyEnCjsm7kg7IKs7J207Yq4KSDrpbwg7J2964qUIOqyg+ydhCDsnbTsg4HsoIHsnLzroZwg7IiY7ZaJ7ZWgIOyImCDsnojrj4TroZ0g7ZWp64uI64ukLiDqt7jrv5Drp4wg7JWE64uI6528LCBIVFRQIOuKlCDshJzrsoQg6rCEIOybuSDshJzruYTsiqQgW1JFU1RdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvR2xvc3NhcnkvUkVTVCkg65iQ64qUIOybuSDsgqzsnbTtirgg64K07J2YIOyalOyyrSBbQUpBWF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9HbG9zc2FyeS9BSkFYKSDsl5Ag64yA7ZWcIOq4sOy0iOuhnOuPhCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC4gLSDstpzsspggTUROXFxyXFxuPlxcclxcbj4g7JqU7LKt7J2E67O064K06rOgKHJlcXVlc3Qp7J2R64u17J2E67Cb64qUKHJlc3BvbnNlKeqzvOygleydtOupsCwg7Jew6rKw64u5IO2VmOuCmOydmCDtirjrnpzsnq3shZjsnYQg7IiY7ZaJ7ZWc64ukLlxcclxcblxcclxcbiMjIyBIVFRQIOyXsOqysFxcclxcblxcclxcbkhUVFDsmYAg6rCZ7J2AIO2BtOudvOydtOyWuO2KuC3shJzrsoQg7ZSE66Gc7Yag7L2c7JeQ7IScLCDshLjshZjsnYAg64uk7J2M7J2YIOyEuCDqsIDsp4Ag6rO87KCV7Jy866GcIOydtOujqOyWtOynkeuLiOuLpDpcXHJcXG5cXHJcXG4xLiDtgbTrnbzsnbTslrjtirjqsIAgVENQIOyXsOqysOydhCDsiJjrpr3tlanri4jri6Qo65iQ64qUIOyghOyGoSDqs4TsuLXsnbQgVENQ6rCAIOyVhOuLjCDri6Trpbgg7KCB64u57ZWcIOyXsOqysOuhnCkuXFxyXFxuMi4g7YG065287J207Ja47Yq464qUIOyalOyyreydhCDsoITshqHtlZwg65KkIOydkeuLteydhCDquLDri6Trpr3ri4jri6QuXFxyXFxuMy4g7ISc67KE64qUIOyalOyyreyXkCDrjIDtlbQg7LKY66as7ZWY6rOgIOq3uOyXkCDrjIDtlZwg7J2R64u17J2EIOyDge2DnCDsvZTrk5wg6re466as6rOgIOyalOyyreyXkCDrtoDtlantlZjripQg642w7J207YSw7JmAIO2VqOq7mCDrj4zroKTrs7Trg4Xri4jri6QuXFxyXFxuXFxyXFxuVENQ66W8IOydtOyaqe2VoCDqsr3smrAsIOy7tO2TqO2EsCDsg4HsnZggSFRUUCDshJzrsoTrpbwg7JyE7ZWcICoq6riw67O4IO2PrO2KuOuKlCA4MCoq7J24642wLCAqKjgwMDAg7Zi57J2AIDgwODAqKuyymOufvCDri6Trpbgg7Y+s7Yq465Ok64+EIOyekOyjvCDsgqzsmqnrkJjqs6Qg7ZWp64uI64ukLiDsmpTssq3snYQg7JyE7ZWcIO2OmOydtOyngCBVUkzsnYAg64+E66mU7J24IOydtOumhOqzvCDtj6ztirgg67KI7Zi4IOuRmCDri6Qg7Y+s7ZWo7ZWY64qU642wLCAqKu2PrO2KuCDrsojtmLjqsIAgODDsnbwg6rK97JqwIOyDneuetSDqsIDriqUqKu2VqeuLiOuLpC5cXHJcXG5cXHJcXG4jIyBIVFRQIE1FU1NBR0UgUkVRVUVTVCAmIFJFU1BPTlNFXFxyXFxuXFxyXFxuIyMjIyAxLiDtgbTrnbzsnbTslrjtirgg7JqU7LKtIOyghOyGoSAoUkVRVUVTVClcXHJcXG5cXHJcXG4xLiDssqvrsojsp7gg7KSE7J2AIO2MjOudvOuplO2EsOqwgCDrlLDrpbTripQg7JqU7LKtIOuplOyEnOuTnOulvCDtj6ztlajtlanri4jri6Q6XFxyXFxuXFxyXFxuICAgVGhlIGZpcnN0IGxpbmUgY29udGFpbnMgYSByZXF1ZXN0IG1ldGhvZCBmb2xsb3dlZCBieSBpdHMgcGFyYW1ldGVyczpcXHJcXG5cXHJcXG4gICAtIOusuOyEnOydmCDqsr3roZwsIOymiSDtlITroZzthqDsvZzqs7wg64+E66mU7J24IOydtOumhOydhCDsoJzsmbjtlZwg7KCI64yAIFVSTFxcclxcbiAgIC0g7IKs7Jqp7KSR7J24IEhUVFAg7ZSE66Gc7Yag7L2cIOuyhOyghFxcclxcblxcclxcbjIuIOuwlOuhnCDri6TsnYwg7KSE65Ok7J2AIOqwgeqwgSDtirnsoJUg7Zek642U66W8IOuCmO2DgOuCtOuKlOuNsCwg642w7J207YSw7J2YIOyiheulmOqwgCDsoIHtlantlZzsp4Ao7JiI66W8IOuTpOyWtCwg7Ja47Ja064qUIOustOyXh+yduOyngCwgTUlNRSDtg4DsnoXsnYAg66y07JeH7J247KeAIOuTsSkg7Zi57J2AIOyEnOuyhOydmCDrj5nsnpHsnYQg7IiY7KCV7ZWY64qUIOuqhyDqsIDsp4Ag642w7J207YSwKOyYiOulvCDrk6TslrQsIOydtOuvuCDsupDsi5zrkJjslrQg7J6I64qUIOqyveyasCDsnZHri7XsnYQg7KCE7Iah7ZWY7KeAIOyViuuKlOuLpOuToOyngCDtlZjripQpIOuTseyXkCDqtIDtlZwg66qHIOqwgOyngCDsoJXrs7Trpbwg7ISc67KE7JeQ6rKMIOygnOqzte2VqeuLiOuLpC4g7J2065+wIEhUVFAg7Zek642U65Ok7J2AIOu5iCDspITroZwg64Gd64KY64qUIOu4lOuhneydhCDtmJXshLHtlanri4jri6QuXFxyXFxuXFxyXFxuMy4g66eI7KeA66eJIOu4lOuhneydgCDrtoDqsIDsoIHsnbgg642w7J207YSwIOu4lOuhneycvOuhnCwg642UIOunjuydgCDrjbDsnbTthLDrpbwg7Y+s7ZWo7ZWY66mwIOyjvOuhnCBQT1NUIOuplOyEnOuTnOyXkCDsnZjtlbQg7IKs7Jqp65Cp64uI64ukLlxcclxcblxcclxcbmBgYG1hcmtkb3duXFxyXFxuR0VUIC8gSFRUUC8xLjFcXHJcXG5Ib3N0OiBkZXZlbG9wZXIubW96aWxsYS5vcmdcXHJcXG5BY2NlcHQtTGFuZ3VhZ2U6IGZyXFxyXFxuYGBgXFxyXFxuXFxyXFxuKirri6TslpHtlZwgaHR0cCByZXF1ZXN0IG1ldGhvZHMqKlxcclxcblxcclxcbi0gSFRUUOuKlCDso7zslrTsp4Qg7J6Q7JuQ7JeQIOuMgO2VtCDsi6TtlonrkJjquLgg67CU652864qUIOuPmeyekeydhCDqsIDrpqztgqTripQg7JqU7LKtIOuplOyGjOuTnCDsp5HtlansnLzroZwsIOuMgO2RnOyggeycvOuhnCBgR0VUYCwgYFBPU1Rg67Cp7Iud7J20IOyeiOyKteuLiOuLpC4gXFxyXFxuLSDsooAg642UIOyekOyEuO2VnCDrgrTsmqnsnYAg7JWE656YIE1ETiDrp4Htgazrpbwg7Ya17ZW0IO2ZleyduO2VtOuztOyEuOyalC5cXHJcXG5cXHJcXG5b64uk7JaR7ZWcIEhUVFAgcmVxdWVzdCBtZXRob2RzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9IVFRQL01ldGhvZHMpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIyAyLiDshJzrsoQg7J2R64u17J2YIOq1rOyhsCAoUkVTUE9OU0UpXFxyXFxuXFxyXFxu7Jew6rKw65CcIOyXkOydtOyghO2KuOqwgCDsnpDsi6DsnZgg7JqU7LKt7J2EIOyghOyGoe2VmOqzoCDrgpwg65Kk7JeQLCDsm7kg7ISc67KE6rCAIOq3uOqyg+ydhCDsspjrpqztlZjqs6Ag7LWc7KKF7KCB7Jy866GcIOydkeuLteydhCDrj4zroKTrs7TrgrTqsowg65Cp64uI64ukLiDtgbTrnbzsnbTslrjtirgg7JqU7LKt6rO8IOycoOyCrO2VmOqyjCwg7ISc67KEIOydkeuLteydgCDshLgg6rCc7J2YIOuLpOuluCDruJTroZ3snLzroZwg64KY64iE7Ja07KeELCBDUkxG66GcIOq1rOu2hOuQnCDthY3siqTtirgg7KeA7Iuc7J6Q65Ok66GcIO2YleyEseuQqeuLiOuLpFxcclxcblxcclxcbjEuIOyDge2DnCDspITsnbggYOyyq+uyiOynuCDspIRg7J2AIGDsg4Htg5wg7JqU7LKtYCjqt7jrpqzqs6Ag7J246rCE7J20IOydveydhCDsiJgg7J6I64qUIO2FjeyKpO2KuCDrgrTsl5DshJzsnZgg7J2Y66+4KeydtCDrlLDrpbTrj4TroZ0g7IKs7Jqp65CcIEhUVFAg67KE7KCE7J2YIGFja25vd2xlZGdtZW5066GcIOq1rOyEseuQqeuLiOuLpC5cXHJcXG4yLiDri6TsnYwg7KSE65Ok7J2AIOqwgeqwgSBg7Yq57KCVIEhUVFAg7Zek642UYOulvCDrgpjtg4DripTrjbAsIOyghOyGoeuQmOuKlCDrjbDsnbTthLDsl5Ag6rSA7ZWcIOygleuztCjsnbTrpbzthYzrqbQsIO2DgOyehSwg642w7J207YSwIO2BrOq4sCwg7IKs7Jqp65CcIOyVley2lSDslYzqs6DrpqzsppgsIOy6kOyLnOyXkCDrjIDtlZwg7Z6M7Yq4IOuTsSnrpbwg7YG065287J207Ja47Yq47JeQ6rKMIOygnOqzte2VqeuLiOuLpC4g7YG065287J207Ja47Yq47J2YIOyalOyyreyXkCDrjIDtlZwgSFRUUCDtl6TrjZQg67iU66Gd6rO8IOycoOyCrO2VmOqyjCwg7J20IEhUVFAg7Zek642U65Ok7J2AIOu5iCDspITroZwg64Gd64KY64qUIOu4lOuhneydhCDtmJXshLHtlanri4jri6QuXFxyXFxuMy4g66eI7KeA66eJIOu4lOuhneydgCDrjbDsnbTthLAg67iU66Gd7Jy866GcICjsobTsnqztlZzri6TrqbQpIOuNsOydtO2EsOulvCDtj6ztlajtlanri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuPiDshJzroZwg7Jyg7IKs7ZWcIO2Yle2DnOydmCBSRVFVRVNUU+yZgCBSRVNQT05TRVNcXHJcXG5cXHJcXG4hW0hUVFBNc2dTdHJ1Y3R1cmUyXShodHRwczovL21lZGlhLnByb2QubWRuLm1veml0LmNsb3VkL2F0dGFjaG1lbnRzLzIwMTYvMDgvMzEvMTM4MjcvMjczNzMwNmRlZjdkOTk0YjE3ODVkNTg3OWYwZjU3MDQvSFRUUE1zZ1N0cnVjdHVyZTIucG5nKVxcclxcblxcclxcbuybuSDtjpjsnbTsp4DsnZgg7ISx6rO17KCB7J24IOyImOyLoDpcXHJcXG5cXHJcXG5gYGBtYXJrZG93blxcclxcbkhUVFAvMS4xIDIwMCBPS1xcclxcbkRhdGU6IFNhdCwgMDkgT2N0IDIwMTAgMTQ6Mjg6MDIgR01UXFxyXFxuU2VydmVyOiBBcGFjaGVcXHJcXG5MYXN0LU1vZGlmaWVkOiBUdWUsIDAxIERlYyAyMDA5IDIwOjE4OjIyIEdNVFxcclxcbkVUYWc6IFxcXCI1MTE0MmJjMS03NDQ5LTQ3OWIwNzViMjg5MWJcXFwiXFxyXFxuQWNjZXB0LVJhbmdlczogYnl0ZXNcXHJcXG5Db250ZW50LUxlbmd0aDogMjk3NjlcXHJcXG5Db250ZW50LVR5cGU6IHRleHQvaHRtbFxcclxcblxcclxcbjwhRE9DVFlQRSBodG1sLi4uIChoZXJlIGNvbWVzIHRoZSAyOTc2OSBieXRlcyBvZiB0aGUgcmVxdWVzdGVkIHdlYiBwYWdlKVxcclxcblxcclxcbmBgYFxcclxcblxcclxcbuyalOyyreuQnCDsnpDsm5DsnbQg7KG07J6s7ZWY7KeAIOyViuuKlOuLpOuKlCDrgrTsmqnsnZgg7JWM66a8XFxyXFxuXFxyXFxuYGBgbWFya2Rvd25cXHJcXG5IVFRQLzEuMSA0MDQgTm90IEZvdW5kXFxyXFxuRGF0ZTogU2F0LCAwOSBPY3QgMjAxMCAxNDozMzowMiBHTVRcXHJcXG5TZXJ2ZXI6IEFwYWNoZVxcclxcbkxhc3QtTW9kaWZpZWQ6IFR1ZSwgMDEgTWF5IDIwMDcgMTQ6MjQ6MzkgR01UXFxyXFxuRVRhZzogXFxcIjQ5OWZkMzRlLTI5ZWMtNDJmNjk1Y2E5Njc2MTs0OGZlNzUyM2NmY2MxXFxcIlxcclxcbkFjY2VwdC1SYW5nZXM6IGJ5dGVzXFxyXFxuQ29udGVudC1MZW5ndGg6IDEwNzMyXFxyXFxuQ29udGVudC1UeXBlOiB0ZXh0L2h0bWxcXHJcXG5cXHJcXG48IURPQ1RZUEUgaHRtbC4uLiAoY29udGFpbnMgYSBzaXRlLWN1c3RvbWl6ZWQgcGFnZSBoZWxwaW5nIHRoZSB1c2VyIHRvIGZpbmQgdGhlIG1pc3NpbmcgcmVzb3VyY2UpXFxyXFxuYGBgXFxyXFxuXFxyXFxuKipIVFRQIFJFUVVFU1QgU1RBVFVTIENPREUg7J2R64u1IOyDgeyEuCDsvZTrk5wqKlxcclxcblxcclxcbkhUVFAg7J2R64u1IOyDge2DnCDsvZTrk5zripQg7Yq57KCVIEhUVFAg7JqU7LKt7J20IOyEseqzteyggeycvOuhnCDsmYTro4zrkJjsl4jripTsp4Ag7JWM66Ck7KSN64uI64ukLiDsnZHri7XsnYAgNeqwnOydmCDqt7jro7nsnLzroZwg64KY64iE7Ja07KeR64uI64ukXFxyXFxuXFxyXFxu7KCV67O066W8IOygnOqzte2VmOuKlCDsnZHri7UsIOyEseqzteyggeyduCDsnZHri7UsIOumrOuLpOydtOugie2KuCwg7YG065287J207Ja47Yq4IOyXkOufrCwg6re466as6rOgIOyEnOuyhCDsl5Drn6wuXFxyXFxuXFxyXFxu6rCA7J6lIOuMgO2RnOyggeyduCDqsoPsnYAgMjAwLCA0MDAsIDUwMCDrsojrjIDsnZgg7JeQ65+s7J6F64uI64ukLlxcclxcblxcclxcbnwgU1RBVFVTIENPREUgICAgICAgICAgICAgICAgICB8IERFU0NSSVBUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxufCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcXHJcXG58IGAyMDBgOiBPSyAgICAgICAgICAgICAgICAgICAgfCDqsIDsnqUg67CY6rCA7Jq0IOyDge2DnOyeheuLiOuLpC4g7JqU7LKt7J20IOyEseqzteyggeycvOuhnCDrkJjsl4jsirXri4jri6QuIOyEseqzteydmCDsnZjrr7jripQgSFRUUCDrqZTshozrk5zsl5Ag65Sw6528IOuLrOudvOynkeuLiOuLpDogR0VUOiDrpqzshozsiqTrpbwg67aI65+s7JmA7IScIOuplOyLnOyngCDrsJTrlJTsl5Ag7KCE7Iah65CY7JeI7Iq164uI64ukLiBIRUFEOiDqsJzssrQg7ZW0642U6rCAIOuplOyLnOyngCDrsJTrlJTsl5Ag7J6I7Iq164uI64ukLiBQVVQg65iQ64qUIFBPU1Q6IOyImO2WiSDqsrDqs7zsl5Ag64yA7ZWcIOumrOyGjOyKpOqwgCDrqZTsi5zsp4Ag67CU65SU7JeQIOyghOyGoeuQmOyXiOyKteuLiOuLpC4gVFJBQ0U6IOuplOyLnOyngCDrsJTrlJTripQg7ISc67KE7JeQ7IScIOyImOyLoO2VnCDsmpTssq0g66mU7Iuc7KeA66W8IO2PrO2VqO2VmOqzoCDsnojsirXri4jri6QuIHxcXHJcXG58IGA0MDBgOiBCYWQgUmVxdWVzdCAgICAgICAgICAgfCDsnbQg7J2R64u17J2AIOyemOuqu+uQnCDrrLjrspXsnLzroZwg7J247ZWY7JesIOyEnOuyhOqwgCDsmpTssq3snYQg7J207ZW07ZWgIOyImCDsl4bsnYzsnYQg7J2Y66+47ZWp64uI64ukLjxiciAvPjQwMTogdW5hdXRob3JpemVkIC0g7J247Kad65CY7KeAIOyViuydgCDsmpTssq0gKOyjvOuhnCBsb2dpbiDrkJjsp4Ag7JWK7J2AIOqyveyasCDrsJzsg50pPGJyIC8+NDAzOiBGb3JiaWRkZW4gLSDsvZjthZDsuKDsl5Ag7KCR6re87ZWgIOq2jOumrOulvCDqsIDsp4Dqs6Ag7J6I7KeAIOyViuuKlCDsmpTssq0uICjso7zroZwg6raM7ZWc7J20IOyXhuuKlCDsnKDsoIDqsIAg7JqU7LKt7ZWY7JesIOuwnOyDnSk8YnIgLz40MDQ6IE5vdCBmb3VuZCAtIOyEnOuyhOuKlCDsmpTssq3rsJvsnYAg66as7IaM7Iqk66W8IOywvuydhCDsiJgg7JeG7Iq164uI64ukLiAo7KO866GcIOyemOuqu+uQnCDrp4Htgazrpbwg7J6R7ISx7ZWY7JesIOuwnOyDne2VmOqxsOuCmCDsmIjsoITsl5Ag7J6I642YIO2OmOydtOyngOqwgCDsl4bslrTsoLjshJwg67Cc7IOdKSB8XFxyXFxufCBgNTAwYDogSW50ZXJuZXIgc2VydmVyIEVycm9yIHwg7J20IOydkeuLteydgCDtgbTrnbzsnbTslrjtirgg7JqU7LKt7JeQ7ISc64qUIOusuOygnOqwgCDsl4bsl4jsnLzrgpgg7JqU7LKt7JeQIOuMgO2VnCDsspjrpqzrpbwg7ZW07KO864qUIOyEnOuyhOyqveyXkCDrrLjsoJzqsIAg7IOd6rK87J2EIOuVjOydmCDsg4Htg5zsvZTrk5zsnoXri4jri6QuPGJyIC8+7J2866qFIGDshJzrsoTqsIAg7YSw7KGM64ukYOuKlCDsg4HtmansnbQg66eO7Iq164uI64ukLiB8XFxyXFxuXFxyXFxuYEhUVFAgUkVRVUVTVCBTVEFUVVMg7L2U65OcYOyXkCDrjIDtlZwg642U7JqxIOyekOyEuO2VnCDrgrTsmqnsnYAg7JWE656YIOunge2BrOulvCDthrXtlbQg7ZmV7J247ZW07KO87IS47JqULlxcclxcblxcclxcbltIVFRQIOyalOyyrSBTVEFUVVMgQ09ERV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvSFRUUC9TdGF0dXMpXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxu64uk7J2M7J2AIGDqsJzrsJzsnpDrpbwg6rS066Gt7Z6I7KeA66eMIOyXhuyWtOyEnOuKlCDslYjrkJjripQgQ09SU+yZgCBTT1Bg7JeQIOuMgO2VnCDtj6zsiqTtjIXsnYQg7ZW067O06rKg7Iq164uI64ukLlxcclxcblxcclxcbi0tLVxcclxcblxcclxcbkNvcHlyaWdodCAtIGxpa2VsaW9uU3VuZ0d1a1xcclxcblxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJXQVPsmYAg7Ju57ISc67KE64qUIOutkOqwgCDri6TrpbjqsbDsp4A/XFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjAxLjAxXFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSBXQVNcXHJcXG4gIC0g7Ju57ISc67KEXFxyXFxuICAtIE5HSU5YXFxyXFxuICAtIEFwYWNoZVxcclxcbiAgLSBUb21jYXRcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIFvtl7fqsIjrpqzripQg6rCc64WQIOu5hOq1kF0gXFxyXFxuXFxyXFxuIyMgMS4gV2ViIOyEnOuyhOuegFxcclxcblxcclxcbi0g7YG065287J207Ja47Yq46rCAIOyEnOuyhOyXkCDtjpjsnbTsp4Ag7JqU7LKt7J2EIO2VmOuptCDsmpTssq3snYQg67Cb7JWEYCDsoJXsoIEg7Luo7YWQ7LigKC5odG1sLCAucG5nLCAuY3Nz65OxKWDrpbwg7KCc6rO17ZWY64qUIOyEnOuyhFxcclxcbi0gV0VC7ISc67KE64qUIO2BtOudvOydtOyWuO2KuOyXkOyEnCDsmpTssq3snbQg7JisIOuVjCDqsIDsnqUg7JWe7JeQ7IScIOyalOyyreyXkCDrjIDtlZwg7LKY66as66W8IOynhO2Wie2VqeuLiOuLpC5cXHJcXG4tIOyekeuPmSBQcm9jZXNzXFxyXFxuICAtIDEuIO2BtOudvOydtOyWuO2KuCDsvZjthZDsuKAg7JqU7LKtXFxyXFxuICAgIDIuIOunjOyVvSDsoJXsoIEg7L2Y7YWQ7LigIOyalOyyreydtOuptCwg7Ju57ISc67KE7JeQ7IScIOygleyglSDsvZjthZDsuKAg7YG065287J207Ja47Yq47JeQ6rKMIOyghOuLrFxcclxcbiAgICAgICDrp4zslb0g64+Z7KCBIOy9mO2FkOy4oCDsmpTssq3snbTrqbQsIOybueyEnOuyhOyXkOyEnCDsspjrpqztlZjquLAg67KE6rGw7JuALiAtPiBXQVPsl5Dqsowg7JqU7LKtXFxyXFxuICAgIDMuIOuBnS5cXHJcXG4tIOuMgO2RnOyggeyduCDsm7nshJzrsoQ6IEFwYWNoZSwgbmdpbnhcXHJcXG5cXHJcXG4hW3dlYl9zZXJ2ZXJdKC9hc3NldHMvaW1nL3dlYl9zZXJ2ZXIucG5nKVxcclxcblxcclxcblxcclxcblxcclxcbiMjIDIuIFdBU+uegFxcclxcblxcclxcbiFbMjAyMDA4MTlfMDAwNzMzXSgvYXNzZXRzL2ltZy9taWRkbGVfd2FyZS5wbmcpXFxyXFxuXFxyXFxuLSBEQuyhsO2ajCDtmLnsnYAg66Gc7KeB7LKY66as6rCAIOyalOq1rOuQmOuKlCBg64+Z7KCBIOy9mO2FkOy4oGDrpbwg7KCc6rO17ZWY6riwIOychO2VtCDrp4zrk6TslrTsp4QgKipXZWIgQXBwbGljYXRpb24gU2VydmVyKirsnoXri4jri6QuIFxcclxcbi0g7KKAIOuNlCDqtazssrTsoIHsnLzroZzripQg67aE7IKwIO2KuOuenOyereyFmCwg67O07JWILCDrqZTsi5zsp5UsIOyTsOugiOuTnCDsspjrpqwg65Ox7J2YIOq4sOuKpeydhCDsspjrpqztlZjripQg67aE7IKw7ZmY6rK97JeQ7IScIOyCrOyaqeuQmOuKlCDrr7jrk6Tsm6jslrTsnoXri4jri6QuXFxyXFxuLSDtgbTrnbzsnbTslrjtirjsl5DshJwgRELshJzrsoTroZwg642w7J207YSw66W8IOyngeygkSDsmpTssq3tlZjripQg6rKD7JeQIOyXrOufrCDrrLjsoJzqsIAg7J6I7JeI64ukLiDssqsg67KI7Ke464qUIOuztOyViCDrrLjsoJwsIOuRkCDrsojsp7jripQg7YG065287J207Ja47Yq47JmAIERC7J2YIOqwr+yImOqwgCDrp47slYTsp4DrqbTshJwg66Gc7KeB7J20IOuzteyeoe2VtOynhOuLpOuKlCDqsoPsnbTri6QuICDrlLDrnbzshJwsIOuvuOuTpOybqOyWtOudvOuKlCDsg4jroZzsmrQg6rCc64WQ7J20IOyDneqyvOuKlOuNsCwg7YG065287J207Ja47Yq464qUIOydtCDrr7jrk6Tsm6jslrTsl5Ag7J6Q7Iug7J2YIOyalOyyreydhCDrqqjrkZAg7KCE7Iah7ZWY6rOgIOydtCDrr7jrk6Tsm6jslrTripQg6rCA7Jq0642w7JeQ7IScIOydtOulvCBkYuyEnOuyhOyXkCDsoITri6ztlZjqs6AgcmVzcG9uc2Xrpbwg67Cb7JWEIOuLpOyLnCDtgbTrnbzsnbTslrjtirjsl5Ag7KCE64us7ZWY64qUIOyXre2VoOydhCDsiJjtlontlanri4jri6QuIFxcclxcbi0gSlNQLCBTZXJ2bGV07J20IOq1rOuPme2VoCDsiJgg7J6I64qUIO2ZmOqyveydhCDsoJzqs7Xtlanri4jri6QuXFxyXFxuLSDsu6jthYzsnbTrhIgsIOybuey7qO2FjOydtOuEiCDtmLnsnbgg7ISc67iU66a/IOy7qO2FjOydtOuEiOudvOqzoOuPhCDrtoDrpoXri4jri6QuXFxyXFxuXFxyXFxuLSDrj5nsnpEg7ZSE66Gc7IS47IqkXFxyXFxuXFxyXFxuICAxLiDsm7nshJzrsoTroZzrtoDthLAg7JqU7LKt7J20IOyYpOuptCDsu6jthYzsnbTrhIjqsIAg67Cb7JWE7IScIOyymOumrFxcclxcblxcclxcbiAgMi4g7Luo7YWM7J2064SI64qUIHdlYi54bWzsnYQg7LC47KGw7ZWY7JesIO2VtOuLuSDshJzruJTrpr/sl5Ag64yA7ZWcIOyTsOugiOuTnCDsg53shLHtlZjqs6AgaHR0cFNlcnZsZXRSZXF1ZXN07JmAIGh0dHBTZXJ2bGV0UmVzcG9uc2Ug6rCd7LK066W8IOyDneyEse2VmOyXrCDsoITri6ztlZzri6QuXFxyXFxuXFxyXFxuICAzLiDsu6jthYzsnbTrhIjripQg7ISc67iU66a/7J2EIO2YuOy2nO2VnOuLpC5cXHJcXG5cXHJcXG4gIDQuIO2YuOy2nOuQnCDshJzruJTrpr/snZgg7J6R7JeF7J2EIOuLtOuLue2VmOqyjCDrkJwg7JOw66CI65OcKDLrsojsl5DshJwg66eM65OgIOyTsOugiOuTnCnripQgZG9Qb3N0KCnrmJDripQgZG9HZXQoKeydhCDtmLjstpztlZzri6QuXFxyXFxuXFxyXFxuICA1LiDtmLjstpzrkJwgZG9Qb3N0KCksIGRvR2V0KCkg66mU7IaM65Oc64qUIOyDneyEseuQnCDrj5nsoIEg7Y6Y7J207KeA66W8IFJlc3BvbnNl6rCd7LK07JeQIOuLtOyVhCDsu6jthYzsnbTrhIjsl5Ag7KCE64us7ZWc64ukLlxcclxcblxcclxcbiAgNi4g7Luo7YWM7J2064SI64qUIOyghOuLrOuwm+ydgCBSZXNwb25zZeqwneyytOulvCBIVFRQUmVzcG9uc2XtmJXtg5zroZwg67CU6r+UIOybueyEnOuyhOyXkCDsoITri6ztlZjqs6Ag7IOd7ISx65CY7JeI642YIOyTsOugiOuTnOulvCDsooXro4ztlZjqs6AgaHR0cFNlcnZsZXRSZXF1ZXN0LCBodHRwU2VydmxldFJlc3BvbnNlIOqwneyytOulvCDshozrqbjsi5ztgqjri6QuXFxyXFxuXFxyXFxuLSDrjIDtkZwgOiBUb21jYXQsIEpldXMsIEpCb3NzXFxyXFxuXFxyXFxuIVtdKC9hc3NldHMvaW1nL1dBUy5wbmcpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMy4g7Ju57ISc67KE7JmAIFdBUyDqtazsobBcXHJcXG5cXHJcXG4hW10oL2Fzc2V0cy9pbWcvd2ViLXNlcnZpY2UtYXJjaGl0ZWN0dXJlLnBuZylcXHJcXG5cXHJcXG7sm7nshJzrsoTripQg64uk7JaR7ZWcIOq1rOyhsOulvCDqsIDsp4gg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4tIENsaWVudCAtPiBXZWIgU2VydmVyIC0+IERCXFxyXFxuLSBDbGllbnQgLT4gV0FTIC0+IERCXFxyXFxuLSBDbGllbnQgLT4gV2ViIFNlcnZlciAtPiBXQVMgLT4gREJcXHJcXG5cXHJcXG7snbQg7KSR7JeQ7IScIOqwgOyepSDrp4jsp4Drp4kg6rWs7KGw7J24IGBDbGllbnQgLT4gV2ViIFNlcnZlciAtPiBXQVMgLT4gREJg6rCAIOychOydmCDrj4Tsi53tmZTrkJwg7ZiV7YOc7J206rOgLCDsnbTroIfqsowg6rCA7J6lIOunjuydtCDqtazrtoTrkJjslrQg7J6I64qUIOq1rOyhsOqwgCDsoovri6Tqs6Ag7Y+J6rCA67Cb6rOgIOyeiOyKteuLiOuLpC4g6re4IOydtOycoOuKlCDslYTrnpgg7IOB7IS47Z6IIOyEpOuqhe2VmOqyoOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA0LiDsm7nshJzrsoTsmYAgV0FTIOq1rOu2hCDsnbTsnKBcXHJcXG5cXHJcXG4tIOydvOuLqCBXQVPripQg7Ju57ISc67KE7J2YIOyXre2VoOuPhCDrp6HsnYQg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG4tIOydtOyghOyXkOuKlCAqKuygleyggey9mO2FkOy4oOq5jOyngCBXQVPsl5DshJwg7ZWY6riw7JeQ64qUIOyEnOuyhOyXkCDrtoDtlZjrpbwg66eO7J20IOykmCDruYTtmqjsnKjsoIEqKuydtOyWtOyEnCDrgpjriLTsl4jsirXri4jri6QuIO2VmOyngOunjCDstZzqt7zsl5DripQgV0FT7J2YIOyEseuKpeydtCDrjZQg7Jis65286rCU6riwIOuVjOusuOyXkCDqtbPsnbQg7ISx64ql7IOB7J2YIOydtOycoCDrlYzrrLjsl5Ag65GY7J2EIOuCmOuIhOyngOuKlCDslYrripTri6Tqs6Ag7ZWp64uI64ukLiBcXHJcXG4tIOq3uOufvOyXkOuPhCDrtojqtaztlZjqs6Ag7J20IOuRkCDqsIDsp4Drpbwg6rWs67aE7ZW07IScIOyTsOqzoCDsnojripTrjbAg7J207Jyg64qUIOuLpOydjOqzvCDqsJnsirXri4jri6QuXFxyXFxuICAxLiAg66y866as7KCBIOu2hOumrOuhnCDsnbjtlZwg67O07JWIIOqwle2ZlCBcXHJcXG4gICAgIC0gV0FT64qUIGRi7ISc67KE66W8IO2YuOy2nO2VmOuKlCDsl63tlaDsnYQg66eh64qU642wLCDsnbQgZGLshJzrsoTsl5DripQg7ZqM7JuQ7KCV67O07JmAIOqwmeydtCDqsIDsnqUg7KSR7JqU7ZWcIOygleuztOuTpOydtCDrk6TslrTsnojsirXri4jri6QuIOuUsOudvOyEnCDtgbTrnbzsnbTslrjtirjsmYAg6rCA7J6lIOqwgOq5jOydtCDsnojripQg7Ju57ISc67KE7J2YIOuztOyViOydtCDrmqvroKTrj4QsIFdBU+yXkOyEnCBkYuyXkCDsoJHqt7ztlZjripQg7ZWcIOuLqOqzhOqwgCDrjZQg7IOd6riw66+A66GcIOuztOyViOyXkCDsg4HrjIDsoIHsnLzroZwg7Jqp7J207ZWp64uI64ukLiDrsJjrqbQsIOybueyEnOuyhOyZgCBXQVPrpbwg6rWs67aE7ZWY7KeAIOyViuuKlCDqsr3smrAg7ZWcIOuyiOyXkCDri6Qg65qr66as6riwIOuVjOusuOyXkCDrs7TslYjsl5Ag7Leo7JW97ZWY64uk6rOgIOuzvCDsiJgg7J6I7Iq164uI64ukLiBcXHJcXG4gIDIuIOyXrOufrCBXQVPrpbwg7Jew6rKw7ZWgIOyImCDsnojsnYxcXHJcXG4gICAgIC0gamF2YeyEnOuyhCwgQ+yEnOuyhCwgcGhw7ISc67KEIOuTsSDtlZjrgpjsnZgg7Ju57ISc67KE66W8IO2Gte2VtCDsl6zrn6wg7ISc67mE7Iqk6rCAIOqwgOuKpe2VmOuLpC5cXHJcXG4gIDMuICoqKuyepeyVoCDqt7nrs7UqKiogLSDrp4zslb0gV0FT7JeQIOyYpOulmOqwgCDrgqzsnYQg6rK97JqwLCDsm7nshJzrsoTsl5DshJwg7J2066W8IOyduOyngO2VmOqzoCDsgqzsmqnsnpDqsIAg7Jik66WY6rCAIOuCnCBXQVPsl5Ag7KCR6re87ZWY7KeAIOuqu+2VmOuPhOuhnSDrp4nqs6AgV0FT66W8IOyerOyLnOyeke2VqeuLiOuLpC4g7J2065WMLCDsnbQg7IKs7Jqp7J6Q6rCAIFdBU+ulvCDtmLjstpztlZjripQg7JqU7LKt7J2EIO2VmOq4sCDsoITquYzsp4DripQg7Ju57ISc67KE7JeQ7IScIOygleyggey9mO2FkOy4oChodG1sLCBwbmcpIOuTseydhCDrs7Tsl6zso7zqs6Ag7J6I6riwIOuVjOusuOyXkCDsmKTrpZjsg4HtmansnYQg7J247KeA7ZWY7KeAIOuqu+2VoCDsiJgg7J6I7Iq164uI64ukLiBcXHJcXG4tIO2Kue2eiOuCmCDshJzruYTsiqTsnZgg6rec66qo6rCAIOy7pOyniOyImOuhnSBXQVPsmYAg7Ju57ISc67KE66W8IOuNlOyasSDtlYTsiJjsoIHsnLzroZwg67aE66as7ZWp64uI64ukLlxcclxcbi0gV2ViIFNlcnZlcuulvCBXQVMg7JWe7JeQIOuRkOqzoCDtlYTsmpTtlZwgV0FT65Ok7J2EIFdlYiBTZXJ2ZXLsl5Ag7ZSM65+s6re47J24IO2Yle2DnOuhnCDshKTsoJXtlZjrqbQg642U7JqxIO2aqOycqOyggeyduCDrtoTsgrAg7LKY66as6rCAIOqwgOuKpe2VmOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG7stpzsspggUmVmcy5cXHJcXG5cXHJcXG5odHRwczovL2dtbHdqZDk0MDUuZ2l0aHViLmlvLzIwMTgvMTAvMjkvd2ViLWFwcGxpY2F0aW9uLXN0cnVjdHVyZS5odG1sXFxyXFxuXFxyXFxuaHR0cHM6Ly9nbWx3amQ5NDA1LmdpdGh1Yi5pby8yMDE4LzEwLzI3L3dlYnNlcnZlci12cy13YXMuaHRtbFxcclxcblxcclxcbmh0dHBzOi8vamVvbmctcHJvLnRpc3RvcnkuY29tLzg0XFxyXFxuXFxyXFxuaHR0cHM6Ly9va2t5LmtyL2FydGljbGUvMjQzNDI3XFxyXFxuXFxyXFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIuyalOqyg+ydtCDsm7ntjKnsnbTri6QhXFxcIlxcbmRhdGU6IFxcXCIyMDIyLTAyLTIyXFxcIlxcbnRhZ3M6XFxuICAtIHdlYnBhY2tcXG4tLS1cXG5cXG5cXG5cXG7snbQg6riA7J2AIFvtlITroaDtirjsl5Trk5wg6rCc67CcIO2ZmOqyveydmCDsnbTtlbRdKGh0dHBzOi8vamVvbmdod2FuLWtpbS5naXRodWIuaW8vc2VyaWVzLzIwMTkvMTIvMTAvZnJvbnRlbmQtZGV2LWVudi13ZWJwYWNrLWJhc2ljLmh0bWwjNS0lRUQlOTQlOEMlRUIlOUYlQUMlRUElQjclQjglRUMlOUQlQjgp66W8IOuplOyduOycvOuhnCDtlbTshJwg6rCE64uo7ZWcIGh0bWwsIGNzcywganPrpbwg7Zmc7Jqp7ZWcIO2UhOuhnOygne2KuOulvCDrp4zrk6TslrTrs7TrqbAg7KCc6rCAIOydtO2VtO2VnCDrjIDroZwg7Ju57Yyp7J2EIOyEpOuqhe2VtCDrhpPsnYAg6riA7J6F64uI64ukLlxcblxcblxcblxcbiMg7JqU6rKD7J20IOybue2MqSAoV2VicGFjaynsnbTri6QhXFxuXFxuIyMgMS4g7Ju57Yyp7J20656AP1xcblxcbiFb7JqU6rKD7J207Ju57Yyp7J2064ukXSgvYXNzZXRzL2ltZy/smpTqsoPsnbTsm7ntjKnsnbTri6QucG5nKVxcblxcbuyYpO2UiCDshozsiqQg7J6Q67CU7Iqk7YGs66a97Yq4wqAqKuuqqOuTiCDrsojrk6Trn6wqKuuhnOyNqCDsl6zrn6zqsJzroZwg64KY64iE7Ja07KC4IOyeiOuKlCDtjIzsnbzrk6TsnYQgKirtlZjrgpjsnZgg7J6Q67CU7Iqk7YGs66a97Yq4IOy9lOuTnOuhnCDslZXstpXtlZjqs6Ag7LWc7KCB7ZmU7ZWY64qUIOudvOydtOu4jOufrOumrCoq7J6F64uI64ukLlxcblxcbuydtOufrO2VnCBCdW5kbGVy7J2YIOqwgOyepSDrjIDtkZzsoIHsnbgg6rKD7J20IGDsm7ntjKlg7J206rOgLCBgUGFyY2VsYCwgYFJvbGx1cGDrk7HsnbQg642UIOyeiOyKteuLiOuLpC5cXG5cXG4hW+qzvOqxsCDsnbzrsJjsoIHsnbgg66qo7Iq17J2YIGh0bWwsIGNzcywganMg6rWs7KGwXFxu6rCB6rCB7J2YIO2MjOydvOuTpOydhCDrlLDroZwg67Cb7JWE7Jik64qUIOqyg+ydgCDrhKTtirjsm4ztgawg64Kt67mE6rCAIO2BrOuLpC5dKC9hc3NldHMvaW1nL+yalOqyg+ydtOybue2MqeydtOuLpCUyMDEucG5nKVxcblxcbuqzvOqxsCDsnbzrsJjsoIHsnbgg66qo7Iq17J2YIGh0bWwsIGNzcywganMg6rWs7KGwXFxu6rCB6rCB7J2YIO2MjOydvOuTpOydhCDrlLDroZwg67Cb7JWE7Jik64qUIOqyg+ydgCDrhKTtirjsm4ztgawg64Kt67mE6rCAIO2BrOuLpC5cXG5cXG4jIyMgMS4xIOybue2MqeydhCDsgqzsmqntlZjripQg7J207JygP1xcblxcbjEuICoq7Jes65+sIO2MjOydvOydmCDsnpDrsJTsiqTtgazrpr3tirgg7L2U65Oc66W8IOyVley2le2VmOyXrCDstZzsoIHtmZQqKiDtlaAg7IiYIOyeiOq4sCDrlYzrrLjsl5AgKirroZzrlKnsl5Ag64yA7ZWcIOuEpO2KuOybjO2BrCDruYTsmqnsnYQg7KSE7J28IOyImCDsnojsirXri4jri6QuIFxcbuKHkiDroZzrlKkg7IaN64+E66W8IOuGkuydvCDsiJgg7J6I7Iq164uI64ukLioqXFxuMi4gKirrqqjrk4gg64uo7JyE66GcIOqwnOuwnOydtCDqsIDriqXtlZjsl6wsIOqwgOuPheyEseqzvCDsnKDsp4Drs7TsiJjqsIAg7Im97Iq164uI64ukLioqXFxuICAgIC0g7JiI66W8IOuTpOyWtCwg6riw64ql67OE66GcIOuCmOuIiOuLpOqzoCDtlZjrqbQgQ3JlYXRlLmpzLCBSZWFkLmpzLCBVcGRhdGUuanMsIERlbGV0ZS5qcyDsiqTtgazrpr3tirjrpbwg6rCB6rCBIOunjOuTpOyWtOyEnCDtlbTri7kg6riw64ql7JeQIO2VhOyalO2VnCDsvZTrk5zrk6Trgbzrpqwg66qo7JWE65GQ6rOgIOuLpOuluCDqsoPrk6TrgbzrpqzripQg67aE66as7ZW07IScICBqYXZhc2NyaXB0IO2MjOydvOydhCDsmqnrj4Trs4TroZwg6rWs67aE7ZW07IScIOyekeyEse2VmOuKlCDqsoPsnbQg6rCc67Cc7J6QIOyeheyepeyXkOyEnOuKlCDtjrjrpqztlanri4jri6QuIOyWtOywqO2UvCDrlLDroZwg66eM65Ok7Ja064+EIFdlYnBhY2vsnLzroZwgQnVpbGQoQnVuZGxpbmcp7J2EIO2VmOuptCAqKu2VmOuCmOydmCBKUyDtjIzsnbwqKuuhnCDrp4zrk6TslrQg7KO864uI6rmM7JqULlxcbjMuICoq7LWc7IugIOyekOuwlOyKpO2BrOumve2KuCDrrLjrspXsnYQg7KeA7JuQ7ZWY7KeAIOyViuuKlCDruIzrnbzsmrDsoIDsl5DshJwg7IKs7Jqp7ZWgIOyImCDsnojripQg7L2U65Oc66GcIOyJveqyjCDrs4DtmZjsi5zsvJwg7KSN64uI64ukLioqXFxuICAgIC0g67iM65287Jqw7KCA7J2YIOyiheulmOyXkCDrlLDrnbwsIOu4jOudvOyasOyggCDrsoTsoITsl5Ag65Sw65287IScIOy1nOyLoCBKYXZhc2NyaXB066y467KV7J2EIOyngOybkO2VmOyngCDslYrsnYQg7IiY64+EIOyeiOyKteuLiOuLpC4gV2VicGFja+ydhCDsgqzsmqntlbTshJwg67mM65Oc7ZWY66m0IOy1nOyLoCBKYXZhc2NyaXB0IOusuOuyleydhCDsgqzsmqntlZwg7L2U65Oc66W8IOydtOyghCDrsoTsoITsl5DshJzrj4Qg7Zi47ZmY7J20IOqwgOuKpe2VmOuPhOuhnSDrs4Dqsr3tlbTspI3ri4jri6QuXFxuNC4gKipKUyDrqqjrk4jtmZQg7J207IqIKipcXG4gICAgLSBKYXZhc2NyaXB066W8IOqwgeqwgSDrtojrn6zsmKTrj4TroZ0g7ZWY66m0IOu2iOufrOyYpOuKlCDsiJzshJzsl5Ag65Sw6528IOyYge2WpeydhCDrsJvripQg7J207IqILlxcbiAgICAtIOyKpOy9lO2UhOqwgCDqsJnsnYAg7JyE7LmY7JeQIOuPmeydvCDrs4DsiJjqsIAg7J6I7Jy866m0IOuzgOyImOqwgCDsm5DtlZjripQg64yA66GcIOyekeuPme2VmOyngCDslYrsirXri4jri6QuXFxuICAgIC0gQ29kZSBFeGFtcGxlXFxuICAgICAgXFxuICAgICAgICBgYGBodG1sXFxuICAgICAgICAjIGluZGV4Lmh0bWxcXG4gICAgICAgIDwhRE9DVFlQRSBodG1sPlxcbiAgICAgICAgPGh0bWwgbGFuZz1cXFwiZW5cXFwiPlxcbiAgICAgICAgPGhlYWQ+XFxuICAgICAgICAgIDxtZXRhIGNoYXJzZXQ9XFxcIlVURi04XFxcIj5cXG4gICAgICAgICAgPG1ldGEgaHR0cC1lcXVpdj1cXFwiWC1VQS1Db21wYXRpYmxlXFxcIiBjb250ZW50PVxcXCJJRT1lZGdlXFxcIj5cXG4gICAgICAgICAgPG1ldGEgbmFtZT1cXFwidmlld3BvcnRcXFwiIGNvbnRlbnQ9XFxcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcXFwiPlxcbiAgICAgICAgICA8dGl0bGU+RG9jdW1lbnQ8L3RpdGxlPlxcbiAgICAgICAgPC9oZWFkPlxcbiAgICAgICAgPGJvZHk+XFxuICAgICAgICAgIDxoMSBpZD1cXFwidGl0bGVcXFwiPkhlbGxvIHdvcmxkITwvaDE+XFxuICAgICAgICBcXG4gICAgICAgICAgPHNjcmlwdCBzcmM9XFxcIi4vanMvQS5qc1xcXCI+PC9zY3JpcHQ+XFxuICAgICAgICAgIDxzY3JpcHQgc3JjPVxcXCIuL2pzL0IuanNcXFwiPjwvc2NyaXB0PlxcbiAgICAgICAgICA8c2NyaXB0IHNyYz1cXFwiLi9qcy9DLmpzXFxcIj48L3NjcmlwdD5cXG4gICAgICAgICAgICBcXG4gICAgICAgIDwvYm9keT5cXG4gICAgICAgIDwvaHRtbD5cXG4gICAgICAgIGBgYFxcbiAgICAgICAgXFxuICAgICAgICBgYGBqc3hcXG4gICAgICAgIC8vIEEuanNcXG4gICAgICAgIGNvbnN0IHRleHQgPSBcXFwiQUFBQUFcXFwiO1xcbiAgICAgICAgbGV0IHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcXCJ0aXRsZVxcXCIpXFxuICAgICAgICB0YXJnZXQuaW5uZXJUZXh0ID0gdGV4dFxcbiAgICAgICAgYGBgXFxuICAgICAgICBcXG4gICAgICAgIGBgYGpzeFxcbiAgICAgICAgLy8gQi5qc1xcbiAgICAgICAgY29uc3QgdGV4dCA9IFxcXCJCQkJCQlxcXCI7XFxuICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXFxcInRpdGxlXFxcIilcXG4gICAgICAgIHRhcmdldC5pbm5lclRleHQgPSB0ZXh0XFxuICAgICAgICBgYGBcXG4gICAgICAgIFxcbiAgICAgICAgYGBganN4XFxuICAgICAgICAvLyBDLmpzXFxuICAgICAgICBjb25zdCB0ZXh0ID0gXFxcIkNDQ0NDXFxcIjtcXG4gICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwidGl0bGVcXFwiKVxcbiAgICAgICAgdGFyZ2V0LmlubmVyVGV4dCA9IHRleHRcXG4gICAgICAgIGBgYFxcbiAgICAgICAgXFxuICAgICAgICAtIOydtCDqsr3smrAgSDHtg5zqt7jsl5DripQg7Ja065akIO2FjeyKpO2KuOqwgCDrk6TslrTqsIjquYzsmpQ/XFxuICAgICAgICAgICAgLSDsoJXri7VcXG4gICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBBQUFBQVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC0g7J207JygXFxuICAgICAgICAgICAgICAtIEEvQi9DIOuqqOuRkCDquIDroZzrsowg7JiB7Jet7JeQ7IScIHRleHQg67OA7IiY66W8IGNvbnN0IOuhnCDsp4DsoJXtlZjqs6Ag7J6I7Iq164uI64ukLiDrj5nsnbwg7JiB7Jet7JeQ7IScIGNvbnN066Gc7J2YIOuzgOyImCDshKDslrjsnYAg6rCA7J6lIOuovOyggCDrtojrprAgQS5qc+ydmCBgY29uc3QgdGV4dCA9IFxcXCJBQUFBQVxcXCJg6rCAIOyEoOyWuOuQqeuLiOuLpC5cXG5cXG4jIyAyLiDsm7ntjKnsnZgg6rWs7ISxXFxuXFxuIyMjICoqMi4xLiBlbnRyeSoqIOKeoe+4j1xcblxcbj4gZW50cnkg7IaN7ISx7J2AIOybue2MqeyXkOyEnCDsm7kg7J6Q7JuQ7J2EIOuzgO2ZmO2VmOuKlCDrjbAg7ZWE7JqU7ZWcIOynhOyeheygkOydtOyekCDsnpDrsJTsiqTtgazrpr3tirgg7YyM7J28IOqyveuhnOyeheuLiOuLpC5cXG4+IFxcblxcbmVudHJ5IOyGjeyEseyXkOyEnCDrsojrk6Trp4HtlZjqs6Ag7Iu27J2AIO2MjOydvOuTpOydhCDshKDslrjtlanri4jri6QuXFxuXFxu7Ju57Yyp7J2AIOyXlO2KuOumrOulvCDthrXtlbTshJwg7ZWE7JqU7ZWcIOuqqOuTiOuTpOydhCDroZzrlKntlZjqs6AsIO2VmOuCmOydmCDtjIzsnbzroZwg66y264qUIOqzvOygleydhCDsp4Ttlontlanri4jri6QuXFxuXFxuIyMjICoqMi4yLiBvdXRwdXQg8J+OryoqXFxuXFxuPiBvdXRwdXQg7IaN7ISx7J2AIOybue2MqeydhCDrj4zrpqzqs6Ag64KcIOqysOqzvOusvOydmCDtjIzsnbwg6rK966Gc66W8IOydmOuvuO2VqeuLiOuLpC5cXG4+IFxcblxcbuuyiOuTpOuQnCDqsrDqs7zrrLzsnYQg7LKY66as7ZWgIOychOy5mOulvCBvdXRwdXTsl5Ag6riw66Gd7ZWp64uI64ukLlxcblxcbiMjIyAqKjIuMy4gbG9hZGVyIPCfmqkqKlxcblxcbj4g7Ju57Yyp7J20IOybuSDslaDtlIzrpqzsvIDsnbTshZjsnYQg7ZW07ISd7ZWgIOuVjCBKUyDtjIzsnbzsnbQg7JWE64uMIEhUTUwsIENTUywgSU1HLCDtj7Dtirgg65Ox7J2EIOuzgO2ZmO2VoCDsiJgg7J6I64+E66GdIOuPhOyZgOyjvOuKlCDsho3shLHsnoXri4jri6QuXFxuPiBcXG5cXG7sm7ntjKnsnYAg66qo65OgIO2MjOydvOydhCDrqqjrk4jroZwg6rSA66as7ZWY7KeA66eMIEpTIOunjCDslYzqs6Ag7J6I7Ja07IScICoq64uk66W4IO2MjOydvOuTpOydhCDsm7ntjKnsnbQg7J207ZW07ZWgIOyImCDsnojrj4TroZ0g67OA6rK97ZW07KO864qUIOqyg+ydtCDroZzrjZTsnZgg7Jet7ZWgKirsnoXri4jri6QuXFxuXFxuIyMjICoqMi40LiBwbHVnaW4g8J+UlyoqXFxuXFxuPiDsm7ntjKnsnZgg6riw67O47KCB7J24IOuPmeyekeyXkCDstpTqsIDsoIHsnbgg6riw64ql7J2EIOygnOqzte2VmOuKlCDsho3shLHsnoXri4jri6QuXFxuPiBcXG5cXG7roZzrjZTrnpEg67mE6rWQ7ZWY66m0ICoq66Gc642U64qUIO2MjOydvOydhCDtlbTshJ3tlZjqs6Ag67OA7ZmY7ZWY64qUIOqzvOygleyXkCDtlbTri7kqKu2VmOqzoCAqKu2UjOufrOq3uOyduOydgCDtlbTri7kg6rKw6rO866y87J2YIO2Yle2DnOulvCDrsJTqvrjripQg6rO87KCV7JeQIO2VtOuLuSoq7ZWp64uI64ukLlxcblxcbiMjIDMuIFdlYnBhY2sg7Iuk7Iq17Jy866GcIOyVjOyVhOuztOq4sFxcblxcbmBgYGJhc2hcXG4kIG5wbSBpIHdlYnBhY2sgd2VicGFjay1jbGkgLS1zYXZlLWRldlxcbmBgYFxcblxcblvwn5KhZ2l0aHViIOuwlOuhnOqwgOq4sF0oaHR0cHM6Ly9naXRodWIuY29tL2xpa2VsaW9uU3VuZ0d1ay93ZWJwYWNrL3RyZWUvMmFhNTZmYmY0ZjAxNjZmNTA4MmMyZDQzZDllNmEzYTE4MTQwNGU1NSlcXG5cXG4jIyMgMy4xIGB3ZWJwYWNrLmNvbmZpZy5qc2Ag7YyM7J28IOyngeygkSDsnpHshLFcXG5cXG5gYGBqc3hcXG4vLyB3ZWJwYWNrLmNvbmZpZy5qc1xcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBtb2RlOiAnZGV2ZWxvcG1lbnQnLFxcblxcbiAgZW50cnk6IHtcXG4gICAgbWFpbjogJy4vanMvQS5qcycsXFxuICB9LFxcblxcbiAgb3V0cHV0OiB7XFxuICAgIGZpbGVuYW1lOiAnW25hbWVdLmpzJywgIC8vIGVudHJ57J2YIOydtOumhOydhCDrnLvtlanri4jri6QuICjsl6zquLDshJzripQgbWFpbilcXG4gICAgcGF0aDogcGF0aC5yZXNvbHZlKCcuL2Rpc3QnKSwgLy8gLnJlc29sdmUg66W8IOydtOyaqe2VtOyEnCDsoIjrjIAg6rK966Gc66W8IOyekeyEsSAoT1MpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8g6riw67O47KCB7Jy866GcIGRpc3TroZwg7ISk7KCV65CY7Ja07J6I7Jy864KYIOybueyXkOyEnOuKlCBwdWJsaWPsnLzroZwg66eO7J20IO2VqFxcbiAgfSxcXG59O1xcbmBgYFxcblxcbi0gbW9kZTogIGAncHJvZHVjdGlvbicgfCAnZGV2ZWxvcG1lbnQnIHwgJ25vbmUnYCDspJEg7ZWY64KY66W8IOyEoO2DnS5cXG4gICAgLSBwcm9kdWN0aW9uXFxuICAgICAgICAtIERlZmluZVBsdWdpbiDsnZggcHJvY2Vzcy5lbnYuTk9ERV9FTlYg66W8IHByb2R1Y3Rpb24g7Jy866GcIOyEpOygle2VqeuLiOuLpC5cXG4gICAgICAgIC0gYOy1nOygge2ZlOulvCDqsIDsnqUg7KSR7KCQ7KCBYOycvOuhnCDrkZDqs6Ag67mM65Oc7ZWY64qUIOyGjeyEsVxcbiAgICAgICAgICAtIHByb2R1Y3Rpb24g66qo65Oc7JeQ7ISc64qUIOy9lOuTnOqwgCDqsIDsnqUg7Ken6rOgIOqwhOqysO2VmOqyjCDruYzrk5zrkKnri4jri6QuXFxuICAgIC0gZGV2ZWxvcG1lbnRcXG4gICAgICAgIC0gRGVmaW5lUGx1Z2luIOydmCBwcm9jZXNzLmVudi5OT0RFX0VOViDrpbwgZGV2ZWxvcG1lbnQg66GcIOyEpOygle2VqeuLiOuLpC5cXG4gICAgICAgIC0gYOu5oOuluCDruYzrk5xg66W8IOykkeyLrOycvOuhnCDrkZDqs6Ag67mM65Oc7ZWY64qUIOyGjeyEsVxcbiAgICAgICAgICAtIGRldmVsb3BtZW50IOuqqOuTnOyXkOyEnCDsi6TsoJzroZwg67mM65Oc66W8IO2VtOuztOuptCDsiJgg66eO7J2AIOyjvOyEneydtCDtlajqu5gg7J6R7ISx65Cp64uI64ukLlxcbiAgICAgICAgICAtIOqwnOuwnOyekOqwgCDqsJzrsJztlZjrqbTshJwg7KeE7ZaJ7IOB7Zmp7J2EIOy1nOuMgO2VnCDslYzslYTrs7wg7IiYIOyeiOuPhOuhnSDsp4Dsm5Dtlanri4jri6QuXFxuICAgIC0gbm9uZVxcbiAgICAgICAgLSDquLDrs7gg7LWc7KCB7ZmUIOyYteyFmOycvOuhnCDshKTsoJXtlanri4jri6QuXFxuICAgIFxcbi0gZW50cnk6IOyXlO2KuOumrOuKlCDslaDtlIzrpqzsvIDsnbTshZgg67KI65Ok66eB7J2EIOyLnOyeke2VoCDsp4DsoJDsnYQg7J2Y66+47ZWp64uI64ukLiDspoksIOyWtOuWpCDtjIzsnbzrk6TsnYQgYnVuZGxpbmftlaAg6rKD7J246rCA7JeQIOuMgO2VnCDqsr3roZzsnoXri4jri6QuXFxuICBcXG4gICAgZW50cnnsnZgg7J2066aE7J20IG1haW7snbTqs6AsIOydtCBtYWlu7J2AIGAuL2pzL0EuanNgIOyeheuLiOuLpC4g7KaJLCBidWlsZOulvCDtlZjrqbQgZGlzdCDtj7TrjZQg7JWE656Y7JeQIG1haW7snbTrnbzripQg7J2066aE7Jy866GcIEEuanPqsIAgYnVuZGxpbmfrkKnri4jri6QuXFxuICAgIFxcbiAgICAtIFNQQeyZgCBNUEEgRW50cnnssKjsnbRcXG4gICAgICBcXG4gICAgICAgIGBgYFxcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgICAgICAgIC8vIFNQQVxcbiAgICAgICAgICBlbnRyeTogJy4vaW5kZXguanMnXFxuICAgICAgICBcXG4gICAgICAgICAgLy8gTVBBXFxuICAgICAgICAgIGVudHJ5OiB7XFxuICAgICAgICAgICAgbWFpbjogJy4vbWFpbi5qcycsXFxuICAgICAgICAgICAgY29udGFjdDogJy4vY29udGFjdC5qcydcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYGBgXFxuICAgICAgICBcXG5cXG7wn5KhW+ybue2MqeycvOuhnCDrsojrk6Trp4Eg7ZaI7J2EIOuVjOyZgCDslYjtlojsnYQg65WM7J2YIOywqOydtF0oaHR0cHM6Ly9naXRodWIuY29tL2xpa2VsaW9uU3VuZ0d1ay93ZWJwYWNrL3RyZWUvNjU0ZWZiMDM0ZTAyMWNkNGQ0NWNjM2Q3MzY4MTA4MjQ2NzNjOWQ2ZClcXG5cXG5gYGBodG1sXFxuIyBCdW5kbGluZyDsoIQgaW5kZXguaHRtbFxcbjwhRE9DVFlQRSBodG1sPlxcbjxodG1sIGxhbmc9XFxcImVuXFxcIj5cXG48aGVhZD5cXG4gIDxtZXRhIGNoYXJzZXQ9XFxcIlVURi04XFxcIj5cXG4gIDxtZXRhIGh0dHAtZXF1aXY9XFxcIlgtVUEtQ29tcGF0aWJsZVxcXCIgY29udGVudD1cXFwiSUU9ZWRnZVxcXCI+XFxuICA8bWV0YSBuYW1lPVxcXCJ2aWV3cG9ydFxcXCIgY29udGVudD1cXFwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFxcXCI+XFxuICA8dGl0bGU+RG9jdW1lbnQ8L3RpdGxlPlxcbjwvaGVhZD5cXG48Ym9keT5cXG4gIDxoMSBpZD1cXFwidGl0bGVcXFwiPkhlbGxvIHdvcmxkITwvaDE+XFxuICA8aDMgaWQ9XFxcIkJcXFwiPjwvaDM+XFxuICA8aDMgaWQ9XFxcIkNcXFwiPjwvaDM+XFxuXFxuICA8c2NyaXB0IHNyYz1cXFwiLi9qcy9BLmpzXFxcIj48L3NjcmlwdD5cXG4gICAgXFxuPC9ib2R5PlxcbjwvaHRtbD5cXG5gYGBcXG5cXG4tIOuPjOuwnFFVSVo6IOyYiOyDgeuQmOuKlCDtmZTrqbTsnYA/XFxuICBcXG4gICAgIVvsmpTqsoPsnbTsm7ntjKnsnbTri6RdKC9hc3NldHMvaW1nL+yalOqyg+ydtOybue2MqeydtOuLpCUyMDIucG5nKVxcbiAgICBcXG5cXG5gYGBodG1sXFxuIyBCdW5kbGluZyDtm4RcXG48IURPQ1RZUEUgaHRtbD5cXG48aHRtbCBsYW5nPVxcXCJlblxcXCI+XFxuPGhlYWQ+XFxuICA8bWV0YSBjaGFyc2V0PVxcXCJVVEYtOFxcXCI+XFxuICA8bWV0YSBodHRwLWVxdWl2PVxcXCJYLVVBLUNvbXBhdGlibGVcXFwiIGNvbnRlbnQ9XFxcIklFPWVkZ2VcXFwiPlxcbiAgPG1ldGEgbmFtZT1cXFwidmlld3BvcnRcXFwiIGNvbnRlbnQ9XFxcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcXFwiPlxcbiAgPHRpdGxlPkRvY3VtZW50PC90aXRsZT5cXG48L2hlYWQ+XFxuPGJvZHk+XFxuICA8aDEgaWQ9XFxcInRpdGxlXFxcIj5IZWxsbyB3b3JsZCE8L2gxPlxcbiAgPGgzIGlkPVxcXCJCXFxcIj48L2gzPlxcbiAgPGgzIGlkPVxcXCJDXFxcIj48L2gzPlxcblxcbiAgPHNjcmlwdCBzcmM9XFxcIi4vbWFpbi5qc1xcXCI+PC9zY3JpcHQ+XFxuICAgIFxcbjwvYm9keT5cXG48L2h0bWw+XFxuYGBgXFxuXFxuLSDrj4zrsJxRVUlaOiDsmIjsg4HrkJjripQg7ZmU66m07J2AP1xcbiAgXFxuICAgICFb7JqU6rKD7J207Ju57Yyp7J2064ukXSgvYXNzZXRzL2ltZy/smpTqsoPsnbTsm7ntjKnsnbTri6QlMjAzLnBuZylcXG4gICAgXFxuXFxu4oeSIOuyiOuTpOungeydhCDtlZjrqbQgSW1wb3J066GcIOyXsOqysOuQmOyWtOyeiOuKlCBKYXZhc2NyaXB0IO2MjOydvOuTpOydhCDrqqjrkZAg7ZWY64KYKGBtYWluLmpzYCnroZwg66qo7JWE7KO86riwIOuVjOusuOyXkCBCLmpz7JmAIEMuanPsl5Ag7J6I64qUIEJCQuyZgCBDQ0PqsIAg66qo65GQIO2ZlOuptOyXkCDrgpjsmLXri4jri6QuXFxuXFxuIVvsmpTqsoPsnbTsm7ntjKnsnbTri6RdKC9hc3NldHMvaW1nL+yalOqyg+ydtOybue2MqeydtOuLpCUyMDQucG5nKVxcblxcbiMjIyAzLjIgbG9hZGVyICYgcGx1Z2luXFxuXFxu7JyE7JeQ7IScIOyWuOq4ie2WiOuTr+ydtCDroZzrjZTripQg7J6Q67CU7Iqk7YGs66a97Yq46rCAIOyVhOuLjCDtjIzsnbzrk6TsnYQg67KI65Ok66eB7ZW07KO864qUIOq4sOuKpeydhCDtlanri4jri6QuXFxuXFxu64yA7ZGc7KCB7J24IOqyg+ydtCBodG1sLCBjc3MsIGltZ+2MjOydvCDrk7HsnbQg7J6I7KOgLlxcblxcbuuhnOuNlOuKlCDslYTrnpjsmYAg6rCZ7J2AIOq3nOy5meycvOuhnCDsnpHshLHrkKnri4jri6QuXFxuXFxuW/CfkqHsu6TsiqTthYAg66Gc642UIOy9lOuTnCDrsJTroZzqsIDquLBdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWtlbGlvblN1bmdHdWsvd2VicGFjay90cmVlL2M1MjJiN2I1MjAxMDM0ODg1MjhiMWJlZGJmMGU4MzllZTFiZDFiODApXFxuXFxuYGBganN4XFxubW9kdWxlIDoge1xcblxcdHJ1bGVzOiB7XFxuXFx0XFx0dGVzdDogJ+qwgOyngOqzoOyYrCDtjIzsnbwg7ZiV7IudIOygleq3nOyLnScsXFxuXFx0XFx0dXNlOiBbXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdGxvYWRlcjogJ+yCrOyaqe2VoCDroZzrjZQg7J2066aEJyxcXG5cXHRcXHRcXHRcXHRvcHRpb25zOiB7IOyCrOyaqe2VoCDroZzrjZQg7Ji17IWYIH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XVxcblxcdH1cXG59XFxuYGBgXFxuXFxu7Luk7Iqk7YWAIOuhnOuNlOulvCDtlZjrgpgg66eM65Ok7Ja0IOuztOqyoOyKteuLiOuLpC5cXG5cXG5gYGBqc3hcXG4vLyBjdXN0b21Mb2FkZXIuanNcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGN1c3RvbUxvYWRlcihjb250ZW50KSB7XFxuICBjb25zb2xlLmxvZyhcXFwiY3VzdG9tTG9hZGVyIOuPmeyekSFcXFwiKVxcbiAgcmV0dXJuIGNvbnRlbnRcXG59XFxuYGBgXFxuXFxu64uo7Iic7Z6IIOuhnOq3uOulvCDssI3snYAg65KkIGNvbnRlbnTrpbwg6re464yA66GcIOuwmO2ZmO2VmOuKlCDqsITri6jtlZwg66Gc642U7J6F64uI64ukLlxcblxcbmBgYGpzeFxcbi8vIHdlYnBhY2suY29uZmlnLmpzXFxubW9kdWxlOiB7XFxuICBydWxlczogW3tcXG4gICAgdGVzdDogL1xcXFwuanMkLywgLy8gLmpzIO2ZleyepeyekOuhnCDrgZ3rgpjripQg66qo65OgIO2MjOydvFxcbiAgICB1c2U6IFtwYXRoLnJlc29sdmUoJy4vY3VzdG9tTG9hZGVyLmpzJyldIC8vIOuwqeq4iCDrp4zrk6Ag66Gc642U66W8IOyggeyaqe2VnOuLpFxcbiAgfV1cXG59XFxuYGBgXFxuXFxuanProZwg64Gd64KY64qUIOuqqOuToCDtmZXsnqXsnpDripQg7J20IOuhnOuNlOulvCDtlZwg67KI7JSpIOuPjOumrOuPhOuhnSDtlZjripQg7ISk7KCV7J6F64uI64ukLlxcblxcbi0g64+M67CcIFFVSVo6IGJ1aWxk66W8ICDrlYwg4oCcY3VzdG9tTG9hZGVyIOuPmeyekSHigJ3snbTrnbzripQg66Gc6re464qUIOuqhyDrsogg64KY7Jis6rmM7JqUP1xcbiAgXFxuICAgICFb7JqU6rKD7J207Ju57Yyp7J2064ukXSgvYXNzZXRzL2ltZy/smpTqsoPsnbTsm7ntjKnsnbTri6QlMjA1LnBuZylcXG4gICAgXFxuXFxu7JWe7IScIOyWuOq4ie2WiOuTr+ydtCDroZzrjZTripQg7KO866GcIEphdmFzY3JpcHTqsIAg7JWE64uMIO2MjOydvOuTpOydhCDsnITtlbQg66eM65Ok7Ja07KC47J6I64qU642wIOyYiOyLnOulvCDsnpDrsJTsiqTtgazrpr3tirjroZwg66eM65Ok7Ja0IOuyhOuguOuEpOyalC4g7J6Q7KO87JOw7J2064qUIExvYWRlcuuTpOydhCDsgrTtjrTrs7TrqbAg7Iuk7KCc66Gc64qUIOyWtOuWu+qyjCDtmZzsmqnrkJjripTsp4Ag7JWM7JWE67O06rKg7Iq164uI64ukLlxcblxcbiMjIDQuIOyekOyjvOyTsOydtOuKlCBMb2FkZXJcXG5cXG4jIyMgNC4xIGNzcy1sb2FkZXJcXG5cXG5b8J+SoWNzcy1sb2FkZXIg7L2U65OcIOuwlOuhnOqwgOq4sF0oaHR0cHM6Ly9naXRodWIuY29tL2xpa2VsaW9uU3VuZ0d1ay93ZWJwYWNrL3RyZWUvMjMxOTU3Mjk5OTk2YmFkNzkyYTc1MDYzOGU0ZjcyZDBjNDNhOWUzYilcXG5cXG5gYGBiYXNoXFxuJCBucG0gaW5zdGFsbCAtRCBjc3MtbG9hZGVyXFxuYGBgXFxuXFxuLSDrj4zrsJxRVUlaOiBgLURg64qUIOustOyKqCDrnLvsnbzquYzsmpQ/XFxuICBcXG4gICAgRCwgLS1zYXZlLWRldiAoUGFja2FnZSB3aWxsIGFwcGVhciBpbiB5b3VywqBgZGV2RGVwZW5kZW5jaWVzYClcXG4gICAgXFxuICAgIOqwnOuwnOydmOyhtOyEsSDrqqjrk5wuXFxuICAgIFxcbiAgICDqsJzrsJztlaAg65WM66eMIO2VhOyalO2VnCDtjKjtgqTsp4DqsIAg7J6I7Iq164uI64ukLiDsnbTrn7Ag6rK97Jqw7JeQ64qUIC1E66W8IOu2meyXrOyEnCDshKTsuZjtlZjrqbQgXFxuICAgIFxcbiAgICDrn7Dtg4DsnoTsl5Drj4Qg7ZWE7JqU7ZWcIO2MqO2CpOyngOqwgCDsnojsnYQg6rK97Jqw7JeQ64qUIC1E66W8IOyDneuete2VmOuptCDrkKnri4jri6QuXFxuICAgIFxcbiAgICBkZXbsl5DshJzrp4wg7ZWE7JqU7ZWY6rOgIHByb2Tsl5DshJzripQg7ZWE7JqU7ZWY7KeAIOyViuydgCDtjKjtgqTsp4DsnZgg6rK97JqwIOydtOugh+qyjCDshKTsuZjtlZjsl6wg7IKs7Jqp7ZWp64uI64ukLlxcbiAgICBcXG4gICAgLSBgbnBtIGluc3RhbGwge+2MqO2CpOyngH1gID09IGBucG0gaW5zdGFsbCAtLXNhdmUge+2MqO2CpOyngH1gXFxuICAgIC0gYG5wbSBpbnN0YWxsIC1EIHvtjKjtgqTsp4B9YCA9PSBgbnBtIGluc3RhbGwgLS1zYXZlLWRldiB77Yyo7YKk7KeAfWBcXG4gICAgXFxuICAgICFb7JqU6rKD7J207Ju57Yyp7J2064ukXSgvYXNzZXRzL2ltZy/smpTqsoPsnbTsm7ntjKnsnbTri6QlMjA2LnBuZylcXG4gICAgXFxuXFxu7ISk7LmY66W8IO2VmOqzoCBgd2VicGFjay5jb25maWcuanNgIOyXkCDroZzrjZQg7ISk7KCV7J2EIOy2lOqwgO2VtOykjeuLiOuLpC5cXG5cXG5gYGBqc3hcXG5tb2R1bGU6IHtcXG4gICAgcnVsZXM6IFtcXG4gICAgICB7XFxuICAgICAgICB0ZXN0OiAvXFxcXC5jc3MkLywgXFxuICAgICAgICB1c2U6IFtcXFwiY3NzLWxvYWRlclxcXCJdLCAvLyBjc3MtbG9hZGVy66W8IOyggeyaqe2VnOuLpFxcbiAgICAgIH0sXFxuICAgIF0sXFxuICB9XFxuYGBgXFxuXFxuYnVpbGTtm4QgbWFpbi5qc1xcblxcbiFb7JqU6rKD7J207Ju57Yyp7J2064ukXSgvYXNzZXRzL2ltZy/smpTqsoPsnbTsm7ntjKnsnbTri6QlMjA3LnBuZylcXG5cXG4tIGBzdHlsZS5jc3Ng7YyM7J287J20IOqwmeydtCDruYzrk5zrkJjslrTsnojripQg6rKD7J2EIO2ZleyduO2VoCDsiJgg7J6I7Iq164uI64ukLlxcblxcbuq3uOugh+uLpOuptCDrsLDqsr3snbQg7LSI66Gd7IOJ7Jy866GcIOuzgOqyveuQmOyXiOydhOq5jOyalD9cXG5cXG4hW+yalOqyg+ydtOybue2MqeydtOuLpF0oL2Fzc2V0cy9pbWcv7JqU6rKD7J207Ju57Yyp7J2064ukJTIwOC5wbmcpXFxuXFxuTk8uID8/P1xcblxcbnN0eWxlLWxvYWRlcuyXkOyEnCDslYzslYTrtIXsi5zri6QuXFxuXFxuIyMjIDQuMiAqKnN0eWxlLWxvYWRlcioqXFxuXFxuW/CfkqFzdHlsZS1sb2FkZXLsvZTrk5wg67CU66Gc6rCA6riwXShodHRwczovL2dpdGh1Yi5jb20vbGlrZWxpb25TdW5nR3VrL3dlYnBhY2svdHJlZS8wNjIwOWI4OTZhZjI3YTEyOGNjZDBhMDUwMTJiM2JkYjNlMWYxZmUzKVxcblxcbuuqqOuTiOuhnCDrs4Dqsr3rkJwg7Iqk7YOA7J28IOyLnO2KuOuKlCDrj5Tsl5Ag7LaU6rCA65CY7Ja07JW866eMIOu4jOudvOyasOyggOqwgCDtlbTshJ3tlaAg7IiYIOyeiOyKteuLiOuLpC4gYGNzcy1sb2FkZXJg66GcIOyymOumrO2VmOuptCBDU1PqsIAg7J6Q67CU7Iqk7YGs66a97Yq4IOy9lOuTnOuhnCDrs4Dqsr3rp4wg65CY7JeI7J2EIOu/kCDrj5Tsl5Ag7KCB7Jqp65CY7KeA64qUIOyViuydgCDsg4HtmansnbTri6QuIOuVjOusuOyXkCDsiqTtg4DsnbzsnbQg7KCB7Jqp65CY7KeAIOyViuydgCDqsoPsnoXri4jri6QuXFxuXFxuc3R5bGUtbG9hZGVy64qUIGphdmFzY3JpcHTroZwg67OA6rK965CcIOyKpO2DgOydvOydhCDrj5Tsl5Ag7LaU6rCA7ZWY64qUIOuhnOuNlOyeheuLiOuLpC5cXG5cXG7inZXqt7jrn6zrr4DroZwgY3NzLWxvYWRlcuyZgCBzdHlsZS1sb2FkZXLripQg64yA67aA67aEIO2VqOq7mCDsgqzsmqnrkKnri4jri6QuXFxuXFxuYGBgYmFzaFxcbiQgbnBtIGluc3RhbGwgLUQgY3NzLWxvYWRlclxcbmBgYFxcblxcbuyEpOy5mCDtm4Qgd2VicGFjay5jb25maWcuanMg7LaU6rCAXFxuXFxuYGBganN4XFxubW9kdWxlOiB7XFxuICBydWxlczogW1xcbiAgICB7XFxuICAgICAgdGVzdDogL1xcXFwuY3NzJC8sIC8vIC5jc3Mg7ZmV7J6l7J6Q66GcIOuBneuCmOuKlCDrqqjrk6Ag7YyM7J28XFxuICAgICAgdXNlOiBbXFxcInN0eWxlLWxvYWRlclxcXCIsIFxcXCJjc3MtbG9hZGVyXFxcIl0sIC8vIHN0eWxlLWxvYWRlcuulvCDslZ7sl5Ag7LaU6rCA7ZWc64ukXFxuICAgIH0sXFxuICBdLFxcbn1cXG5gYGBcXG5cXG7tirnsnbTtlZwg7KCQ7J2AIOuSpOyXkCDshKTsuZjrkJwgc3R5bGUtbG9hZGVy66W8IHVzZSDrsLDsl7TsnZgg7JWe7Kq97JeQIOyggeyXiOuLpOuKlCDsoJDsnoXri4jri6QuIOydtCDrsLDsl7TsnYAg65Kk7JeQ7IScIOu2gO2EsCDsnb3slrTrk6Tsl6wg66Gc642U66W8IOyLpO2Wie2VnOuLpOqzoCDtlanri4jri6QuIOuUsOudvOyEnCBjc3PrpbwganProZwg67CU6r6464qUIGNzcy1sb2FkZXLrqLzsoIAg7Iuk7ZaJ7ZWY6rOgIOq3uCDrkqTsl5Agc3R5bGUtbG9hZGVy66W8IOyLpO2Wie2VtOyVvCDtlZjrr4DroZwg7JyE7JmAIOqwmeydgCDsiJzshJzrjIDroZwg7J6R7ISx7ZW07KSY7JW8IO2VqeuLiOuLpC5cXG5cXG5gYGBqc3hcXG4kIG5wbSBydW4gYnVpbGRcXG5gYGBcXG5cXG4hW+uTnOuUlOyWtCDrqrvsg53quLQg7LSI66Gd7IOJIOuwsOqyvSDsiqTtg4DsnbwoYmFja2dyb3VuZDogZ3JlZW4p7J20IOyggeyaqeuQmOyXiOuEpOyalC5dKC9hc3NldHMvaW1nL+yalOqyg+ydtOybue2MqeydtOuLpCUyMDkucG5nKVxcblxcbuuTnOuUlOyWtCDrqrvsg53quLQg7LSI66Gd7IOJIOuwsOqyvSDsiqTtg4DsnbwoYmFja2dyb3VuZDogZ3JlZW4p7J20IOyggeyaqeuQmOyXiOuEpOyalC5cXG5cXG7snbQg7Jm47JeQIGZpbGUtbG9hZGVyLCB1cmwtbG9hZGVyLCBiYWJlbC1sb2FkZXLrk6TsnbQg7J6Q7KO8IOyCrOyaqeuQmOuKlCDroZzrjZTrnbzqs6Ag7ZWp64uI64ukLlxcblxcbiMjIDUuIO2UjOufrOq3uOyduFxcblxcbuuhnOuNlOqwgCDigJztjIzsnbzigJ0g64uo7JyE66GcIOyymOumrO2VnOuLpOuptCDtlIzrn6zqt7jsnbjsnYAg4oCc67KI65Ok65CcIOqysOqzvOusvOKAneydhCDsspjrpqztlanri4jri6QuXFxuXFxu7Yq57KeV7KCQ7J24IOqyg+ydgCDtlIzrn6zqt7jsnbgg67Cw7Je07JeQ64qUIOyDneyEseyekOulvCDsgqzsmqntlbTshJwg66eM65Ok7Ja07KSY7JW8IO2VnOuLpOuKlCDsoJDsnoXri4jri6QuXFxuXFxuYGBganN4XFxuLy8gd2VicGFjay5jb25maWcuanMgXFxudmFyIHdlYnBhY2sgPSByZXF1aXJlKCd3ZWJwYWNrJyk7IFxcbnZhciBIdG1sV2VicGFja1BsdWdpbiA9IHJlcXVpcmUoJ2h0bWwtd2VicGFjay1wbHVnaW4nKTsgXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBtb2RlIDogJycsIFxcblxcdGVudHJ5IDoge30sIFxcblxcdG91dHB1dCA6IHt9LCBcXG5cXHRtb2R1bGUgOiB7fSxcXG4gcGx1Z2lucyA6IFsgXFxuXFx0bmV3IEh0bWxXZWJwYWNrUGx1Z2luKCksIFxcblxcdG5ldyB3ZWJwYWNrLlByb2dyZXNzUGx1Z2luKCksIFxcblxcdG5ldyB3ZWJwYWNrLm9wdGltaXplLlVnbGlmeUpzUGx1Z2luKClcXG5cXHQgLy8gLi4uIF0gXFxufVxcblxcbmBgYFxcblxcblvwn5Kh7ZSM65+s6re47J24IOuwlOuhnOqwgOq4sF0oaHR0cHM6Ly9naXRodWIuY29tL2xpa2VsaW9uU3VuZ0d1ay93ZWJwYWNrL3RyZWUvNDdkZjg3MWU3Y2IzMTdlNDkwOTQ4NjI3YjljYzMxNjVhMjgyOWMyMylcXG5cXG7qsIDsnqUg7J207ZW07ZWY6riwIO2OuO2VnCBgSHRtbFdlYnBhY2tQbHVnaW5g7J2YIOyCrOyaqSDsgqzroYDrpbwg7IK07Y6067O06rKg7Iq164uI64ukLlxcblxcbmBgYGJhc2hcXG4kIG5wbSBpbnN0YWxsIC0tc2F2ZS1kZXYgaHRtbC13ZWJwYWNrLXBsdWdpblxcbmBgYFxcblxcbmBIdG1sV2VicGFja1BsdWdpbmAg7J2AIOuyiOuTpOungSDtlojsnYQg65WMIOy1nOyiheyggeycvOuhnCDsmYTshLHrkJwgSHRtbOydhCDqsJnsnbQgZXhwb3J07ZW07KO864qUIOq4sOuKpeydhCDsoJzqs7Xtlanri4jri6QuXFxuXFxu7ZSM65+s6re47J247J2AIOqwgeqwgeydmCDtlIzrn6zqt7jsnbjrs4TroZwg7IKs7Jqp67KV7J20IOunjuydtCDssKjsnbTqsIAg64Kc64uk6rOgIO2VqeuLiOuLpC4g65Sw65287IScIHdlYnBhY2sg6rO17IudIOyCrOydtO2KuOyXkOyEnCDsoJzqs7XtlbTso7zripQgR3VpZGXrpbwg65Sw6528IOqwgOupsCDsp4TtlontlaAg6rKD7J2EIOq2jOyepeuTnOumveuLiOuLpC5cXG5cXG5bSHRtbFdlYnBhY2tQbHVnaW4gfCB3ZWJwYWNrXShodHRwczovL3dlYnBhY2suanMub3JnL3BsdWdpbnMvaHRtbC13ZWJwYWNrLXBsdWdpbilcXG5cXG4hW+yalOqyg+ydtOybue2MqeydtOuLpF0oL2Fzc2V0cy9pbWcv7JqU6rKD7J207Ju57Yyp7J2064ukJTIwMTAucG5nKVxcblxcbuyDgeuLqOyXkCByZXF1aXJlLCDtlZjri6jsl5Ag7IOd7ISx7J6QIOyDneyEseydhCDsp4TtlontlbTspI3ri4jri6QuXFxuXFxuYGBganN4XFxuY29uc3QgSHRtbFdlYnBhY2tQbHVnaW4gPSByZXF1aXJlKCdodG1sLXdlYnBhY2stcGx1Z2luJyk7XFxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIG1vZGU6ICdkZXZlbG9wbWVudCcsXFxuXFxuICBlbnRyeToge1xcbiAgICBtYWluOiAnLi9zcmMvanMvQS5qcycsXFxuICB9LFxcbiAgb3V0cHV0OiB7XFxuICAgIGZpbGVuYW1lOiAnW25hbWVdLmpzJyxcXG4gICAgcGF0aDogcGF0aC5yZXNvbHZlKCcuL2Rpc3QnKSxcXG4gIH0sXFxuICBtb2R1bGU6IHtcXG4gICAgcnVsZXM6IFtcXG4gICAgICB7XFxuICAgICAgICB0ZXN0OiAvXFxcXC5jc3MkLywgLy8gLmNzcyDtmZXsnqXsnpDroZwg64Gd64KY64qUIOuqqOuToCDtjIzsnbxcXG4gICAgICAgIHVzZTogW1xcXCJzdHlsZS1sb2FkZXJcXFwiLCBcXFwiY3NzLWxvYWRlclxcXCJdLCAvLyBzdHlsZS1sb2FkZXLrpbwg7JWe7JeQIOy2lOqwgO2VnOuLpFxcbiAgICAgIH0sXFxuICAgIF0sXFxuICB9LFxcbiAgcGx1Z2luczogW25ldyBIdG1sV2VicGFja1BsdWdpbigpXVxcbn07XFxuYGBgXFxuXFxu7J207ZuEIGBucG0gcnVuIGJ1aWxkYFxcblxcbmBgYGh0bWxcXG4vLyBpbmRleC5odG1sXFxuPCFET0NUWVBFIGh0bWw+XFxuPGh0bWw+XFxuICA8aGVhZD5cXG4gICAgPG1ldGEgY2hhcnNldD1cXFwidXRmLThcXFwiPlxcbiAgICA8dGl0bGU+V2VicGFjayBBcHA8L3RpdGxlPlxcbiAgPG1ldGEgbmFtZT1cXFwidmlld3BvcnRcXFwiIGNvbnRlbnQ9XFxcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXFxcIj48c2NyaXB0IGRlZmVyIHNyYz1cXFwibWFpbi5qc1xcXCI+PC9zY3JpcHQ+PC9oZWFkPlxcbiAgPGJvZHk+XFxuICA8L2JvZHk+XFxuPC9odG1sPlxcbmBgYFxcblxcbuq4sOyhtOyXkOuKlCDrlLDroZwg66eM65Ok7Ja07KSs642YIGluZGV4Lmh0bWwg7J207JeI7KeA66eMIOydtOuyiOyXkOuKlCDtlIzrn6zqt7jsnbjsnbQg7KeB7KCRIGluZGV4Lmh0bWzsnYQg7IOd7ISx7ZW07KO87JeI7Iq164uI64ukLiBpbmRleC5odG1s7J2EIOu4jOudvOyasOyggOuhnCDsl7TslrTrs7TqsqDsirXri4jri6QuXFxuXFxuIVvsmpTqsoPsnbTsm7ntjKnsnbTri6RdKC9hc3NldHMvaW1nL+yalOqyg+ydtOybue2MqeydtOuLpCUyMDExLnBuZylcXG5cXG7snbTsg4HtlZjqsozrj4Qg7Iqk7YOA7J287J2AIOq3uOuMgOuhnCDsoIHsmqnsnbQg65CY7JeI64qU642wLCDquLDsobQgaDHtg5zqt7gg65Ok7J20IOyCrOudvOyguCDsnojsirXri4jri6QuXFxuXFxu7Jqw66as6rCAIOybkO2VmOuKlCDqsoPsnYAg6riw67O4IGluZGV4Lmh0bWzsnYQg7YWc7ZSM66a/7Jy866GcIO2VtOyEnCDsg4jroa3qsowg67mM65Oc7ZW07KO864qUIOqyg+ydtOyXiOuKlOuNsCDqt7jroIfqsowg64+Z7J6R7ZWY7KeAIOyViuyVmOuEpOyalC5cXG5cXG7snbTqsoPsnYQg6rCA64ql7ZWY6rKMIO2VmOugpOuptCDthZztlIzrpr/snYQg7KeA7KCV7ZWY64qUIOyEpOygleydhCDstpTqsIDtlbTspJjslbwg7ZWp64uI64ukLlxcblxcbmB3ZWJwYWNrLmNvbmZpZy5qc2BcXG5cXG5gYGBqc3hcXG5wbHVnaW5zOiBbbmV3IEh0bWxXZWJwYWNrUGx1Z2luKHtcXG4gIHRlbXBsYXRlOiAnLi9pbmRleC5odG1sJywgLy8g7YWc7ZSM66a/7J20IOuQoCBodG1sIHBhdGjrpbwg7KeA7KCVXFxuICBmaWxlbmFtZTogJy4vb3V0cHV0Lmh0bWwnIC8vIOu5jOuTnOuQoCBodG1s7J2YIOydtOumhC9wYXRoIOyngOyglVxcbn1cXG5gYGBcXG5cXG7snZjrj4TsoIHsnLzroZwg7J2066aE7J2EIGBvdXRwdXQuaHRtbGAg66GcIOyngOyWtOu0pOyKteuLiOuLpC5cXG5cXG4hW+yalOqyg+ydtOybue2MqeydtOuLpF0oL2Fzc2V0cy9pbWcv7JqU6rKD7J207Ju57Yyp7J2064ukJTIwMTIucG5nKVxcblxcbmBvdXRwdXQuaHRtbGBcXG5cXG5gYGBqc3hcXG48IURPQ1RZUEUgaHRtbD5cXG48aHRtbCBsYW5nPVxcXCJlblxcXCI+XFxuPGhlYWQ+XFxuICA8bWV0YSBjaGFyc2V0PVxcXCJVVEYtOFxcXCI+XFxuICA8bWV0YSBodHRwLWVxdWl2PVxcXCJYLVVBLUNvbXBhdGlibGVcXFwiIGNvbnRlbnQ9XFxcIklFPWVkZ2VcXFwiPlxcbiAgPG1ldGEgbmFtZT1cXFwidmlld3BvcnRcXFwiIGNvbnRlbnQ9XFxcIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcXFwiPlxcbiAgPHRpdGxlPkRvY3VtZW50PC90aXRsZT5cXG48c2NyaXB0IGRlZmVyIHNyYz1cXFwibWFpbi5qc1xcXCI+PC9zY3JpcHQ+PC9oZWFkPlxcbjxib2R5PlxcbiAgPGgxIGlkPVxcXCJ0aXRsZVxcXCI+SGVsbG8gd29ybGQhPC9oMT5cXG4gIDxoMyBpZD1cXFwiQlxcXCI+PC9oMz5cXG4gIDxoMyBpZD1cXFwiQ1xcXCI+PC9oMz5cXG5cXG4gIDxzY3JpcHQgc3JjPVxcXCIuL2pzL0EuanNcXFwiPjwvc2NyaXB0PlxcbiAgICBcXG48L2JvZHk+XFxuPC9odG1sPlxcbmBgYFxcblxcbuyasOumrOqwgCDsm5DtlZjrjZgg64yA66GcIGluZGV4Lmh0bWwg7YWc7ZSM66a/7J2EIOq3uOuMgOuhnCDqsIDsoLjsmZTrhKTsmpQuXFxuXFxu4oCULUVOROKAlC1cXG5cXG4tLS1cXG5cXG7ssLjqs6DsnpDro4xcXG5cXG5bbnBtLWluc3RhbGwgfCBucG0gRG9jc10oaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9jbGkvdjgvY29tbWFuZHMvbnBtLWluc3RhbGwpXFxuXFxuW25wbSBpbnN0YWxsIChwbHVnaW4pIC0tc2F2ZeyZgCAtLXNhdmUtZGV2IOywqOydtOygkF0oaHR0cHM6Ly9pdGh1Yi50aXN0b3J5LmNvbS8xNjUpXFxuXFxuW+qwnOuwnChEZXZlbG9wbWVudCkg66qo65Oc64qUIOyWtOuWu+qyjCDsnpHrj5ntlaDquYw/XShodHRwczovL3VpLnRvYXN0LmNvbS93ZWVrbHktcGljay9rb18yMDE5MTIxMilcXG5cXG5b7ZSE66Gg7Yq47JeU65OcIOqwnOuwnO2ZmOqyveydmCDsnbTtlbQ6IOybue2MqSjquLDrs7gpXShodHRwczovL2plb25naHdhbi1raW0uZ2l0aHViLmlvL3Nlcmllcy8yMDE5LzEyLzEwL2Zyb250ZW5kLWRldi1lbnYtd2VicGFjay1iYXNpYy5odG1sIzUtJUVEJTk0JThDJUVCJTlGJUFDJUVBJUI3JUI4JUVDJTlEJUI4KVxcblxcbltXcml0aW5nIGEgUGx1Z2luIHwgd2VicGFja10oaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4vI2Jhc2ljLXBsdWdpbi1hcmNoaXRlY3R1cmUpXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIuuYkeuYke2VmOqyjCBBU1NFVFPqtIDrpqztlZjripQgRUlNQSDrnbzsnbTruIzrn6zrpqwg7LaU7LKc7ZWp64uI64ukIVxcXCJcXG5kYXRlOiBcXFwiMjAyMi4xMC4xMlxcXCJcXG50YWdzOlxcbi0g66as7JWh7Yq4XFxuLSDsnbTrr7jsp4BcXG4tIEVJTUFcXG4tIOudvOydtOu4jOufrOumrFxcbi0tLVxcblxcblxcblxcbiMjIDEuIEludHJvXFxuXFxu6rCc67Cc7J2EIO2VmOuLpOuztOuptCBwbmcsIHN2ZyDtjIzsnbwg65Ox7J2YIEFzc2V0c+uTpOydhCBpbXBvcnTtlbTsmYDshJwg7I2o7JW8IO2VmOuKlCDqsr3smrDqsIAg67mI67KI7ZWY6rKMIOuwnOyDne2VqeuLiOuLpC4g7J20IOqzvOygleydhCDrsJjrs7XtlZjri6Trs7TrqbQg7YGs6rKMIOuRkCDqsIDsp4Ag6reA7LCu7J2AIOyDge2ZqeydtCDrsJzsg53tlZjripTrjbAg7ZWY64KY64qUIGltcG9ydOusuOydtCDquLjslrTsp4Tri6TripQg6rKD7J206rOgIOuYkCDri6Trpbgg7ZWY64KY64qUIOuLpOyWke2VnCDqs7Psl5DshJwg7Zmc7Jqp65CY64qUIGFzc2V0c+ydgCBBLCBCLCBD4oCmIOuTsSBu6rCc7J2YIOyXrOufrCDtjIzsnbzsl5Ag6rG47LOQ7IScIOqzhOyGjSBpbXBvcnQg65CY6rOgIOyTsOyXrOyVvCDtlZzri6TripQg6rKD7J207KOgLiDqt7jrlYzrp4jri6Qg7ZW064u5IOyGjOyKpOydmCBwYXRo66W8IOyDgeuMgOqyveuhnOuhnCDqsIDsp4Dqs6Ag7Jik64qUIOqyg+uPhCDqvaTrgpgg6reA7LCu7J2AIOuwmOuzteyekeyXheyeheuLiOuLpC5cXG5cXG4jIyMgRUlNQSDrnbzsnbTruIzrn6zrpqwg7IaM6rCcXFxuXFxu7J2065+wIOu2iO2OuO2VnCDsoJDsnYQg6rCc7ISg7ZWgIOyImCDsnojrj4TroZ0g64+E7JmA7KO864qUIOyii+ydgCDrnbzsnbTruIzrn6zrpqzrpbwg7LC+7JWEIOqzteycoO2VqeuLiOuLpC5cXG5cXG5baHR0cHM6Ly9naXRodWIuY29tL0pvbmdoYWtzZW8vRWltYUpTXShodHRwczovL2dpdGh1Yi5jb20vSm9uZ2hha3Nlby9FaW1hSlMpXFxuXFxuRUlNQeudvOydtOu4jOufrOumrOuKlCDtlZjrgpjsnZgg65SU66CJ7Yag66asIOyViOyXkCDsnojripQgYXNzZXRz65Ok7J2EIFvsg4HsnIRkaXIgXyDtlZjsnIRkaXIgXyDsnbTrpoRd7Jy866GcIOq1rOu2hOyngOyWtCDsib3qsowgaW1wb3J07ZWY6rOgIOydtOumhOydhCDqsoDsg4ntlaAg7IiYIOyeiOuPhOuhnSDrp4zrk6TslrTso7zripQg65iR65iR7ZWcIOq4sOuKpeydhCDsoJzqs7Xtlanri4jri6QuXFxuXFxu7JiI66W865Ok7Ja0IGBpbWcvYWJjL2RlZi9za3kucG5nYCDrnbzripQg7J2066+47KeA6rCAIOyeiOycvOuptCBgQUJDX0RFRl9TS1lfUE5HYCDrnbzripQg7J2066aE7Jy866GcIO2VtOuLuSBwYXRo66W8IOu2iOufrOyYrCDsiJgg7J6I64+E66GdIOuPhOyZgOykjeuLiOuLpC5cXG5cXG5gYGBcXG4vLyBhc3NldHMuanNcXG5pbXBvcnQgQUJDX0RFRl9TS1lfUE5HIGZyb20gXFxcImltZy9hYmMvZGVmL3NreS5wbmdcXFwiO1xcblxcbmNvbnN0IEFTU0VUUyA9IHtcXG4gIEFCQ19ERUZfU0tZX1BOR1xcbn1cXG5leHBvcnQgZGVmYXVsdCBBU1NFVFNcXG5gYGBcXG5cXG7rmJAg7ZW064u5IOuUlOugie2GoOumrOulvCB3YXRjaO2VmOqzoCDsnojri6TqsIAg7IOI66Gc7Jq0IOumrOyGjOyKpOqwgCDrk6TslrTsmKTrqbQg6re4IOumrOyGjOyKpOyXkCDrjIDtlZwg7J2066aE6rO8IHBhdGjrj4Qg67CU66GcIOunjOuTpOyWtOyEnCBhc3NldHMuanPsl5Ag7LaU6rCA7ZW07KO87Ja0IOumrOyGjOyKpOulvCDstpTqsIDtlZwg65KkIOuYkCBhc3NldHMuanPsl5Ag7LaU6rCA7ZW07JW865CY64qUIOuyiOqxsOuhnOybgOydhCDsl4bslaDso7zsl4jsirXri4jri6QuXFxuXFxuZWltYeulvCDshKTsuZjtlZjqs6AgYGVpbWEgaW5pdGAg66qF66C57Ja066W8IOyeheugpe2VmOuptCDquLDrs7jsoIHsnLzroZwg7IOd6riw64qUIOqyg+ydtCBlaW1hLmpzb27snoXri4jri6QuXFxuXFxuYGBgdHN4XFxuLy8gZWltYS5qc29uXFxue1xcblxcdFxcXCJ0YXJnZXRcXFwiOlxcXCJlczZcXFwiLFxcblxcdFxcXCJoaWRlU2l6ZVxcXCI6ZmFsc2UsXFxuXFx0XFxcImxpbnRQYXRoXFxcIjpcXFwic3JjXFxcIixcXG5cXHRcXFwicGF0aHNcXFwiOlt7XFxcImFzc2V0c1xcXCI6XFxcInNyYy9pbWdcXFwiLFxcXCJvdXRcXFwiOlxcXCJzcmMvYXNzZXRzLmpzXFxcIixcXFwidk5hbWVcXFwiOlxcXCJBU1NFVFNcXFwifV1cXG59XFxuYGBgXFxuXFxuLSB0YXJnZXTsnYAgRUNNQVNDUklQVCDrrLjrspXsnYQg65y77ZWY66mwIGVzNuuhnCDtlaAg6rK97JqwIOydteyIme2VnCBpbXBvcnQgZnJvbSDsnLzroZwg67OA7ZmY7Iuc7LycIOykjeuLiOuLpC5cXG4tIOyXrOq4sOyEnCDspJHsmpTtlZjqsowg67SQ7JW87ZWgIOqyg+ydgCBwYXRoc+yduOuNsCwgcGF0aHPrgrTrtoDsnZggKiphc3NldHPsnYAg7YOA6rKfIOuUlOugie2GoOumrOydmCBwYXRoKirrpbwg64Sj7Ja07KO86rOgIG91dOydgCDslrTrlqQg7JyE7LmY7JeQIGFzc2V0c+ulvCBpbXBvcnTtlZjsl6wg7J2066aE6rO8IHBhdGjrpbwg67CY7ZmY7ZW07KO864qUIGpz7YyM7J287J2YIHBhdGjsmYAgbmFtZSwg7ZmV7J6l7J6Q6rmM7KeAIOyggeyWtOykjeuLiOuLpC4gdk5hbWXsnYAgZXhwb3J07ZWgIOuMgO2RnCDri4nrhKTsnoTsnbTrnbwg67O07Iuc66m0IOuQqeuLiOuLpC5cXG4tIOychOyZgCDqsJnsnbQg7ISk7KCV7ZWY66m0IGVpbWEuanNvbuydgCDrlJTroInthqDrpqwg7LWc7IOB64uoLCBhc3NldHMuanPrnbzripQg7J2066aE7J2YIO2MjOydvOydgCBzcmMg7JWE656YIOyDneq4sOqzoCDri4nrhKTsnoTsnYAgQVNTRVRT66GcIOyEpOygleuQqeuLiOuLpC5cXG4tIOydtCDshKTsoJXtjIzsnbzsnYQg7JmE66OM7ZWcIOuSpCBgZWltYSBzdGFydGAg66qF66C57Ja066W8IOyeheugpe2VmOuptCBhc3NldHMuanMg6rCAIOyDneq4sOuptOyEnCBBU1NFVFPsnZgg7J2066aE6rO8IHBhdGjqsIAg7IOd7ISx65Cp64uI64ukLlxcblxcbj4g8J+SoeyjvOydmDogZWltYeulvCDrpqzslaHtirgg7ZSE66Gc7KCd7Yq4IOuCtOu2gOyXkCDshKTsuZjtlZjrqbQgZWltYSDrqoXroLnslrTqsIAg7KCc64yA66GcIOuPmeyeke2VmOyngCDslYrsirXri4jri6QuIFxcbj4gbnBtIGkgZWltYSAtZyDrqoXroLnslrTroZwg6riA66Gc67KM66GcIOyEpOy5mO2VmOyLnOuptCBlaW1h7J2YIOuqheugueyWtOulvCDsi6TtlontlaAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG5cXG5cXG4jIyAyLiBTVkcg7YyM7J287J2EIFJlYWN0Q29tcG9uZW5066GcIOyCrOyaqe2VmOq4sFxcblxcbuq4sOyhtOyXkOuKlCBTVkcg7YyM7J287J2EIOumrOyVoe2KuCDsu7Ttj6zrhIztirjroZwg7IKs7Jqp7ZWY6riwIOychO2VtCDri6TsnYzqs7wg6rCZ7J2AIOusuOuyleydhCDtmZzsmqntlZjsmIDsirXri4jri6QuXFxuXFxuYGBgdHN4XFxuaW1wb3J0IHsgUmVhY3RDb21wb25lbnQgYXMgRmlsZVVwbG9hZCB9IGZyb20gJy4uL3NyYy9pbWcvaWNvbi9maWxlX3VwbG9hZC5zdmcnO1xcbmBgYFxcblxcbu2VmOyngOunjCDsg4jroa3qsowgRUlNQSDrnbzsnbTruIzrn6zrpqzrpbwg7JOw6rKMIOuQmOuptOyEnCBpbXBvcnQg7J6Q7LK066W8IFJlYWN0Q29tcG9uZW5066GcIO2VtOyYpOq4sOuKlCDslrTroKTsm6DsirXri4jri6QuIOydtOulvCDtlbTqsrDtlZjquLAg7JyE7ZW07IScIHN2Z+ydmCBBU1NFVFMgc3JjIOulvCDsoITri6ztlZjrqbQgUmVhY3RDb21wb25lbnTrpbwg66eM65Ok7Ja0IOyjvOuKlCDsu7Ttj6zrhIztirjrpbwg66eM65Ok7JeI7Iq164uI64ukLlxcblxcbmBgYHRzeFxcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcXG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcXG5cXG5pbnRlcmZhY2UgU3ZnQ29tcG9uZW50UHJvcHMge1xcbiAgc3JjOiBzdHJpbmc7XFxuICBjbGFzc05hbWU6IHN0cmluZztcXG4gIGRpc2FibGVkPzogYm9vbGVhbjtcXG59XFxuXFxuY29uc3QgU3ZnQ29tcG9uZW50ID0gKHByb3BzOiBTdmdDb21wb25lbnRQcm9wcykgPT4gPFN0eWxlZE9iamVjdCB0eXBlPVxcXCJpbWFnZS9zdmcreG1sXFxcIiBkYXRhPXtwcm9wcy5zcmN9IGNsYXNzTmFtZT17cHJvcHMuY2xhc3NOYW1lfSBkaXNhYmxlZD17cHJvcHMuZGlzYWJsZWR9IC8+O1xcblxcbmV4cG9ydCBkZWZhdWx0IFN2Z0NvbXBvbmVudDtcXG5cXG5pbnRlcmZhY2UgU3R5bGVkT2JqZWN0UHJvcHMge1xcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xcbn1cXG5cXG5jb25zdCBTdHlsZWRPYmplY3QgPSBzdHlsZWQub2JqZWN0PFN0eWxlZE9iamVjdFByb3BzPmBcXG4gIGZpbHRlcjogJHsocHJvcHMpID0+IChwcm9wcy5kaXNhYmxlZCA/IGBpbnZlcnQoNTAlKSBzZXBpYSgwJSkgc2F0dXJhdGUoNTAlKSBodWUtcm90YXRlKDBkZWcpIGJyaWdodG5lc3MoMTAwJSkgY29udHJhc3QoMTAwJSlgIDogYGApfTtcXG5gO1xcbmBgYFxcblxcbuyXrOq4sOyEnCDtirnsnbTtlZwg7KCQ7J2AIG9iamVjdOulvCDsjbzri6TripQg7KCQ7J24642w7JqULCBzdmfrpbwg7IKs7Jqp7ZWY64qUIOuLpOyWke2VnCDrsKnsi53snbQg7J6I7JeI7KeA66eMIHN2Z+ydmCDsg4nsg4HsnYQg7KCc7Ja07ZW07JW87ZaI642YIOyDge2ZqeyXkOyEnCBvYmplY3Qg7YOc6re46rCAIOq3uOuCmOuniCDsnKDsmqntlZjri6Tqs6Ag7Jes6rKo7KGM7Iq164uI64ukLlxcblxcblvsm7nsl5DshJwgU1ZHIOyCrOyaqe2VmOq4sF0oaHR0cHM6Ly9zdmdvbnRoZXdlYi5jb20va28vKVxcblxcblxcblxcbiMjIyAyLTEuIE9iamVjdO2DnOq3uCDsl5Drn6wg7ZW465Ok66eBXFxuXFxub2JqZWN07YOc6re466GcIGRpc2FibGVk6rCAIHByb3Bz66GcIOyZlOydhCDrlYwg7IOJ7IOBIOuzgOqyveq5jOyngCDsp4TtlontlaAg7IiYIOyeiOyWtOyEnCDsnbTsoJwg64ukIOuQmOyXiOq1rOuCmCDsg53qsIHtlZjqs6Ag7J6I7JeI7J2EIOuVjCDsmIjsg4HsuZgg66q77ZWcIOyDge2ZqeydtCDtlZjrgpgg7Y687LOQ7KGM7Iq164uI64ukLiDrp4jsmrDsiqQg7Luk7ISc66W8IOuztOuptCDslYTsnbTsvZgg67CU66GcIOychOyXkCDsnITsuZjtlojsnYQg65WM64qUIO2PrOyduO2EsCDsu6TshJzqsIAg7JWE64uMIOydvOuwmOy7pOyEnO2Yle2DnOuhnCDrgpjsmKTqs6Ag7YG066at64+EIOuQmOyngCDslYrsirXri4jri6QuIO2VtOuLuSDslYTsnbTsvZgg7JiB7Jet7J2EIOuyl+yWtOuCmOuptCDri6Tsi5wg7J2867CYIOuyhO2KvOqzvCDrj5nsnbztlZjqsowg64+Z7J6R7ZWY6rKMIOuQmOuKlCDqsoPsnbTso6AuXFxuXFxuPHZpZGVvIHNyYz1cXFwiL2Fzc2V0cy9pbWcvb2JqZWN07YOc6re47J207IqILm1wNFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGF1dG9wbGF5IGNvbnRyb2xzIGxvb3A+PC92aWRlbz5cXG5cXG7rsJTroZwgc3Zn6rCAIOyDgeychOydmCDrsoTtirwg7Lu07Y+s64SM7Yq47J2YIO2BtOumrSDsnbTrsqTtirjrpbwg66eJ6rOgIOyeiOyXiOyKteuLiOuLpC5cXG5cXG7rlLDrnbzshJwgY3Nz7JeQIGBwb2ludGVyLWV2ZW50czogbm9uZTtgIOydhCDstpTqsIDtlbTso7zqs6Ag64KY7ISc7JW8IOuTnOuUlOyWtCDsoJXsg4HsoIHsnLzroZwg64+Z7J6R7ZWgIOyImCDsnojqsowg65CY7JeI7Iq164uI64ukLlxcblxcbltIb3cgdG8gYmluZCBjbGljayBldmVudCB0byBvYmplY3QgdGFnP10oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU5MTY0MDMvaG93LXRvLWJpbmQtY2xpY2stZXZlbnQtdG8tb2JqZWN0LXRhZyM6fjp0ZXh0PTEuJTIwSXNzdWUlM0ElMjBFdmVudCUyMGhhbmRsaW5nKVxcblxcblxcblxcbiMjIyAyLTIuIOyVhOydtOy9mOuniOuLpCDsg4nsg4HsnbQg64uk66W4IOydtOyKiFxcblxcblN2Z0NvbXBvbmVudOuhnCDslYTsnbTsvZjsnYQg656Y7ZWR7ZW07IScIFJlYWN0Q29tcG9uZW507ZmUIO2VtOyjvOyWtOuPhCDrrLjsoJzqsIAg65CY64qUIOqyg+ydgCDsg4nsg4Eg7J207IqI7JiA7Iq164uI64ukLiDslYTsnbTsvZjsnZgg7IOJ7IOB7J20IOybkO2VmOuNmCDsg4nsnbQg6re464yA66GcIOuCmOyYpOyngCDslYrripQg7IOB7Zmp7J207JeI64qU642wIOybkOyduOydgCDtgazqsowg65GQIOqwgOyngOqwgCDsnojsl4jsirXri4jri6QuXFxuXFxuMS4gc3Zn64qUIOq4sOyhtCBjbGFzc+yXkCDshKDslrjrkJwgY3NzIOyYge2WpeydhCDrsJvsp4Ag7JWK64qU64ukLlxcbjIuIHN2ZyDtjIzsnbzrs4TroZwg6rCB6rCB7J2YIOyDieyDgeqwkuydtCDsobTsnqztlZjqs6Ag6re4IOqwkuydtCDri6TrpbTri6QuXFxuXFxuYGBgdHN4XFxuLy8gZXg6IGZpbGVfZG93bmxvYWQuc3ZnXFxuPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIGhlaWdodD1cXFwiMjRweFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiB3aWR0aD1cXFwiMjRweFxcXCIgZmlsbD1cXFwiIzAwMDAwMFxcXCI+IC4uLlxcblxcbi8vIGV4MjogaWMtY2FsLWFyZWEuc3ZnXFxuPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxNFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj4uLi5cXG5gYGBcXG5cXG7smIjrpbwg65Ok7Ja0IGZpbGVfZG93bmxvYWQuc3ZnIO2MjOydvOydgCDquLDrs7jsoIHsnLzroZwg6rKA7KCV7IOJIOyDieyDgeydtCBmaWxs66GcIOyggeyaqeuQmOyWtOyeiOqzoCDsnbTsmYDripQg64us66asIGljLWNhbC1hcmVhIO2MjOydvOydgCBmaWxsIOyDieyDgeydtCDrlLDroZwg7KeA7KCV65CY7Ja07J6I7KeAIOyViuuKlCDtirnshLHsnYQg6rCA7KeA6rOgIOyeiOyKteuLiOuLpC5cXG5cXG7rlLDrnbzshJwg6rCB6rCB7J2YIHN2Z+2MjOydvOyXkCDquLDrs7gg7IOJ7IOB6rCSICNDQ0Prpbwg64Sj7Ja07KO86rOgIO2VtOuLuSDqsJLsnbQg67OA7ZW07JW8IO2VmOuKlCDsg4Htmako7JiI66W8IOuTpOyWtCBkaXNhYmxlZCnsl5DshJzripQgZmlsdGVyIOyWtO2KuOumrOu3sO2KuOulvCDsgqzsmqntlZjsl6wg7IOJ7IOB6rCS7J2EIOuzgOqyve2VtOyjvOyXiOyKteuLiOuLpC5cXG5cXG48YXNpZGU+XFxu8J+SoSBTVkdSIOudvOydtOu4jOufrOumrOulvCDtmZzsmqntlZjrqbQgU1ZHIO2MjOydvOydhCBSZWFjdENvbXBvbmVudOuhnCDrs4Dqsr3tlZjsl6wg7IKs7Jqp7ZWgIOyImCDsnojqsowg65Cp64uI64ukLiDtlZjsp4Drp4wg6rCc7J247KCB7Jy866GcIEVJTUEg65287J2067iM65+s66as66W8IOyEpOy5mO2VnOuNsOuLpOqwgCBTVkdS6rmM7KeAIOuRkCDqsJzrpbwg7ISk7LmY7ZWY64qU6rKMIOyigCDqurzroKTsoYzqs6AsIOyigCDrjZQg7JuQ7ZaI642Y6rKD7J2AIOqwgeqwgeydmCBTVkftjIzsnbzsnbQgUmVhY3RDb21wb25lbnTqsIAg65CY64qUIOqyg+ydtCDslYTri4jrnbwgU1ZH7J2YIFBhdGjrp4zsnLzroZwg7Im96rKMIFJlYWN0Q29tcG9uZW5066W8IOunjOuTpOqzoCDsi7bslrTshJwg7J2067KI7JeQ64qUIOychOyZgCDqsJnsnbQg7J6R7JeF7ZWY7JiA7Iq164uI64ukLlxcbjwvYXNpZGU+XFxuYGBgamF2YXNjcmlwdFxcbjxpbWcgY2xhc3NOYW1lPVxcXCJsb2FkaW5nLWltZ1xcXCIgc3JjPXtBU1NFVFMuSUNPTl9MT0FESU5HX1BOR30gYWx0PVxcXCJsb2FkaW5nLWltZ1xcXCIgLz5cXG5gYGBcXG5cXG5cXG7snbTrn7Dsi53snLzroZwg6riw7KG0IHN2Z+ydmCDqsr3roZzrpbwg7LC+7JWE7IScIHNyY+yXkCDsp4HsoJEg64Sj64qUIOqyg+uztOuLpCB2c0NvZGXsmYAgRUlNQeydmCDrj4Tsm4DsnYQg67Cb7JWEIOuCtOqwgCDstpTqsIDtlZwgYXNzZXRz7J2YIOqyveuhnOyZgCDsnbTrpoTsnLzroZwg7IaQ7Im96rKMIOywvuyVhOyYrCDsiJgg7J6I64uk64qUIOygkOydtCDsg4Hri7ntnogg7Y6466as7ZW07KGM64uk64qUIOqyg+yeheuLiOuLpC4g65iQ7ZWcIOyXrOufrOqwnOydmCDtjpjsnbTsp4Dsl5Ag64+Z7J287ZWcIOydtOuvuOyngCBhc3NldHPrk6TsnbQgaW1wb3J0IOuQmOqzoCDsnojripTrjbAg7J2065+wIOu2gOu2hOuTpOydgCDstpTtm4QgYXNzZXRz7J2YIOqyveuhnOuCmCDtjIzsnbzsnbQg67OA6rK965CY66m0IOuyiOqxsOuhreqyjCDrqqjrkZAg7IiY7KCV7ZW07KO87Ja07JW8IO2VmOqzoCDqt7jsl5Ag65Sw6528IOuyhOq3uCDrsJzsg53tmZXrpaDrj4Qg7Jis65286rCIIOyImCDsnojri6TripQg64uo7KCQ7J20IOyeiOyKteuLiOuLpC4g7ZWY7KeA66eMIOydtOugh+qyjCDrj5nsnbztlZwgYXNzZXTsl5Ag64yA7ZW0IOqwmeydgCDsnbTrpoTsnYQg7IKs7Jqp7ZWc64uk66m0IOuzgOqyveyCrO2VreydtCDsnojrjZTrnbzrj4Qg66qo65GQIOuPmeydvO2VmOqyjCDsoIHsmqnrkKAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG7snbTsmYAg6rCZ7J2AIOqzvOygleydhCDrsJjrs7XtlZjrqbTshJwg6riw7KG0IEFzc2V0c+uTpOydhCDrjIDssrTtlbTspI3ri4jri6QuXFxuXFxuIyMjIDMtMi4gUmVhY3RDb21wb25lbnTroZwgaW1wb3J07ZW07IScIOyCrOyaqe2VmOuNmCBTVkcg7YyM7J28IOyImOyglSDsmIjsi5xcXG5cXG5gYGB0c3hcXG4vLyDquLDsobRcXG5pbXBvcnQgeyBSZWFjdENvbXBvbmVudCBhcyBEb3VibGVBcnJvd1JpZ2h0IH0gZnJvbSBcXFwiLi9pbWcvaWNvbi9kb3VibGVfYXJyb3dfcmlnaHQuc3ZnXFxcIlxcbjxEb3VibGVBcnJvd1JpZ2h0IGNsYXNzTmFtZT1cXFwiaWNvblxcXCIgLz5cXG5gYGBcXG5cXG48dmlkZW8gc3JjPVxcXCIvYXNzZXRzL2ltZy9SZWFjdENvbXBvbmVudC1laW1hLm1wNFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGF1dG9wbGF5IGNvbnRyb2xzIGxvb3A+PC92aWRlbz5cXG5cXG5gYGB0c3hcXG4vLyDrs4DtmZhcXG5pbXBvcnQgU3ZnQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50cy9TdmdDb21wb25lbnQnO1xcbmltcG9ydCBBU1NFVFMgZnJvbSAnLi9hc3NldHMnO1xcblxcbjxTdmdDb21wb25lbnQgY2xhc3NOYW1lPVxcXCJpY29uXFxcIiBzcmM9e0FTU0VUUy5JQ09OX0RPVUJMRV9BUlJPV19SSUdIVF9TVkd9IGRpc2FibGVkPXt0aGlzLnN0YXRlLmVuZFBhZ2VOdW0gLSAxMCA8IHRoaXMucHJvcHMuY3VyUGFnZSB8fCB0aGlzLnN0YXRlLmVuZFBhZ2VOdW0gPT09IHRoaXMucHJvcHMuY3VyUGFnZX0gLz5cXG5gYGBcXG5cXG7snbTroIfqsowgU1ZH7J2YIHNyYyBwYXRo66W8IFN2Z0NvbXBvbmVudOyXkCBwcm9wc+ycvOuhnCDrgrTroKTso7zripQg67Cp7Iud7Jy866GcIOyVhOydtOy9mOydhCDsib3qsowgUmVhY3RDb21wb25lbnTtmZQg7ZW07IScIO2ZnOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlxcblxcblxcblxcbiMjIDQuIOyCrOyaqeuylVxcblxcbkVpbWHrpbwg64+E7J6F7ZWY6rOg7J6QIO2VnOuLpOuptCDri6TsnYzqs7wg6rCZ7J20IOyTuCDsiJgg7J6I7Iq164uI64ukLlxcblxcbu2EsOuvuOuEkOydhCDrkZAgIOqwnCDsnbTsg4Eg7Lyt64uI64ukLlxcblxcbuq3uOuemOyEnCDtlZjrgpjripQg66Gc7LusIOyEnOuyhOuhnCDsgqzsmqntlZjqs6Ag65iQIOuLpOuluCDtlZjrgpjripQgZWltYeulvCDsgqzsmqntlanri4jri6QuICjsoIDripQgZ2l07Jqp7Jy866GcIDPqsJzslKkg7Lyc7IScIOyTsOqzoCDsnojsirXri4jri6QuKVxcblxcbiFbZWltYeyCrOyaqeuylS5wbmddKC9hc3NldHMvaW1nL2VpbWHsgqzsmqnrspUucG5nKVxcblxcbuydtOugh+qyjCDrkJjrqbQgYXNzZXRz6rCAIOuwlOudvOuztOqzoCDsnojripQg65SU66CJ7Yag66as7JeQIOyDiOuhnOyatCBhc3NldHPsnbQg7LaU6rCA65CgIOuVjOuniOuLpCBhc3NldHMuanMg7JeQIO2VtOuLuSBhc3NldHPsnZgg7Yyo7Iqk7JmAIOydtOumhOydtCDsnpDrj5nsnLzroZwg7LaU6rCA65CY7Ja0IOyGkOyJveqyjCDsgqzsmqntlaAg7IiYIOyeiOqyjCDrkKnri4jri6QuXFxuXFxu7KCc6rCAIO2VnCDrsogg7I2o67O06rOgIOq0nOywruycvOuptCDsoIDtnawg7YyA7JeQ64+EIOyGjOqwnO2VmOugpOqzoCDtlojripTrjbAg6rCc7J247KCB7Jy866GcIOyDgeuLue2eiCDrp4zsobHtlZjqs6Ag7J6I7Ja07IScIO2MgOyXkCDshozqsJwg7ZuEIOuPhOyehe2VmOugpOqzoCDtlanri4jri6QuXFxuXFxu7KKL7J2AIOudvOydtOu4jOufrOumrOulvCDrp4zrk6TslrTso7zsi6AgW+yEnOyihe2VmV0oaHR0cHM6Ly9ub29rcGkudGlzdG9yeS5jb20vOTc/Y2F0ZWdvcnk9OTA2MDcyKSDri5jqu5gg64uk7IucIO2VnCDrsogg6rCQ7IKs65Oc66a964uI64ukIPCfmYdcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwiRkVjb25mIDIwMjIgUmVzY3JpcHTqsJnsnbTtlbTsmpRcXFwiXFxuZGF0ZTogXFxcIjIwMjIuMTAuMTRcXFwiXFxudGFnczpcXG4tIGZlY29uZlxcbi0gcmVzY3JpcHRcXG4tIOq3uOumsOueqeyKpFxcbi0tLVxcblxcblxcblxcbiMgMjAyMiBGRWNvbmYgVHJhY2sgQSAtIFJlc2NyaXB06rCZ7J207ZW07JqUXFxuXFxuMjAyMuuFhOu2gO2EsCDsvZTroZzrgpgg6rec7KCc6rCAIOyEnOyEnO2eiCDtkoDrpqzrqbTshJwg7Luo7Y2865+w7Iqk65Ok7J20IOyYpO2UhOudvOyduOycvOuhnCDsp4TtlonsnbQg65CY6rOgIOyeiOyKteuLiOuLpC4g7Jis7ZW0IOyymOydjCDsi5zsnpHtlZwg7J247ZSE7L2Y64+EIOyeiOyXiOqzoCBGZWNvbmbrj4QgMTDsm5Tsl5Ag7Je066C47Iq164uI64ukLlxcblxcbkZFY29uZuuKlCDqt7gg7J246riw6rCAIOuMgOuLqO2VtOyEnCDrp4jsuZgg66y07IqoIEJUUyDsvZjshJztirgg7Yuw7LyT7YyFIO2VmOuTr+ydtCDsiJzsi53qsITsl5Ag66eI66y066as6rCAIOuQmOyXiOuNlOudvOq1rOyalC4g7Jis7ZW0IOq8rSDsmKTtlITrnbzsnbgg7Luo7Y2865+w7Iqk66W8IOywuOyXrO2VtOuztOqzoCDsi7bsl4jripTrjbAg7Jis7ZW064qUIOyJveyngCDslYrsnYQg6rKDIOqwmeyVhCDslYTsib3rhKTsmpQuIOuCtOuFhOyXkOuKlCDqvK0g7LC47ISd7ZWY6rOgIOyLtuyKteuLiOuLpC4g7KeR6rWs7ISd7JeQ7IScIOyYqOudvOyduOycvOuhnCDsu6jtjbzrn7DsiqQg64K07Jqp7J2EIOygleumrO2VtOuztOupsCDsiqTsiqTroZwg66eI7J2M7J2EIOuLrOuemOu0heuLiOuLpC5cXG5cXG5cXG5cXG5UcmFjayBBIOuqqeywqFxcblxcbjEuICoqUmVzY3JpcHTqsJnsnbTtlbTsmpQqKlxcblxcbjIuIEB3ZWJ0b29uL3BzZCDrnbzsnbTruIzrn6zrpqwg6rCc67Cc6riwXFxuXFxuMy4g7ZSE66Gg7Yq47JeU65OcIEREROulvCDrp4zrgpjri6QgXFxuXFxuNC4g7YWN7Iqk7Yq4IOyXkOuUlO2EsD8g6re46rKMIOutmCDrp4zrk5zripTqsbTrjbA/IFxcblxcbjUuIEVkZ2Ug7Lu07ZOo7YyF7Jy866GcIO2UhOuhoO2KuOyXlOuTnCDtj6zthZDshZwg64GM7Ja07Jis66as6riwIFxcblxcblxcblxcbiMjIFJlc2NyaXB06rCZ7J207ZW07JqUXFxuXFxuLSDrsJztkZzsnpA6IOq3uOumsOueqeyKpCDsoJXrr7jrn4lcXG5cXG4tIOyYiOyDgSDssq3snpA6IO2UhOuhoO2KuOyXlOuTnCDruYTquLDrhIgsIO2DgOyeheyWuOyWtCDsgqzsmqntlbTrs7Tqs6Ag7Iu27J2A67aELCDtlajsiJjtmJUg7ZSE66Gc6re4656Y67CN7JeQIOq0gOyLrOyeiOycvOyLoCDrtoQg65OxXFxuLSDrsJztkZwg64K07JqpIOyalOyVvTogUmVzY3JpcHTrnbzripQg7Iic7IiY7ZWo7IiY66W8IOyngO2Wpe2VmOuKlCDtlajsiJjtmJUg7ZSE66Gc6re4656Y67CNIOygleyggSDtg4DsnoXslrjslrTrpbwg7IaM6rCc7ZWY64qUIOyEuOyFmOydtOyXiOycvOupsCDqt7jrprDrnqnsiqTsl5DshJwg7JmcIFJlc2NyaXB066W8IOyTsOqzoCDsnojqs6Ag6re4IOyepeygkOydtCDrrLTsl4fsnbjsp4Ag7JWM66Ck7KO87IWo7Iq164uI64ukLlxcblxcblxcblxcbiMjIFJlc2NyaXB07J2YIO2KueynlVxcblxcbi0g67aI67OA7ISx7J2EIOycoOyngO2VmOq4sCDsnITtlbQg67OA7IiY6rCS7J2EIOuzgOqyve2VoCDsiJgg7JeG64ukLlxcbi0gbGV066eMIOyeiOuLpCAo7J6s7ZWg64u57J20IOyViOuQmOyEnCBjb25zdOyZgCDsmKTtnojroKQg7Jyg7IKsKVxcbi0gcmV0dXJuIOydtCDsl4bri6QuICjrp4jsp4Drp4kg65287J247J20IOyVlOusteyggSDrsJjtmZjrkKgpXFxuLSBpbXBvcnQgZXhwb3J06rCAIOyXhuuLpC4gKOuqqOuToCDrqqjrk4jsnYAg64K067O064K07KeE64ukLilcXG4tIFRT7LKY65+8IEpT7J2YIHN1cGVyc2V07J246rCAPyBOT1xcbiAgLSBKU+ydmCDquLDriqUg7KSRIO2KueuzhO2eiCDshKDsoJXrkJwg6riw64ql66eM7J2EIOuLpOujqOqzoCDsnojripQg7IOI66Gc7Jq0IOyWuOyWtFxcblxcblxcblxcbiMjIFJlc2NpcnB07J2YIOyGjOyGjO2VnCDsnqXsoJBcXG5cXG4tIOuqqOuToCBKUyDrnbzsnbTruIzrn6zrpqzrpbwgUmVzY3JpcHTsmYAg7ZWo6ruYIOyCrOyaqSDqsIDriqXtlZjri6QuIChucG0sIHlhcm4sIHBhY2thZ2UuanNvbiDrqqjrkZAg7IKs7JqpIOqwgOuKpSlcXG5cXG4tIO2MjOydtO2UhCDsl7DsgrDsnpDrpbwg7Ya17ZW0IO2VnCDrsKntlqXsnLzroZwg7L2U65Oc66W8IOydveq4sCDtjrjtlZjqsowg64+E7JmA7KSA64ukICjsoowgLT4g7JqwLCDsnIQgLT4g7JWE656YKSBcXG5cXG4gIC0gSlPrrLjrspXsnbQg64us65287KGM64uk6riwIOuztOuLpCDrrLjrspXsoIEg7ISk7YOVKFN5bnRhY3RpYyBTdWdhcinsnLzroZwg67O066m0IOuQnOuLpC5cXG5cXG4gIC0gYGBgamF2YXNjcmlwdFxcbiAgICAvLyDquLDsobQganNcXG4gICAgQShCKEMoLi4uYXJncykpKVxcbiAgICBcXG4gICAgLy8gcmVzY3JpcHRcXG4gICAgQSAtPiBCIC0+IENcXG4gICAgYGBgXFxuXFxuLSDrqqjrk6Ag66qo65OI7J20IOuCtOuztOuCtOyngOq4sCDrlYzrrLjsl5AgaW1wb3J0LCBleHBvcnTrrLjsnbQg6ri47Ja07KeA7KeAIOyViuuKlOuLpC5cXG5cXG5cXG5cXG4jIyBSZXNjcmlwdOydmCDtgbAg7J6l7KCQXFxuXFxuIyMjIO2DgOyehey2lOuhoFxcblxcbi0g7YOA7J6F7Ja064W47YWM7J207IWYIOyXhuydtCDrqqjrk6Ag7ZGc7ZiE7Iud7J2YIO2DgOyeheydhCDtnozrk6Trpqwt67CA64SIIO2DgOyeheycvOuhnCDstpTroaAg6rCA64ql7ZWY64ukXFxuXFxuLSBgYGBqYXZhc2NyaXB0XFxuICBsZXQgYWRkIChhLCBiKSA9PiBhK2IgICAgIC0tLSAoaW50LCBpbnQpID0+IGludFxcbiAgbGV0IGFkZDIgKGEsIGIpID0+IGErK2IgIC0tLSAoc3RyLCBzdHIpID0+IHN0clxcbiAgbGV0IGFkZDMgKGEsIGIpID0+IGErLmIgIC0tLSAoZmxvYXQsIGZsb2F0KSA9PiBmbG9hdFxcbiAgYGBgXFxuXFxuLSDsnbTqsowg6rCA64ql7ZWcIOydtOycoOuKlCDqsIEg7YOA7J6F67OE66GcIOyXsOyCsOyekOulvCDri6TrpbTqsowg7IKs7Jqp7ZWY64qUIFJlc2NyaXB07J2YIO2KueynleuVjOusuOydtOuLpC5cXG5cXG4tIOydtCDrv5Drp4wg7JWE64uI6rOgIOyLpOygnOuhnCDtg4DsnoXsnYQg7ISg7Ja47ZWcIOuSpCDruYTsirftlZwg6rCd7LK066W8IOyDiOuhreqyjCDsg53shLHtlZjrqbQgUmVzY3JpcHTripQg7Iqk7Iqk66GcIOqwgOyepSDsoIHtlantlbQg67O07J2064qUIO2DgOyeheydhCDstpTroaDtlZzri6QuXFxuXFxuLSB2YXJpYW50IO2DgOyehVxcblxcbiAgLSBgYGBqYXZhc2NyaXB0XFxuICAgIHR5cGUgcmVzdWx0ID0gUGVuZGluZyB8IFN1Y2Nlc3MoeyBkYXRhOiBzdHJpbmcgfSkgfCBGYWlsXFxuICAgIGBgYFxcblxcbiAgLSDsnITsmYAg6rCZ7J20IFZhcmlhbnQg7IOd7ISx7J6Q64qUIO2DgOyeheyXkCDstpTqsIAg6rCS7J2EIOqwgOyniCDsiJjqsIAg7J6I64ukLlxcblxcbi0g7Yyo7YS066ek7LmtXFxuXFxuICAtIOychCB2YXJpYW50IO2DgOyeheydhCDtmZzsmqntlZjrqbQg7Yyo7YS0IOunpOy5reyXkCDsnKDrpqztlZjri6RcXG5cXG4gIC0gYGBgamF2YXNjcmlwdFxcbiAgICBsZXQgZGF0YSA9ICh0cnVlLCBmYWxzZSkgLy8g7Yqc7ZSMXFxuICAgIGxldCBjb21wb25lbnQgPSBzd2l0Y2ggZGF0YSB7XFxuICAgICAgICB8ICh0cnVlLCB0cnVlKSA9PiBcXFwidHRcXFwiXFxuICAgICAgICB8ICh0cnVlLCBmYWxzZSkgPT4gXFxcInRmXFxcIlxcbiAgICAgICAgfCAoZmFsc2UsIHRydWUpID0+IFxcXCJmdFxcXCJcXG4gICAgfVxcbiAgICBgYGBcXG5cXG4gIC0g7JyE7JmAIOqwmeydtCDsvZTrk5zrpbwg7Kec66m0IFJlc2NyaXB0IGNvbXBpbGUg64u57IucIFxcXCJmZlxcXCIg7IyN7J20IOyXhuuLpOuKlCDqsoPsnYQg7LC+7JWE7KSA64ukLlxcblxcbi0gb3B0aW9uIO2DgOyehVxcblxcbiAgLSBSZXNjcmlwdOyXkOuKlCBudWxsbCwgdW5kZWZpbmVkIOqwnOuFkOydtCDsl4bri6QuIOydtOufsCDqsr3smrAgb3B0aW9u7YOA7J6F7J2EIOydtOyaqe2VtOyEnCDqsJLsnbQg7J6I64qU7KeAIOyXhuuKlOyngOulvCDssrTtgaztlaAg7IiYIOyeiOuLpC5cXG5cXG5cXG5cXG4jIyBSZXNjcmlwdOulvCDsk7DrqbTshJwg7JWE7Ims7Jug642YIOygkFxcblxcbiMjIyAxLiDrsJTsnbjrlKlcXG5cXG5SZXNjcmlwdOyXkOyEnOuKlCBqYXZhc2NyaXB07ZWo7IiY66W8IOyCrOyaqe2VmOq4sCDsnITtlbQg67CU7J2465Sp7J2EIO2VtOyVvCDtlZzri6QuIOydtOqyg+ydtCDslrTroLXqs6Ag6reA7LCu64ukLlxcblxcbj4g67CU7J2465Sp7J20656AP1xcbj5cXG4+IO2YhOyerCDslrjslrTsl5DshJwg64uk66W4IOyWuOyWtOuhnCDsk7Dsnbgg7L2U65Oc66W8IO2YuOy2nO2VmOq4sCDsnITtlZwg7J247YSw7Y6Y7J207IqkXFxuXFxu6re466aw656p7Iqk7JeQ7ISc64qUIG5leHQsIG5vY2ssIGplc3QsIHJlYWN0LWhvb2stZm9ybSwgcmVhY3QtbGlua2lmeSDrk7Eg64uk7JaR7ZWcIHJlc2NyaXB0LWJpbmRpbmdzIOudvOydtOu4jOufrOumrOulvCDsoJzqs7Xtlanri4jri6QuXFxuXFxuTkVYVCDsmIjsi5wg66eB7YGsOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9AZ3JlZW5sYWJzL3Jlc2NyaXB0LW5leHRcXG5cXG5cXG5cXG4jIyMgMi4g7J6R7J2AIOy7pOuupOuLiO2LsFxcblxcblN0YWNrb3ZlcmZsb3fsl5DshJwg6rKA7IOJ7ZW064+EIOuCmOyYpOuKlCDqsoPsnbQg6rGw7J2YIOyXhuydjCDjhaDjhaBcXG5cXG5bcmVzY3JpcHRdIO2DnOq3uOuhnCDsobDtmoztlbTrs7TrqbQgMjLrhYQgMTDsm5Qg7ZiE7J6sIDY56rCcIOygleuPhOuwluyXkCDrgpjsmKTsp4Ag7JWK7J2EIOygleuPhOuhnCDquIDroZzrsowg66CI67Ko7JeQ7ISc64+EIOyCrOyaqeu5iOuPhOqwgCDtmZXsi6Ttnogg64Ku7J2AIO2OuOyXkCDsho3tlZzri6QuXFxuXFxuXFxuXFxuIyMg64qQ64KA7KCQXFxuXFxuUmVzY3JpcHTrnoAg6rKD7J2EIOyymOydjCDrs7gg64qQ64KM7J2AIOutlOqwgCBKU+yZgCBUU+qwgCDtlanss5DsoLjshJwg7ZWY64KY7J2YIOyWuOyWtOuhnCDri6Tsi5wg7YOc7Ja064KcIOqygyDqsJnri6TripQg7IOd6rCB7J20IOuTnOuEpOyalC5cXG5cXG7qt7zrjbAg7ZiEIO2UhOuhnOygne2KuOyXkCDrj4TsnoXtlZzri6Tqs6Ag7ZWY66m0IOyigCDqurzroKTsp4DripQg7IOd6rCB7J20IOyasOyEoCDrk63ri4jri6QuIOutlOqwgCDrsozsjajrtoDthLAg6ryw64yA6rCAIOuQnCDripDrgozsnbjrjbAuLi4g7Jew7IKs67aE6ruY7IScIOunkOyUgO2VmOyLoCDqsoPsspjrn7wg65+s64ud7Luk67iM6rCAIOyigCDsnojquLDrj4Qg7ZWY6rOgIOq4sOyhtCBKUy9UUyDsobDtlansnLzroZwg7IKs7Jqp7ZW064+EIOyWtOuKkCDsoJXrj4Qg66eM7KGx7ZWY6riwIOuVjOusuOydtCDslYTri5DquYwg7Iu26riw64+E7ZWY6rOgIOyVhOyngSDsiqTsiqTroZwg64qQ64G86riw7JeQICdKUy9UU+uPhCDsmYTrsr3tlZjqsowg66q77JOw64qUIOuGiOydtCDtlZwg64iIIO2MjOuCmCcg652864qUIOyDneqwgeydtCDrk6TquLDrj4Qg7ZWp64uI64ukLlxcblxcbuq3uOuemOuPhCBGZWNvbmbsl5DshJwg7IOI66Gc7Jq0IOyWuOyWtOulvCDsgrTtjrTrs7TripQg7J6s66+46rCAIOyeiOyXiOyKteuLiOuLpC5cXG5cXG7rp4nsg4Eg7I2o67O066m0IOuYkCDri6Trpbwg7IiY64+EIOyeiOydhCDqsoMg6rCZ7JWE7JqULlxcblxcblxcblxcbi0tLVxcblxcbuy2nOyymDogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1qWk5rLU5jZXo2RVxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJqZWt5bGwgQmxvZyDrp4zrk5zripTqsowg6riA7JOw64qUIOqyg+uztOuLpCDtnpjrk6Ag7IKs656M65Ok7JeQ6rKMXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIwLjEyLjE3XFxcIlxcclxcbnRhZ3M6XFxyXFxuICAgLSBqZWt5bGxcXHJcXG4gICAtIGpla3lsbCB0aGVtZVxcclxcbiAgIC0gcnVieVxcclxcbiAgIC0gcmFpbHNcXHJcXG4gICAtIGJsb2dcXHJcXG4gICAtIG1hY1xcclxcbiAgIC0g7KeA7YKsIO2FjOuniFxcclxcbi0tLVxcclxcblxcclxcbiMgW21hY10gSmVreWxsIEJsb2cg7KeA7YKsIOu4lOuhnOq3uCBOZVhUIHRoZW1lIOuUsOudvO2VmOq4sFxcclxcblxcclxcbiMjIDEuIOykgOu5hOyCrO2VrVxcclxcblxcclxcbjEuIGdpdGh1YiBwYWdlcyDtmLjsiqTtjIXsnYQg6riw67O47Jy866GcIO2VqeuLiOuLpC5cXHJcXG5cXHJcXG4gICBgdXNlcm5hbWUuZ2l0aHViLmlvYOudvOuKlCDsnbTrpoTsnZggcmVwb3NpdG9yeeulvCBnaXRodWLsl5Ag66eM65Ok7Ja0IOykjeuLiOuLpC5cXHJcXG4gICBcXHJcXG4yLiBgbWFjIE9TYOyXkOyEnCBgcnVieSBvbiByYWlsc2Drpbwg7Zmc7Jqp7ZWp64uI64ukLiAod2luZG93c+uKlCDsooAg642UIOuzteyeoe2VnCDqsoMg6rCZ7Iq164uI64ukLi4uIOy2lO2bhCB3aW5kb3dz7JeQ7ISc64+EIO2VtOuztOqzoCAy7YOE7J2EIOyYrOumtOq5jCDsg53qsIHspJHsnoXri4jri6QpXFxyXFxuICAgXFxyXFxuXFxyXFxucnVieSDrpbwg7ISk7LmY7ZWY7KeAIOyViuqzoCBqZWt5bGwg7J2EIO2ZnOyaqe2VmOqzoCDsi7bsnLzsi5zri6TrqbQgIFvsib3qs6Ag67mg66W06rKMIOyImOykgCDquInsnZggR2l0SHViIOu4lOuhnOq3uCDrp4zrk6TquLAgLSBqZWt5bGwgcmVtb3RlIHRoZW1l7Jy866GcXShodHRwczovL2RyZWFtZ29uZmx5LmdpdGh1Yi5pby9ibG9nL2pla3lsbC1yZW1vdGUtdGhlbWUvKSDtj6zsiqTtjIXsnYQg7LC46rOg7ZWY7IS47JqULiBcXHJcXG4gICDsoIDsnZgg7Y+s7Iqk7YyF7JeQ7ISc64qUIOyigCDrjZQgY3VzdG9t7J20IOqwgOuKpe2VnCBgcnVieSBvbiByYWlsc2Drpbwg7Zmc7Jqp7ZWY64qUIOuwqeuyleydhCDshKTrqoXrk5zrpqzqsqDsirXri4jri6QuXFxyXFxuXFxyXFxuMy4g66eI7J2M7JeQIOuTnOuKlCBqZWt5bGwgdGhlbWXrpbwg7ISg7YOd7ZWp64uI64ukLiDslYTrnpgg7IKs7J207Yq4IOuTpOydhCDrj4zslYTri6Tri4jrqbAg7J6Q7Iug7J20IOybkO2VmOuKlCB0aGVtZeulvCDssL7slYTrs7TshLjsmpRcXHJcXG5cXHJcXG4gICAtIGh0dHA6Ly9qZWt5bGx0aGVtZXMub3JnL1xcclxcbiAgIC0gaHR0cHM6Ly9qZWt5bGx0aGVtZXMuaW8vZnJlZVxcclxcbiAgIC0gaHR0cDovL3RoZW1lcy5qZWt5bGxyYy5vcmcvXFxyXFxuICAgLSBodHRwczovL2dpdGh1Yi5jb20vdG9waWNzL2pla3lsbC10aGVtZVxcclxcblxcclxcbiAgIOygnCDruJTroZzqt7jsl5DripQg64uk7J2M7J2YIOqyg+uTpOydtCDqvK0g7ZWE7JqU7ZWY64uk6rOgIOyDneqwge2WiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4gICAtIOuniO2BrOuLpOyatOycvOuhnCDquIAg7J6R7ISxXFxyXFxuXFxyXFxuICAgLSDsubTthYzqs6DrpqxcXHJcXG4tIHRhZ+q4sOuKpSBcXHJcXG4gICAtIOqygOyDieq4sOuKpVxcclxcbi0g7Y+s7Iqk7Yq4IOuMk+q4gCDquLDriqUg65OxXFxyXFxuICBcXHJcXG5cXHJcXG7snITsnZgg7JqU7IaM65Ok7J2EIO2PrO2VqO2VmOuKlCDthYzrp4gg7KSR7JeQ7IScIOq5lOuBlO2VmOuLpOqzoCDsg53qsIHtlZxbIGBOZXh0IHRoZW1lYF0oaHR0cHM6Ly9naXRodWIuY29tL1NpbXBsZXl5dC9qZWt5bGwtdGhlbWUtbmV4dCnrpbwg7ISg7YOd7ZaI7Iq164uI64ukLlxcclxcblxcclxcbuqwnOyduOyggeycvOuhnCDquZTrgZTtlZwg7YWM66eI66W8IOy2lOyynO2VmOyekOuptCBbVGFsZV0oaHR0cHM6Ly9naXRodWIuY29tL2NoZXN0ZXJob3cvdGFsZSnthYzrp4jrj4Qg7LaU7LKc7ZWp64uI64ukLiBgTmV4dCB0aGVtZWDqs7wgVGFsZSDsgqzsnbTsl5DshJwg66eO7J20IOqzoOuvvO2WiOyXiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG7shKDtg53tlZwgdGhlbWXsnZggZ2l0aHViIHJlcG9zaXRvcnnrpbwg66Gc7LusIO2ZmOqyveyXkCDri6TsmrTrsJvsirXri4jri6QuIOydtO2bhCB1c2VybmFtZS5naXRodWIuaW8g7JeQIGdpdCByZW1vdGUg66W8IOyXsOqysO2VtOykjeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuICAgJCBnaXQgcmVtb3RlIGFkZCBvcmlnaW4gaHR0cHM6Ly9naXRodWIuY29tL3VzZXJuYW1lL3VzZXJuYW1lLmdpdGh1Yi5pb1xcclxcbmBgYFxcclxcblxcclxcbjMuIC5naXRpZ25vcmUg66W8IOy2lOqwgO2VtOykjeuLiOuLpC5cXHJcXG4gICBcXHJcXG5cXHJcXG5bamVreWxsIGdpdGlnbm9yZV0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYnJhZG9ub21pY3MvY2Y1OTg0YjY3OTlkYTdmZGZhZmQpIO2OmOydtOyngOulvCDtmZzsmqntlZjsi5zrqbQg65Cp64uI64ukLlxcclxcblxcclxcbjUuIEpla3lsbOydgCDquLDrs7jsoIHsnLzroZwgYHJ1Ynkgb24gcmFpbHNgIOydmCDsoJXsoIEg7Y6Y7J207KeAIO2UhOuhnOygne2KuOyeheuLiOuLpC4g65Sw65287IScIHJ1Ynkg7Ja47Ja0IOyEpOy5mOqwgCDtlYTsmpTtlanri4jri6QuXFxyXFxuICAg66eM7JW9IG1hYyBPU+ulvCDsk7Dqs6Ag6rOE7Iuc66m0IHJ1YnnqsIAg6riw67O47KCB7Jy866GcIOyEpOy5mOuQmOyWtCDsnojsnYQg7IiY64+EIOyeiOyKteuLiOuLpC4gXFxyXFxuICAgKOyVhOuLiOuptCBob21lYnJld+ulvCDthrXtlbQg6rCE64uo7Z6IIOyEpOy5mOuPhCDqsIDriqXtlanri4jri6QuKVxcclxcbiAgICjrp4zslb0gd2luZG93cyBPU+ulvCDsk7Dqs6Ag6rOE7Iuc64uk66m0WyBgcnVieWluc3RhbGxlcmBdKGh0dHBzOi8vcnVieWluc3RhbGxlci5vcmcvKeulvCDtmZzsmqntlbQg7ISk7LmY7ZWY7Iuc66m0IOuQqeuLiOuLpC4gKVxcclxcbiAgIOyggO2drOuKlCDsnbTrsojsl5DripQgcnZtIOydhCDsgqzsmqntlbTshJwgcnVieeulvCDshKTsuZjtlbTrs7TqsqDsirXri4jri6QuXFxyXFxuICAgcnVieeuKlCAyLjEueCDsnbTsg4Eg67KE7KCE7Jy866GcIOyEpOy5mO2VtOyjvOyEuOyalC5cXHJcXG5cXHJcXG42LiDro6jruYTrpbwg7ISk7LmY7ZWY6riwIOyghOyXkCBydm3snYQg7ISk7LmY7ZWY6rOgIOydtO2bhCBydWJ57J2YIOuyhOyghOydhCDrp57stpTslrQg7ISk7LmY7ZW07KSN64uI64ukLlxcclxcblxcclxcbiAgIGBgYGJhc2hcXHJcXG4gICAkIFxcXFxjdXJsIC1MIGh0dHBzOi8vZ2V0LnJ2bS5pbyB8IGJhc2ggLXMgc3RhYmxlXFxyXFxuICAgYGBgXFxyXFxuXFxyXFxuICAgcnZtIOyEpOy5mCDtm4QgIOyytO2BrFxcclxcblxcclxcbiAgIGBgYGJhc2hcXHJcXG4gICAkIHJ2bSBsaXN0IGtub3duXFxyXFxuICAgYGBgXFxyXFxuXFxyXFxuICAgYGBgYmFzaFxcclxcbiAgICQgcnZtIGluc3RhbGwgW3J1YnktdmVyc2lvbl1cXHJcXG4gICDsmIg6IHJ2bSBpbnN0YWxsIHJ1YnktMi43LjBcXHJcXG4gICBgYGBcXHJcXG5cXHJcXG4gICBydWJ5IHZlcnNpb27tmZXsnbhcXHJcXG5cXHJcXG4gICBgYGBiYXNoXFxyXFxuICAgJCBydWJ5IC12IFxcclxcbiAgIOuYkOuKlFxcclxcbiAgICQgcnVieSAtLXZlcnNpb25cXHJcXG4gICBgYGBcXHJcXG5cXHJcXG4gICBcXHJcXG5cXHJcXG4jIyAyLiBHZW1cXHJcXG5cXHJcXG4qKirrp4zslb0g7ZW064u5IOqzvOyglSDspJEgIOyYpOulmOqwgCDrsJzsg53tlZzri6TrqbQgIO2PrOyKpO2MheyVhOuemCAzLiBlcnJvcnMgJiBhY3Rpb25z66W8IO2ZleyduO2VtOyjvOyEuOyalC4qKipcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgMi0xLiBHZW1maWxlIOyEpOy5mO2VmOq4sFxcclxcblxcclxcbmBgYHJ1YnlcXHJcXG5zb3VyY2UgJ2h0dHBzOi8vcnVieWdlbXMub3JnJ1xcclxcbmdlbSAnZ2l0aHViLXBhZ2VzJywgZ3JvdXA6IDpqZWt5bGxfcGx1Z2luc1xcclxcbiNnZW0gJ2pla3lsbC1hZG1pbicsIGdyb3VwOiA6amVreWxsX3BsdWdpbnNcXHJcXG5nZW0gJ2JpZ2RlY2ltYWwnLCAnMS4zLjUnXFxyXFxuYGBgXFxyXFxuXFxyXFxuYEdlbWZpbGVg7J2EIOyVhOuemOyZgCDqsJnsnbQg7J6R7ISx7ZW07KO87IS47JqULlxcclxcblxcclxcbi0gZ2l0aHViLXBhZ2VzIGdlbeydhCDstpTqsIDtlbTso7zqs6AsIGpla3lsbC1hZG1pbiDrtoDrtoTsnYAg7KO87ISd7LKY66asIO2VqeuLiOuLpC5cXHJcXG4tIGJpZ2RlY2ltYWzsnZgg6rK97JqwIG1hYyBPUyDsgqzsmqkg7IucIGBnZW1gIOuyhOyghOydtCDrp57sp4Ag7JWK7JWEIOuyhOyghOq5jOyngCDstpTqsIDroZwg7ISk7KCV7ZW07KO87JeI7Iq164uI64ukLlxcclxcblxcclxcbiMjIyAyLTIuIHJhaWxzLCBidW5kbGVyIOyEpOy5mO2VmOq4sFxcclxcblxcclxcbjEuIHJ1YnnsnZgg7ZSE66CI7J6E7JuM7YGs7J24IHJhaWxz66W8IOyEpOy5mO2VtOykjeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuJCBnZW0gaW5zdGFsbCByYWlsc1xcclxcbmBgYFxcclxcblxcclxcbjIuIOuLpOydjOycvOuhnCDrnbzsnbTruIzrn6zrpqwg6rSA66as66W8IOuPhOyZgOyjvOuKlCBidW5kbGVy66W8IOyEpOy5mO2VtOykjeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuJCBnZW0gaW5zdGFsbCBidW5kbGVyXFxyXFxuYGBgXFxyXFxuXFxyXFxuMy4g6re466as6rOgIHVwZGF0ZeulvCDsi6TtlontlbTspI3ri4jri6QuXFxyXFxuXFxyXFxuKOyZnCDsspjsnYwg7ISk7LmY7ZWgIOuVjOu2gO2EsCDstZzsi6DrsoTsoITsnbQg7JWE64uM7KeA7JeQIOuMgO2VtOyEnOuKlCDsoJXtmZXtnogg66qo66W06rKg7KeA66eMLCDslYTrp4ggYnVuZGxlcuu/kOunjCDslYTri4jrnbwg6rSA66CoIGdlbSDrnbzsnbTruIzrn6zrpqzrk6TsnbQgYnVuZGxlciDrsoTsoITsl5Ag66ee7LawIOyXheuNsOydtO2KuCDtlbTspJjslbwg7ZWY64qUIOqygyDqsJnsirXri4jri6QuLjs7KVxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4kIGJ1bmRsZSB1cGRhdGUgLS1idW5kbGVyXFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgYmFzaFxcclxcbiQgYnVuZGxlIGluc3RhbGxcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgMi0zLiDroZzsu6zsl5DshJwg7KCc64yA66GcIOuPjOyVhOqwgOuKlOyngCDtmZXsnbjtlZjquLBcXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuJCBidW5kbGUgZXhlYyBqZWt5bGwgc2VydmVyXFxyXFxuYGBgXFxyXFxuXFxyXFxu7J20IOuqheugueyWtOulvCDsnoXroKXtlZjrqbQgYGh0dHA6Ly8xMjcuMC4wLjE6NDAwMGAg7JeQ7IScIOyEnOuyhOqwgCDqtazrj5nrkJjripQg6rKD7J2EIO2ZleyduO2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbuydvOuLqCDsl6zquLDquYzsp4Drp4wg7KCc64yA66GcIOuQmOuptCDslYTso7wgTmljZe2VnCDsg4HtmansnoXri4jri6Trp4wuLi5cXHJcXG5cXHJcXG7si6TsoJzroZwg7KCA64qUIOydtCDtmZTrqbTsnYQg652E7Jqw64qU642wIOq8rOuwlSDtlZjro6gg6rG466C4642YIOqygyDqsJnsirXri4jri6QuXFxyXFxuXFxyXFxu64uk7J2M7J2AIGpla3lsbOydhCDshKTsuZjtlZjqs6Ag7Iuk7ZaJ7Iuc7YKk66m07IScIOuniOyjvOyzpOuNmCDsmKTrpZgg66mU7Iuc7KeA65Ok6rO8IOq3uOyXkCDrjIDtlZwg7ZW06rKw7LGF65Ok7J2EIOuztOyXrOuTnOumrOqyoOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4jIyAzLiBlcnJvcnMgJiBhY3Rpb25zXFxyXFxuXFxyXFxu7YGs6rKMIDTqsIDsp4DsnZggZXJyb3Lrk6TsnbQg6rS066Gt7ZiU7JeI64qU642w7JqUIO2VmOuCmOyUqSDshozqsJztlbTrk5zrpqzqsqDsirXri4jri6QuXFxyXFxuXFxyXFxuIyMjIDMtMS4gW29oLW15LXpzaF0gcGVybWlzc2lvbiBlcnJvclxcclxcblxcclxcbuyggOuKlCB0ZXJtaW5hbOydhCBgb2gtbXktenNoYOulvCDsgqzsmqntlZjqs6Ag7J6I7Iq164uI64ukLiDsl6zquLDshJwg6rOE7IaNIOydtOufsCDsmKTrpZjqsIAg67Cc7IOd7ZWp64uI64ukLlxcclxcblxcclxcbiFbb2gtbXktenNoLXBlcm1pc3Npb25dKGh0dHBzOi8vYmxvZy5rYWthb2Nkbi5uZXQvZG4vYnhYWFYyL2J0cUYwMHpXcldPL2taMFRJRkJnV2dnQzU3TFhPOE1KQksvaW1nLnBuZylcXHJcXG5cXHJcXG7snbQg66y47KCc64qUIO2VtOuLuSBkaXJlY3RvcnnsnZggb3dlcuqwgCDtmITsnqwgdXNlcuyZgCDri6Trpbgg6rK97Jqw7JeQIOuwnOyDne2VnOuLpOqzoCDtlanri4jri6QuXFxyXFxuXFxyXFxu7JiI66W8IOuTpOyWtCwg66el7JeQIDLqsJzsnZgg6rOE7KCV7J20IOyeiOuKlOuNsCDshJzroZwg64uk66W4IOqzhOygleydhCDsgqzsmqntlZjrqbTshJwg7IOd6ri0IOusuOygnOudvOqzoCDtlanri4jri6QuICjtlZjsp4Drp4wg7KCA64qUIOq3uOugh+yngCDslYrslZjrjZgg6rKDIOqwmeydgOuNsCDqs4Tsho0g7J20IOuplOyLnOyngOqwgCDrlrTsirXri4jri6QuLi47OylcXHJcXG5cXHJcXG4jIyMgMy0xLiBbb2gtbXktenNoXSBwZXJtaXNzaW9uIGVycm9yIGFjdGlvbnMg64yA7J2RIOuwqeuylVxcclxcblxcclxcbu2VtOqysCDrsKnrspXsnYAg7J2066+47KeA7J2YIOuniOyngOunieyXkOyEnOuPhCDrs7wg7IiYIOyeiOuTr+ydtCBgWlNIX0RJU0FCTEVfQ09NUEZJWGDrpbwgdHJ1ZeuhnCDshKTsoJXtlbTso7zripQg6rKD7J6F64uI64ukLlxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4kIHZpIH4vLnpzaHJjXFxyXFxuYGBgXFxyXFxuXFxyXFxu66qF66C57Ja066W8IOyeheugpe2VmOyXrCB2aSBlZGl0b3Ig66qo65Oc66GcIOuzgOqyve2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuLi4uXFxyXFxuWlNIX0RJU0FCTEVfQ09NUEZJWD1cXFwidHJ1ZVxcXCJcXHJcXG5cXHJcXG5zb3VyY2UgJFpTSC9vaC1teS16c2guc2hcXHJcXG4uLi5cXHJcXG5gYGBcXHJcXG5cXHJcXG4qKiHso7zsnZghKipcXHJcXG5cXHJcXG7sl6zquLDshJwg6rCA7J6lIOykkeyalO2VnCDqsoPsnYAg7JyE7LmY7J6F64uI64ukLiDrsJjrk5zsi5wgYHNvdXJjZSAkWlNIL29oLW15LXpzaC5zaGDrs7Tri6Qg7JyE7Kq97JeQIGBaU0hfRElTQUJMRV9DT01QRklYPVxcXCJ0cnVlXFxcImDrpbwg7J6F66Cl7ZW07KO87IS47JqUXFxyXFxuXFxyXFxuYHNvdXJjZSAkWlNIL29oLW15LXpzaC5zaGAg64qUIOychOydmCBzY3JpcHRzIOuTpOydhCDsoIHsmqntlZjripQg66qF66C57Ja07J24642wIOydtOqyg+uztOuLpCDrkqTsl5Ag7J6I7Jy866m0IOyggeyaqeuQmOyngCDslYrripTri6Tqs6Ag7J207ZW07ZWY7Iuc66m0IOuQqeuLiOuLpC5cXHJcXG5cXHJcXG5gOndxYOuhnCDsoIDsnqUg7ZuEIHZpIGVkaXRvcuulvCDruaDsoLjrgpjsmLXri4jri6QuXFxyXFxuXFxyXFxu7J20IOyXkOufrOuKlCDsnbTroIfqsowg7ZW06rKw7ZWgIOyImCDsnojsl4jsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIDMtMi4gdW5kZWZpbmVkIG1ldGhvZCBgbmV3JyBmb3IgQmlnRGVjaW1hbDpDbGFzcywgUnVieSAyLjdcXHJcXG5cXHJcXG5gYGBiYXNoXFxyXFxuYnVuZGxlcjogZmFpbGVkIHRvIGxvYWQgY29tbWFuZDogZmFzdGxhbmUgKC9Vc2Vycy9SRURBQ1RFRC8uZ2VtL3J1YnkvMi43LjAvYmluL2Zhc3RsYW5lKVxcclxcbk5vTWV0aG9kRXJyb3I6IFshXSB1bmRlZmluZWQgbWV0aG9kIGBuZXcnIGZvciBCaWdEZWNpbWFsOkNsYXNzXFxyXFxuICAvVXNlcnMvUkVEQUNURUQvLmdlbS9ydWJ5LzIuNy4wL2dlbXMvYWN0aXZlc3VwcG9ydC00LjIuMTEuMS9saWIvYWN0aXZlX3N1cHBvcnQvY29yZV9leHQvb2JqZWN0L2R1cGxpY2FibGUucmI6MTExOmluIGA8Y2xhc3M6QmlnRGVjaW1hbD4nXFxyXFxuICAvVXNlcnMvUkVEQUNURUQvLmdlbS9ydWJ5LzIuNy4wL2dlbXMvYWN0aXZlc3VwcG9ydC00LjIuMTEuMS9saWIvYWN0aXZlX3N1cHBvcnQvY29yZV9leHQvb2JqZWN0L2R1cGxpY2FibGUucmI6MTA2OmluIGA8dG9wIChyZXF1aXJlZCk+J1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2FjdGl2ZXN1cHBvcnQtNC4yLjExLjEvbGliL2FjdGl2ZV9zdXBwb3J0L2NvcmVfZXh0L29iamVjdC5yYjozOmluIGByZXF1aXJlJ1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2FjdGl2ZXN1cHBvcnQtNC4yLjExLjEvbGliL2FjdGl2ZV9zdXBwb3J0L2NvcmVfZXh0L29iamVjdC5yYjozOmluIGA8dG9wIChyZXF1aXJlZCk+J1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2FjdGl2ZXN1cHBvcnQtNC4yLjExLjEvbGliL2FjdGl2ZV9zdXBwb3J0L2NvcmVfZXh0LnJiOjI6aW4gYHJlcXVpcmUnXFxyXFxuICAvVXNlcnMvUkVEQUNURUQvLmdlbS9ydWJ5LzIuNy4wL2dlbXMvYWN0aXZlc3VwcG9ydC00LjIuMTEuMS9saWIvYWN0aXZlX3N1cHBvcnQvY29yZV9leHQucmI6MjppbiBgYmxvY2sgaW4gPHRvcCAocmVxdWlyZWQpPidcXHJcXG4gIC9Vc2Vycy9SRURBQ1RFRC8uZ2VtL3J1YnkvMi43LjAvZ2Vtcy9hY3RpdmVzdXBwb3J0LTQuMi4xMS4xL2xpYi9hY3RpdmVfc3VwcG9ydC9jb3JlX2V4dC5yYjoxOmluIGBlYWNoJ1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2FjdGl2ZXN1cHBvcnQtNC4yLjExLjEvbGliL2FjdGl2ZV9zdXBwb3J0L2NvcmVfZXh0LnJiOjE6aW4gYDx0b3AgKHJlcXVpcmVkKT4nXFxyXFxuICAvVXNlcnMvUkVEQUNURUQvLmdlbS9ydWJ5LzIuNy4wL2dlbXMvc2xhY2stcnVieS1jbGllbnQtMC4xNC40L2xpYi9zbGFjay1ydWJ5LWNsaWVudC5yYjozOTppbiBgcmVxdWlyZSdcXHJcXG4gIC9Vc2Vycy9SRURBQ1RFRC8uZ2VtL3J1YnkvMi43LjAvZ2Vtcy9zbGFjay1ydWJ5LWNsaWVudC0wLjE0LjQvbGliL3NsYWNrLXJ1YnktY2xpZW50LnJiOjM5OmluIGA8dG9wIChyZXF1aXJlZCk+J1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2Zhc3RsYW5lLTIuMTQ2LjEvZmFzdGxhbmUvbGliL2Zhc3RsYW5lL2Zhc3RsYW5lX3JlcXVpcmUucmI6MTA6aW4gYHJlcXVpcmUnXFxyXFxuICAvVXNlcnMvUkVEQUNURUQvLmdlbS9ydWJ5LzIuNy4wL2dlbXMvZmFzdGxhbmUtMi4xNDYuMS9mYXN0bGFuZS9saWIvZmFzdGxhbmUvZmFzdGxhbmVfcmVxdWlyZS5yYjoxMDppbiBgaW5zdGFsbF9nZW1faWZfbmVlZGVkJ1xcclxcbiAgL1VzZXJzL1JFREFDVEVELy5nZW0vcnVieS8yLjcuMC9nZW1zL2Zhc3RsYW5lLTIuMTQ2LjEvZmFzdGxhbmUvbGliL2Zhc3RsYW5lL2Zhc3RfZmlsZS5yYjoyMzI6aW4gYGZhc3RsYW5lX3JlcXVpcmUnXFxyXFxuICBGYXN0ZmlsZTo1NTppbiBgYmxvY2sgaW4gcGFyc2luZ19iaW5kaW5nJ1xcclxcbmBgYFxcclxcblxcclxcbuydtCDsl5Drn6zripQgcnVieSDrsoTsoITqs7wgYEJpZ0RlY2ltYWxgIOydtOudvOuKlCBnZW3snZgg67KE7KCEIOywqOydtCDrrLjsoJzroZwg67Cc7IOd7ZWcIOqygyDqsJnsirXri4jri6QuXFxyXFxuXFxyXFxuR2VtZmlsZSDrgrTsl5AgYGdlbSAnYmlnZGVjaW1hbCcsICcxLjMuNSdgIOuhnCDrsoTsoITquYzsp4Ag66qF7ZmV7Z6IIOy2lOqwgO2VnCDtm4QgYGJ1bmRsZSBpbnN0YWxsYCDtlZjri4gg7ZW06rKw65CY7JeI7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyAzLTMuIGJ1bmRsZSAvIGJ1bmRsZSBpbnN0YWxsIOydtCDslYjrkJjripQg7JeQ65+sXFxyXFxuXFxyXFxu7J20IOyXkOufrOuPhCDqvaTrgpgg6rOg7IOd7ZaI642YIOyXkOufrOyYgOyKteuLiOuLpC5cXHJcXG5cXHJcXG7soIDripQgYGhvbWVicmV3YOulvCDsgqzsmqntlZjsl6wgcnVieSDrk7Eg64uk7JaR7ZWcIOqyg+uTpOydhCDshKTsuZjtlZjqs6Ag7ZaI7JeI64qU642wIOydtOqyjCBtYWMgT1Mg7LWc7IugIOuyhOyghOyduCBDYXRhbGluYeyZgOydmCDstqnrj4wg66y47KCc7J246rG07KeALCDslYTri4jrqbQgcmJlbnbsmYDsnZgg7Lap64+M7J246rG07KeA64qUIOyemCDrqqjrpbTqsqDsirXri4jri6QuIFxcclxcblxcclxcbiMjIyBBY3Rpb25zIO2VtOqysOuylSBcXHJcXG5cXHJcXG7soIDripQg7JWE656Y7JmAIOqwmeydgCDrkZAg7KSE7J2YIOy9lOuTnOulvCBgdmkgfi8uenNocmNg7JeQIOy2lOqwgO2VmOyXrCDtlbTqsrDtlojsirXri4jri6QuXFxyXFxuXFxyXFxu7JyE7JmAIOqwmeydtCBgc291cmNlICRaU0gvb2gtbXktenNoLnNoYCDrs7Tri6Qg7JyE7Kq97JeQIOyeheugpe2VmOqzoCDsoIDsnqXtlZjrqbQg65Cp64uI64ukLlxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4uLi5cXHJcXG5leHBvcnQgUEFUSD1cXFwiJEhPTUUvLnJiZW52L2JpbjokUEFUSFxcXCJcXHJcXG5ldmFsIFxcXCIkKHJiZW52IGluaXQgLSlcXFwiXFxyXFxuXFxyXFxuc291cmNlICRaU0gvb2gtbXktenNoLnNoXFxyXFxuLi4uXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7ZWcIOydtO2LgCDsoJXrj4Qg7KeA64KY6rOg64KY7IScIOyekeyEse2VmOuLpOuztOuLiCDqt7jsg4gg7JeQ65+s7JmAIOuMgOydkeuyleydhCDrp47snbQg7J6K7JeI7Iq164uI64ukLlxcclxcblxcclxcbu2PrOyKpO2MheydmCDrsKnrspXsnbQg7JmE67K97ZWY7KeAIOyViuydhCDsiJgg7J6I7Jy864uIIOyCrOyaqeyXkCDso7zsnZjtlbTso7zsi5zqs6AsIO2YueyLnCDsnpjrqrvrkJwg67aA67aE7J2EIOuwnOqyrO2VmOyLoCDrtoTsnYAg7JWE656YIOuMk+q4gOuhnCDrgqjqsqjso7zsi5zrqbQg7KCV66eQIOqwkOyCrO2VmOqyoOyKteuLiOuLpC5cXHJcXG5cXHJcXG7snbQg7Jm47JeQ64+EIOyXrOufrOqwgOyngCDsl5Drn6zqsIAg642UIOyDneqwgeuCmOqxsOuCmCDsoJzrs7TrsJvsnLzrqbQg7LaU6rCA7ZW067O06rKg7Iq164uI64ukLlxcclxcblxcclxcbldpbmRvd3Mg7Lu07ZOo7YSw7JeQ7ISc64+EIO2VnCDrsogg7ZW067O06rOgIOyYrOugpOuztOuPhOuhnSDtlZjqsqDsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu6rCQ7IKs7ZWp64uI64ukIVxcclxcblxcclxcbi0tLVxcclxcblxcclxcbkNvcHlyaWdodDogbGlrZWxpb25TdW5nR3VrIOyhsOyEseq1rVxcclxcblxcclxcblxcclxcblxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJqZWt5bGwgQmxvZ+yXkCDtj6zsiqTtjIUg7ZWY64qU67KVLeydtOuvuOyngOuEo+q4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMC4xMi4xN1xcXCJcXHJcXG50YWdzOiBcXHJcXG4gICAtIGJsb2dcXHJcXG4gICAtIGpla3lsbFxcclxcbiAgIC0gamVreWxsXFxyXFxuICAgLSB0aGVtZVxcclxcbiAgIC0gTmV4VCB0aGVtZVxcclxcbiAgIC0g7KeA7YKsIO2FjOuniFxcclxcbiAgIC0g7KeA7YKsIOu4lOuhnOq3uCDtj6zsiqTtjIVcXHJcXG4gICAtIEdpdEh1YiBQYWdlc1xcclxcbi0tLVxcclxcblxcclxcbiMjIEpla3lsbCBCbG9nIFBvc3RpbmcgQmFzaWNcXHJcXG5cXHJcXG4hW2ltYWdlLTIwMjAxMjE3MjAyNDQ0MDI4XSgvYXNzZXRzL2ltZy9pbWFnZS0yMDIwMTIxNzIwMjQ0NDAyOC5wbmcpXFxyXFxuXFxyXFxuYmxvZyBwb3N0aW5n7J2AIGBfcG9zdGAg7Y+0642UIOyViOyXkCBgbWFya2Rvd25g66y47ISc66W8IOyekeyEse2VmOuptCDrkKnri4jri6QuXFxyXFxuXFxyXFxu64yA7IugIOydtCDrlYwg7KeA7Lyc7JW87ZWgIO2YleyLneydtCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu67CU66GcIGBtYXJrZG93bmDrrLjshJzsnZgg7LWc7IOB64uo7JeQIOyVhOuemOyZgCDqsJnsnYAgYFlhbWxgIOuwqeyLneydmCDsvZTrk5zrpbwg7IK97J6F7ZW07KO864qUIOqyg+yeheuLiOuLpC5cXHJcXG5cXHJcXG7slYTrnpjripQg7J2067KIIO2PrOyKpO2MheydmCDsmIjsi5zrpbwg6re464yA66GcIOyCrOyaqe2VmOyYgOyKteuLiOuLpC5cXHJcXG5cXHJcXG5gYGB5YW1sXFxyXFxuLS0tXFxyXFxubGF5b3V0OiBwb3N0XFxyXFxudGl0bGU6IGpla3lsbCBCbG9n7JeQIO2PrOyKpO2MhSDtlZjripTrspUt7J2066+47KeA64Sj6riwXFxyXFxuZGF0ZTogMjAyMC0xMi0xNyAxNzozMjowOVxcclxcbmNhdGVnb3JpZXM6IFxcclxcbi0gamVreWxsXFxyXFxuLSBibG9nXFxyXFxudGFnczogW2Jsb2csIGpla3lsbCwgYmxvZywgamVreWxsIHRoZW1lLCBOZXhUIHRoZW1lLCDsp4Dtgqwg7YWM66eILCDsp4Dtgqwg67iU66Gc6re4IO2PrOyKpO2MhSwgR2l0SHViIFBhZ2VzXVxcclxcbi0tLS0gXFxyXFxuYGBgXFxyXFxuXFxyXFxu7ZWY64KYIO2VmOuCmCDsgrTtjrTrs7TrqbRcXHJcXG5cXHJcXG4xLiDsnIQg7JWE656Y66W8IOyEuCDqsJzsnZgg64yA7IucKC0p66GcIOunieqzoCDqt7gg7JWI7JeQIOuCtOyaqeydhCDsnpHshLHtlanri4jri6QuXFxyXFxuMi4gYGxheW91dGA6IOugiOydtOyVhOybg+ydgCDsnbQg6riA7J20IOyWtOuWpCDtmJXsi53snbjsp4Drpbwg66qF7Iuc7ZWp64uI64ukLiBOZXh0IHRoZW1l7JeQ7ISc64qUIGFyY2hpdmUsIHBvc3QsIHBhZ2UsIGNhdGVnb3J5LCB0YWcsICDrk7HsnZgg66CI7J207JWE7JuD7J20IOyeiOyKteuLiOuLpC4gXFxyXFxuICAg7J20IOykkeyXkOyEnCDtj6zsiqTtjIXsnYAgYHBvc3Rg66W8IOyCrOyaqe2VqeuLiOuLpC5cXHJcXG4zLiBgdGl0bGVg7J2AIOydtCDtj6zsiqTtjIXsnZgg7KCc66qp7J2EIOuCmO2DgOuDheuLiOuLpC4gKOy2lO2bhCDsnpDrj5nsoIHsnLzroZwg7ZW064u5IG1hcmtkb3duIO2MjOydvCDsnpDssrTsnZgg7J2066aE7J20IOuQqeuLiOuLpC4pXFxyXFxuNC4gYGNhdGVnb3JpZXNg64qUIOydtCDquIDsnZgg7Lm07YWM6rOg66as66W8IOuCmO2DgOuCtOuKlCDqsoPsnLzroZwg7J20IOq4gOydtCDslrTrlrvqsowg67aE66WYIOuQmOyXiOycvOuptCDtlZjripTsp4Ag7Z2s66ed7ZWY64qUIOuMgOuhnCDsnpHshLHtlZjrqbQg65Cp64uI64ukLiDsmIjsi5zsnZgg66qo7Iq17LKY65+8IOuMgOyLnCgtKSDsnbTtm4Qg7ZWcIOy5uCDrnYTqs6Ag7JeU7YSw7LmY64qUIOuwqeyLneycvOuhnOuPhCDsnpHshLHsnbQg6rCA64ql7ZWY6rOgIOyVhOuemCB0YWdz7JmAIOqwmeydtCDrsLDsl7Qg7ZiV7YOc66GcIOuRkCDqsIDsp4Ag7ZiV7IudIOuqqOuRkCDsnpHshLEg6rCA64ql7ZWp64uI64ukLlxcclxcbjUuIGB0YWdzYOuKlCDsnbQg6riA7JeQIOyXrOufrOqwnOydmCB0YWfrpbwg64us7JWEIOy2lO2bhCB0YWfrs4Qg6rWs67aE7J20IOqwgOuKpe2VmOuPhOuhnSDtlZjqs6Ag6rKA7IOJ7JeU7KeE7JeQIOyemCDsnqHtnojrj4TroZ0gYFNFT2Drpbwg64+E7JmA7KO86riw64+EIO2VqeuLiOuLpC4gXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7J20IOyZuOyXkOuPhCBwZXJtYWxpbmssIGRhdGUg7ZiV7IudIOuzgOqyvSDrk7Eg64uk7JaR7ZWcIOuCtOyaqeydtCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu642UIOyekOyEuO2VnCDrgrTsmqnsnYAgWyoqamVreWxsIOqzteyLnSDsgqzsnbTtirgqKl0oaHR0cHM6Ly9qZWt5bGxyYi5jb20vZG9jcy9mcm9udC1tYXR0ZXIvKeyXkOyEnCDtmZXsnbjtlZjsi5zqs6Ag7ZWY64KY7JSpIO2FjOyKpO2KuO2VtOuztOyLnOuptCDrkKnri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7J207ZuEIOyVhOuemCDrtoDrtoTsl5Ag7Y+J67KU7ZWcIG1hcmtkb3duIO2YleyLneycvOuhnCDquIDsnYQg7J6R7ISx7ZWY66m0IOuQqeuLiOuLpC4g7J207ZuEIEdpdCBQdXNoIO2VtOyjvOyLnOuptCDrqocg67aEIO2bhCDquIDsnbQg7Y+s7Iqk7YyFIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG4qKuunjOyVvSDsmKjrnbzsnbjsl5Ag7Ja065a76rKMIO2PrOyKpO2MhSDrkKAg7KeAIOuvuOumrCDtmZXsnbjtlbQg67O06rOgIOyLtuycvOyLnOuLpOuptCwqKlxcclxcblxcclxcbjEuIGBgX2RyYWZ0YCDtj7TrjZTrpbwg65Sw66GcIOunjOuTpOyWtCDsmKjrnbzsnbgg7IOB7JeQ7IScIO2ZleyduO2VmOuKlCDrsKnrspVcXHJcXG4yLiBgQXRvbWAg7JeQ65SU7YSw66W8IO2ZnOyaqe2VmOyXrCBtYXJrZG93biDsnpHshLHqs7wg64+Z7Iuc7JeQIFdlYuyXkOyEnCDrs7Tsl6zsp4DripQg7ZmU66m07J2EIOuztOuptOyEnCDsnpHshLFcXHJcXG4zLiBgYnVuZGxlIGV4ZWMgamVreWxsIHNlcnZlYOuhnCDroZzsu6wg7ISc67KE66GcIOuovOyggCDrj4zroKTshJwg7ZmV7J247ZWY64qUIOuwqeuylVxcclxcblxcclxcbuuTsSDsnbQg7J6I7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIOyDneqwgeuztOuLpCDrgpzqtIDsnbgg7J2066+47KeAIOuEo+q4sFxcclxcblxcclxcbiMjIyDrrLjsoJzsg4HtmalcXHJcXG5cXHJcXG7tlZjsp4Drp4wg7JiI7KCE6rO8IOqwmeydtCBgbWFya2Rvd25g7J2EIOyekeyEse2VmOyLnOuptOyEnCDquIAg7KSR6rCEIOykkeqwhCDsnbTrr7jsp4Drpbwg7JeF66Gc65OcIO2VmOyLpCDqsr3smrAsIOybueyDgeyXkOyEnOuKlCDsnbTrr7jsp4DqsIAg7KCc64yA66GcIOucqOyngCDslYrripQg7Jik66WY6rCAIOyLrOyLrOywruqyjCDrsJzsg53tlanri4jri6QuXFxyXFxuXFxyXFxu7KCA7J2YIOqyveyasCBgTWFya2Rvd25g7YyM7J287J2EIGBUeXBvcmFg652864qUIOyXkOuUlO2EsOulvCDtmZzsmqntlbTshJwg7J6R7ISx7ZWY64qU642wLCDsnbTrlYwg7J2066+47KeA6rCAIOyekOuPmeycvOuhnCDtlZwg7Y+0642U7JeQIOuqqOydtOuPhOuhnSDtlZjripQg7ISk7KCV7J2EIO2ZnOyaqe2VqeuLiOuLpC5cXHJcXG5cXHJcXG7rlYzrrLjsl5AgYO2PrOyKpO2MheqzvCDrmJHqsJnsnYAg7J2066aELmFzc2V0c2DrnbzripQg7Y+0642U6rCAIO2VmOuCmCDrjZQg7IOd6riw6rKMIOuQmOqzoCDsnbTrlYwg7IOB64yA6rK966Gc66GcIOydtOuvuOyngOulvCDsnpDrj5nsnLzroZwg7LC+7JWE7Jik6riwIOuVjOusuOyXkCDrp4nsg4Eg66Gc7Lus7JeQ7ISc64qUIOygnOuMgOuhnCDrj5nsnpHtlZjripQg6rKD7LKY65+8IOuztOyeheuLiOuLpC5cXHJcXG5cXHJcXG4hW2ltYWdlLTIwMjAxMjE3MjA0NTEzMDM1XSgvYXNzZXRzL2ltZy9pbWFnZS0yMDIwMTIxNzIwNDUxMzAzNS5wbmcpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu6re465+s64KYLCDsm7nsl5DshJwg7ZW064u5IO2PrOyKpO2MheydmCBVUkzsnbQg67OA6rK965CY66m07IScIOydtCDsg4HrjIDqsr3roZzqsIAg7KCc64yA66GcIOyngOygleuQmOyngCDslYrslYQg7J2066+47KeA6rCAIOu2iOufrOyZgOyngOyngCDslYrripQg7Jik66WY6rCAIOuwnOyDne2VqeuLiOuLpC5cXHJcXG5cXHJcXG4hW2ltYWdlLTIwMjAxMjE3MjA0NjU1ODkyXSgvYXNzZXRzL2ltZy9pbWFnZS0yMDIwMTIxNzIwNDY1NTg5Mi5wbmcpXFxyXFxuXFxyXFxu7JWE656YIOydtOuvuOyngOyXkOyEnCDrs7Trk6/snbQgVVJM7JeQIOuztOyLnOuptCBge+uCoOynnH1gL2B7dGl0bGV9YOydmCDtmJXsi53snLzroZwg65CY7Ja0IOyeiOuKlCDqsoPsnYQg7JWMIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIO2VtOqysFxcclxcblxcclxcbuydtCDrrLjsoJzrpbwg7ZW06rKw7ZWY64qUIOuwqeuyleydgCDsg53qsIHrs7Tri6QgKirqsITri6gqKu2VmOyngOunjCwgKirqt4DssK7snYAg7J6R7JeFKirsnbQg65CgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu7ZW06rKw67Cp67KV7J2AIGDsoIjrjIDqsr3roZxg66W8IOydtOyaqe2VmOuKlCDqsoPsnoXri4jri6QuXFxyXFxuXFxyXFxu64uk7IucIO2MjOydvO2KuOumrOulvCDsgrTtjrTrs7TrqbQsIGBhc3NldHNg7Y+0642U6rCAIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4hW2ltYWdlLTIwMjAxMjE3MjA1MDE1MzIxXSgvYXNzZXRzL2ltZy9pbWFnZS0yMDIwMTIxNzIwNTAxNTMyMS5wbmcpXFxyXFxuXFxyXFxu7KCA7J2YIOqyveyasCDtj6zsiqTtjIXsl5Ag7IKs7Jqp7ZWY64qUIOydtOuvuOyngOuTpOydgCDrqqjrkZAgYGltZ2DrnbzripQg7Y+0642U7JeQIOuEo+yWtOuRkOqzoCDtlbTri7nsnbTrr7jsp4DsnZggYOygiOuMgOyjvOyGjGDrpbwg66eI7YGs64uk7Jq07JeQIOunge2BrO2VtOuRkOyXiOyKteuLiOuLpC5cXHJcXG5cXHJcXG7soJXrpqztlZjrqbQsIFxcclxcblxcclxcbjEuIGFzc2V0c+yXkCBpbWftj7TrjZTrpbwg66eM65Og64ukXFxyXFxuXFxyXFxuMi4g7Y+s7Iqk7YyF7JeQIOyTsOyduCBpbWfrk6TsnYQg66qo65GQIGAvYXNzZXRzL2ltZ2Ag7JWI7JeQIOuEo+uKlOuLpC4gKOuzteyCrCDrmJDripQg7J2064+ZKVxcclxcblxcclxcbjMuIO2PrOyKpO2MhSDrgrTsl5Ag7J2066+47KeA65Ok7J2YIOunge2BrOulvCDrqqjrkZAg64uk7J2M6rO8IOqwmeydtCDrs4Dqsr3tlZzri6QuXFxyXFxuXFxyXFxuICAgYGBgbWFya2Rvd25cXHJcXG4gICAhW0Zvb10oL2Fzc2V0cy9pbWdlL0Zvby5qcGcpXFxyXFxuICAgIVtCYXJdKC9hc3NldHMvaW1nZS9CYXIucG5nKVxcclxcbiAgIGBgYFxcclxcblxcclxcbiAgIFxcclxcblxcclxcbuydtOugh+qyjCDsspjrpqztlZwg65KkIGBnaXQgcHVzaGDtlbTrs7TrqbQg7J2066+47KeA6rmM7KeAIOygnOuMgOuhnCDtj6zsiqTtjIUg65CcIOqyg+ydhCDtmZXsnbjtlZjsi6Qg7IiYIOyeiOyKteuLiOuLpCA6c21pbGU6XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7Zi57IucIOywuOqzoO2VmOyFlOuPhCDtj6zsiqTtjIXsl5Ag7Ja066Ck7JuA7J2EIOqyquycvOyLoCDqsr3smrAg64yT6riA7JeQIOusuOydmO2VtOyjvOyEuOyalC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5Db3B5cmlnaHQ6IGxpa2VsaW9uU3VuZ0d1ayDsobDshLHqta1cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwiamVreWxsIE5leHQg7YWM66eIIOyekOyEuO2eiCDslYzslYTrs7TquLBcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjAuMTIuMTdcXFwiXFxyXFxudGFnczogW1xcclxcbiAgLSBibG9nXFxyXFxuICAtIGpla3lsbFxcclxcbiAgLSBqZWt5bGwgdGhlbWVcXHJcXG4gIC0gTmV4VCB0aGVtZVxcclxcbiAgLSDsp4Dtgqwg7YWM66eIXFxyXFxuICAtIEdpdEh1YiBQYWdlc1xcclxcbi0tLVxcclxcblxcclxcbiMjIF9jb25maWcueW1sXFxyXFxuXFxyXFxu64yA67aA67aE7J2YIEpla3lsbOydmCDtmZjqsr3shKTsoJXsnYAgYF9jb25maWcueW1sYOyXkOyEnCDtlanri4jri6QuXFxyXFxuXFxyXFxu7J2067KIIO2PrOyKpO2MheyXkOyEnOuKlCBgX2NvbmZpZy55bWxg7J2EIOyekOyEuO2eiCDslYzslYTrtIXsi5zri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgU2l0ZVxcclxcblxcclxcbj4gU2l0ZSDquLDrs7gg7ISk7KCV7J6F64uI64ukLiDslYTrnpgg7J2066+47KeA66W8IO2Gte2VtCDslrTrlqQg64K07Jqp7J20IOyWtOuUlOyXkCDrnKjripTsp4Ag7ZmV7J247ZW067O07IS47JqULlxcclxcblxcclxcbmBgYHlhbWxcXHJcXG50aXRsZTogQmxvZyDrjIDrrLhcXHJcXG5zdWJ0aXRsZTog6rCc67Cc7J6QIOyhsOyEseq1reydmCDruJTroZzqt7jsnoXri4jri6QuXFxyXFxuZGVzY3JpcHRpb246IFB5dGhvbiwgZGphbmdvLCBhbGdvcml0aG0sIENvbXB1dGVyIHNjaWVuY2UsIElUIO2KuOugjOuTnFxcclxcbmF1dGhvcjogbGlrZWxpb25TdW5nR3VrIOyhsOyEseq1rVxcclxcblN1cHBvcnQgbGFuZ3VhZ2U6IGVuLCBrb1xcclxcbmxhbmd1YWdlOiBlblxcclxcbmRhdGVfZm9ybWF0OiAnJVktJW0tJWQnXFxyXFxuYGBgXFxyXFxuXFxyXFxuIVvtmZTrqbRdKC9hc3NldHMvaW1nL0lNR18wMjg0LmpwZylcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBVUmxcXHJcXG5cXHJcXG5gYGB5YW1sXFxyXFxudXJsOiBcXFwiaHR0cHM6Ly9saWtlbGlvblN1bmdHdWsuZ2l0aHViLmlvXFxcIlxcclxcbmJhc2V1cmw6IFxcXCJcXFwiXFxyXFxucGVybWFsaW5rOiBwcmV0dHlcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBQYWdpbmF0aW9uXFxyXFxuXFxyXFxuPiBwYWdpbmF0aW9u7J2AIOqyjOyLnOq4gOydtCBO6rCcIOydtOyDgeydvCDqsr3smrAgTisx6rCc67aA7YSw64qUIOuLpOydjCDtjpjsnbTsp4Dsl5DshJwg67O07Jes7KO864+E66GdIO2VmOuKlCDrgrTsmqnsnoXri4jri6QuIFxcclxcbj4gcGFnaW5hdGUgMTDsnbgg6rK97JqwIOqyjOyLnOusvCAxMOqwnOq5jOyngOuKlCDtlZwg7Y6Y7J207KeA7JeQIOuCmOyYpOqzoCDqt7gg64uk7J2M67aA7YSw64qUIFxcXCJORVhUXFxcIuuyhO2KvCDriITrpbTrqbQg64uk7IucIDEw6rCc6rCAIOuFuOy2nOuQmOuKlCDtmJXsi53snoXri4jri6QuXFxyXFxuXFxyXFxuYGBgeWFtbFxcclxcbnBhZ2luYXRlOiAxMFxcclxcbnBhZ2luYXRlX3BhdGg6IFxcXCIvcGFnZTpudW0vXFxcIlxcclxcbmFyY2hpdmU6XFxyXFxuICBwYWdpbmF0ZTogMTBcXHJcXG4gIHBhZ2luYXRlX3BhdGg6IFxcXCIvcGFnZTpudW0vXFxcIlxcclxcbmNhdGVnb3J5OlxcclxcbiAgcGFnaW5hdGU6IDEwXFxyXFxuICBwYWdpbmF0ZV9wYXRoOiBcXFwiL3BhZ2U6bnVtL1xcXCJcXHJcXG50YWc6XFxyXFxuICBwYWdpbmF0ZTogMTBcXHJcXG4gIHBhZ2luYXRlX3BhdGg6IFxcXCIvcGFnZTpudW0vXFxcIlxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcbiMjIGZhdmljb25cXHJcXG5cXHJcXG4+IGZhdmljb27snYAgY2hyb20g7YOt7J2YIOunqCDslZ7sl5Ag64KY7Jik64qUIOyhsOq3uOuniO2VnCBpY29u7J6F64uI64ukLlxcclxcbj4gYXNzZXRzIO2PtOuNlOyXkCBmYXZpY29u7J2EIOuEo+ycvOyLnOuptCDtlbTri7kgaWNvbuycvOuhnCBmYXZpY29u7J2EIOyEpOyglSDqsIDriqXtlanri4jri6QuXFxyXFxuXFxyXFxuYGBgeWFtbFxcclxcbiMgUHV0IHlvdXIgZmF2aWNvbi5pY28gaW50byBgYXNzZXRzL2AgZGlyZWN0b3J5LlxcclxcbmZhdmljb246IC9hc3NldHMvZmF2aWNvbl90ZXJtaW5hbC5pY29cXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBpbmRleF93aXRoX3N1YnRpdGxlXFxyXFxuXFxyXFxuPiBIb21lIO2ZlOuptOyXkOyEnCBzdWJ0aXRsZeq5jOyngCDrs7Tsl6zso7zripQg7KeAIOyXrOu2gOyXkCDrjIDtlZwg64K07Jqp7J6F64uI64ukLlxcclxcbj4gdHJ1ZeuhnCDshKTsoJXtlZjrqbQgc3VidGl0bGXquYzsp4Ag64KY7Ji164uI64ukLlxcclxcblxcclxcbmBgYHlhbWxcXHJcXG4jIElmIHRydWUsIHdpbGwgYWRkIHNpdGUtc3VidGl0bGUgdG8gaW5kZXggcGFnZSwgYWRkZWQgaW4gamVreWxsIGNvbmZpZy5cXHJcXG4jIHN1YnRpdGxlOiBTdWJ0aXRsZVxcclxcbmluZGV4X3dpdGhfc3VidGl0bGU6IHRydWVcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBtZW51XFxyXFxuXFxyXFxuPuyWtOuWpCDrqZTribTrk6TsnYQg7Zmc7Jqp7ZWY7KeAIOyEoO2Dne2VqeuLiOuLpC5cXHJcXG4+SG9tZSwgQ2F0ZWdvcnksIEFib3V0LCBBcmNoaXZlLCBUYWdzIOuTpOydhCDtmZzshLHtmZTsi5zsvLDsnLzrqbAgc2l0ZW1hcCwgY29tbW9ud2VhbOydmCDqsr3smrAg67mE7Zmc7ISx7ZmUIO2VmOyYgOyKteuLiOuLpC5cXHJcXG5cXHJcXG5gYGB5YW1sXFxyXFxuIyBXaGVuIHJ1bm5pbmcgdGhlIHNpdGUgaW4gYSBzdWJkaXJlY3RvcnkgKGUuZy4gZG9tYWluLnRsZC9ibG9nKSwgcmVtb3ZlIHRoZSBsZWFkaW5nIHNsYXNoICgvYXJjaGl2ZXMgLT4gYXJjaGl2ZXMpXFxyXFxubWVudTpcXHJcXG4gIGhvbWU6IC9cXHJcXG4gIGNhdGVnb3JpZXM6IC9jYXRlZ29yaWVzL1xcclxcbiAgYWJvdXQ6IGFib3V0L1xcclxcbiAgYXJjaGl2ZXM6IC9hcmNoaXZlcy9cXHJcXG4gIHRhZ3M6IC90YWdzL1xcclxcbiAgI3NpdGVtYXA6IC9zaXRlbWFwLnhtbFxcclxcbiAgI2NvbW1vbndlYWw6IC80MDQuaHRtbFxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcbiMjIG1lbnUgaWNvbnNcXHJcXG5cXHJcXG4+ICBtZW5166W8IO2RnO2YhO2VmOuKlCBpY29u65Ok7J6F64uI64ukLlxcclxcbj4gZm9udGF3ZXNvbWUg7J2YICDslYTsnbTsvZgg7J2066aE65Ok7J2EIOyggeyWtOyjvOuptCDtlbTri7kgaWNvbuuTpOuhnCDrs4Dqsr3rkKnri4jri6QuXFxyXFxuXFxyXFxuYGBgeWFtbFxcclxcbm1lbnVfaWNvbnM6XFxyXFxuICBlbmFibGU6IGF1dG9cXHJcXG4gICMgS2V5TWFwc1RvTWVudUl0ZW1LZXk6IE5hbWVPZlRoZUljb25Gcm9tRm9udEF3ZXNvbWVcXHJcXG4gIGhvbWU6IGhvbWVcXHJcXG4gIGFib3V0OiB1c2VyXFxyXFxuICBjYXRlZ29yaWVzOiB0aFxcclxcbiAgc2NoZWR1bGU6IGNhbGVuZGFyXFxyXFxuICB0YWdzOiB0YWdzXFxyXFxuICBhcmNoaXZlczogYXJjaGl2ZVxcclxcbiAgc2l0ZW1hcDogc2l0ZW1hcFxcclxcbiAgY29tbW9ud2VhbDogaGVhcnRiZWF0XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgaHRtbFxcclxcbjxpIGNsYXNzPVxcXCJmYXMgZmEtaG9tZVxcXCI+PC9pPlxcclxcbmBgYFxcclxcblxcclxcbltmb250YXdlc29tZV0oaHR0cHM6Ly9mb250YXdlc29tZS5jb20vaWNvbnMvKeyCrOydtO2KuOyXkOyEnCDsnITsmYAg6rCZ7J20IGBmYS1g65Kk7JeQIOuCmOyYpOuKlCDsnbTrpoTrk6TsnYQgYF9jb25maWcueW1sYOyXkCDrhKPslrTso7zrqbQg65Cp64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIHNjaGVtZSBzZXR0aW5nc1xcclxcblxcclxcbj4gTmV4dCB0aGVtZeykkeyXkOyEnOuPhCDtgazqsowgM+qwgOyngCDrlJTsnpDsnbgg7ZiV7Iud7J20IOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5gYGB5YW1sXFxyXFxuIyBTY2hlbWVzXFxyXFxuc2NoZW1lOiBNdXNlXFxyXFxuI3NjaGVtZTogTWlzdFxcclxcbiNzY2hlbWU6IFBpc2Nlc1xcclxcbmBgYFxcclxcblxcclxcbk1pc3QsIFBpc2NlcyDtmJXsi53snZgg67iU66Gc6re466W8IOuztOqzoCDsi7bsnLzsi5zri6TrqbQgW01pc3Qg7JiI7IucXShodHRwczovL2Jsb2cuenpiZC5vcmcvKSAvIFtQaXNjZXMg7JiI7IucXShodHRwczovL2RhbmR5eHUubWUvKeulvCDthrXtlbQgRGVtb+ulvCDtmZXsnbjtlbTso7zshLjsmpQuXFxyXFxuXFxyXFxuKFtNdXNlIO2YleyLneydmCDjhY7jhLfjhLftlZwgQ3VzdG9tIENTUyDsoIHsmqkg7IKs66GAXShodHRwczovL2FjcmlzLm1lLykpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgZm9udHNcXHJcXG5cXHJcXG4+6rCBIOyYgeyXreuzhOuhnCBmb25066W8IOuCtOqwgCDsm5DtlZjripQg6rKD7Jy866GcIOuzgOqyve2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbmBgYHlhbWxcXHJcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcbiMgRm9udCBTZXR0aW5nc1xcclxcbiMgLSBGaW5kIGZvbnRzIG9uIEdvb2dsZSBGb250cyAoaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9mb250cylcXHJcXG4jIC0gQWxsIGZvbnRzIHNldCBoZXJlIHdpbGwgaGF2ZSB0aGUgZm9sbG93aW5nIHN0eWxlczpcXHJcXG4jICAgICBsaWdodCwgbGlnaHQgaXRhbGljLCBub3JtYWwsIG5vcm1hbCBpdGFsaWMsIGJvbGQsIGJvbGQgaXRhbGljXFxyXFxuIyAtIEJlIGF3YXJlIHRoYXQgc2V0dGluZyB0b28gbXVjaCBmb250cyB3aWxsIGNhdXNlIHNpdGUgcnVubmluZyBzbG93bHlcXHJcXG4jIC0gSW50cm9kdWNlIGluIDUuMC4xXFxyXFxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXHJcXG5mb250OlxcclxcbiAgZW5hYmxlOiB0cnVlXFxyXFxuXFxyXFxuICAjIFVyaSBvZiBmb250cyBob3N0LiBFLmcuIC8vZm9udHMuZ29vZ2xlYXBpcy5jb20gKERlZmF1bHQpXFxyXFxuICBob3N0OiB77Ju5IO2PsO2KuCDso7zshowg64Sj64qUIOqzszog7JiIKSBmb250cy5nb29nbGVhcGlzLmNvbX0gXFxyXFxuXFxyXFxuICAjIEdsb2JhbCBmb250IHNldHRpbmdzIHVzZWQgb24gPGJvZHk+IGVsZW1lbnQuXFxyXFxuICAjIEJsb2cg7KCE7LK07J2YIOq4gOq8tCDsp4DsoJUgKO2YhCBMYXRvKVxcclxcbiAgZ2xvYmFsOlxcclxcbiAgICAjIGV4dGVybmFsOiB0cnVlIHdpbGwgbG9hZCB0aGlzIGZvbnQgZmFtaWx5IGZyb20gaG9zdC5cXHJcXG4gICAgZXh0ZXJuYWw6IHRydWVcXHJcXG4gICAgZmFtaWx5OiBMYXRvXFxyXFxuXFxyXFxuICAjIEZvbnQgc2V0dGluZ3MgZm9yIEhlYWRsaW5lcyAoaDEsIGgyLCBoMywgaDQsIGg1LCBoNilcXHJcXG4gICMgRmFsbGJhY2sgdG8gYGdsb2JhbGAgZm9udCBzZXR0aW5ncy5cXHJcXG4gICMgaDEsIGgyLCBoMywgaDQsIGg1LCBoNu2DnOq3uOunjCBmb25067CU6r646rOgIOyLtuuLpOuptCDshKTsoJVcXHJcXG4gIGhlYWRpbmdzOlxcclxcbiAgICBleHRlcm5hbDogdHJ1ZVxcclxcbiAgICBmYW1pbHk6XFxyXFxuXFxyXFxuICAjIEZvbnQgc2V0dGluZ3MgZm9yIHBvc3RzXFxyXFxuICAjIEZhbGxiYWNrIHRvIGBnbG9iYWxgIGZvbnQgc2V0dGluZ3MuXFxyXFxuICAjIHBvc3Rpbmcg7YyM7Yq4IGZvbnTshKTsoJVcXHJcXG4gIHBvc3RzOlxcclxcbiAgICBleHRlcm5hbDogdHJ1ZVxcclxcbiAgICBmYW1pbHk6XFxyXFxuXFxyXFxuICAjIEZvbnQgc2V0dGluZ3MgZm9yIExvZ29cXHJcXG4gICMgRmFsbGJhY2sgdG8gYGdsb2JhbGAgZm9udCBzZXR0aW5ncy5cXHJcXG4gICMgVGhlIGBzaXplYCBvcHRpb24gdXNlIGBweGAgYXMgdW5pdFxcclxcbiAgbG9nbzpcXHJcXG4gICAgZXh0ZXJuYWw6IHRydWVcXHJcXG4gICAgZmFtaWx5OlxcclxcbiAgICBzaXplOlxcclxcblxcclxcbiAgIyBGb250IHNldHRpbmdzIGZvciA8Y29kZT4gYW5kIGNvZGUgYmxvY2tzLlxcclxcbiAgY29kZXM6XFxyXFxuICAgIGV4dGVybmFsOiB0cnVlXFxyXFxuICAgIGZhbWlseTpcXHJcXG4gICAgc2l6ZTpcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBzZWFyY2hcXHJcXG5cXHJcXG4+IOqygOyDieq4sOuKpeydhCDsm5DtlZjsi5zripQg6rK97JqwIGVuYWJsZTogdHJ1ZeuhnCDshKTsoJXtlbTso7zshLjsmpRcXHJcXG4+IHRyaWdnZXI6IG1hbnVhbOydmCDqsr3smrAg7IKs7Jqp7J6Q6rCAIHNlYXJjaCDslYTsnbTsvZjsnYQg7YG066at7ZaI7J2EIOuVjOyXkOunjCDrgpjtg4DrgpjripQg7ISk7KCV7J6F64uI64ukLlxcclxcblxcclxcbmBgYHlhbWxcXHJcXG4jIExvY2FsIHNlYXJjaFxcclxcbmxvY2FsX3NlYXJjaDpcXHJcXG4gIGVuYWJsZTogdHJ1ZVxcclxcbiAgIyBpZiBhdXRvLCB0cmlnZ2VyIHNlYXJjaCBieSBjaGFuZ2luZyBpbnB1dFxcclxcbiAgIyBpZiBtYW51YWwsIHRyaWdnZXIgc2VhcmNoIGJ5IHByZXNzaW5nIGVudGVyIGtleSBvciBzZWFyY2ggYnV0dG9uXFxyXFxuICB0cmlnZ2VyOiBtYW51YWxcXHJcXG4gICMgc2hvdyB0b3AgbiByZXN1bHRzIHBlciBhcnRpY2xlLCBzaG93IGFsbCByZXN1bHRzIGJ5IHNldHRpbmcgdG8gLTFcXHJcXG4gIHRvcF9uX3Blcl9hcnRpY2xlOiAxXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7J20IOyZuOyXkCDrjZQg64uk7JaR7ZWcIOyEpOygleuTpOydtCDsnojsp4Drp4wg64yA67aA67aEIOykkeq1rSDqtIDroKggU29jaWFsIOunge2BrOuTpOydtOqxsOuCmCDrtojtlYTsmpTtlZjri6Tqs6Ag7IOd6rCB7ZWY7JesIOyKpO2Cte2VmOyYgOyKteuLiOuLpC5cXHJcXG5cXHJcXG7stpTqsIDroZwg6raB6riI7ZWcIOygkOydtCDsnojsnLzsi5zrqbQg64yT6riAIOuCqOqyqOyjvOyEuOyalC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5Db3B5cmlnaHQ6IGxpa2VsaW9uU3VuZ0d1ayDsobDshLHqta1cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwiSmVreWxsIOu4lOuhnOq3uCDsobDtmozsiJgg67GD7KeAIOuLrOq4sCAtIEhJVFNcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDEuMDVcXFwiXFxyXFxudGFnczogXFxyXFxuICAtIGpla3lsbFxcclxcbiAgLSBibG9nXFxyXFxuICAtIGdpdGh1YiBwYWdlc1xcclxcbiAgLSDquYPtl5ntjpjsnbTsp4BcXHJcXG4gIC0g7KeA7YKsIOu4lOuhnOq3uFxcclxcbiAgLSBoaXRzXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyDrsKnrrLjsnpDsl5Dqsowg6rKM7Iuc6riAIOyhsO2ajOyImCDrs7Tsl6zso7zripTrspVcXHJcXG5cXHJcXG5KZWt5bGzqs7wg6rCZ7J2AIOygleyggSDruJTroZzqt7jripQg6rCE7Y647ZWcIOqyg+ydtCDsnqXsoJDsnoXri4jri6QuIO2VmOyngOunjCBEQuqwgCDsl4bquLAg65WM66y47JeQIOuIhOyggSDrsKnrrLjsnpAg7IiY66W8IOyytO2BrO2VmOq4sOqwgCDslrTroLXri6TripQg64uo7KCQ7J20IOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG7snbTqsoPsnYQg7ZW06rKw7ZWY6riwIOychO2VtOyEnOuKlCDsjajrk5ztjIzti7Ag7JWx7J24ICoqW0hJVFNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kd3lsL2hpdHMpKirrpbwg7IKs7Jqp7ZWY66m0IOqwhOuLqO2VmOqyjCDtlbTqsrDqsIDriqXtlanri4jri6QuXFxyXFxuXFxyXFxuICoqW0hJVFNdKGh0dHBzOi8vZ2l0aHViLmNvbS9kd3lsL2hpdHMpKirripQgZ2l0aHViIHJlcG9zaXRvcnnsl5Ag67Cp66y47ZWY64qUIOyCrOuejOuTpOydhCDshLjquLAg7JyE7ZWcIO2UhOuhnOygne2KuOuhnCDrp4zrk6TslrTsoYzri6Tqs6Ag7ZWp64uI64ukLiDslYTrnpgg7J2066+47KeA7JeQIO2RnOyLnOuQnCDrtoDrtoTsnYAgKipbSElUU10oaHR0cHM6Ly9naXRodWIuY29tL2R3eWwvaGl0cykqKuydmCBnaXRodWIgcmVwb3NpdG9yeeydmCBgUkVBRE1FLm1kYOydmCDrqqjsirXsnoXri4jri6QuXFxyXFxuXFxyXFxuIVtpbWFnZS0yMDIxMDEwNTEwMzQ0Njk3MV0oL2Fzc2V0cy9pbWcvaW1hZ2UtMjAyMTAxMDUxMDM0NDY5NzEucG5nKVxcclxcblxcclxcblxcclxcblxcclxcbiMjIyMgKiEg7KO87J2YICEg7ZiE7J6sIEhpdHPqsIAg65SU7Iqk7YGsIOuplOuqqOumrCDrrLjsoJzroZwg7KCV7IOB7KCB7Jy866GcIOyekeuPme2VmOqzoCDsnojsp4Ag7JWK7JWEIOyeoOyLnCDsgqzsmqnsnYQg67O066WY7ZW065GQ7JeI7Iq164uI64ukLiogXFxyXFxuXFxyXFxuIyMgamVreWxsIGJsb2fsl5DshJwgSGl0cyDsgqzsmqntlZjquLBcXHJcXG5cXHJcXG5IaXRz66W8ICDsgqzsmqntlZjquLAg7JyE7ZW07ISc64qUIOyggeygiO2VnCDsnITsuZjsl5Ag7JWE656Y7JmAIOqwmeydgCDsvZTrk5zrpbwg7IK97J6F7ZW07JW8IO2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBodG1sXFxyXFxuPGRpdiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+XFxyXFxuICAgIDxhXFxyXFxuICAgICAgIGhyZWY9XFxcImh0dHA6Ly9oaXRzLmR3eWwuY29tL3t7IHNpdGUudXJsIHwgcmVtb3ZlX2ZpcnN0OiAnaHR0cHM6Ly8nIHwgcmVtb3ZlX2ZpcnN0OiAnaHR0cDovLycgfX17eyBwYWdlLnVybCB9fVxcXCJcXHJcXG4gICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiXFxyXFxuICAgICA+XFxyXFxuICAgICA8aW1nXFxyXFxuICAgICAgIHNyYz1cXFwiaHR0cDovL2hpdHMuZHd5bC5jb20ve3sgc2l0ZS51cmwgfCByZW1vdmVfZmlyc3Q6ICdodHRwczovLycgfCByZW1vdmVfZmlyc3Q6ICdodHRwOi8vJyB9fXt7IHBhZ2UudXJsIH19LnN2Z1xcXCJcXHJcXG4gICAgIC8+XFxyXFxuICAgIDwvYT5cXHJcXG48L2Rpdj5cXHJcXG5gYGBcXHJcXG5cXHJcXG7soIDripQg7KCc66qp6rO8IOuzuOusuOydtCDsi5zsnpHtlZjripQg7IKs7J207JeQIOyCveyehe2VtOuztOyVmOyKteuLiOuLpC4g7KCB7KCI7ZWcIOychOy5mOulvCDssL7quLAg7JyE7ZW0IGDtgazroawg6rCc67Cc7J6Q64+E6rWsYOulvCDtmZzsmqntlbTshJwg7LC+7JWE67O07Iuc66m0IOuQqeuLiOuLpC5cXHJcXG5cXHJcXG7qt7zrjbAg6re4IOychOy5mOulvCDrgrQgYmxvZ+y9lOuTnCDrgrTsl5DshJwg7LC+64qUIOqyg+ydtCDsg53qsIHrs7Tri6Qg67O17J6h7ZWp64uI64ukLiDslYTrnpgg7J2066+47KeA66W8IOuztOyLnOuptOyEnCDtjIzsnbwg7Yq466as66W8IOywvuycvOyLnOuptCDsoovsirXri4jri6QuXFxyXFxuXFxyXFxuPiAnX2luY2x1ZGVzJyA+ICdfbWFjcm8nID4gJ3Bvc3QuaHRtbCdcXHJcXG5cXHJcXG4hW2ltYWdlLTIwMjEwMTA1MTAyODMxNjc0XSgvYXNzZXRzL2ltZy9pbWFnZS0yMDIxMDEwNTEwMjgzMTY3NC5wbmcpXFxyXFxuXFxyXFxu7ZW064u5IOychOy5mOyXkCDsgr3snoXtlZjrqbQg7JWE656YIOydtOuvuOyngOyZgCDqsJnsnbQg7KGw7ZqM7IiY6rCAIO2RnOyLnOuQqeuLiOuLpC5cXHJcXG5cXHJcXG4hWzExXSgvYXNzZXRzL2ltZy8xMS5wbmcpXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxucmVmZXJlbmNlc1xcclxcblxcclxcbltIaXRzIOyDneyEseq4sF0oaHR0cDovL2hpdHMuZHd5bC5pby8pXFxyXFxuXFxyXFxuW0hpdHMgR2l0aHViIHJlcG9zaXRvcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kd3lsL2hpdHMpXFxyXFxuXFxyXFxuW0hJVFMh66W8IOydtOyaqe2VmOyXrCBKZWt5bGwg67iU66Gc6re47JeQIOyhsO2ajOyImCDrsLDsp4Ag64us6riwXShodHRwczovL3J5YW5raW5nMTMuZ2l0aHViLmlvLzIwMjAvMDMvMDkvamVreWxsLXZpZXdzLWNvdW50LWJhZGdlLmh0bWwpXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIkphdmFzY3JpcHQg7J6Q7KO87JOw64qUIOuCtOyepSDtlajsiJgg67O17Iq17ZWY6riwXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjAzLjMxXFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSBqYXZhc2NyaXB0XFxyXFxuICAtIGpzXFxyXFxuICAtIHZhbmlsbGFKU1xcclxcbiAgLSBlczZcXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIOyekOyjvOyTsOuKlCBKUyDrgrTsnqXtlajsiJggOm1hcCwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXIsIGluZGV4T2YsIHNwbGljZSwgc2xpY2UsIHNoaWZ0ICYgcG9wLCBqb2luLCByZWR1Y2VcXHJcXG5cXHJcXG4jIyAxLiBtYXBcXHJcXG5cXHJcXG5tYXDsnYAg67Cw7Je0IOyViOydmCDqsIEg7JuQ7IaM66W8IOuzgO2ZmCDtlaAg65WMIOyCrOyaqSDrkJjrqbAsIOydtCDqs7zsoJXsl5DshJwg7IOI66Gc7Jq0IOuwsOyXtOydtCDrp4zrk6TslrTsp5Hri4jri6QuIOuwsOyXtC5tYXAoKVxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdO1xcclxcbmNvbnN0IHNxdWFyZSA9IG4gPT4gbioqMlxcclxcbmNvbnN0IHNxdWFyZWQgPSBhcnJheS5tYXAoc3F1YXJlKVxcclxcbmNvbnNvbGUubG9nKHNxdWFyZWQpXFxyXFxuXFxyXFxuLy8gWzEsICA0LCAgOSwgMTYsIDI1LCAzNiwgNDksIDY0XVxcclxcbmBgYFxcclxcblxcclxcbi0gbWFw7JWI7JeQIOuTpOyWtOqwgOuKlCBzcXVhcmXqsJnsnYAg7ZWo7IiY66W8IGDrs4DtmZTtlajsiJhg65286rOgIO2VnOuLpC5cXHJcXG4tIOuzgO2ZlO2VqOyImOulvCDsk7Dsp4Ag7JWK6rOgIOuwlOuhnCDtlbTrj4Qg65Cc64ukXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgYXJyYXkgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOF07XFxyXFxuY29uc3Qgc3F1YXJlZCA9IGFycmF5Lm1hcChuID0+IG4qKjIpXFxyXFxuY29uc29sZS5sb2coc3F1YXJlZClcXHJcXG4vLyDqsrDqs7zripQg6rCZ64ukLiBbMSwgIDQsICA5LCAxNiwgMjUsIDM2LCA0OSwgNjRdXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgMi4gaW5kZXhPZlxcclxcblxcclxcbmluZGV4T2Yg64qUIOybkO2VmOuKlCDtla3rqqnsnbQg67Cw7Je0IOuCtCDrqofrsojsp7gg7JuQ7IaM7J247KeAIOywvuyVhOyjvOuKlCDtlajsiJjsnoXri4jri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3Qgc3VwZXJoZXJvZXMgPSBbJ+yVhOydtOyWuOunqCcsICfsuqHti7Qg7JWE66mU66as7Lm0JywgJ+2GoOultCcsICfri6XthLAg7Iqk7Yq466CI7J247KeAJ11cXHJcXG5jb25zdCBpbmRleCA9IHN1cGVyaGVyb2VzLmluZGV4T2YoJ+2GoOultCcpXFxyXFxuY29uc29sZS5sb2coaW5kZXgpXFxyXFxuLy8gMlxcclxcbmBgYFxcclxcblxcclxcbiMjIDMuIGZpbmRJbmRleCAtIOywvuyVhOuCuCDqsJLsnZggaW5kZXjrpbwg67CY7ZmYXFxyXFxuXFxyXFxu67Cw7Je0IOyViOyXkCDsnojripQg6rCS7J20IOqwneyytOydtOqxsOuCmCwg67Cw7Je07J20652866m0IGluZGV4T2Yg66GcIOywvuydhCDsiJgg7JeG7Iq164uI64ukLiDsnbTrn7Qg65WMIGZpbmRJbmRleOulvCDsgqzsmqntlanri4jri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8gdG9kb3Psl5DshJwgaWTqsIAgM+yduCDqsJ3ssrTqsIAg66qHIOuyiOynuCDsnbjsp4Ag7LC+6riwXFxyXFxuXFxyXFxuY29uc3QgdG9kb3MgPSBbXFxyXFxuICB7XFxyXFxuICAgIGlkOiAxLFxcclxcbiAgICB0ZXh0OiAn7J6Q67CU7Iqk7YGs66a97Yq4IOyeheusuCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAyLFxcclxcbiAgICB0ZXh0OiAn7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAzLFxcclxcbiAgICB0ZXh0OiAn6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogNCxcXHJcXG4gICAgdGV4dDogJ+uwsOyXtCDrgrTsnqXtlajsiJgg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogZmFsc2VcXHJcXG4gIH1cXHJcXG5dO1xcclxcblxcclxcbmNvbnN0IGluZGV4ID0gdG9kb3MuZmluZEluZGV4KHRvZG8gPT4gdG9kby5pZCA9PT0gMyk7XFxyXFxuY29uc29sZS5sb2coaW5kZXgpO1xcclxcblxcclxcbi8vIDJcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA0LiBmaW5kIC0g7LC+7JWE64K4IOqwkiDsnpDssrTrpbwg67CY7ZmYXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgdG9kb3MgPSBbXFxyXFxuICB7XFxyXFxuICAgIGlkOiAxLFxcclxcbiAgICB0ZXh0OiAn7J6Q67CU7Iqk7YGs66a97Yq4IOyeheusuCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAyLFxcclxcbiAgICB0ZXh0OiAn7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IHRydWVcXHJcXG4gIH0sXFxyXFxuICB7XFxyXFxuICAgIGlkOiAzLFxcclxcbiAgICB0ZXh0OiAn6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogNCxcXHJcXG4gICAgdGV4dDogJ+uwsOyXtCDrgrTsnqXtlajsiJgg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogZmFsc2VcXHJcXG4gIH1cXHJcXG5dO1xcclxcblxcclxcbmNvbnN0IHRvZG8gPSB0b2Rvcy5maW5kKHRvZG8gPT4gdG9kby5pZCA9PT0gMyk7XFxyXFxuY29uc29sZS5sb2codG9kbyk7XFxyXFxuXFxyXFxuLy8ge2lkOiAzLCB0ZXh0OiBcXFwi6rCd7LK07JmAIOuwsOyXtCDrsLDsmrDquLBcXFwiLCBkb25lOiB0cnVlfVxcclxcbmBgYFxcclxcblxcclxcbiMjIDUuIGZpbHRlclxcclxcblxcclxcbu2KueyglSDsobDqsbTsnYQg66eM7KGx7ZWY64qUIOqwkuuTpOunjCDrlLDroZwg7LaU7Lac7ZWY7JesIOyDiOuhnOyatCDrsLDsl7TsnYQg66eM65Ot64uI64ukLlxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IHRvZG9zID0gW1xcclxcbiAge1xcclxcbiAgICBpZDogMSxcXHJcXG4gICAgdGV4dDogJ+yekOuwlOyKpO2BrOumve2KuCDsnoXrrLgnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogMixcXHJcXG4gICAgdGV4dDogJ+2VqOyImCDrsLDsmrDquLAnLFxcclxcbiAgICBkb25lOiB0cnVlXFxyXFxuICB9LFxcclxcbiAge1xcclxcbiAgICBpZDogMyxcXHJcXG4gICAgdGV4dDogJ+qwneyytOyZgCDrsLDsl7Qg67Cw7Jqw6riwJyxcXHJcXG4gICAgZG9uZTogdHJ1ZVxcclxcbiAgfSxcXHJcXG4gIHtcXHJcXG4gICAgaWQ6IDQsXFxyXFxuICAgIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsXFxyXFxuICAgIGRvbmU6IGZhbHNlXFxyXFxuICB9XFxyXFxuXTtcXHJcXG5cXHJcXG5jb25zdCB0YXNrc05vdERvbmUgPSB0b2Rvcy5maWx0ZXIodG9kbyA9PiB0b2RvLmRvbmUgPT09IGZhbHNlKTtcXHJcXG5jb25zb2xlLmxvZyh0YXNrc05vdERvbmUpO1xcclxcbi8qIFxcclxcbnRvZG8uZG9uZeydtCBmYWxzZeyduCB7aWQ6IDQsIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsIGRvbmU6IGZhbHNlfSBcXHJcXG7qsJ3ssrTrp4wg7IOI66Gc7Jq0IOuwsOyXtCh0YXNrTm90RG9uZSkg7JWI7JeQIOuTpOyWtOqwhOuLpC5cXHJcXG5bIHsgaWQ6IDQsIHRleHQ6ICfrsLDsl7Qg64K07J6l7ZWo7IiYIOuwsOyasOq4sCcsIGRvbmU6IGZhbHNlIH0gXVxcclxcblxcclxcbiovXFxyXFxuXFxyXFxuLy8gIOydtOugh+qyjCDtkZztmITtlaAg7IiY64+EIOyeiOuLpC5cXHJcXG5jb25zdCB0YXNrc05vdERvbmUgPSB0b2Rvcy5maWx0ZXIodG9kbyA9PiAhdG9kby5kb25lKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA2LiBzcGxpY2VcXHJcXG5cXHJcXG7rsLDsl7Tsl5DshJwg7Yq57KCVIO2VreuqqeydhCDsoJzqsbDtlaAg65WMIOyCrOyaqeuQnOuLpC4g7J24642x7IqkIOqwkuycvOuhnCDsp4DsmrDripQg6rKD7J206riwIOuVjOusuOyXkCDsnbjrjbHsiqTrpbwg66i87KCAIOq1rO2VmOqzoCDtlbTri7kg7J24642x7Iqk66Gc67aA7YSwIOuqhyDqsJzrgpgg7KeA7Jq4IOqyg+yduOyngCDshKDtg53tlZjsl6wg7Jes65+s6rCS7J2EIO2VnCDrsojsl5Ag7KeA7Jq4IOyImCDsnojri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY29uc3QgbnVtYmVycyA9IFsxMCwgMjAsIDMwLCA0MF07XFxyXFxuY29uc3QgaW5kZXggPSBudW1iZXJzLmluZGV4T2YoMzApO1xcclxcbm51bWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcXHJcXG5jb25zb2xlLmxvZyhudW1iZXJzKTtcXHJcXG5cXHJcXG4vLyAzMOydmCBpbmRleCA9IDLsnbTqs6AgMuuyiOynuCDsnbjrjbHsiqTroZzrtoDthLAg7ZWcIOqwnOydmCDqsJLsnYQg7KeA7Jqw66+A66GcIDMw66eMIOyngOybjOynhOuLpC5cXHJcXG4vLyBbMTAsIDIwLCA0MF1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA3LiBzbGljZVxcclxcblxcclxcbuq4sOyhtCDrsLDsl7Tsl5Ag67OA7ZmU66W8IOydvOycvO2CpOyngCDslYrqs6Ag7Iqs65287J207IuxIO2VmOyXrCDsg4jroZzsmrQg67Cw7Je07J2EIOyDneyEse2VnOuLpC5cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5jb25zdCBudW1iZXJzID0gWzEwLCAyMCwgMzAsIDQwXTtcXHJcXG5jb25zdCBzbGljZWQgPSBudW1iZXJzLnNsaWNlKDAsIDIpOyAvLyAw67aA7YSwIOyLnOyeke2VtOyEnCAy7KCE6rmM7KeAXFxyXFxuXFxyXFxuY29uc29sZS5sb2coc2xpY2VkKTsgLy8gWzEwLCAyMF1cXHJcXG5jb25zb2xlLmxvZyhudW1iZXJzKTsgLy8gWzEwLCAyMCwgMzAsIDQwXVxcclxcbmBgYFxcclxcblxcclxcbiMjIDguIHNoaWZ0ICYgcG9wXFxyXFxuXFxyXFxuc2hpZnTripQg67Cw7Je07J2YIOyyqyDrsojsp7gg6rCS7J2EIOu9keyVhOuCtOqzoCwgcG9w7J2AIOunqCDrkqTsnZgg6rCS7J2EIOu9keyVhOuCuOuLpC4gcHl0aG9u6rO8IOu5hOq1kO2VmOuptCBzaGlmdCA9IHBvcCgwKSwgcG9w7J2AIOuYkeqwmeuLpC5cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5jb25zdCBudW1iZXJzID0gWzEwLCAyMCwgMzAsIDQwXTtcXHJcXG5jb25zdCB2YWx1ZSA9IG51bWJlcnMuc2hpZnQoKTtcXHJcXG5jb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDEwXFxyXFxuY29uc3QgdmFsdWUyID0gbnVtYmVycy5wb3AoKTtcXHJcXG5jb25zb2xlLmxvZyh2YWx1ZTIpOyAvLyA0MFxcclxcbmNvbnNvbGUubG9nKG51bWJlcnMpOyAvL1syMCwgMzBdXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgOS4gam9pblxcclxcblxcclxcbuuwsOyXtCDslYjsnZgg6rCS65Ok7J2EIOusuOyekOyXtCDtmJXtg5zroZwg7ZWp7LOQ7KSN64uI64ukLlxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IGFycmF5ID0gWzEsIDIsIDMsIDQsIDVdO1xcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oKSk7IC8vIDEsMiwzLDQsNVxcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oJyAnKSk7IC8vIDEgMiAzIDQgNVxcclxcbmNvbnNvbGUubG9nKGFycmF5LmpvaW4oJywgJykpOyAvLyAxLCAyLCAzLCA0LCA1XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgMTAuIHJlZHVjZVxcclxcblxcclxcbuuwsOyXtOydmCDqsIEg7JqU7IaM7JeQIOuMgO2VtCDso7zslrTsp4Qg66as65OA7IScKHJlZHVjZXIpIO2VqOyImOulvCDsi6TtlontlZjqs6AsIO2VmOuCmOydmCDqsrDqs7zqsJLsnYQg67CY7ZmY7ZWp64uI64ukLiDslZ7snZgg66y47J6l66eMIOydveyWtOyEnOuKlCDsnbTtlbTtlZjquLAg7Ja066Ck7Jq0642wLCDrgrTqsIAg7KeA7KCV7ZW07KSAIO2VqOyImOulvCDsi6Ttlokg7ZuEIOuCmOyYqCDqsrDqs7zqsJLsnYQg64uk7IucIO2MjOudvOuvuO2EsOuhnCDsgqzsmqntlZjrj4TroZ0g7ZWp64uI64ukLiDslYTrnpgg7JiI66W8IO2Gte2VtCDsnbTtlbTtlbTrtIXsi5zri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8g6riw7KG0IOuwqeyLnVxcclxcbmNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV07XFxyXFxuXFxyXFxubGV0IHN1bSA9IDA7XFxyXFxubnVtYmVycy5mb3JFYWNoKG4gPT4ge1xcclxcbiAgc3VtICs9IG47XFxyXFxufSk7XFxyXFxuY29uc29sZS5sb2coc3VtKTsgIC8vMTVcXHJcXG5cXHJcXG4vL3JlZHVjZeulvCDsgqzsmqntlZjripQg67Cp7IudXFxyXFxuY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0LCA1XTtcXHJcXG5sZXQgc3VtID0gYXJyYXkucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4gYWNjdW11bGF0b3IgKyBjdXJyZW50LCAwKTtcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhzdW0pOyAgLy8xNVxcclxcbmNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNCwgNV07XFxyXFxubGV0IHN1bSA9IG51bWJlcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudCkgPT4ge1xcclxcbiAgY29uc29sZS5sb2coeyBhY2N1bXVsYXRvciwgY3VycmVudCB9KTtcXHJcXG4gIHJldHVybiBhY2N1bXVsYXRvciArIGN1cnJlbnQ7XFxyXFxufSwgMCk7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coc3VtKTtcXHJcXG5cXHJcXG4vLyDqsrDqs7xcXHJcXG57IGFjY3VtdWxhdG9yOiAwLCBjdXJyZW50OiAxIH1cXHJcXG57IGFjY3VtdWxhdG9yOiAxLCBjdXJyZW50OiAyIH1cXHJcXG57IGFjY3VtdWxhdG9yOiAzLCBjdXJyZW50OiAzIH1cXHJcXG57IGFjY3VtdWxhdG9yOiA2LCBjdXJyZW50OiA0IH1cXHJcXG57IGFjY3VtdWxhdG9yOiAxMCwgY3VycmVudDogNSB9XFxyXFxuMTVcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG4qKnJlZmVyZW5jZXMqKlxcclxcblxcclxcbltMZWFybkpTIEdpdEJvb2tdKGh0dHBzOi8vbGVhcm5qcy52bHB0LnVzL2Jhc2ljcy8wOS1hcnJheS1mdW5jdGlvbnMuaHRtbClcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwiRVMyMDIxIOy1nOyLoCDsnpDrsJTsiqTtgazrpr3tirgg7IOI66Gt6rKMIOy2lOqwgOuQnCDquLDriqUg7IK07Y6067O06riwXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA4LjAzXFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgICAtIGphdmFzY3JpcHRcXHJcXG4gICAgLSDsnpDrsJTsiqTtgazrpr3tirhcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIEVTMjAyMSDstZzsi6Ag7J6Q67CU7Iqk7YGs66a97Yq4IOyDiOuhreqyjCDstpTqsIDrkJwg6riw64ql7J2EIOyVjOyVhOuztOyekFxcclxcblxcclxcbiMjIHJlcGxhY2VBbGxcXHJcXG5cXHJcXG5TdHJpbmfsnYQg67OA6rK97ZW07KO864qUIHJlcGxhY2XsnZggdXBncmFkZSDrsoTsoITsnbTri6QuIFxcclxcblxcclxcbifqt7jrg6UgcmVwbGFjZeyTsOuptCDrkJjripTqsbAg7JWE64uI7JW8Pyfrnbzqs6Ag7IOd6rCB7ZWgIOyImCDsnojsp4Drp4wg7Yq57IiY66y47J6Q6rCAIOuTpOyWtOqwhCDqsr3smrAg7KCV6rec7ZGc7ZiE7Iud7J2EIOyNqOyVvO2VtOyEnCDri6Tshowg67O17J6h7ZW07KeA64qUIOqyveyasOqwgCDrp47snYDrjbAsIHJlcGxhY2VBbGzsnbQg7J6I7Jy866m0IO2bqOyUrCDqsITtjrjtlZjri6QuIOu5hOq1kO2VtOyEnCDrs7TsnpAuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuPiBNaWtl7JmAIENhcuyVnuuSpOuhnCDsnojripQg64yA6rSE7Zi466W8IOykkeq0hO2YuOuhnCDrsJTqv5Trs7TsnpAuXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIHJlcGxhY2VcXHJcXG5jb25zdCBzdHIxID0gXFxcIkknbSBbTWlrZV0uIFRoaXMgaXMgVG9tJ3MgW0Nhcl1cXFwiO1xcclxcbnN0cjEucmVwbGFjZSgvXFxcXFsvZywgXFxcIn5cXFwiKS5yZXBsYWNlKC9cXFxcXS9nLCBcXFwiflxcXCIpO1xcclxcbmBgYFxcclxcblxcclxcbuydtOugh+qyjCDsoJXqt5ztkZztmITsi53snYQg7I2o7IScIOuMgOq0hO2YuOydmCDqsIHqsIEnWycgLCAnXSfsnYQg7ISk7KCV7ZWY6rOgICdnJ+uhnCDrqqjrk6Ag7ZW064u5IOq4sO2YuOulvCDshKDtg53tlZwg65KkIOuzgOqyve2VtOykmOyVvO2VnOuLpC5cXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gcmVwbGFjZUFsbFxcclxcbmNvbnN0IHN0cjIgPSBcXFwiSSdtIFtNaWtlXS4gVGhpcyBpcyBUb20ncyBbQ2FyXVxcXCI7XFxyXFxuc3RyMi5yZXBsYWNlQWxsKFxcXCJbXFxcIiwgXFxcIn5cXFwiKS5yZXBsYWNlQWxsKFxcXCJdXFxcIiwgXFxcIn5cXFwiKVxcclxcbmBgYFxcclxcblxcclxcbuygleq3nO2RnO2YhOyLneydhCDsk7gg7ZWE7JqU7JeG7J20IOyngeq0gOyggeycvOuhnCDsib3qsowg7IKs7Jqp7J20IOqwgOuKpe2VmOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBQcm9taXNlLmFueVxcclxcblxcclxcbnByb21pc2UucmFjZeydmCDqsr3smrAg6rCA7J6lIOu5oOultOqyjCDsspjrpqzrkJjripQg6rCd7LK066W8IOuwmO2ZmO2VqeuLiOuLpC5cXHJcXG5cXHJcXG7smIjrpbwg65Ok7Ja0IOuRkCDqsJzsnZggUHJvbWlzZeyalOyyreydtCDsnojsnYQg6rK97JqwLCBSZWplY3TrkJwg7JqU7LKt7J20IOuNlCDruaDrpbTqsowg64+E7LCp7ZWc64uk66m0IHByb21pc2UucmFjZeuKlCAnUmVqZWN0J+ulvCDrsJjtmZgg7ZWgIOqyg+yeheuLiOuLpC5cXHJcXG5cXHJcXG7tlZjsp4Drp4wg7Jqw66as64qUIOyXrOufrOqwnOydmCDsmpTssq0g7KSRIO2VmOuCmOunjOydtOudvOuPhCDshLHqs7XtlZjripTqsowg7J6I64qU7KeAIOyVjOqzoCDsi7bsnYQg65WM6rCAIOyeiOyKteuLiOuLpC4g7J20IOqyveyasCDsg4jroZwg7IOd6ri0IGBQcm9taXNlLmFueWDrpbwg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIDEuIFxcclxcbmNvbnN0IEZhaWwgPSBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IHtcXHJcXG4gICAgc2V0VGltZU91dCgoKT0+IHtcXHJcXG4gICAgICAgIHJlamVjdChcXFwiZmFpbC4uXFxcIilcXHJcXG4gICAgfSwgMTAwMClcXHJcXG59KVxcclxcbmNvbnN0IFN1Y2Nlc3MgPSBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IHtcXHJcXG4gICAgc2V0VGltZU91dCgoKT0+IHtcXHJcXG4gICAgICAgIHJlcyhcXFwic3VjY2VzcyFcXFwiKVxcclxcbiAgICB9LCAyMDAwKVxcclxcbn0pXFxyXFxuXFxyXFxuY29uc3QgcHJvbWlzZVJhY2UgPSBQcm9taXNlLnJhY2UoW0ZhaWwsIFN1Y2Nlc3NdKVxcclxcbi8vIGxvZyAtPiBmYWlsLi5cXHJcXG5jb25zdCBwcm9taXNlQW55ID0gUHJvbWlzZS5hbnkoW0ZhaWwsIFN1Y2Nlc3NdKVxcclxcbi8vIGxvZyAtPiBzdWNlc3MhXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgfHw9ICwgJiY9ICwgPz89XFxyXFxuXFxyXFxu7KCV7Iud66qF7Lmt7J2AIGBMb2dpY2FsIEFzc2lnbm1lbnQgT3BlcmF0b3JgIOyeheuLiOuLpC4gXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIDEuIHx8PVxcclxcbiAgICBuYW1lID0gbmFtZSB8fCAnYW5vbnltb3VzJ1xcclxcbuychCDsvZTrk5zripQg64uk7J2M6rO8IOqwmeydtCDsk7Dsnbwg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG4gICAgbmFtZSB8fD0gJ2Fub255bW91cydcXHJcXG5cXHJcXG4vLyAyLiAmJj1cXHJcXG4gICAgbmFtZSA9IG5hbWUgJiYgYEhlbGxvICR7bmFtZX1gXFxyXFxuXFx0XFx0XFx0PT09XFxyXFxuICAgIG5hbWUgJiY9IGBIZWxsbyAke25hbWV9YDtcXHJcXG5cXHJcXG4vLyAzLiA/Pz0gKE51bGzrs5Htlansl7DsgrDsnpApXFxyXFxuXFx0bmFtZSA9IG5hbWUgPz8gXFxcIk1pa2VcXFwiO1xcclxcblxcdG5hbWUgPz89IFxcXCJNaWtlXFxcIlxcclxcbmBgYFxcclxcblxcclxcbi0gTnVsbCDrs5Htlakg7Jew7IKw7J6Q7JmAIE9S7J2YIOywqOydtOuKlCDri6TsnYzqs7wg6rCZ64ukLlxcclxcblxcclxcbiAgLSBgKip8fCoqYCA6IOyVnuydmCDqsJLsnbQgZmFsc3nsnbTrqbQg65Kk7J2YIOqwklxcclxcbiAgLSBgKio/PyoqYCA6IOyVnuydmCDqsJLsnbQgbnVsbOydtOuCmCB1bmRlZmluZWQg7J2066m0IOuSpOydmCDqsJIgXFxyXFxuXFxyXFxuICBgYGBqYXZhc2NyaXB0XFxyXFxuICBsZXQgbnVtID0gMFxcclxcbiAgbGV0IGEgPSBudW0gfHwgM1xcclxcbiAgLy8gYeuKlD9cXHJcXG4gIC8vIC0+IGEgPSAzXFxyXFxuICBcXHJcXG4gIGxldCBiID0gbnVtID8/IDNcXHJcXG4gIC8vIGLripQ/IFxcclxcbiAgLy8gLT4gYiA9IDBcXHJcXG4gIG51bGzsnbTrgpggdW5kZWZpbmVk6rCAIOyVhOuLiOuvgOuhnCBudW0oMCnsnbQgYuqwgCDrkJzri6QuXFxyXFxuICBgYGBcXHJcXG5cXHJcXG4gIFxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLsnpDrsJTsiqTtgazrpr3tirgg7ZSE66Gc7JmAIOuCmOydmCDssKjsnbTripQuLi4/XFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA4LjA1XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgICAtIGphdmFzY3JpcHRcXHJcXG4gICAgLSDsnpDrsJTsiqTtgazrpr3tirhcXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG4jIOyekOuwlOyKpO2BrOumve2KuOulvCDtlITroZzsspjrn7wg7IS466Co65CY6rKMIOyTsOuKlCDrspVcXHJcXG7snKDtipzruIwg65Oc66a87L2U65SpIOyXmOumrCDsmIHsg4HsnYQg67O064ukIOyii+ydgCDrgrTsmqnsnbQg7J6I7Ja0IOygleumrO2VmOyXrCDqs7XsnKDtlanri4jri6QuXFxyXFxuXFxyXFxuW1RPQ11cXHJcXG5cXHJcXG5cXHJcXG4jIyDsobDqsbTrrLjsl5DshJwg7KGw6rG07J20IOuRkCDqsJzrnbzrqbQg6rO86rCQ7ZWY6rKMIOyCvO2VreyXsOyCsOyekCDsgqzsmqlcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gbm90IGdvb2QuLi5cXHJcXG5mdW5jdGlvbiAoc2NvcmUpIHtcXHJcXG5cXHRpZiAoc2NvcmUgPiA1KSB7XFxyXFxuICAgICAgICByZXN1bHQgPSAndGh1bWJ1cCdcXHJcXG4gICAgfSBlbHNlIGlmIHtcXHJcXG4gICAgICAgIHJlc3VsdCA9ICd0aHVtYmRvd24nXFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIHJlc3VsdDtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLy8gQmV0dGVyICEhXFxyXFxuZnVuY3Rpb24gKHNjb3JlKSB7XFxyXFxuXFx0cmV0dXJuIHNjb3JlID4gNSA/ICd0aHVtYnVwJzogJ3RodW1iZG93bic7XFxyXFxufVxcclxcblxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcbiMjIE51bGxpc2ggQ29hbGVzY2luZyBvcGVyYXRvcuulvCDsgqzsmqntlbTrs7TsnpBcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gbm90IGdvb2QuLi5cXHJcXG5mdW5jdGlvbiBwcmludE1lc3NhZ2UodGV4dCkge1xcclxcbiAgICBsZXQgbWVzc2FnZSA9IHRleHQ7XFxyXFxuICAgIGlmICh0ZXh0ID09IG51bGwgfHwgdGV4dCA9PSB1bmRlZmluZWQpIHtcXHJcXG4gICAgICAgIG1lc3NhZ2UgPSAnTm90aGluZyB0byBkaXNwbGF5JztcXHJcXG4gICAgfVxcclxcbiAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLy8gQmV0dGVyICFcXHJcXG5mdW5jdGlvbiBwcmludE1lc3NhZ2UodGV4dCkge1xcclxcbiAgICBjb25zdCBtZXNzYWdlID0gdGV4dCA/PyAnTm90aGluZyB0byBEaXNwbGF5JztcXHJcXG4gICAgY29uc29sZS5sb2cobWVzc2FnZSk7XFxyXFxufVxcclxcblxcclxcbmBgYFxcclxcblxcclxcbi0g7JyEIOy9lOuTnOyZgCDslYTrnpgg7L2U65Oc64qUIOuPmeydvO2VmOqyjCDrj5nsnpHtlZzri6QuXFxyXFxuLSB0ZXh06rCAIG51bGwgb3IgdW5kZWZpbmVk7J2066m0ICdOb3RoaW5nIHRvIERpc3BsYXkn66W8IO2VoOuLue2VmOuKlCDsvZTrk5zsnbjrjbAsIOychCDsvZTrk5zripQgbWVzc2FnZeulvCDsnbzri6gg67Cb6rOgLCBudWxsL3VuZGVmaW5lZCBjaGVjayDtm4QgbWVzc2FnZeyXkCDtlaDri7ntlZzri6QuXFxyXFxuLSDtlZjsp4Drp4wg7JWE656YIOy9lOuTnCDqsJnsnYAg6rK97JqwIHRleHTrpbwg67CU66GcIOyytO2BrO2VmOyXrCBtZXNzYWdl7JeQIOyEoOyWuOqzvCDtlaDri7nsnbQg64+Z7Iuc7JeQIOqwgOuKpe2VmOq4sCDrlYzrrLjsl5AgbWVzc2FnZeulvCBjb25zdOuhnCDshKDslrjtlaAg7IiYIOyeiOqzoCDqsIDrj4XshLHrj4Qg7KKL64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyBMb2dpY2FsIE9wZXJhdG9yIE9SPHx8PuyZgCBOdWxsaXNoIENvYWxlc2NpbmcgT3BlcmF0b3LsnZgg7LCo7J20XFxyXFxuXFxyXFxuKipPUioqXFxyXFxuXFxyXFxuLSBMZWZ0OiBmYWxzeSDtlZjrqbQg7Jik66W47Kq97J20IHRydWVcXHJcXG5cXHJcXG4qKk51bGxpc2ggQ29hbGVzY2luZyAoPz8pKipcXHJcXG5cXHJcXG4tIExlZnQ6IG51bGwsIHVuZGVmaWVuZCDsnbTrqbQg7Jik66W47Kq97J20IHRydWVcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5udWxsICYgdW5kZWZpbmVk64qUIOuqqOuRkCBmYWxzeeyXkCDtj6ztlajrkJzri6QuIOydtOyZuOyXkOuPhCAwLCAtMCwgTmFOLCDruYjrrLjsnpDsl7QoJycpIOuTseuPhCDrqqjrkZAgZmFsc3nsl5Ag7Y+s7ZWo65Cc64ukLiDri6Tsi5wg66eQ7ZW0IGZhbHN56rCAIOyigCDrjZQg6rSR67KU7JyE7ZWcIOuylOychOulvCDtj6zqtITtlZzri6QuXFxyXFxuXFxyXFxuKirrlLDrnbzshJwg65GQIOyXsOyCsOyekOqwgCDruYTsirftlbTrs7TsnbTsp4Drp4wg7KGw6riIIOuLpOuluCDqsrDqs7zrpbwg7LSI656Y7ZWgIOyImCDsnojsnLzrr4DroZwg7LCo7J2066W8IOygle2Zle2VmOqyjCDsnbTtlbTtlZjqs6Ag7IKs7Jqp7ZWY64qUIOqyg+ydtCDspJHsmpTtlZjri6QhKipcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBPYmplY3QgRGVzdHJ1Y3R1cmluZ+ycvOuhnCDrs4DsiJgg7ZWg64u5L+yEoOyWuO2VmOq4sFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vLyBOb3QgZ29vZC4uLlxcclxcbmZ1bmN0aW9uIGRpc3BsYXlQZXJzb24ocGVyc29uKSB7XFxyXFxuICAgIGNvbnN0IG5hbWUgPSBwZXJzb24ubmFtZTtcXHJcXG4gICAgY29uc3QgYWdlID0gcGVyc29uLmFnZTtcXHJcXG4gICAgZGlzcGxheUF2YXRhcihuYW1lKTtcXHJcXG4gICAgZGlzcGxheU5hbWUobmFtZSk7XFxyXFxuICAgIGRpc3BsYXlQcm9maWxlKG5hbWUsIGFnZSk7XFxyXFxufVxcclxcblxcclxcbi8vIEJldHRlciAhIVxcclxcbmZ1bmN0aW9uIGRpc3BsYXlQZXJzb24ocGVyc29uKSB7XFxyXFxuICAgIGNvbnN0IHsgbmFtZSwgYWdlIH0gPSBwZXJzb247XFxyXFxuICAgIGRpc3BsYXlBdmF0YXIobmFtZSk7XFxyXFxuICAgIGRpc3BsYXlOYW1lKG5hbWUpO1xcclxcbiAgICBkaXNwbGF5UHJvZmlsZShuYW1lLCBhZ2UpO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBPYmplY3Qg6rKw7ZWp7J2AIE9iamVjdC5hc3NpZ24g7Zi57J2AIFNwcmVhZCBTeW50YXjrpbwg7IKs7Jqp7ZWY7J6QXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIE5vdCBHb29kLi4uXFxyXFxuY29uc3QgaXRlbSA9IHtcXHJcXG4gICAgLi4uXFxyXFxufVxcclxcbmNvbnN0IGRldGFpbCA9IHtcXHJcXG5cXHQuLi4gICAgXFxyXFxufVxcclxcblxcclxcbmNvbnN0IG5ld09iamVjdCA9IHtcXHJcXG4gICAgdHlwZTogaXRlbS50eXBlLFxcclxcbiAgICBzaXplOiBpdGVtLnNpemUsXFxyXFxuICAgIHByaWNlOiBkZXRhaWwucHJpY2UsXFxyXFxuICAgIG1hZGU6IGRldGFpbC5tYWRlLFxcclxcbiAgICBnZW5kZXI6IGRldGFpbC5nZW5kZXJcXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuLy8gQmV0dGVyICEhXFxyXFxuIC8vIDEuIE9iamVjdC5hc3NpZ25cXHJcXG5jb25zdCBuZXdPYmogPSBPYmplY3QuYXNzaWduKGl0ZW0sIGRldGFpbCk7XFxyXFxuXFxyXFxuIC8vIDIuIFNwcmVhZCBTeW50YXhcXHJcXG5jb25zdCBuZXdPYmoyID0gey4uLml0ZW0sIC4uLmRldGFpbH07XFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgT3B0aW9uYWwgQ2hhaW5pbmdcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gTm90IGdvb2QuLi5cXHJcXG5mdW5jdGlvbiBkaXNwbGF5Sm9iVGl0bGUocGVyc29uKSB7XFxyXFxuICAgIGlmIChwZXJzb24uam9iICYmIHBlcnNvbi5qb2IudGl0bGUpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHBlcnNvbi5qb2IudGl0bGUpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8vIEJldHRlciAhIVxcclxcbmZ1bmN0aW9uIGRpc3BsYXlKb2JUaXRsZShwZXJzb24pIHtcXHJcXG4gXFx0aWYgKHBlcnNvbi5qb2I/LnRpdGxlKXtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHBlcnNvbi5qb2IudGl0bGUpXFxyXFxuXFx0fSAgIFxcclxcbn1cXHJcXG5cXHJcXG4vLyBPcHRpb25hbCBDaGFpbmluZyArIE51bGxpc2ggQ29hbGVzY2luZ1xcclxcbmZ1bmN0aW9uIGRpc3BsYXlKb2JUaXRsZShwZXJzb24pIHtcXHJcXG4gXFx0Y29uc3QgdGl0bGUgPSBwZXJzb24uam9iPy50aXRsZSA/PyAnTm8gSm9iIHlldCdcXHJcXG5cXHRjb25zb2xlLmxvZyh0aXRsZSlcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuLSDsnbQg64K07Jqp7J2AIOyYpOuKmCDrgq7sl5Drj4Qg64K06rCAIE5vdCBHb29k7Jy866GcIOy9lOuTnOulvCDsp7DrjZgg64K07Jqp7J207JeI7Ja07IScIOuNlOyasSDqs7XqsJDtlZjrqbAg65Ok7JeI642YIOuCtOyaqeyeheuLiOuLpC5cXHJcXG4tIHBlcnNvbuyXkCBqb2LsnbQg7J6I7J2EIOyImOuPhCDsnojqs6AsIOyXhuydhCDsiJjrj4Qg7J6I64qUIOqyveyasCDsnbzri6ggcGVyc29uLmpvYuydhCDrqLzsoIAg7LK07YK57ZWY6rOgIHBlcnNvbi5qb2IudGl0bGXsnYQg7LK07YK57ZWY64qUIOy9lOuTnOyeheuLiOuLpC4g7J206rKMIOydvOuwmOyggeycvOuhnCDsoJXrp5Ag66eO7J20IOyCrOyaqeuQqeuLiOuLpC4g7Yq57Z6IIHR5cGVzY3JpcHTsmYAg7ZWo6ruYIOyTsOydtOuptCBqb2LsnbTrgpggam9iLnRpdGxl7J20IG51bGwgb3IgdW5kZWZpbmVkIOuQoCDsiJgg7J6I7Ja07IScIOydtCDrgrTsmqnsl5Ag7YOA7J6F7J2EIOuvuOumrCDshKTsoJXtlbTso7zripQg6rKD7J20IOyDneqwgeuztOuLpCDqs6Dsl63snoXri4jri6QuXFxyXFxuLSA/66W8IO2Gte2VtOyEnCBwZXJzb24uam9i7J20IOyeiOuKlOyngCDsl4bripTsp4Drpbwg64+Z7Iuc7JeQIOyymOumrO2VoCDsiJgg7J6I6rKMIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG4tIOqwgOyepSDslYTrnpjsl5DripQgb3B0aW9uYWwgY2hhaW5pbmfqs7wgTnVsbHNpaCBDb2FsZXNjaW5n7J2EIO2VnCDrsojsl5Ag7IKs7Jqp7ZWY64qUIOqyveyasOyeheuLiOuLpC4gcGVyc29uLmpvYuydtCDsnojripTsp4Ag7LK07YGs7ZWY6rOgIHBlcnNvbi5qb2IudGl0bGXsnbQg7J6I64qU7KeA6rmM7KeAIO2VnCDrsojsl5Ag7LK07YGs7ZW07IScIOyXhuuKlCDqsr3smrDsl5AgJ05vIGpvYiB5ZXQn7J2EIOy2nOugpe2VoCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIEFycmF5IOq0gOugqCDsl7DsgrDsnYAgbWFwLCBmaWx0ZXIsIHJlZHVjZeulvCDsoIHqt7kg7Zmc7Jqp7ZWY7J6QIVxcclxcblxcclxcbkphdmFzY3JpcHTsnZgg67Cw7Je0IG1ldGhvZHMgKG1hcCwgZmlsdGVyLCByZWR1Y2Up65Ok7J2AIOygleunkCDqsJXroKXtlanri4jri6QuIFxcclxcblxcclxcbuyghO2GteyggeyduCBmb3IgbG9vcOuztOuLpOuKlCDsnbQg7Lmc6rWs65Ok7J2EIOyggeq3ueyggeycvOuhnCDtmZzsmqntlZjrqbQg7Ja47Ja07J2YIO2KueynleydhCDsnpgg7J207ZW07ZWY6rOgIOyCrOyaqe2VmOuKlCDtlITroZzri6TsmrQg66m066qo66W8IOuztOyXrOykhCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vLyBOb3QgZ29vZC4uLlxcclxcbmNvbnN0IGFyciA9IFsxLDIsMyw0LDVdXFxyXFxuXFx0Ly8g7Ked7IiYIOq1rO2VmOq4sFxcclxcbmNvbnN0IGV2ZW4gPSBbXTtcXHJcXG5mb3IgKGxldCBpID0gMCA7IGkgPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgIGlmIChpdGVtc1tpXSAlIDIgPT09IDApIHtcXHJcXG4gICAgICAgIGV2ZW4ucHVzaChpdGVtc1tpXSk7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuLy8gQmV0dGVyICEhXFxyXFxuY29uc3QgZXZlbiA9IGFyci5maWx0ZXIoaXRlbSA9PiBpdGVtICUgMiA9PSAwKVxcclxcblxcclxcbmBgYFxcclxcblxcclxcbi0g7L2U65Sp7YWM7Iqk7Yq466W8IOyjvOuhnCBweXRob27snYQg6riw67CY7Jy866GcIOykgOu5hO2WiOyXiOuKlOuNsCDtlITroaDtirjsl5Trk5wg6rCc67Cc7J6Q66GcIOy3qOyXheydhCDtlZjri6Trs7TrqbQgSmF2YXNjcmlwdCDri6jsnbwg7Ja47Ja066GcIOy9lO2FjOulvCDrp47snbQg7KCc6rO17ZWp64uI64ukLiDsnbTrlYwg7LSI67CY7JeQ64qUIOyggOuPhCDsnITsmYAg6rCZ7J2AIOy9lOuTnOulvCDsnpDsl7DsiqTrn73qsowg7I287JeI64qU642wLi4uLiDtlZguLi4uIOydtOygnOyZgOyEnCDrj4zsnbTsvJwg7IOd6rCB7ZW067O064uI6rmMIOydtOqyjCDrrLjsoJzqsIAg7ZKA66aw64uk6rOgIO2VtOuPhCDsoJzqsIAg66m07KCR6rSA7J20652866m0IOychOyZgCDqsJnsnbQgamF2YXNjcmlwdOulvCDsk7DripQg6rCc67Cc7J6Q7JmAIOqwmeydtCDsnbztlZjripTqsowg6rq866Ck7KeIIOqygyDqsJnri6TripQg7IOd6rCB7J20IOuTnOuEpOyalCDjhY7jhY5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5SZWYuXFxyXFxuXFxyXFxuW+uTnOumvOy9lOuUqeyXmOumrF0oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1CVUFocEIzRm1TNCZ0PTJzKVxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLsnpDrsJTsiqTtgazrpr3tirgg67OA7IiYLXZhciwgbGV0LCBjb25zdCDqvK0g7JWM7JWE7JW87ZWgIOywqOydtOygkFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wOC4wOVxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gSmF2YXNjcmlwdFxcclxcbiAgLSBsZXRcXHJcXG4gIC0gdmFyXFxyXFxuICAtIGNvbnN0XFxyXFxuICAtIOuzgOyImFxcclxcbi0tLVxcclxcblxcclxcbiMg7J6Q67CU7Iqk7YGs66a97Yq4IOuzgOyImCB2YXIsIGxldCwgY29uc3Qg67mE6rWQXFxyXFxuXFxyXFxu7Jyg7Yqc67iMIGDsvZTrlKnslZnrp4gg7LGE64SQYOydmCDsnpDrsJTsiqTtgazrpr3tirgg7KSR6riJIDHtjrggdmFyLCBsZXQsIGNvbnN066W8IOuztOuLpOqwgCDsoovsnYAg64K07Jqp7J20IOyeiOyWtCDsoJXrpqztlanri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMg7Zi47J207Iqk7YyFIFxcclxcblxcclxcbuyEoOyWuO2VmOq4sCDsoITsl5Ag7Zi47Lac65CcIHZhcuuzgOyImOqwgCDsmKTrpZjqsIAg64KY7KeAIOyViuuKlOuLpOuKlCDqsoPsnYQg6rGw7J2YIOuqqOuToCDtlITroaDtirjsl5Trk5wg6rCc67Cc7J6Q652866m0IOyVjOqzoCDsnojsnYQg6rKD7J6F64uI64ukLiDqt7gg7J207Jyg64qUIOuwlOuhnCBob2lzdGluZyDrlYzrrLjsnbjrjbAsIEVTNiDsnbTtm4Qg64KY7JioIGxldOydtOuCmCBjb25zdCDroZwg67OA7IiY66W8IOyEoOyWuO2VmOuKlCDqsoPsnYAgdmFy7JmAIOuLrOumrCDsnbTqsoPsnbQg65CY7KeAIOyViuuKlOuLpC4g6re466CH64uk66m0IGxldOydgCDtmLjsnbTsiqTtjIUg65CY7KeAIOyViuuKlCDqsoPsnbzquYw/652864qUIOydmOusuOydtCDrk6Tsl4jsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIPCfkqEgbGV064+EIGhvaXN0aW5n65Cc64ukLlxcclxcblxcclxcbjx1PuqysOuhoOu2gO2EsCDrp5DtlZjsnpDrqbQgbGV064+EIO2YuOydtOyKpO2MhSDrkKnri4jri6Q8L3U+LiDtlZjsp4Drp4wgdmFy7LKY65+8IOuPmeyeke2VmOyngCDslYrripQg7J207Jyg64qUIGDrs4DsiJjsnZgg7IOd7ISx64uo6rOEIDPqsIDsp4AgYCAqKlxcXCLshKDslrhcXFwiLVxcXCLstIjquLDtmZRcXFwiLVxcXCLtlaDri7lcXFwiKiog7J2YIOynhO2WieqzvOygleydtCDri6TrpbTquLAg65WM66y47J2064ukLlxcclxcblxcclxcbnwgdmFyICAgICAgICAgICAgICAgICB8IGxldCAgICAgICB8IGNvbnN0ICAgICAgICAgICAgICAgICAgICAgICAgIHxcXHJcXG58IC0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XFxyXFxufCAxLiDshKDslrggKyAyLiDstIjquLDtmZQgfCAxLiDshKDslrggICB8IDEuIOyEoOyWuCArIDIuIOy0iOq4sO2ZlCArIDMuIO2VoOuLuSB8XFxyXFxufCAtICAgICAgICAgICAgICAgICAgIHwgMi4g7LSI6riw7ZmUIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcclxcbnwgMy4g7ZWg64u5ICAgICAgICAgICAgIHwgMy4g7ZWg64u5ICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxuXFxyXFxu7JyEIO2RnOyXkOyEnCDrs7Trk6/snbQgKirshLgg6rCA7KeAIOuzgOyImOyEpOyglSDtg4DsnoXsnYAg66qo65GQIOuLpOuluCDqs7zsoJXsnYQg7Ya17ZW0IOuzgOyImOulvCDsg53shLEqKu2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gMS4gdmFyXFxyXFxuY29uc29sZS5sb2cobmFtZSkgLy8gdW5kZWZpbmVkXFxyXFxudmFyIG5hbWU9XFxcIu2Zjeq4uOuPmVxcXCJcXHJcXG5cXHJcXG4vLyAyLiBsZXQgXFxyXFxuY29uc29sZS5sb2cobmFtZSkgLy8gRXJyb3I6IOugiO2NvOufsOyKpCDsl5Drn6xcXHJcXG5sZXQgbmFtZT1cXFwi7ZmN6ri464+ZXFxcIlxcclxcblxcclxcbi8vIDMuIGNvbnN0XFxyXFxuY29uc29sZS5sb2cobmFtZSkgLy8gRXJyb3JcXHJcXG5jb25zdCBuYW1lPVxcXCLtmY3quLjrj5lcXFwiXFxyXFxuXFxyXFxuLy8gNC4gY29uc3Qg7LaU6rCAXFxyXFxuY29uc3QgbmFtZTtcXHJcXG5uYW1lPVxcXCLtmY3quLjrj5lcXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxuLSB2YXLsnZgg6rK97JqwIOyVhOyngSDtlaDri7nrkJjsp4Ag7JWK7J2AIG5hbWXsnYQg66i87KCAIO2YuOy2nO2VmOuNlOudvOuPhCDtmLjsnbTsiqTtjIXrkJwg67OA7IiY66qFIG5hbWXsnYAg7J2066+4IOyVjOqzoCDsnojsnLzrqbAg64uk66eMIO2VtOuLuSDqsJLsnYAgdW5kZWZpbmVk7IOB7YOc7J2064ukLiDrlLDrnbzshJwg7JeQ65+s6rCAIOuCmOyngCDslYrripTri6QuXFxyXFxuXFxyXFxuLSBsZXTsnZgg6rK97JqwIO2YuOydtOyKpO2MheydgCDrkJjrr4DroZwgbmFtZeuzgOyImOulvCDslYTsmIgg66qo66W064qUIOqyg+ydgCDslYTri4jrgpgsIOy0iOq4sO2ZlChuYW1l7JeQIHVuZGVmaW5lZCnqsIAg65CY7KeA7JWK7JWY7Jy866+A66GcIG5hbWXsl5Ag7ZW064u57ZWY64qUIOugiO2NvOufsOyKpOqwgCDsl4bslrQg66CI7Y2865+w7IqkIOyXkOufrOqwgCDrgpzri6QuXFxyXFxuLSBjb25zdOydmCDqsr3smrAg7ISg7Ja4L+y0iOq4sO2ZlC/tlaDri7kg7IS4IOqwgOyngOqwgCDrqqjrkZAg7ZWcIOuyiOyXkCDsnbTrpITsoLjslbwg7ZWY64qU642wIOq3uOugh+yngCDslYrslZjsnLzrr4DroZwg7JeQ65+s6rCAIOuwnOyDne2VnOuLpC5cXHJcXG4tIGNvbnN07J2YIOqyveyasCDshKDslrjqs7wg64+Z7Iuc7JeQIO2VoOuLueq5jOyngCDsnbTrpITsoLjslbwg7ZWc64ukLiDrlLDrnbzshJwgNOuyiOyymOufvCDsg53shLHrp4wg7ZW065GQ6rOgIOuCmOykkeyXkCDtlaDri7ntlZjrqbQg7Jik66WY6rCAIOuwnOyDne2VnOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyDsiqTsvZTtlIRcXHJcXG5cXHJcXG58IHZhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGxldCwgY29uc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxufCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxcclxcbnwg7ZWo7IiYIOyKpOy9lO2UhCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCDruJTroZ0g7Iqk7L2U7ZSEICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxufCBmdW5jdGlvbigpIOuLqOychCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGlmLCB3aGlsZSwgZm9yLCB0cnkvY2F0Y2jrrLgg65OxICAgICAgICAgICAgICAgICAgICAgICAgIHxcXHJcXG58IC0+IGlm66y47J2064KYIHdoaWxl66y4IOuTsSDruJTroZ3siqTsvZTtlIQg64K07JeQ7IScIOyEoOyWuOuQmOyWtOuPhCDtlajsiJjri6jsnITsl5DshJwg7Zi47Lac7J20IOqwgOuKpe2VqC4gPGJyIC8+64uoLCDtlajsiJjri6jsnITrpbwg64SY7Ja07ISc64qUIOqzs+yXkOyEnOydmCDtmLjstpzsnYAg7JWI65Cc64ukLiB8IGlm66y47J2064KYIHdoaWxl66y465OxIOyEoOyWuOuQnCDruJTroZ0g64K07JeQ7ISc66eMIO2YuOy2nOydtCDqsIDriqXtlaguIHxcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tLS1cXHJcXG5SZWYuXFxyXFxuXFxyXFxuW+ycoO2KnOu4jCDsvZTrlKnslZnrp4gg7LGE64SQXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PW9jR2MtQW1XU25RJmxpc3Q9UExaS1RYUG1hSms4SloyTkFDNTM4VXpoWV9VTnFNZFpCNClcXHJcXG5cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwi7J6Q67CU7Iqk7YGs66a97Yq4IOu5hOuPmeq4sOydmCDqvYMgYXN5bmMgYXdhaXQg7LSI7Iqk7ZS865Oc66GcIO2VteyLrOunjCDssrTtgaxcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDguMTdcXFwiXFxyXFxudGFnczogXFxyXFxuICAgIC0gamF2YXNjcmlwdFxcclxcbiAgICAtIGFzeW5jXFxyXFxuICAgIC0g67mE64+Z6riwXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyDsnpDrsJTsiqTtgazrpr3tirgg67mE64+Z6riw7J2YIOq9gyBhc3luYyBhd2FpdCDstIjsiqTtlLzrk5zroZwg7JWM7JWE67O06riwXFxyXFxuXFxyXFxuIyMgOmJ1bGI6IO2VteyLrCDssrTtgawg66y464u1XFxyXFxuXFxyXFxuIyMjIDpvbmU6IGFzbnljIGF3YWl0656APyBcXHJcXG5cXHJcXG4g7J6Q67CU7Iqk7YGs66a97Yq4IOu5hOuPmeq4sCDtlajsiJjsnZgg6rCA64+F7ISx7J2EIOuGkuyXrOyjvOuKlCDrrLjrspVcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgOnR3bzogYXN5bmMgYXdhaXTsnZgg7J6l7KCQ7J2AP1xcclxcblxcclxcblByb21pc2Ug67O064ukICoqPHU+6rCE6rKwPC91Pioq7ZWY6rOgICoqPHU+7KeB6rSA7KCBPC91Pioq7J2066mwICoqPHU+64aS7J2AIOqwgOuPheyEseydhCDrs7Tsl6zso7zripQg7J6l7KCQPC91Pioq7J20IOyeiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgOnRocmVlOiBQcm9taXNl66W8IOuMgOyytO2VmOuKlOqwgD9cXHJcXG5cXHJcXG4qKjpub19nb29kOiBOTyEqKiAgICoqKnByb21pc2Xrpbwg7JmE7KCE7Z6IIOuMgOyytO2VmOyngOuKlCDrqrvtlZzri6QqKiouXFxyXFxuXFxyXFxucHJvbWlzZeuKlCDqsJLsnLzroZwg7KG07J6s7ZWY7JesIOuNlCDri6TslpHtlZwg67KU7JyE7JeQ7IScIO2ZnOyaqeuQmOuKlCDrsJjrqbQsICoqPHU+YXN5bmMgYXdhaXTsnYAg7ZWo7IiY66W8IOygleydmO2VoCDrlYzsl5Drp4wg7IKs7Jqp65Cc64ukPC91Pioq64qUIOygkOyXkOyEnCDtmZzsmqkg67KU7JyE6rCAIHByb21pc2Xrs7Tri6TripQg7J6R64ukLlxcclxcblxcclxcbmFzeW5jIO2VqOyImOydmCDrsJjtmZjqsJLsnYAg7ZWt7IOBIGBQcm9taXNlYOqwneyytOydtOuLpC4g7J20IFByb21pc2XqsJ3ssrTripQgKio8dT7sg4Htg5zsmYAg67CY7ZmY6rCSPC91Pioq7J20IO2PrO2VqOuQmOyWtOyeiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA6YnVsYjogYXN5bmMgYXdhaXQg67OR66Cs7LKY66asXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbmZ1bmN0aW9uIGFzeW5jRnVuYzEoKSB7XFxyXFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKCfsspjrpqzspJEgMScpO1xcclxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgcmVzb2x2ZSgxMCk7XFxyXFxuICAgICAgICB9LCAxMDAwKVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5mdW5jdGlvbiBhc3luY0Z1bmMyKCkge1xcclxcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZygn7LKY66as7KSRIDInKTtcXHJcXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcclxcbiAgICAgICAgICAgIHJlc29sdmUoMjApO1xcclxcbiAgICAgICAgfSwgMTAwMClcXHJcXG4gICAgfSlcXHJcXG59XFxyXFxuXFxyXFxuLy8g67OR66Cs7LKY66asIChPKVxcclxcbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEoKSB7XFxyXFxuICAgIGNvbnN0IHAxID0gYXN1bmNGdW5jMSgpO1xcclxcbiAgICBjb25zdCBwMiA9IGFzeW5jRnVuYzIoKTtcXHJcXG4gICAgY29uc3QgZGF0YTEgPSBhd2FpdCBwMTtcXHJcXG4gICAgY29uc3QgZGF0YTIgPSBhd2FpdCBwMjtcXHJcXG4gICAgY29uc29sZS5sb2coe2RhdGExLCBkYXRhMn0pO1xcclxcbn0gLy8gMey0iCDtm4Tsl5AgTE9HOiAn7LKY66as7KSRIDEnLCAn7LKY66as7KSRIDInXFxyXFxuXFxyXFxuLy8g67OR66Cs7LKY66asIChYKVxcclxcbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEoKSB7XFxyXFxuICAgIGNvbnN0IGRhdGExID0gYXdhaXQgYXN1bmNGdW5jMSgpO1xcclxcbiAgICBjb25zdCBkYXRhMiA9IGF3YWl0IGFzeW5jRnVuYzIoKTtcXHJcXG4gICAgY29uc29sZS5sb2coe2RhdGExLCBkYXRhMn0pO1xcclxcbn0gLy8gMey0iCDtm4Tsl5AgTE9HOjogJ+yymOumrOykkSAxJywgMuy0iCDtm4Tsl5AgTE9HOjogJ+yymOumrOykkSAyJ1xcclxcbmBgYFxcclxcblxcclxcbi0g67OR66Cs7LKY66as66W8IOynhO2Wie2VnCDsmIjrpbwg67O066m0IDHstIjsl5AgZGF0YTHqs7wgZGF0YTLsnZgg66Gc6re466W8IOuqqOuRkCDrs7wg7IiYIOyeiOuLpC5cXHJcXG4tIO2VmOyngOunjCDrs5HroKzsspjrpqzrpbwg7KeE7ZaJ7ZWY7KeAIOyViuydgCDsmIjsi5zsspjrn7wg7L2U65Oc66W8IOyekeyEse2VmOuptCAx7LSI66W8IOyNqOyEnCBkYXRhMeydhCDrsJvslYTsmKTqs6Ag6re4IOuLpOydjCDrmJAg64uk7IucIDHstIjrpbwgZGF0YTLsl5Ag7IKs7Jqp7ZWY6riwIOuVjOusuOyXkCDstJ0gMuy0iOqwgCDqsbjrpqzripQg67mE7Zqo7Jyo7J20IOuwnOyDne2VnOuLpC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5SZWYuXFxyXFxuXFxyXFxu7Iuk7KCEIOyekOuwlOyKpO2BrOumve2KuCAtIOydtOyerOyKuVwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLsnpDrsJTsiqTtgazrpr3tirjsnZgg7IOI66Gc7Jq0IO2VqOyImCBHZW5lcmF0b3Lrpbwg7JWM7JWE67O07J6QXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA4LjI2XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgICAtIGphdmFzY3JpcHRcXHJcXG4gICAgLSBnZW5lcmF0b3JcXHJcXG4gICAgLSBFUzZcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIOyekOuwlOyKpO2BrOumve2KuOydmCDsg4jroZzsmrQg7ZWo7IiYIEdlbmVyYXRvcuulvCDslYzslYTrs7TsnpBcXHJcXG4jIyBHZW5lcmF0b3LripQ/XFxyXFxuXFxyXFxu7Iic7LCo7KCB7Jy866GcIOynhO2Wie2VmOuKlCDsnpDrsJTsiqTtgazrpr3tirjsnZgg7Yq567OE7ZWcIO2VqOyImC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyDsgqzsmqnrspVcXHJcXG5cXHJcXG4jIyMgMS4g7ISg7Ja4XFxyXFxuXFxyXFxuZnVuY3Rpb27snYQg7ISg7Ja47ZWgIOuVjCDsl5AgYCpgIOydhCDstpTqsIDtlZzri6QuXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIFJlY29tbWVuZFxcclxcbmZ1bmN0aW9uKiBleGFtcGxlKCkge31cXHJcXG5cXHJcXG4vLyBOb3QgUmVjb21tZW5kXFxyXFxuZnVuY3Rpb24gKmV4YW1wbGUoKSB7fVxcclxcbmBgYFxcclxcblxcclxcbi0gZnVuY3Rpb27qs7wg7ZWo7IiYIOydtOumhOykkeyXkOyEnCBmdW5jdGlvbuyXkCBgKmDsnYQg67aZ7Jes7KO864qUIOqyg+ydhCDstpTsspztlZzri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIDIuIHllaWxk7JmAIG5leHQoKSDrqZTshozrk5xcXHJcXG5cXHJcXG7soJzrhIjroIjsnbTthLDripQgeWllbGTrpbwg7Iic7LCo7KCB7Jy866GcIOyLpO2Wie2VmOuKlOuNsCwg7J2066W8IOyLpO2Wie2VmOq4sCDsnITtlbTshJzripQgbmV4dCgpIOuplOyGjOuTnOulvCDtmZzsmqntlbTslbwg64uk7J2MIHlpZWxk66GcIOuEmOyWtOqwiCDsiJgg7J6I64ukLlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5mdW5jdGlvbiogZjEoKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKCdmMS0xJyk7XFxyXFxuICAgIHlpZWxkIDEwO1xcclxcbiAgICBjb25zb2xlLmxvZygnZjEtMicpO1xcclxcbiAgICB5aWVsZCAyMDtcXHJcXG4gICAgY29uc29sZS5sb2coJ2YxLTMnKTtcXHJcXG4gICAgcmV0dXJuICdmaW5pc2hlZCdcXHJcXG59XFxyXFxuXFxyXFxuY29uc3QgZ2VuID0gZjEoKTtcXHRcXHQvLygxKVxcclxcbmNvbnNvbGUubG9nKGdlbi5uZXh0KCkpOy8vKDIpXFxyXFxuY29uc29sZS5sb2coZ2VuLm5leHQoKSk7Ly8oMylcXHJcXG5jb25zb2xlLmxvZyhnZW4ubmV4dCgpKTsvLyg0KVxcclxcbmBgYFxcclxcblxcclxcbi0gKDEp6rmM7KeA64qUIOyVhOustOqyg+uPhCDstpzroKXrkJjsp4Ag7JWK64qU64ukLlxcclxcbi0gKDIp6rCAIOyLpO2WieuQmOuptCDroZzqt7jsl5AgZjEtMeydtCDstpzroKXrkJjqs6Age3ZhbHVlOiAxMCwgZG9uZTogZmFsc2V96rCAIOuwmO2ZmOuQnOuLpC4gbmV4dOydmCDrsJjtmZjqsJLsnYAg7ZWt7IOBIHZhbHVl7JmAIGRvbmXsnbQg7Y+s7ZWo65CcIOqwneyytOuhnCDrhJjslrTsmKjri6QuIGRvbmXsnYAg7J20IOygnOuEiOugiOydtO2EsCDtlajsiJjqsIAg66qo65GQIOyLpO2WieuQmOuptCB0cnVl6rCAIOuQnOuLpC5cXHJcXG4tICgzKeydtCDsi6TtlonrkJjrqbQg66Gc6re47JeQIGYxLTLsnbQg7Lac66Cl65CY6rOgIHt2YWx1ZTogMjAsIGRvbmU6IGZhbHNlfeqwgCDrsJjtmZjrkJzri6QuXFxyXFxuLSAoMynsnbQg7Iuk7ZaJ65CY66m0IOuhnOq3uOyXkCBmMS0z7J20IOy2nOugpeuQmOqzoCB7dmFsdWU6ICdmaW5pc2hlZCcsIGRvbmU6IHRydWV96rCAIOuwmO2ZmOuQnOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG46aGVhdnlfZXhjbGFtYXRpb25fbWFyazogKirrp4zslb0gcmV0dXJuIOuLpOydjOyXkCB5aWVsZOqwgCDrjZQg7J6I64uk7ZWY642U652864+EIHJldHVybuydtCDrkJwg7Iic6rCEIOuNlCDsnbTsg4EgbmV4dCgpIOuplOyGjOuTnOuKlCDrj5nsnpHtlZjsp4Ag7JWK6rOgIOydtO2bhCB5aWVsZOuKlCDrqqjrkZB9IHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfSDrp4zsnbQg67CY7ZmY65Cc64ukLioqXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMy4gR2VuZXJhdG9y66W8IOyTsOuKlCDsnbTsnKAsIOyepeygkFxcclxcblxcclxcbiMjIyA6YnVsYjogR2VuZXJhdG9y64qUIOyLpO2WieuQmOuKlCDrlLEg6re4IOyInOqwhOyXkOunjCDsl7DsgrDsnYQg7Iuk7ZaJ7ZWc64ukLiDrlLDrnbzshJwg66y07J2Y66+47ZWcIOuwmOuzteydtCDtlYTsmpTtlZjsp4Ag7JWK64ukLlxcclxcblxcclxcbj4gIOuniOy5mCDrsLDsl7Tsl5DshJwg7Iic7ZqM7ZWY64qUIOqyg+qzvCDqsJnsnbQg7J6R64+Z7ZWY64qU642wLCDrsLDsl7TsnZgg6rK97JqwIOyymOydjCDsg53shLHtlaAg65WM67aA7YSwIOuqqOuToCDqsJLsnbQg7KCV7ZW07KC47J6I6riwIOuVjOusuOyXkCDrqZTrqqjrpqwg7IKs7Jqp65+J7J20IOunjuuLpC4g7ZWY7KeA66eMIOygnOuEiOugiOydtO2EsOuKlCDrp4zrk6TslrTsp4DripQg6re4IOuVjCDrqZTrqqjrpqzsl5Ag7KCA7J6l65CY6riwIOuVjOusuOyXkCA8dT7rqZTrqqjrpqwg7Zmc7Jqp7ISxIOy4oeuptOyXkOyEnCDtgbAg7J6l7KCQPC91PuydtCDsnojri6QuXFxyXFxuXFxyXFxuLSDsmIgpIOuwsOyXtOydmCDrgZ3quYzsp4Ag64ukIOyInO2ajO2VmOyngCDslYrqs6Ag7ZWE7JqU7ZWcIOqzs+q5jOyngOunjCDsiJztmoztlZjripQg7IKs66GAXFxyXFxuXFxyXFxuICBgYGBqYXZhc2NyaXB0XFxyXFxuICBjb25zdCB2YWx1ZXMgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXFxyXFxuICBjb25zdCByZXN1bHQgPSB0YWtlKDMsXFxyXFxuICBtYXAoZmlsdGVyKHZhbHVlcywgbj0+IG4gJSAyID09PSAwKSxcXHJcXG4gICAgICBuID0+IG4qIDEwXFxyXFxuICBcXHQpXFxyXFxuICApXFxyXFxuICBgYGBcXHJcXG5cXHJcXG4tIOychOydmCDsmIjsi5zripQg6rO87JewIOyWtOuWpCDqsJLsnYQg67CY7ZmY7ZWg6rmMP1xcclxcblxcclxcbi0gbG9n66W8IOywjeyWtOuztOuptCBbMjAsIDQwLCA2MF3snbQg67CY7ZmY65CgIOqyg+ydtOuLpC5cXHJcXG5cXHJcXG4tIOynneyImOulvCDsiJztmoztlZjri6TqsIAgYHRha2UoMylg66W8IOuztOqzoCAz67KI7Ke47JeQ7IScIOuUsSDrqYjstpTripQg6rKD7J2064ukLiBHZW5lcmF0b3LsnZgg7Zqo7Jyo7ISx7J20IOuPi+uztOyduOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgOmJ1bGI6IOuplOuqqOumrCDsgqzsmqnsnbQg7Zqo7Jyo7KCB7Jy866GcIOyCrOyaqe2VoCDsiJgg7J6I64ukLlxcclxcblxcclxcbi0g7JiIKSBtYXAsIGZpbHRlcu2VqOyImCDrk7HsnYQg67CY7ZmY7ZWY64qUIOuwsOyXtCDsl4bsnbQg66eM65Ok7Ja07IScIOyTuCDsiJgg7J6I64ukLlxcclxcblxcclxcbiAgYGBgamF2YXNjcmlwdFxcclxcbiAgZnVuY3Rpb24qIG1hcChpdGVyLCBtYXBwZXIpIHtcXHJcXG4gICAgICBmb3IgKGNvbnN0IHYgb2YgaXRlcikge1xcclxcbiAgICAgICAgICB5aWVsZCBtYXBwZXIodik7XFxyXFxuICAgICAgfVxcclxcbiAgfVxcclxcbiAgXFxyXFxuICBmdW5jdGlvbiogZmlsdGVyKGl0ZXIsIHRlc3QpIHtcXHJcXG4gICAgICBmb3IgKGNvbnN0IHYgb2YgaXRlcikge1xcclxcbiAgICAgICAgICBpZiAodGVzdCh2KSkge1xcclxcbiAgICAgICAgICAgICAgeWllbGQgdjtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gIH1cXHJcXG4gIFxcclxcbiAgYGBgXFxyXFxuXFxyXFxuLSDsnITsmYAg6rCZ7J20IG1hcCwgZmlsdGVy7ZWo7IiY66W8IOygnOuEiOugiOydtO2EsOuhnCDrp4zrk6TslrTshJwg7IKs7Jqp7ZWY66m0IOq4sOyhtCDrgrTsnqXtlajsiJjrs7Tri6Qg66mU66qo66as66W8IOuNlCDtmqjsnKjsoIHsnLzroZwg7IKs7Jqp7ZWgIOyImCDsnojri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuUmVmLlxcclxcblxcclxcbuyLpOyghCDsnpDrsJTsiqTtgazrpr3tirggLSDsnbTsnqzsirlcXHJcXG5cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwi7J6Q67CU7Iqk7YGs66a97Yq4IGl0ZXJhYmxl6rO8IGl0ZXJhdG9y7JeQIOuMgO2VtCDslYzslYTrs7TsnpBcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDguMzBcXFwiXFxyXFxudGFnczogXFxyXFxuICAgIC0gamF2YXNjcmlwdFxcclxcbiAgICAtIGl0ZXJhYmxlXFxyXFxuICAgIC0gaXRlcmF0b3JcXHJcXG4gICAgLSBFUzZcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIOyekOuwlOyKpO2BrOumve2KuCBpdGVyYWJsZeqzvCBpdGVyYXRvcuyXkCDrjIDtlbQg7JWM7JWE67O07J6QIFxcclxcbiMjIOydtO2EsOufrOu4lCAoaXRlcmFibGUp7J20656AP1xcclxcblxcclxcbj4g67CY67O1IOqwgOuKpe2VnCDqsJ3ssrQgKEVTMjAxNeyXkCDstpTqsIDrkJwg66y467KVKVxcclxcblxcclxcbuqwneyytOydmCBgU3ltYm9sLml0ZXJhdG9yYCDsho3shLHsl5Ag7Yq57KCVIO2Yle2DnOydmCDtlajsiJjqsIAg65Ok7Ja07J6I64uk66m0LCDsnbTrpbwgKioq67CY67O1IOqwgOuKpe2VnCDqsJ3ssrQoaXRlcmFibGUgb2JqZWN0KSoqKiDtmLnsnYAg7KSE7Jes7IScICoqaXRlcmFibGUqKuydtOudvCDrtoDrpbTqs6AsIDx1Pu2VtOuLuSDqsJ3ssrTripQgaXRlcmFibGUgcHJvdG9jb2zsnYQg66eM7KGx7ZWc64ukPC91PuqzoCDrp5Dtlanri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIOydtO2EsOufrOu4lOydmCDsobDqsbQgXFxyXFxuXFxyXFxuMS4g7Iic7ZqMIO2VoOyImCDsnojripQg642w7J207YSw66W8IOqwgOyngOqzoCDsnojslrTslbztlZzri6QuIFxcclxcbjIuIOyghOyXrSDigJx3ZWxsLWtub3du4oCdIHN5bWJvbCDsnbhgU3ltYm9sLml0ZXJhdG9yYCDsnYQg66mU7ISc65Oc66GcIOqwgOyngOqzoCDsnojslrTslbztlZzri6QuIOuYkO2VnCDsnbQg66mU7ISc65Oc64qUICMzICwgIzYg7JeQIOuUsOudvCDqtaztmITrkJjslrTslbwg7ZWc64ukLlxcclxcbjMuIGBTeW1ib2wuaXRlcmF0b3JgIOuplOyEnOuTnOuKlCAqKuKAnGl0ZXJhdG9y4oCdIOqwneyytOulvCDrsJjtmZgqKu2VtOyVvO2VqeuLiOuLpFxcclxcbjQuIOKAnGl0ZXJhdG9y4oCdIOqwneyytOuKlCAqKuuwmOuTnOyLnCBuZXh0IOudvOqzoCDtlZjripQg66mU7ISc65Oc66W8IOqwgOyguOyVvO2VqeuLiOuLpC4qKiAo7KeA64KcIEdlbmVyYXRvciDtj6zsiqTtjIXsl5DshJwg67Sk642YIOqwnOuFkOyeheuLiOuLpC4pXFxyXFxuNS4gbmV4dCDsl5DripQgIzHsl5Ag7KCA7J6l65CY7Ja07J6I64qUIOuNsOydtO2EsOyXkCDsoJHqt7wg7ZWgIOyImCDsnojslrTslbztlanri4jri6QuXFxyXFxuNi4g4oCcaXRlcmF0b3LigJ0g6rCd7LK07J24IGl0ZXJhdG9yT2Jq66W8IGl0ZXJhdG9yT2JqLm5leHQoKe2VmOuptCBge3ZhbHVlOjxzdG9yZWQgZGF0YX0sZG9uZTpmYWxzZX1gICMxIOuNsOydtO2EsOqwgCDstpTstpwg65CY66mwIOyghOu2gOuLpCDsiJztmoztlojsnYQg6rK97JqwIGB7ZG9uZTpmYWxzZX1gIOqwgCDrsJjtmZjrkJjrj4TroZ0g7ZWc64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyDsnbTthLDrn6zruJQoaXRlcmFibGUp7J20IOyCrOyaqeuQmOuKlCDqs7NcXHJcXG5cXHJcXG4tIGZvci4uLiBvZiDro6jtlIRcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuY29uc3QgaXRlcmFibGUgPSBbMSwyLDNdXFxyXFxuZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcXHJcXG4gICAgY29uc29sZS5sb2codmFsdWUpXFxyXFxufVxcclxcbi8vIDEsIDIsIDNcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4tIGRlc3RydWN0dXJpbmdcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8gc3ByZWFkIG9wZXJhdG9yXFxyXFxubGV0IG5ld0l0ZXJhYmxlID0gWy4uLml0ZXJhYmxlXSAvLyBbMSwgMiwgM11cXHJcXG5cXHJcXG4vLyBkZXN0cnVjdHVyaW5nXFxyXFxuY29uc3QgW2MxLCBjMl0gPSAnaGVsbG8nO1xcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcbiMjIOydtO2EsOufrOu4lChpdGVyYWJsZSnqs7wg7J207YSw66CI7J207YSwKGl0ZXJhdG9yKeydmCDssKjsnbRcXHJcXG5cXHJcXG4tIOydtO2EsOufrOu4lDog7Iic7ZqM7ZWgIOyImCDsnojripQg6rCd7LK0XFxyXFxuLSDsnbTthLDroIjsnbTthLA6IG5leHTrqZTshozrk5zrpbwg7Zi47Lac7ZWY66m0IHtkb25lOiBib29sZWFuLCB2YWx1ZX0g66W8IOuwmO2ZmO2VmOuKlCDsmKTruIzsoJ3tirgsIOqwneyytCDqt7gg7J6Q7LK0XFxyXFxuXFxyXFxu7J207YSw65+s67iU7J2AIOyInO2ajO2VoCDsiJgg7J6I64qUIOuqqOuToCDqsJ3ssrTqsIAg65CgIOyImCDsnojri6QuIOuUsOudvOyEnCDrsLDsl7QoQXJyYXkpLCDrrLjsnpDsl7Qoc3RyaW5nKSwg6rCd7LK0IOuTsSDri6TslpHtlZwg6rKD65Ok7J20IOuQoCDsiJgg7J6I64ukLiDsnbTthLDroIjsnbTthLDripQg7J207YSw65+s67iU7J2YIOyGjeyEseydhCDqsIDsp4Qg67CU66GcIOq3uCDqsJ3ssrTrpbwg7J2Y66+47ZWc64ukLiBcXHJcXG5cXHJcXG7snbTthLDroIjsnbTthLDripQgLm5leHQoKSDrqZTshozrk5zrpbwg67CY65Oc7IucIOqwluuKlOuLpC4g7KaJLCDslZ4g65Kk66GcIOuwlOuhnCDsnbTsoITqs7wg67CU66GcIOuLpOydjCDqsJLrp4zsnYQg6rCA7KC47JisIOyImCDsnojri6QuIO2VmOyngOunjCDsnbTthLDrn6zruJQg7KSRIO2VmOuCmOyduCDrsLDsl7TsnYAg7J24642x7Iqk66GcIOuenOuNpCBBY2Nlc3PqsIAg6rCA64ql7ZWY64uk64qUIOygkOyXkOyEnCDsnbTthLDrn6zruJTqs7wg7J207YSw66CI7J207YSw7J2YIOywqOydtOulvCDslYwg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG7rrLzroaAg6rCc64WQ7KCB7Jy866GcIOyZhOyghO2eiCDtj6zqtITtlZjripQg64qQ64KM7J2AIOyVhOuLiOyngOunjCwg7IKs7Iuk7IOBIOuwsOyXtOydgCDslrjsoJzrk6Ag7J207YSw66CI7J207YSw66GcIOuzgO2ZmOydtCDqsIDriqXtlZjri6TripQg7KCQ7JeQ7IScIOydtO2EsOugiOydtO2EsOqwgCDsnbTthLDrn6zruJTsnYQg7Y+s7ZWo7ZWY64qUIOq0gOqzhOuhnCDrs7wg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG58IEl0ZXJhYmxlIOydtO2EsOufrOu4lCAgICAgICB8IEl0ZXJhdG9yIOydtO2EsOugiOydtO2EsCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxyXFxufCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxcclxcbnwg656c642kIEFjY2Vzc+qwgCDqsIDriqXtlZjri6QuIHwgLm5leHQoKSDrqZTshozrk5wsIOuwlOuhnCDslZ4v65KkIOqwkuunjOydhCDqsIDsoLjsmKwg7IiYIOyeiOuLpC4gfFxcclxcbnwg6riw64ql7J20IOunjuuLpCAtPiDrrLTqsoHri6QgICB8IOq4sOuKpeydtCDrsLDsl7Tsl5Ag67mE7ZW0IOyDgeuMgOyggeycvOuhnCDsoIHri6QgLT4g6rCA67ON64ukICAgICAgfFxcclxcbnwg66mU66qo66asIOyCrOyaqeufieydtCDrp47ri6QuICAgfCDrqZTrqqjrpqwg7Zqo7Jyo7KCB7J2064ukLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcclxcblxcclxcblxcclxcblxcclxcbi0tLVxcclxcblxcclxcblJlZi5cXHJcXG5cXHJcXG5odHRwczovL2hlbGxvd29ybGRqYXZhc2NyaXB0Lm5ldC9wYWdlcy8yNjAtaXRlcmF0aW9uLmh0bWxcXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwiamF2YXNjcmlwdCDsponsi5zsi6TtlontlajsiJgoPykg7J2864uoIOyVjOyVhOuztOyekFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wOS4xNlxcXCJcXHJcXG50YWdzOiBcXHJcXG4gICAgLSBqYXZhc2NyaXB0XFxyXFxuICAgIC0g7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyBqYXZhc2NyaXB0IOymieyLnOyLpO2Wie2VqOyImOuegCDrrLTsl4fsnbzquYxcXHJcXG5cXHJcXG4+IOymieyLnOyLpO2Wie2VqOyImDog7ZWo7IiY7ISg7Ja46rO8IOuPmeyLnOyXkCDrsJTroZwg7Iuk7ZaJ7J20IOuQmOuKlCDtlajsiJguXFxyXFxuXFxyXFxuamF2YXNjcmlwdOuKlCDsnbztmozshLHsnLzroZwg7IKs7Jqp65CY64qUIO2VqOyImOqwgCDri6Trpbgg7Ja47Ja07JeQIOu5hO2VtCDrp47snYAg7Y647J24642wLCDsnbTrpbwg7Zqo7Jyo7KCB7Jy866GcIOynhO2Wie2VmOq4sCDsnITtlbRg7J2166qF7ZWo7IiYYCwgYOymieyLnOyLpO2Wie2VqOyImGAg65Ox7J2EIOyngOybkO2VqeuLiOuLpC5cXHJcXG5cXHJcXG7ri7nsl7Dtnogg64uoIO2VnCDrsojrp4wg7Zi47Lac65CY6rOgIOyLpO2WieuQqeuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyDsponsi5zsi6TtlontlajsiJhcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuLy8g7J2867CY7ZWo7IiYXFxyXFxuXFxyXFxuZnVuY3Rpb24gbm9ybWFsKCkge1xcclxcbiAgICBjb25zb2xlLmxvZygnSGVsbG8gV29ybGQhJyk7XFxyXFxufVxcclxcbm5vcm1hbCgpO1xcclxcbmBgYFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG4vLyDsponsi5zsi6TtlontlajsiJggLSDsnbTrpoTsnbQg7J6I7Jy866+A66GcIFxcXCLquLDrqoXsponsi5zsi6TtlontlajsiJhcXFwi65286rOg64+EIOu2iOumsOuLpC5cXHJcXG4oZnVuY3Rpb24gaW1tZWRpYXRlKCl7XFxyXFxuICAgIGNvbnNvbGUubG9nKCdVUkdFTlQhIScpXFxyXFxufSkoKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG7snITsnZgg7JiI7Iuc7JeQ7IScIOuztOuTr+ydtCDtlajsiJjshKDslrjrtoDrtoQg7KCE7LK066W8IOq0hO2YuOuhnCDqsJDsi7jqs6Ag6re4IOuSpOyXkCAoKSDrpbwg67aZ7Jes7IScIOuwlOuhnCDsi6TtlontlZjrj4TroZ0g7ZWp64uI64ukLlxcclxcblxcclxcbuyCrOyLpCDtlZwg67KI66eMIO2YuOy2nOuQmOqzoCDrjZQg7J207IOBIO2YuOy2nOuQmOyngCDslYrquLAg65WM66y47JeQIO2VqOyImOydmCDsnbTrpoTsnbQg7ZWE7JqU7ZWY7KeAIOyViuyKteuLiOuLpC4g65Sw65287IScIOuLpOydjOqzvCDqsJnsnbQg7JO4IOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbi8vIEFub255bW91cyBmdW5jdGlvbiAtIOydtOumhOydtCDsl4bsnLzrr4DroZwgXFxcIuydteuqheymieyLnOyLpO2Wie2VqOyImFxcXCLrnbzqs6Drj4Qg67aI66aw64ukLlxcclxcbihmdW5jdGlvbiAoKXtcXHJcXG4gICAgY29uc29sZS5sb2coJ1VSR0VOVCEhJylcXHJcXG59KSgpO1xcclxcblxcclxcbi8vIEVTNlxcclxcbigoKT0+IHtjb25zb2xlLmxvZygnVVJHRU5UISEnKX0pKCk7XFxyXFxuYGBgXFxyXFxuXFxyXFxu7J2867CY7KCB7Jy866GcIOymieyLnOyLpO2Wie2VqOyImOuKlCDslrTssKjtlLwg7Iuk7ZaJIOyEoOyWuCDtm4Qg67CU66GcIOyCrOyaqeuQmOqzoCDri6Tsi5wg7IKs7Jqp65CY7KeAIOyViuycvOuvgOuhnCAqKirsnbXrqoXtlajsiJgqKirroZwg66eO7J20IOyTsOyeheuLiOuLpC5cXHJcXG5cXHJcXG7tlZjsp4Drp4wgKioq6riw66qF7ZWo7IiYKioq66GcIOyTsOydtOuKlCDqsr3smrDrj4Qg7J6I64qU642wLCDrsJTroZwg7J6s6reA7ZWo7IiY7J6F64uI64ukLiDsnpDquLAg7J6Q7Iug7J2EIOuLpOyLnCDtmLjstpztlbTslbwg7ZWY64qU642wIOydtOumhOydtCDsl4bsnLzrqbQg7Zi47Lac7ZWgIOyImOqwgCDsl4bsnLzrr4DroZwg7J6s6reA7ZWo7IiY7JeQ7ISc64qUIOydtOumhOydhCDsp4DslrTshJwg7Zmc7Jqp7ZWp64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyDtlajsiJgg7J247J6QKGFyZ3VtZW50cynripQg7Ja065a76rKMIO2ZnOyaqe2VoOq5jD9cXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuKGZ1bmN0aW9uIHN1bShhLCBiKXtcXHJcXG4gICAgY29uc29sZS5sb2coYFRoZSBhbnN3ZXIgaXMgJHthK2J9YClcXHJcXG59KSgzLCA1KVxcclxcbi8vIFxcXCJUaGUgYW5zd2VyIGlzIDhcXFwiXFxyXFxuXFxyXFxuXFxyXFxuKGZ1bmN0aW9uIChhcnIpe1xcclxcbiAgICBhcnIubWFwKChpdGVtKSA9PiB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhpdGVtKVxcclxcbiAgICB9KVxcclxcbn0pKFtcXFwiSGVsbG9cXFwiLCBcXFwiV29ybGRcXFwiLCBcXFwiIVxcXCJdKVxcclxcbi8vIFxcXCJIZWxsb1xcXCJcXHJcXG4vLyBcXFwiV29ybGRcXFwiXFxyXFxuLy8gXFxcIiFcXFwiIFxcclxcbmBgYFxcclxcblxcclxcbuyVhOuemCDsmIjsi5zsmYAg6rCZ7J20IO2VqOyImOuSpOyXkCDrtpnsl6zso7zripQg6rSE7Zi47JWI7JeQIOyduOyekOulvCDrhKPslrTso7zrqbQg7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYIOuCtOu2gOyXkOyEnCDtmZzsmqntlaAg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG7sp4DquIjsnYAg7Iir7J6QIOyekOujjO2YleydhCDrhKPslrTspKzsp4Drp4wg67Cw7Je064+EIOqwgOuKpe2VqeuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwiUmVhY3TtlITroZzsoJ3tirggTm9kZWpzIOuyhOyghCh2MTAueCDihpIgdjE0LngpIOyYrOumrOq4sFxcXCJcXG5kYXRlOiBcXFwiMjAyMi4wMy4yNFxcXCJcXG50YWdzOlxcbiAgICAgICAtIG5vZGVqc1xcbiAgICAgICAtIGNyYVxcbiAgICAgICAtIHJlYWN0XFxuICAgICAgIC0g64W465Oc67KE7KCEXFxuLS0tXFxuXFxuXFxuIyBSZWFjdO2UhOuhnOygne2KuCBOb2RlanMg67KE7KCEKHYxMC54IOKGkiB2MTQueCkg7Jis66as6riwXFxuXFxuIyMgYnVpbGRpdC1jby1rci1yZWFjdCDtlITroZzsoJ3tirgg7ZiEIOyKpO2OmVxcblxcbmBgYGpzeFxcbi8vIHBhY2thZ2UuanNvblxcblxcblxcXCJyZWFjdC1zY3JpcHRzXFxcIjogXFxcIl4yLjEuOFxcXCIsXFxuXFxcInR5cGVzY3JpcHRcXFwiOiBcXFwiMy44XFxcIixcXG5cXFwibm9kZS1zYXNzXFxcIjogXFxcIl40LjE0LjFcXFwiLFxcbi4uLlxcbmBgYFxcblxcbi0g7ZqM7IKsIO2UhOuhnOygne2KuOuKlCAyMDIy64WEIDPsm5QgMjHsnbwgbm9kZWpz64qUIDEwLjIzLjAg67KE7KCE7J2EIOyCrOyaqe2VmOqzoCDsnojsirXri4jri6QuXFxuXFxubm9kZSDrsoTsoITsnbQg64Ku7J2AIO2OuOydtOyWtOyEnCDstZzsi6AgamF2YXNjcmlwdCDrrLjrspXsnYQg7JOw7KeAIOuqu+2VmOuKlCDrrLjsoJwg7IOB7Zmp7J20IOyeiOyXiOuKlOuNsCwg7J2066W8IO2VtOqysO2VmOq4sCDsnITtlbTshJzripQg7YGs6rKMIOuRkCDqsIDsp4Ag67Cp67KV7J20IOyeiOyKteuLiOuLpC5cXG5cXG4x77iP4oOjIHJlYWN0LXJld2lyZeuhnCBDUkEg7ISk7KCVIOykkSBiYWJlbOyEpOygleydhCBvdmVycmlkZe2VmOq4sFxcblxcbjLvuI/ig6Mgbm9kZSDrsoTsoITqs7wgZGVwZW5kZWN56rCAIOyeiOuKlCDrnbzsnbTruIzrn6zrpqzrk6TsnZgg67KE7KCE7J2EIOqwmeydtCDsmKzroKTshJwg7ZW06rKw7ZWY6riwXFxuXFxuMeuyiOydmCDqsr3smrAg7JWE656YIOq4gOyXkOyEnCDsnpHshLHtlZwg6rKD7LKY65+8IOydtOuvuCDsnpHsl4XsnYQg7KeE7ZaJ7ZW067O07JWY7Iq164uI64ukLlxcblxcbiMjIyMgOmxpbms6W3JlYWN0LXJld2lyZWQg7IKs7Jqp7ZW07IScIGVqZWN07JeG7J20IENSQeyXkGJhYmVs7ISk7KCVIOy2lOqwgO2VmOq4sF0oaHR0cHM6Ly9saWtlbGlvbnN1bmdndWsuZ2l0aHViLmlvLzIyLTAzLTIzL3JlYWN0LXJld2lyZWQtJUVDJTgyJUFDJUVDJTlBJUE5JUVEJTk1JUI0JUVDJTg0JTlDLWVqZWN0JUVDJTk3JTg2JUVDJTlEJUI0LUNSQSVFQyU5NyU5MGJhYmVsJUVDJTg0JUE0JUVDJUEwJTk1LSVFQyVCNiU5NCVFQSVCMCU4MCVFRCU5NSU5OCVFQSVCOCVCMClcXG5cXG5cXG5cXG4x67KI7J2YIOqyveyasCBDUkEg4oCcb25lIGJ1aWxkIGRlcGVuZGVjeeKAneqwgCDquajsp4gg7IiYIOyeiOuKlCDsnITtl5jshLHsnbQg7J6I7Jy866+A66GcIOydtOywuOyXkCAy67KIIOuwqeuyleydhCDsjajrs7TquLDroZwg7ZaI7Iq164uI64ukLlxcblxcbiMjIOuyhOyghCDshKDtg53tlZjquLBcXG5cXG7rqLzsoIAgbm9kZWpzIOuyhOyghOydhCDshKDtg53tlZjquLAg7KCE7JeQ64qUIOuLpOydjOydmCDrgrTsmqnrk6TsnYQg7LK07YGs7ZW067Sk7Iq164uI64ukLlxcblxcbuKchSDsgqzsmqntlZjqs6DsnpAg7ZWY64qUIOq4sOuKpeydhCDsoJzqs7XtlZjripTqsIA/XFxuXFxu4pyFIOuLpOuluCDtlITroZzsoJ3tirjrk6Tqs7wg67KE7KCEIOywqOydtOqwgCDsi6ztlZjsp4Ag7JWK64qU6rCAP1xcblxcbi0tLVxcblxcbiMjIyDinIUg7IKs7Jqp7ZWY6rOg7J6QIO2VmOuKlCDquLDriqXsnYQg7KCc6rO17ZWY64qU6rCAP1xcblxcbuykkeygkOyggeycvOuhnCDsg53qsIHtlojrjZgg6riw64ql7J2EICoqKm9wdGlvbmFsIGNoYWluaW5nKioqIOydtOyXiOyKteuLiOuLpC5cXG5cXG4hW+y2nOyymDogbWRuXSgvYXNzZXRzL2ltZy8wMzI0LTAucG5nKVxcblxcbuy2nOyymDogbWRuXFxuXFxuMTQuMC4wIOuyhOyghCDsnbTsg4HrtoDthLAg7KeA7JuQ7ZWY64qUIOqyg+ydhCDtmZXsnbjtlaAg7IiYIOyeiOyXiOyKteuLiOuLpC5cXG5cXG4jIyMg4pyFIOuLpOuluCDtlITroZzsoJ3tirjrk6Tqs7wg67KE7KCEIOywqOydtOqwgCDsi6ztlZjsp4Ag7JWK64qU6rCAP1xcblxcbi0g7ZqM7IKs64K0IOuLpOuluCDtlITroZzsoJ3tirgxOiBgbm9kZWpzMTQueGBcXG4tIO2ajOyCrOuCtCDri6Trpbgg7ZSE66Gc7KCd7Yq4MjogYG5vZGVqczEyLnhgXFxuXFxu7KKF7ZWp7KCB7Jy866GcIOqzoOugpO2VtOu0pOydhCDrlYwg7LWc7KKF7KCB7Jy866GcIG5vZGVqcyAxNOuyhOyghOydhCDsgqzsmqntlZjquLDroZwg7ZWY7JiA7Iq164uI64ukLlxcblxcbm52bSDsnLzroZwgbm9kZWpzIOuyhOyghOydhCAxMC4yMy4wLiDsl5DshJwgMTQuMTUuNOuhnCDrsJTqvrjqs6Ag64KY7IScIG5wbSBzdGFydOulvCDsi6TtlontlZjrqbQg7JeQ65+s6rCAIOuwnOyDne2VqeuLiOuLpC5cXG5cXG4hW25vZGXrsoTsoITsl5Drn6xdKC9hc3NldHMvaW1nLzAzMjQtMS5wbmcpXFxuXFxubm9kZeuyhOyghOyXkOufrFxcblxcbmBgYGJhc2hcXG5Ob2RlIFNhc3MgdmVyc2lvbiBYLjAuMCBpcyBpbmNvbXBhdGlibGUgd2l0aCBeNC4wLjAgXFxuYGBgXFxuXFxu67O066m0IG5vZGUtc2FzcyDrnbzsnbTruIzrn6zrpqzsmYAg7J2Y7KG07ISxIOy2qeuPjOydtCDsnbzslrTrgpjqs6Ag7J6I7Iq164uI64ukLlxcblxcbiFbbm9kZXNhc3PsnZjsobTshLHstqnrj4xdKC9hc3NldHMvaW1nLzAzMjQtMi5wbmcpXFxuXFxubm9kZSAxNOuyhOyghOydgCBub2RlLXNhc3Mg7LWc7IaMIDQuMTQg67KE7KCEIOydtOyDgeydhCDshKTsuZjtlbTspJjslbwg7KCV7IOBIOuPmeyeke2VmOuKlCDqsoPsnLzroZwg67O07J6F64uI64ukLlxcblxcbuyCtO2OtOuztOuLiCDquLDsobQgbm9kZS1zYXNz67KE7KCE7J20IDQuMTQg67KE7KCE7J207JeI64qU642wIOy2qeuPjOydtCDrgqzsirXri4jri6QuIDQuMTQrIOuKlCDsnbTsg4HsnZgg6rCc64WQ67O064uk64qUIFxcXCLstIjqs7xcXFwiIOqwnOuFkOycvOuhnCDrs7Tqs6AgNC4xNC4x67KE7KCE7J2EIOyEpOy5mO2VtOu0pOyKteuLiOuLpC5cXG5cXG5cXG5cXG4jIyDsnpHsl4Ug7KeE7ZaJXFxuXFxuMS4gbm9kZSB2ZXJzaW9uIOuzgOqyvSAodjE0LjE1LjTroZwg7ZaI7Iq164uI64ukLilcXG4yLiBub2RlLXNhc3MgdW5pbnN0YWxsXFxuMy4gbm9kZS1zYXNzQDQuMTQuMeuhnCDsnqzshKTsuZggKGBucG0gaSBub2RlLXNhc3NANC4xNC4xYClcXG40LiByZWFjdC1zY3JpcHRzIOuyhOyghOyYrOumrOq4sCBgcGFja2FnZS5qc29uYCDsl5DshJwgXFxcInJlYWN0LXNjcmlwdHNcXFwiOlxcXCJeMy4zLjBcXFwiXFxuNS4gcGFja2FnZS1sb2NrLmpzb24g7KeA7Jqw6rOgIOuLpOyLnCBgbnBtIGlgXFxuNi4gZXMtbGludCDsmKTrpZgg7IiY7KCVXFxuXFxu7JyEIOuLqOqzhOulvCDsi6TtlontlZjri6Trs7TrqbQgM+uyiCDsnbTtm4Tsl5Ag64uk7J2M6rO8IOqwmeydgCDsl5Drn6zrpbwg66eM64KgIOyImCDsnojsirXri4jri6QuXFxuXFxuYGBgYmFzaFxcbkFkZCBAYmFiZWwvcGx1Z2luLXByb3Bvc2FsLW9wdGlvbmFsLWNoYWluaW5nXFxuYGBgXFxuXFxu7J2065WMIHJlYWN0LXNjcmlwdHPsnZgg67KE7KCE7J2EIDMuMy4wIOydtOyDgeycvOuhnCDrgYzslrTsmKzroKTso7zrqbQg7JyEIOusuOygnOulvCDtlbTqsrDtlaAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG4ocmVhY3QtcmV3aXJl66W8IOyViOyTsOqzoCDstZzrjIDtlZwgcmVhY3Qtc2NyaXB0c+ulvCDsgqzsmqntlZjquLAg7JyE7ZW0IHJlYWN0LXNjcmlwdHPrsoTsoITsnYQg6rCZ7J20IOyYrOugpOyjvOyXiOyKteuLiOuLpC4pXFxuXFxu7J207ZuEIDbrsojquYzsp4DsnZgg6rO87KCV7J2EIOynhO2Wie2VmOuptCBub2RlMTTrsoTsoITsnLzroZwg7ZSE66Gc7KCd7Yq466W8IOy7tO2MjOydvCDtlZjsl6wg7Iuk7ZaJ7ZWgIOyImCDsnojsirXri4jri6QuXFxuXFxuXFxuXFxuIyMg67Cw7Y+sIOusuOygnCDrsJzsg51cXG5cXG7snIQg7J6R7JeF7J2EIOynhO2Wie2VmOqzoOuCmOuptCDroZzsu6zsl5DshJzripQg66y47KCc7JeG7J20IOyekeuPmeyLnO2CrCDsiJgg7J6I7Iq164uI64ukLiDtlZjsp4Drp4wg67Cw7Y+s66W8IO2VmOuptCDruYzrk5zqsIAg7Iuk7Yyo7ZWY66mwIOuwsO2PrOyXkCDsi6TtjKjtlanri4jri6QuXFxuXFxuIVvsl6zquLDquYzsp4DripQg66y47KCc7JeG6rOgXSgvYXNzZXRzL2ltZy8wMzI0LTMucG5nKVxcblxcbuyXrOq4sOq5jOyngOuKlCDrrLjsoJzsl4bqs6BcXG5cXG4hW0NJPVRydWVdKC9hc3NldHMvaW1nLzAzMjQtNC5wbmcpXFxuXFxu7Jes6riw7ISc67aA7YSwIFtwcm9jZXNzLmVudi5DSV0oaHR0cDovL3Byb2Nlc3MuZW52LkNJKSA9IHRydWUg7Jes7IScIHdhcm5pbmdzIOulvCBlcnJvcnProZwg67O464uk6rOgIO2VmOuptOyEnCBjb21waWxl7JeQIOyLpO2MqO2VmOuKlCDrqqjsirXsnYQg67O07Jes7KSN64uI64ukLlxcblxcbiFb7Lu07YyM7J287JeQIOyLpO2MqO2VmOqzoOyEnCBnaXRsYWIgY2nsnZggSm9i7J20IOyLpO2MqO2WiOyKteuLiOuLpC5dKC9hc3NldHMvaW1nLzAzMjQtNS5wbmcpXFxuXFxu7Lu07YyM7J287JeQIOyLpO2MqO2VmOqzoOyEnCBnaXRsYWIgY2nsnZggSm9i7J20IOyLpO2MqO2WiOyKteuLiOuLpC5cXG5cXG4jIyMg67Cw7Y+s7Iuk7YyoIOusuOygnOybkOyduCDssL7quLBcXG5cXG4jIyMgKipXaGF0IGlzIHRoaXMgZXJyb3IgYWxsIGFib3V0PyAoYWJvdXQgbmV0bGlmeSBkZXBsb3kpKipcXG5cXG5CZWdpbm5pbmcgb27CoCpKdW5lIDE1LCAyMDIwLCrCoE5ldGxpZnkgc3RhcnRlZCBhIGdyYWR1YWwgcm9sbG91dCBvZsKgYWRkaW5nIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBDSSB0byBidWlsZCBlbnZpcm9ubWVudHMsIHdpdGggdGhlIHZhbHVlIG9mIHRydWUuIFRoaXMgZW52aXJvbm1lbnQgdmFyaWFibGUsIHNob3J0IGZvciBDb250aW51b3VzIEludGVncmF0aW9uLCBpcyBjb21tb25seSBzZXQgaW4gdmFyaW91cyBDSSBlbnZpcm9ubWVudHMgbGlrZSBUcmF2aXMgQ0kgYW5kIEdpdGh1YiBBY3Rpb25zLCBhbW9uZyBtYW55IG90aGVycy4gVGhlIGVjb3N5c3RlbSBoYXMgbGFyZ2VseSBhZ3JlZWQgdG8gdXNlIHRoaXMgZW52aXJvbm1lbnQgc2V0dGluZyB0byBkZXRlY3Qgd2hlbiBhIGJ1aWxkIGlzIGV4ZWN1dGluZyBpbiBhIENJIGVudmlyb25tZW50LCBhcyBvcHBvc2VkIHRvIGEgbG9jYWwgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQuXFxuXFxuVGhpcyBzZXR0aW5nIGFsbG93cyBtYW55IGNvbW1vbiBsaWJyYXJpZXMgdG8gZGV0ZWN0IGEgQ0kgZW52aXJvbm1lbnQgYW5kIGNoYW5nZSBiZWhhdmlvciBhY2NvcmRpbmdseS4gT25lIHN1Y2ggYmVoYXZpb3IgaXMgdGhlIGRpc2FibGluZyBvZiBwcm9ncmVzcyDigJxzcGlubmVyc+KAnSB0aGF0IHdoaWxlIHVzZWZ1bCBpbiBhIGxvY2FsIGRldmVsb3BtZW50IHRlcm1pbmFsLCBjYW4gcmVuZGVyIHBvb3JseSB3aGVuIG9wZXJhdGluZyBpbiBhIGxvZyBzdHJlYW1lZCBDSSBlbnZpcm9ubWVudC5cXG5cXG4qKipCZWNhdXNlIG9mIHRoaXMgc29tZSBsaWJyYXJpZXMgbm93IGludGVycHJldCB3aGF0IHdlcmUgcHJldmlvdXNseSBqdXN0IHdhcm5pbmdzIGFzIGhhcmQgZXJyb3JzIGFuZCBoYWx0IHRoZSBidWlsZCoqKi4gVGhlIGludGVudGlvbiBpcyB0aGF0IGRldmVsb3BlcnMgc2hvdWxkIG5vdCBzaGlwIHBvdGVudGlhbGx5IGJyb2tlbiBjb25maWd1cmF0aW9ucywgYnV0IHRoZSBkb3duc2lkZSBpcyB0aGF0IGJ1aWxkcyB0aGF0IHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgcHJldmlvdXNseSBzdGFydGVkIGZhaWxpbmcgYWZ0ZXIgdGhpcyBjaGFuZ2UuXFxuXFxu7JyEIOuCtOyaqeydhCDsmpTslb3tlZjrqbQsIENJ7ZmY6rK97J2AIGdpdGh1YiBhY3Rpb25z64KYIHRyYXZpcyDrk7HsnYQg7Y+s7ZWo7ZWY7JesIOuLpOyWke2VnCDqs7Psl5DshJwg7J2867CY7KCB7Jy866GcIOyEpOygleuQmOqzoCDsnojsirXri4jri6QuIOuhnOy7rCDqsJzrsJwg7ZmY6rK97J20IOyVhOuLjCBDSe2ZmOqyveyXkOyEnCDruYzrk5zqsIAg7Iuk7ZaJ65CY64qUIO2ZmOqyveyXkCDrp57strDshJwg67mM65Oc66W8IO2VqeuLiOuLpC4g7Jmc64OQ7ZWY66m0IOuhnOy7rCDtmZjqsr3sl5DshJzripQg7Jyg7Jqp7ZaI642YIOqyg+uTpOydtCBDSeydmCBsb2cgc3RyZWFt6rO8IOqwmeydgCDqs7Psl5DshJwg7J6R64+Z7ZWgIOuVjOuKlCB3b3JraW5nIHBvb3JseSDtlZjquLAg65WM66y47J6F64uI64ukLlxcblxcbuuUsOudvOyEnCBgQ0k9dHJ1ZWAg64qUIOq4sOuzuCDshKTsoJXsnbTrqbAg7J20IOyEpOygleydtCBgdHJ1ZWDroZwg7IS47YyFIOuQmOyWtOyeiOydhCDrlYzsl5DripQgIENJ7ZmY6rK97JeQIOunnuqyjCB3YXJuaW5nc+ulvCBlcnJvcuuhnCDsspjrpqztlZjsl6wg67mM65Oc66W8IOygleyDgeyggeycvOuhnCDqtazshLHtlaAg7IiYIOyeiOuPhOuhnSDtlanri4jri6QuXFxuXFxu7J6l7KCQ7J2AIOqwnOuwnOyekOqwgCBjb25maWfrpbwg7YyM6rS07ZWY7KeAIOuqu+2VmOuPhOuhnSDtlZjripQg6rKD7J20IOyeiOyKteuLiOuLpC4g7ZWY7KeA66eMIOuLqOygkOydgCDquLDsobTsl5Ag7J6YIOuwsO2PrOuQmOuNmCDsi5zsiqTthZzsnbQg7J20IOyEpOygleuVjOusuOyXkCBmYWlsZWTrkJzri6TripQg6rKD7J6F64uI64ukLlxcblxcbkZhY2Vib29rIOyXkOyEnOuPhCByZWFjdC1zY3JpcHRz66W8IO2Gte2VtCDruYzrk5ztlaAg65WMIENJPXRydWXrpbwg6riw67O47ISk7KCV7Jy866GcIO2VmOq4sOuhnCDtlojri6Tqs6Ag7ZWp64uI64ukLiDsl6zquLDshJzripQg7J6Q6riw65Ok64G866asIOyXhOyyreuCmOqyjCBkaXNjdXNzaW9u7J2EIO2VnCDtm4Qg64K066awIOqysOuhoOydtOudvOqzoCDtlZjrhKTsmpQuXFxuXFxuW2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNjU3XShodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzY1NylcXG5cXG5cXG5cXG4jIyMg7ZW06rKw67KVIChGSVgpXFxuXFxuYGBgYmFzaFxcbiQgQ0k9JycgbnBtIHJ1biBidWlsZFxcbiAgICAgICBvclxcbiQgQ0k9ZmFsc2UgbnBtIHJ1biBidWlsZFxcbmBgYFxcblxcbkNJPWZhbHNl7JmAIENJPSDsnYAg7KGw6riIIOuLpOumheuLiOuLpC5cXG5cXG4qKuKAnEZhbHNl4oCdIGlzbuKAmXQgYWx3YXlzIGZhbHNlKipcXG5cXG5UaG91Z2ggaXQgc2VlbXMgbGlrZSB0aGUgbG9naWNhbCBvcHBvc2l0ZSBvZsKgYENJPXRydWVgLCBzZXR0aW5nwqBgQ0k9ZmFsc2VgwqBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIFRoaXMgaXMgYmVjYXVzZSBlbnZpcm9ubWVudCB2YXJpYWJsZSB2YWx1ZXMgYXJlIHByb2Nlc3NlZCBhcyBzdHJpbmdzLCBhbmQgbWFueSBsaWJyYXJpZXMgaW50ZXJwcmV0wqAqYW55KsKgbm9uLWVtcHR5IHN0cmluZyB2YWx1ZSBmb3LCoGBDSWDCoGFzwqBgdHJ1ZWAuXFxuXFxu7ZmY6rK9IOuzgOyImOuTpOydmCDqsJLsnYAg7Iqk7Yq466eB7Jy866GcIOyymOumrOuQmOq4sCDrlYzrrLjsl5Ag66eO7J2AIOudvOydtOu4jOufrOumrOyXkOyEnCBub24tZW1wdHkgc3RyaW5n7J2EIHRydWXroZwg7ZWY6riwIOuVjOusuOyeheuLiOuLpC4gKENJPWZhbHNl66GcIEZhbHNl6rCS7J2EIOyjvOyXiOuLpOqzoCDsg53qsIHtlZjsp4Drp4wgZW1wdHnqsIAg7JWE64uI6riwIOuVjOusuOyXkCBUcnVl65286rOgIOyYpOulmOulvCDrsJzsg53si5ztgqwg7IiYIOyeiOuLpOuKlCDrgrTsmqnsnoXri4jri6QuKVxcblxcbu2ajOyCrOyXkOyEnOuKlCBnaXRsYWIgQ0nrpbwg7JOw6rOgIOyeiOyKteuLiOuLpC4gZ2l0bGFiIENJ7JeQ7ISc64qUIGBDST1mYXNlYCDroZwg7ZaI7J2EIOuVjCDrrLjsoJwg7JeG7J20IOuwsO2PrOulvCDthrXqs7ztlZjquLQg7ZaI7Iq164uI64ukLlxcblxcblxcblxcbi0tLVxcblxcblJlZmVyZW5jZXMuXFxuXFxuW09wdGlvbmFsIGNoYWluaW5nIC0gSmF2YVNjcmlwdCB8IE1ETl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wdGlvbmFsX2NoYWluaW5nKVxcblxcbltIb3cgdG8gZW5hYmxlIG9wdGlvbmFsIGNoYWluaW5nIHdpdGggQ3JlYXRlIFJlYWN0IEFwcCBhbmQgVHlwZVNjcmlwdF0oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTkwOTM2MzAvaG93LXRvLWVuYWJsZS1vcHRpb25hbC1jaGFpbmluZy13aXRoLWNyZWF0ZS1yZWFjdC1hcHAtYW5kLXR5cGVzY3JpcHQpXFxuXFxuW1RyZWF0aW5nIFdhcm5pbmdzIEFzIEVycm9ycyBCZWNhdXNlIFByb2Nlc3MuZW52LkNJID0gVHJ1ZS5dKGh0dHBzOi8vMzYwdGVjaGV4cGxvcmVyLmNvbS90cmVhdGluZy13YXJuaW5ncy1hcy1lcnJvcnMtYmVjYXVzZS1wcm9jZXNzLWVudi1jaS10cnVlLXZlcmNlbC1uZXRsaWZ5LWplbmtpbnMtZXRjLylcXG5cXG5bW1NvbHZlZF0gXFxcIlRyZWF0aW5nIHdhcm5pbmdzIGFzIGVycm9ycyBiZWNhdXNlIG9mIHByb2Nlc3MuZW52LkNJID0gdHJ1ZVxcXCJdKGh0dHBzOi8vZGV2LnRvL2thcGkxL3NvbHZlZC10cmVhdGluZy13YXJuaW5ncy1hcy1lcnJvcnMtYmVjYXVzZS1vZi1wcm9jZXNzLWVudi1jaS10cnVlLWJrNSlcXG5cXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwiaW5wdXQg7KCV7IiY66eMIOyeheugpeuwm+q4sFxcXCJcXG5kYXRlOiBcXFwiMjAyMi4wNy4wOFxcXCJcXG50YWdzOlxcbiAgLSBqYXZhc2NyaXB0XFxuICAtIHRlc3RcXG4gIC0gamVzdFxcbiAgLSB0ZGRcXG4tLS1cXG5cXG4jIGphdmFzY3JpcHQgaW5wdXQg7KCV7IiY66eMIOyeheugpeuwm+q4sFxcblxcbiMjIOusuOygnCDsg4HtmalcXG5cXG48dmlkZW8gc3JjPVxcXCIvYXNzZXRzL2RhdGEv7IaM7IiY7KCQ7Jik66WYLm1wNFxcXCIgd2lkdGg9XFxcIjEwMCVcXFwiIGF1dG9wbGF5IGNvbnRyb2xzIGxvb3A+PC92aWRlbz5cXG5cXG4tIGlucHV07J2YIOu5hOycqOydhCDshozsiJjsoJDsnLzroZwg7J6F66Cl7ZaI7J2EIOuVjCDrtoTrqoUg7J6F66Cl7ZWcIOuMgOuhnOuKlCDstJ0g7ZWp6rOE6rCAIDEwMOydtCDrgpjsmYDshJwg65SxIOunnuyVhCDrlqjslrTsp4DripTrjbAsIOuvuOyEoO2DneyXkCAwLjAwMDAwMDAwMDEg6rO8IOqwmeydgCDsiKvsnpDqsIAg64Ko7JWE7J6I6rGw64KYIDEwMOydtCDri6Qg66ee7J2EIOuVjCA3LjEwMjM5ODEyMDPsmYAg6rCZ7J2AIOyXieuase2VnCDsiKvsnpDqsIAg64KY7Jik64qUIOyYpOulmOqwgCDsnojsirXri4jri6QuXFxuXFxuXFxuXFxuIyMg66y47KCcIOybkOyduFxcblxcbiFbaW1hZ2UucG5nXSgvYXNzZXRzL2ltZy9qYXZhc2NyaXB0aW5wdXTsoJXsiJjrp4zsnoXroKXrsJvquLAxLnBuZylcXG5cXG7rrLjsoJwg7JuQ7J247J2AIOyekOuwlOyKpO2BrOumve2KuCDshozsiJjsnZgg7Yq57KeV7J6F64uI64ukLlxcblxcbuyekOuwlOyKpO2BrOumve2KuOydmCDsiKvsnpDripQgKioqKjY0IOu5hO2KuCDrtoDrj5kg7IaM7IiY7KCQKioqKuyeheuLiOuLpC5cXG5cXG7smrDrpqzqsIAg7JOw64qUIDEw7KeE67KV7J2EIOyekOuwlOyKpO2BrOumve2KuCDsl5Tsp4TsnYAgMuynhOuyleycvOuhnCDrsJTqv5TshJwg6rOE7IKw7J2EIO2VmOuKlOuNsCwg7J2065WMIO2KueyglSDshozsiJjsnZgg6rK97JqwIOustO2VnOyGjOyImOqwgCDrkJjslrTrsoTrpr3ri4jri6QuICjsmIg6IGNvbnN0IOyGjOyImCA9IDEwLzMpXFxuXFxu7J2065+wIOqyveyasCDsnpDrsJTsiqTtgazrpr3tirjripQg66y07ZWc7IiY66W8IOygle2VtOynhCDsnpDsm5Ag7JWI7JeQ7IScIO2RnO2YhO2VmOq4sCDsnITtlbQg7Jyg7ZWc7ZWY6rKMIOuzgOqyvSDtlZjroKTri6Qg67O064uIIOuvuOyEuO2VnCDqsJLrk6TsnbQg7LSI6rO865CY6rGw64KYIOyGkOyLpOuwnOyDne2VmOqyjCDrkKnri4jri6QuXFxuXFxu65WM66y47JeQIOqyveyasOyXkCDrlLDrnbwg64yA6561IOyGjOyImOygkCDslYTrnpggMTUgfiAxN+yekOumrOyXkOyEnCDqt7gg66y07ZWc7IaM7IiY66W8IOuBiuqzoCDqt7zsgqzqsJLsnLzroZwg7KCA7J6l7ZWY7JesIOyXsOyCsOydhCDsiJjtlontlanri4jri6QuXFxuXFxuXFxuXFxuIyMg66y47KCc7ZW06rKwIOuwqeyLnSDqsrDsoJVcXG5cXG4jIyMgdG9GaXhlZCwgcm91bmTrpbwg7IKs7Jqp7ZWY7KeAIOyViuuKlCDsnbTsnKBcXG5cXG7qsIDsnqUg66eO7J20IOyTsOydtOuKlCDqsoPsnbQgdG9GaXhlZCwgcm91bmQg6rCZ7J20IOyGjOyImOygkOydhCDtirnsoJUg7J6Q66a/7IiY7JeQ7IScIOuBiuqzoOyEnCDtlbTri7kg7IiY7LmY65Ok7J2EIO2VqeqzhO2VmOqxsOuCmCDri6Qg7Jew7IKw7J20IOuQnCDtm4Tsl5Ag64+Z7J287ZWcIOyymOumrOulvCDtlaAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG7tlZjsp4Drp4wg7IS464yA7YOA7J6F7J2AIOy0ne2VqeydtCAxMDDsnbQg65CY7Ja07JW8IO2VmOqzoCDsnbQg7ZWp6rOE66W8IOynhO2Wie2VmOuKlCDroZzsp4HsnbQg7IOd6rCB67O064ukIOyXrOufrCDqs7Psl5DshJwg67mI67KI7ZWY6rKMIOydvOyWtOuCmOqzoCDsnojsirXri4jri6QuXFxuXFxu7J20IO2VqeqzhOuhnOyngeuTpOydhCDrqqjrkZAg7LC+7JWE64uk64uI66m07IScIOyImOygle2VmOuKlCDqsoPsnYAg67mE7Zqo7Jyo7KCB7J24IOuwqeuyleydtOudvCDtjJDri6jtlojsirXri4jri6QuXFxuXFxuIyMjIOyEuOuMgO2DgOyehSDruYTsnKgg7J6F66ClIOyLnCDsoJXsiJjqsJLrp4wg67Cb64+E66GdIOyImOygle2VnCDsnbTsnKBcXG5cXG7shozsiJjrrLjsoJzrpbwg6rCA7J6lIOyJveqyjCDtlbTqsrDtlaAg7IiYIOyeiOuKlCDqsoPsnYAg7J6F66Cl7J2EIOygleyImOuhnOunjCDrsJvrj4TroZ0g7ZWY64qUIOqyg+yeheuLiOuLpC5cXG5cXG7tlZjsp4Drp4wgVVjqtIDsoJDsl5DshJwg7IKs7Jqp7J6Q6rCAIOyEuOuMgO2DgOyeheydmCDruYTsnKjsnYQg6rytIOyGjOyImOygkOycvOuhnCDtkZztmITtlbTslbzrp4wg7ZWc64uk66m0IOuYkCDri6Trpbgg7JaY6riw7J6F64uI64ukLiDsnbQg65WMIOyLpOygnOuhnCDsnpDso7wg7IKs7Jqp7ZWY64qUIOyCrOyaqeyEseydhCDssrTtgaztlbTrs7gg6rKw6rO8IOyEuOuMgO2DgOyehSDruYTsnKjsnYAg64yA65617KCB7J24IOyImOy5mOydtOq4sCDrlYzrrLjsl5Ag67CY65Oc7IucIOyGjOyImOygkOq5jOyngCDtkZzquLDtlaAg7ZWE7JqU6rCAIOyXhuuLpOuKlCDqsoPsnYQg7ZmV7J247ZWY7JiA7Iq164uI64ukLiDrlLDrnbzshJwg7KCV7IiY66GcIOyImOygle2VtOuPhCDtgbAg66y066as6rCAIOyXhuuLpOuKlCDtjJDri6jsnYQg7ZWgIOyImCDsnojsl4jsirXri4jri6QuXFxuXFxuXFxuXFxuIyMg66y47KCc7ZW06rKwIOqzvOyglVxcblxcbmphdmFzY3JpcHTsl5DshJzripQg7YOA7Ja47Ja07JmAIOuLpOultOqyjCDsiKvsnpAg7YOA7J6F7J20IOuUsSDtlZjrgpjrsJbsl5Ag7JeG7Iq164uI64ukLiDrlLDrnbzshJwgaW50ZWdlcuuhnCDshKTsoJXsnYQg67CU6r6464qUIOuwqeuyleydhCDsgqzsmqntlZjsp4Ag66q77ZWY66+A66GcIOygleyImOqwkuunjCDsnoXroKXsnYQg67Cb64+E66GdIO2VmOq4sCDsnITtlbTshJzripQg7JW96rCE7J2YIO2KuOumreydtCDtlYTsmpTtlanri4jri6QuXFxuXFxuLSDsnbzri6gg7KCV7IiY66eMIOyeheugpeydtCDqsIDriqXtlZjrj4TroZ0g7ZWY64qUcGF0dGVybuydhCBwcm9wc+ycvOuhnCDrgrTroKTspJjshJwgcGF0dGVybuyXkCDrp57ripQg7J6F66Cl66eMIOyeheugpeydtCDqsIDriqXtlZjrj4TroZ0g7ZW07KSY7JW8IO2VqeuLiOuLpC5cXG4tIGlucHV07JeQIHBhdHRlcm7snYQg7KSEIOyImCDsnojripQg6rKD7J2AIHRleHTtg4DsnoXsnoXri4jri6QuIChudW1iZXLripQgWClcXG4tIOuUsOudvOyEnCBpbnB1dCB0eXBlPeKAnW51bWJlcuKAnSDqsIAg7JWE64uMIGlucHV0IHR5cGU94oCddGV4dOKAneuhnCDshKTsoJXtlbTspJjslbwg7ZWp64uI64ukLlxcblxcbiMjIyAxLiBQcm9qZWN0Rm9ybUhvdXNpbmcgPiBQcm9qZWN0RmllbGRJbnB1dCDsiJjsoJVcXG5cXG5gYGBqc3hcXG4vLyDquLDsobRcXG48UHJvamVjdEZpZWxkSW5wdXRcXG5cXHQuLi5cXG4gIHR5cGU9XFxcIm51bWJlclxcXCJcXG4gIHVuaXQ9XFxcIiVcXFwiXFxuICAuLi5cXG4vPlxcbmBgYFxcblxcbmBgYGpzeFxcbi8vIOyImOyglSDtm4RcXG48UHJvamVjdEZpZWxkSW5wdXRcXG5cXHQuLi5cXG4gIHR5cGU9XFxcInRleHRcXFwiXFxuICBwYXR0ZXJuPXtcXFwiWzAtOV0qXFxcIn1cXG4gIHVuaXQ9XFxcIiVcXFwiXFxuICAuLi5cXG4vPlxcbmBgYFxcblxcbjHssKjroZwg7J2066CH6rKMIOyekeyXheydhCDsp4TtlontlZwg65KkIHByb2plY3RGaWVsbklucHV07JeQ7IScIHBhdHRlcm7snYQgcHJvcHPrsJvslYTshJwg7IKs7Jqp7ZW067O066m0IOygleyImOunjCDsnoXroKXsnbQg6rCA64ql7ZWY64+E66GdIOyemCDrj5nsnpHtlanri4jri6QuXFxuXFxu7ZWY7KeA66eMLCDsiKvsnpDsnoXroKXqsJLsnbQg7JWE64uMIOuLpOuluCDsnoXroKXqsJLsnbQg65Ok7Ja07Jik64qUIOqyveyasCBgTmFOYCDsnYQg652E7JuM7KO864qUIOydmOuPhO2VmOyngCDslYrsnYAg64+Z7J6R7J20IOydvOyWtOuCqeuLiOuLpC5cXG5cXG4hW+yIq+yekOqwgCDslYTri4wg7J6F66Cl7J2EIO2VmOuptCBOYU7snYQg652E7JuM7KO864qUIOydmOuPhOy5mCDslYrsnYAg64+Z7J6R7J2EIO2VmOqyjCDrkKnri4jri6QuXSgvYXNzZXRzL2ltZy9qYXZhc2NyaXB0aW5wdXTsoJXsiJjrp4zsnoXroKXrsJvquLAyLnBuZylcXG5cXG7siKvsnpDqsIAg7JWE64uMIOyeheugpeydhCDtlZjrqbQgTmFO7J2EIOudhOybjOyjvOuKlCDsnZjrj4TsuZgg7JWK7J2AIOuPmeyekeydhCDtlZjqsowg65Cp64uI64ukLlxcblxcbiMjIyAyLiBvbmNoYW5nZSDsl5DshJwg7Iir7J6Q6rCAIOyVhOuLjCDqsJIg7LKY66as7ZW07KO86riwXFxuXFxu7ZiE7J6sIO2ZnOyaqe2VmOqzoCDsnojripQgcHJvamVjdEZpZWxkSW5wdXTsnYAgb25DaGFuZ2Ug7J2067Kk7Yq4IOuwnOyDneyLnOyXkCBgdXBkYXRlVmFsdWVgIO2VqOyImOulvCDthrXtlbQgc3RhdGXqsJLsnYQg6rSA66as7ZWY6rOgIOyeiOyKteuLiOuLpC5cXG5cXG7snbQg7ZWo7IiY7JeQ7IScIOyIq+yekOqwgCDslYTri4wg7J6F66Cl6rCS7J2EIOuwm+ydgCDqsr3smrAgcmV0dXJuIOydhCDrp4nslYTso7zrqbQsIOychCDsmKTrpZgg7IKs7ZWt7J2EIO2VtOqysO2VoCDsiJgg7J6I7J2EIOqxsOudvCDtjJDri6jtlojsirXri4jri6QuXFxuXFxuYGBganN4XFxudXBkYXRlVmFsdWUgPSAodHlwZTogJ0hPVVNJTkcnIHwgJ01ZX1RZUEUnLCBpbmRleDogbnVtYmVyLCBhcmVhPzogbnVtYmVyLCBiYXk/OiBudW1iZXIsIHByb3BvcnRpb24/OiBudW1iZXIsIHVzZXJkZWY/OiBib29sZWFuKSA9PiB7XFxuICAgIGlmIChwcm9wb3J0aW9uICE9PSB1bmRlZmluZWQgJiYgIWlzRmluaXRlKHByb3BvcnRpb24pKSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4uLi5cXG59XFxuYGBgXFxuXFxu7JyE7JmAIOqwmeydtCB1cGRhdGVWYWx1ZSDtlajsiJjsnZgg7LWc7IOB64uo7JeQIHByb3BvcnRpb27snbQg7Iir7J6Q6rCAIOyVhOuLjOqyveyasCByZXR1cm7snYQg67mE7Ja065GQ7Ja0IOyymOumrO2VmOyYgOyKteuLiOuLpC4gYGlzRmluaXRlKClgIOydgCDsiKvsnpDsnbjsp4Ag7JWE64uM7KeAIOyytO2BrO2VmOuKlCDtlajsiJjsnoXri4jri6QuIOy1nOyDgeychCDtlajsiJjroZwg7Ja065akIOqwneyytOyZgOuPhCDsl7DqsrDrkJjsp4Ag7JWK7JWY7Iq164uI64ukLiBOYW4sIC1pbmZpbml0ZSwgK2luZmluaXRlIOKGkiBmYWxzZSwg64KY66i47KeA64qUIHRydWXrpbwg67CY7ZmY7ZWp64uI64ukLlxcblxcbiMjIyAzLiBDU1Mg66ee7LaU6riwXFxuXFxuQnVpbGRpdElucHV07J2AIO2BrOqyjCB0eXBl7J20IHRleHTsnbjsp4AgbnVtYmVy7J247KeA7JeQIOuUsOudvCBDU1PqsIAg64uk66W06rKMIOyEpOygleuQqeuLiOuLpC5cXG5cXG5UZXh07J2YIOqyveyasCBpbnB1dOywveydmCDsmbzsqr3sl5Ag7KCV66Cs7J20IOuQmOqzoCB1bml0IOyEpOygleydgCDrlLDroZwg7JeG7Iq164uI64ukLlxcblxcbk51bWJlcuydmCDqsr3smrAgaW5wdXTssL3snZgg7Jik66W47Kq97JeQIOygleugrOydtCDrkJjqs6AgdW5pdOydgCBwcm9wc+ulvCDrsJvsirXri4jri6QuXFxuXFxuIVtURVhUXSgvYXNzZXRzL2ltZy9qYXZhc2NyaXB0aW5wdXTsoJXsiJjrp4zsnoXroKXrsJvquLAzLnBuZylcXG5cXG5URVhUXFxuXFxuIVtOdW1iZXJdKC9hc3NldHMvaW1nL2phdmFzY3JpcHRpbnB1dOygleyImOunjOyeheugpeuwm+q4sDQucG5nKVxcblxcbk51bWJlclxcblxcbuyEuOuMgO2DgOyeheydmCDqsr3smrAg7JuQ656Y64yA66Gc652866m0IOyasOy4oeygleugrOydtCDrkJjqs6Ag64uo7JyE7J24ICXquYzsp4AgdW5pdOycvOuhnCDtkZztmITrkJjripQg6rKD7J20IOyYrOuwlOumheuLiOuLpC4g7ZWY7KeA66eMIOydtOuyiCDsoJXsiJjrp4wg7J6F66Cl6rCA64ql7ZWY64uk64qUIO2KueyEseydtCDstpTqsIDrkJjrqbTshJwg7J20IOu2gOu2hOyXkCDrjIDtlZwgVUnthrXsnbzshLHsnbQg6rmo7KC467KE66as6rKMIOuQmOyXiOycvOuvgOuhnCDsnbTrpbwg64uk7IucIOunnuy2sOyjvOuKlCDsnpHsl4XsnbQg7ZWE7JqU7ZWp64uI64ukLlxcblxcbuydtOuvuCDsu7Ttj6zrhIztirgg7J6Q7LK07JeQIGFsaWdu7J20652864qUIO2UhOuhnO2NvO2LsOulvCDsoJXsnZjtlbQg65GQ7JeI6riwIOuVjOusuOyXkCDqsITri6jtlZjqsowgbGVmdCwgcmlnaHQsIGNlbnRlcuulvCDshKDtg53tlaAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG7rlLDrnbzshJwgUHJvamVjdEZpZWxkSW5wdXQgY29tcG9uZW507JeQ7IScIGFsaWduPeKAnXJpZ2h04oCd7J2EIHByb3Bz7ZW07KO866m0IOyasOy4oeygleugrOydhCDtlaAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG4hW1VudGl0bGVkXSgvYXNzZXRzL2ltZy9qYXZhc2NyaXB0aW5wdXTsoJXsiJjrp4zsnoXroKXrsJvquLA1LnBuZylcXG5cXG7igJTrgZ3igJRcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwiVHlwZXNjcmlwdCDsi5zsnpHtlZjquLBcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDQuMTRcXFwiXFxyXFxudGFnczogXFxyXFxuICAtIHR5cGVzY3JpcHRcXHJcXG4gIC0gdHNcXHJcXG4gIC0g7YOA7J6F7Iqk7YGs66a97Yq4XFxyXFxuLS0tXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyDtg4DsnoXsiqTtgazrpr3tirggZnVuZGFtZW50YWxzIC0g7YOA7J6FLCDtlajsiJgsIOyduO2EsO2OmOydtOyKpCwgZW51bSwg7YG0656Y7IqkXFxyXFxuXFxyXFxuXFxyXFxuIyMgMS4g6riw67O47YOA7J6FXFxyXFxuXFxyXFxu67OA7IiY7ISg7Ja467Cp7IudIOuzgOyImOuqhSA6IO2DgOyehSA9IOqwkjtcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgc3RyOiBzdHJpbmcgPSAnaGknXFxyXFxubGV0IG51bTogbnVtYmVyID0gMTA7XFxyXFxubGV0IGlzTG9nZ2VkSW46IGJvb2xlYW4gPSBmYWxzZTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgQXJyYXlcXHJcXG5cXHJcXG7smpTshozsnZgg7KeR7ZWpXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IGFycjogbnVtYmVyW10gPSBbMSwgMiwgM107XFxyXFxuYXJyWzJdID0gMTAwO1xcclxcblxcclxcbi8vIO2DgOyeheydtCDri6TrpbTrr4DroZwg7JeQ65+sXFxyXFxuYXJyWzJdID0gJ2hpJztcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgVHVwbGVcXHJcXG5cXHJcXG4qKuq4uOydtOqwgCDqs6DsoJUqKuuQmOqzoCDsmpTshowgKirtg4DsnoXsnbQg7KeA7KCVKirrkJwg67Cw7Je0XFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IHR1cGxlOiBbc3RyaW5nLCBudW1iZXJdID0gWydoaScsIDEwXTtcXHJcXG5cXHJcXG4vL+q4uOydtOqwgCDqs6DsoJXrkJjquLDrlYzrrLjsl5Ag7JeQ65+s65y4XFxyXFxudHVwbGVbNV0gPSAnaGVsbG8nO1xcclxcbi8vIG51bWJlcu2DgOyeheyXkCBzdHJpbmcg7ZWg64u5IHgg7JeQ65+sXFxyXFxudHVwbGVbMV0gPSAnaGknO1xcclxcblxcclxcbmBgYFxcclxcblxcclxcbiMjIyBFbnVtXFxyXFxuXFxyXFxuKirsg4HsiJgqKuuTpOydmCDsp5HtlansnbTri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBBdmVuZ2VycyB7IENhcHQsIElyb25NYW4sIFRob3IgfVxcclxcbmxldCBoZXJvOiBBdmVuZ2VycyA9IEF2ZW5nZXJzLkNhcHQ7XFxyXFxuXFxyXFxuY29uc29sZS5sb2coaGVybyk7IC8vIDBcXHJcXG5cXHJcXG4vL+ydveq4sOyghOyaqeydtOudvOyEnCDtlaDri7nrtojqsIAg7JeQ65+sXFxyXFxuQXZlbmdlcnMuQ2FwdCA9IDM7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIEFueVxcclxcblxcclxcbuyekOuwlOyKpO2BrOumve2KuOydmCDrs4DsiJjrnpEg65iR6rCZ64ukLiDrrZDrk6Ag7ZWg64u5IOqwgOuKpVxcclxcblxcclxcbmBgYHRzeFxcclxcbmxldCBzdHI6IGFueSA9ICdoaSc7XFxyXFxubGV0IG51bTogYW55ID0gMTA7XFxyXFxubGV0IGFycjogYW55ID0gWydhJywgMiwgdHJ1ZV07XFxyXFxuXFxyXFxuLy9hbnnrnbzshJwgbnVt7JeQICdoaScg7ZWg64u5IOqwgOuKpVxcclxcbm51bSA9ICdoaSc7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIFZvaWRcXHJcXG5cXHJcXG51bmRlZmluZWTsmYAgbnVsbOunjCDtlaDri7nqsIDriqXtlZjri6QuIOydvOuwmOyggeycvOuhnCDrsJjtmZjtlZjsp4Ag7JWK64qUICoq7ZWo7IiYKirsl5DshJwg7IKs7JqpXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IHVudXNlZnVsOiB2b2lkID0gdW5kZWZpbmVkO1xcclxcbmZ1bmN0aW9uIG5vdHVzZSgpOiB2b2lkIHtcXHJcXG4gIGNvbnNvbGUubG9nKCdzdGgnKTtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIG5ldmVyXFxyXFxuXFxyXFxu7JeQ65+s66W8IHRocm93IO2VmOqxsOuCmCDsoIjrjIAg67CY7ZmY7ZWY7KeAIOyViuuKlCDtlajsiJgo66y07ZWc66Oo7ZSE7J2865WMIOyTsOydtOuEpOyalClcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBuZXZlckVuZCgpOiBuZXZlciB7XFxyXFxuICB3aGlsZSAodHJ1ZSkge1xcclxcblxcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiBuZXZlciB7XFxyXFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMgMi4g7ZWo7IiYXFxyXFxuXFxyXFxuIyMjIO2VqOyImOydmCDquLDrs7jsoIHsnbgg7YOA7J6FIOyEoOyWuFxcclxcblxcclxcbuyekOuwlOyKpO2BrOumve2KuOyZgOydmCDssKjsnbTsoJDsnYAgKirrp6TqsJwg67OA7IiYKirsmYAgKirrsJjtmZgg6rCSKirsl5Ag7YOA7J6FIOu2gOyXrFxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIHN1bShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XFxyXFxuXFx0cmV0dXJuIGEgKyBiO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7ZWo7IiY7J2YIOyduOyekFxcclxcblxcclxcbuyghOuLrCDsnbjsnpDsnZgg7IiY6rCAIOuNlCDrp47qsbDrgpgg7KCB6rGw64KYIO2VmOuptCDri7nsl7Dtnogg7JWI65CY6rKg7KOgPyDri7nsl7Dtnogg7YOA7J6F64+EIOuLpOultOuptCDslYjrkJjsmpRcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBzdW0oYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xcclxcbiAgcmV0dXJuIGEgKyBiO1xcclxcbn1cXHJcXG5zdW0oMTAsIDIwKTsgLy8gMzBcXHJcXG5zdW0oMTAsIDIwLCAzMCk7IC8vIGVycm9yLCB0b28gbWFueSBwYXJhbWV0ZXJzXFxyXFxuc3VtKDEwKTsgLy8gZXJyb3IsIHRvbyBmZXcgcGFyYW1ldGVyc1xcclxcbmBgYFxcclxcblxcclxcbiMjIyDshKDtg53soIEg66ek6rCc67OA7IiYXFxyXFxuXFxyXFxu7ZWY7KeA66eMIOunpOqwnOuzgOyImOyXkCA/66W8IOuLrOyVhOyjvOuptCDqt7gg7KCE64us7J247J6Q66W8IOuEmOq4sOyngCDslYrslYTrj4Qg65Cp64uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIHN1bShhOiBudW1iZXIsIGI/OiBudW1iZXIpOiBudW1iZXIge1xcclxcbiAgcmV0dXJuIGEgKyBiO1xcclxcbn1cXHJcXG5zdW0oMTAsIDIwKTsgLy8gMzBcXHJcXG5zdW0oMTAsIDIwLCAzMCk7IC8vIGVycm9yLCB0b28gbWFueSBwYXJhbWV0ZXJzXFxyXFxuc3VtKDEwKTsgLy8gMTBcXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG4vLyBlcnJvciDtlYTsiJgg66ek6rCc67OA7IiY6rCAIOyEoO2DneyggSDrp6TqsJzrs4DsiJggXFxyXFxuLy8g7ISg7YOd7KCBIOunpOqwnOuzgOyImOqwgCDslZ7sl5Ag7J6I7Jy866m0IOyViOuQqeuLiOuLpC5cXHJcXG5mdW5jdGlvbiBzdW0oYT86IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcXHJcXG4gIHJldHVybiBhICsgYjtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu6riw67O46rCS64+EIOyEpOygle2VtCDspIQg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5mdW5jdGlvbiBzdW0oYTogbnVtYmVyLCBiID0gMTAwKTogbnVtYmVyIHtcXHJcXG4gIHJldHVybiBhICsgYjtcXHJcXG59XFxyXFxuc3VtKDEwLCB1bmRlZmluZWQpOyAvLyAxMTBcXHJcXG5zdW0oMTAsIDIwLCAzMCk7IC8vIGVycm9yLCB0b28gbWFueSBwYXJhbWV0ZXJzXFxyXFxuc3VtKDEwKTsgLy8gMTEwXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIOyduO2EsO2OmOydtOyKpFxcclxcblxcclxcbuyduO2EsO2OmOydtOyKpOuKlCDsg4HtmLjqsITsnZgg7KCV7J2Y7ZWcIOyVveyGjeydtOuCmCDqt5zsuZnsnYQg7J2Y66+47ZWc64ukLlxcclxcblxcclxcbuqwneyytOydmCDsho3shLHqs7wg7IaN7ISx7YOA7J6FXFxyXFxuXFxyXFxu7ZWo7IiY7J2YIOunpOqwnOuzgOyImOuCmCDrsJjtmZjtg4DsnoVcXHJcXG5cXHJcXG7rsLDsl7Tqs7wg6rCd7LK066W8IOygkeq3vO2VmOuKlCDrsKnsi51cXHJcXG5cXHJcXG7tgbTrnpjsiqRcXHJcXG5cXHJcXG5sb2dBZ2Ug66mU7IaM65Oc64qUIGFnZeudvOuKlCDsho3shLHsnYQg6rCW6rOgIG51bWJlcu2DgOyeheydhCDqsJbripQg6rCd7LK066W8IOuwm+uKlOqyg+ydhCDslb3sho3tlojri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IHBlcnNvbiA9IHsgbmFtZTogJ0NhcHQnLCBhZ2U6IDI4IH07XFxyXFxuXFxyXFxuZnVuY3Rpb24gbG9nQWdlKG9iajogeyBhZ2U6IG51bWJlciB9KSB7XFxyXFxuICBjb25zb2xlLmxvZyhvYmouYWdlKTsgLy8gMjhcXHJcXG59XFxyXFxubG9nQWdlKHBlcnNvbik7IC8vIDI4XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIHBlcnNvbkFnZSB7XFxyXFxuICBhZ2U6IG51bWJlcjtcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gbG9nQWdlKG9iajogcGVyc29uQWdlKSB7XFxyXFxuICBjb25zb2xlLmxvZyhvYmouYWdlKTtcXHJcXG59XFxyXFxubGV0IHBlcnNvbiA9IHsgbmFtZTogJ0NhcHQnLCBhZ2U6IDI4IH07XFxyXFxubG9nQWdlKHBlcnNvbik7XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIOyYteyFmOyGjeyEsVxcclxcblxcclxcbuyVhOq5jCDrp6TqsJzrs4DsiJjrlYzsmYAg66eI7LCs6rCA7KeA66GcID/rpbwg67aZ7ZiA7KO866m0IOq3uCDsho3shLHsnYQg66qo65GQIOuLpCDqvK0g7IKs7Jqp7ZWY7KeAIOyViuyVhOuPhCDrkKnri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIENyYWZ0QmVlciB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuICBob3A/OiBudW1iZXI7ICBcXHJcXG59XFxyXFxuXFxyXFxubGV0IG15QmVlciA9IHtcXHJcXG4gIG5hbWU6ICdTYXBvcm8nXFxyXFxufTtcXHJcXG5mdW5jdGlvbiBicmV3QmVlcihiZWVyOiBDcmFmdEJlZXIpIHtcXHJcXG4gIGNvbnNvbGUubG9nKGJlZXIubmFtZSk7IC8vIFNhcG9yb1xcclxcbn1cXHJcXG5icmV3QmVlcihteUJlZXIpO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyDsnb3quLAg7KCE7JqpIOyGjeyEsVxcclxcblxcclxcbnJlYWRvbmx56rCAIOu2meydgCDsho3shLHsnYAg7J2964qU6rKD66eMIOuQnOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgQ3JhZnRCZWVyIHtcXHJcXG4gIHJlYWRvbmx5IGJyYW5kOiBzdHJpbmc7XFxyXFxufVxcclxcblxcclxcbmxldCBteUJlZXI6IENyYWZ0QmVlciA9IHtcXHJcXG4gIGJyYW5kOiAnQmVsZ2lhbiBNb25rJ1xcclxcbn07XFxyXFxubXlCZWVyLmJyYW5kID0gJ0tvcmVhbiBDYXJwZW50ZXInOyAvLyBlcnJvciFcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMg7J296riwIOyghOyaqSDrsLDsl7RcXHJcXG5cXHJcXG5SZWFkb25seUFycmF566GcIOyEoOyWuO2VmOuptCDrsLDsl7Qg64K07JqpIOuzgOqyvSDrtojqsIBSZWFkb25seUFycmF566GcIOyEoOyWuO2VmOuptCDrsLDsl7Qg64K07JqpIOuzgOqyvSDrtojqsIBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5sZXQgYXJyOiBSZWFkb25seUFycmF5PG51bWJlcj4gPSBbMSwyLDNdO1xcclxcbmFyci5zcGxpY2UoMCwxKTsgLy8gZXJyb3JcXHJcXG5hcnIucHVzaCg0KTsgLy8gZXJyb3JcXHJcXG5hcnJbMF0gPSAxMDA7IC8vIGVycm9yXFxyXFxuYXJyID0gWzEwLCAyMCwgMzBdOyAvLyBlcnJvclxcclxcbmBgYFxcclxcblxcclxcbuqwneyytCDshKDslrjqs7wg6rSA66Co65CcIO2DgOyehSDssrTtgrlcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgQ3JhZnRCZWVyIHtcXHJcXG4gIGJyYW5kPzogc3RyaW5nO1xcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBicmV3QmVlcihiZWVyOiBDcmFmdEJlZXIpIHtcXHJcXG4gIC8vIC4uXFxyXFxufVxcclxcbmJyZXdCZWVyKHsgYnJhbmRvbjogJ3doYXQnIH0pOyAvLyDsho3shLHsnbQg64uk66W064uIIOyXkOufrOucueuLiOuLpC5cXHJcXG5gYGBcXHJcXG5cXHJcXG7snbTrn6zrqbQg7YOA7J6FIOyytO2BrOulvCDrrLTsi5ztlZzri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxubGV0IG15QmVlciA9IHsgYnJhbmRvbjogJ3doYXQnIH0nO1xcclxcbmJyZXdCZWVyKG15QmVlciBhcyBDcmFmdEJlZXIpO1xcclxcbmBgYFxcclxcblxcclxcbiMjIyDtlajsiJgg7YOA7J6FXFxyXFxuXFxyXFxu7ZWo7IiYIOunpOqwnOuzgOyImOyZgCDrsJjtmZjtg4DsnoXrj4Qg7J247YSw7Y6Y7J207IqkIOygleydmOqwgCDqsIDriqXtlZjri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIGxvZ2luIHtcXHJcXG4gICh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogYm9vbGVhbjtcXHJcXG59XFxyXFxuXFxyXFxubGV0IGxvZ2luVXNlcjogbG9naW47IC8vIO2VqOyImCDsoIDsnqXtlaAg67OA7IiYIOyEoOyWuFxcclxcbmxvZ2luVXNlciA9IGZ1bmN0aW9uKGlkOiBzdHJpbmcsIHB3OiBzdHJpbmcpIHtcXHJcXG4gIGNvbnNvbGUubG9nKCfroZzqt7jsnbgg7ZaI7Iq164uI64ukJyk7XFxyXFxuICByZXR1cm4gdHJ1ZTtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxu7YG0656Y7IqkIO2DgOyehVxcclxcblxcclxcbuyekOuwlOydmCDsnbjthLDtjpjsnbTsiqTsmYAg66qp7KCB7J20IOu5hOyKt+2VnOuNsFxcclxcblxcclxcbuyWtOuWpCDsnbjthLDtjpjsnbTsiqTrpbwgaW1wbGVtZW50c+2VnCDtgbTrnpjsiqTqsIAg7J6I64uk66m0XFxyXFxuXFxyXFxu7J247YSw7Y6Y7J207Iqk7J2YIOuplOyGjOuTnOyZgCDrs4DsiJjqsIAg7J6I64uk64qUIOqyg+ydhCDrs7TsnqXtlZzri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuaW50ZXJmYWNlIENyYWZ0QmVlciB7XFxyXFxuICBiZWVyTmFtZTogc3RyaW5nO1xcclxcbiAgbmFtZUJlZXIoYmVlcjogc3RyaW5nKTogdm9pZDtcXHJcXG59XFxyXFxuXFxyXFxuY2xhc3MgbXlCZWVyIGltcGxlbWVudHMgQ3JhZnRCZWVyIHtcXHJcXG4gIGJlZXJOYW1lOiBzdHJpbmcgPSAnQmFieSBHdWlubmVzcyc7XFxyXFxuICBuYW1lQmVlcihiOiBzdHJpbmcpIHtcXHJcXG4gICAgdGhpcy5iZWVyTmFtZSA9IGI7XFxyXFxuICB9XFxyXFxuICBjb25zdHJ1Y3RvcigpIHt9XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbuyduO2EsO2OmOydtOyKpCDrgbzrpqwg7IOB7IaN64+EIOqwgOuKpe2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgUGVyc29uIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG59XFxyXFxuaW50ZXJmYWNlIERyaW5rZXIge1xcclxcbiAgZHJpbms6IHN0cmluZztcXHJcXG59XFxyXFxuaW50ZXJmYWNlIERldmVsb3BlciBleHRlbmRzIFBlcnNvbiB7XFxyXFxuICBza2lsbDogc3RyaW5nO1xcclxcbn1cXHJcXG5sZXQgZmUgPSB7fSBhcyBEZXZlbG9wZXI7XFxyXFxuZmUubmFtZSA9ICdqb3NoJztcXHJcXG5mZS5za2lsbCA9ICdUeXBlU2NyaXB0JztcXHJcXG5mZS5kcmluayA9ICdCZWVyJztcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyA0LiBFbnVtXFxyXFxuXFxyXFxuPiDtirnsoJUg6rCS65Ok7J2YICoq7KeR7ZWpKirsnYQg7J2Y66+47ZWY64qUIOyekOujjO2YleycvOuhnCDtgazqsowge+yIq+yekO2YlSDsnbTrhJgsIOusuOyekO2YlSDsnbTrhJh9IOuRkCDqsIDsp4DqsIAg7J6I64ukXFxyXFxuXFxyXFxuLSBFbnVt7J20652864qUIOqwnOuFkOydhCDsnbTtlbTtlZjquLAg7Ja066Ck7Jug642YIOydtOycoOuKlCwgamF2YXNjcmlwdOyXkOuKlCBlbnVt7J20IOyXhuyXiOq4sCDrlYzrrLjsnbTri6QuICjtlZjsp4Drp4wg6rKA7IOJ7ZW067O064uIIEPslrjslrTsl5DshJzripQg7KCc6rO17ZWY64qUIOqygyDqsJnsnYwuKVxcclxcblxcclxcbiMjIyA0LTEuIOyIq+yekO2YlSDsnbTrhJhcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIERpcmVjdGlvbiB7XFxyXFxuICBVcCA9IDEsXFxyXFxuICBEb3duLFxcclxcbiAgTGVmdCxcXHJcXG4gIFJpZ2h0XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbu2KueydtO2VnCDqsoPsnYAg7J2066CH6rKMIOyEoOyWuO2VmOuptCAg7JaR67Cp7Zal7Jy866GcIO2YuOy2nO2VoCDsiJgg7J6I64qUIO2KueydtO2VnCDsnpDro4zqtazsobDqsIAg65Cc64uk64qUIOqyg+ydtOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5jb25zb2xlLmxvZyhEaXJlY3Rpb25bMV0pICAgIC8vIFxcXCJVcFxcXCJcXHJcXG5jb25zb2xlLmxvZyhEaXJlY3Rpb25bXFxcIlVwXFxcIl0pIC8vIDFcXHJcXG5jb25zb2xlLmxvZyhEaXJlY3Rpb25bM10pICAgIC8vIFxcXCJMZWZ0XFxcIlxcclxcbmBgYFxcclxcblxcclxcbuydtOyZgCDqsJnsnbQg7Iir7J6Q7ZiVIEVudW3sl5DshJwgRGlyZWN0aW9uLlVwIOycvOuhnCAx6rCS7J2EIOyWu+qxsOuCmCDrsJjrjIDroZwgRGlyZWN0aW9uWzFd66GcIFxcXCJVcFxcXCLqsJLsnYQg7Ja764qUIOqyg+ydhCAqKmDrpqzrsoTsiqQg66ek7ZWRYCoqIOydtOudvOqzoCDtlZzri6QuXFxyXFxuXFxyXFxu7J2066CH6rKMIOy0iOq4sOqwkuydhCDshKDslrjtlbTso7zrqbQgMSwgMiwgMywgNCDsnZgg7Iic7ISc66GcIDHslKkg7Kad6rCA7ZWY66mwIO2VoOuLueuQnOuLpC4g66eM7JW9LFxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gRGlyZWN0aW9uIHtcXHJcXG5cXHRVcCwgXFxyXFxuXFx0RG93bixcXHJcXG5cXHRMZWZ0LFxcclxcblxcdFJpZ2h0XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbuycvOuhnCDshKDslrjrkJjsl4jri6TrqbQgVXAgLSAwICwgRG93biAtIDEsIExlZnQgLSAyLCBSaWdodCAtIDPsnbQg65Cc64ukLlxcclxcblxcclxcbiMjIyA0LTIg7Iir7J6Q7ZiVIGVudW0g7IKs7JqpXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBSZXNwb25zZSB7XFxyXFxuICBObyA9IDAsXFxyXFxuICBZZXMgPSAxLFxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiByZXNwb25kKHJlY2lwaWVudDogc3RyaW5nLCBtZXNzYWdlOiBSZXNwb25zZSk6IHZvaWQge1xcclxcbiAgY29uc29sZS5sb2cocmVjaXBpZW50LCBtZXNzYWdlKVxcclxcbn1cXHJcXG5cXHJcXG5yZXNwb25kKFxcXCJDYXB0YWluIFBhbmd5b1xcXCIsIFJlc3BvbnNlLlllcyk7XFxyXFxuXFxyXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS1cXHJcXG5bTE9HXTogXFxcIkNhcHRhaW4gUGFuZ3lvXFxcIiwgIDFcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNC0zLiDrrLjsnpDtmJUgZW51bVxcclxcblxcclxcbj4g66y47J6Q7ZiVIOydtOuEmOydgCDsnbTrhJgg6rCSIOyghOu2gCDri6Qg7Yq57KCVIOusuOyekCDrmJDripQg64uk66W4IOydtOuEmCDqsJLsnLzroZwg7LSI6riw7ZmUIO2VtOykmOyVvCDtlanri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBEaXJlY3Rpb24ge1xcclxcbiAgICBVcCA9IFxcXCJVUFxcXCIsXFxyXFxuICAgIERvd24gPSBcXFwiRE9XTlxcXCIsXFxyXFxuICAgIExlZnQgPSBcXFwiTEVGVFxcXCIsXFxyXFxuICAgIFJpZ2h0ID0gXFxcIlJJR0hUXFxcIixcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuKiog67O17ZWpIGVudW1zICoqXFxyXFxuXFxyXFxu66y47J6Q7JmAIOyIq+yekOulvCDtmLztlantlZjsl6wgZW51beydhCDsg53shLHtlaAg7IiYIOyeiOycvOuCmCwg6raM7J6l7ZWY7KeAIOyViuuKlCDrsKnsi50hXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuZW51bSBCb29sZWFuTGlrZUhldGVyb2dlbmVvdXNFbnVtIHtcXHJcXG4gICAgTm8gPSAwLFxcclxcbiAgICBZZXMgPSBcXFwiWUVTXFxcIixcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDQtNC4g65+w7YOA7J6EIOyLnOygkOyXkOyEnOydmCDsnbTrhJgg7Yq57KeVXFxyXFxuXFxyXFxu7J2064SY7J2AIOufsO2DgOyehOyLnOyXkCDsi6TsoJwg6rCd7LK0IO2Yle2DnOuhnCDsobTsnqztlanri4jri6QuIOyYiOulvCDrk6TslrQg7JWE656Y7JmAIOqwmeydgCDsnbTrhJgg7L2U65Oc6rCAIOyeiOydhCDrlYxcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIEUge1xcclxcbiAgWCwgWSwgWlxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZXRYKG9iajogeyBYOiBudW1iZXIgfSkge1xcclxcbiAgcmV0dXJuIG9iai5YO1xcclxcbn1cXHJcXG5nZXRYKEUpOyAvLyDsnbTrhJggReydmCBY64qUIOyIq+yekOydtOq4sCDrlYzrrLjsl5Ag7KCV7IOBIOuPmeyekVxcclxcbi0tLS0tXFxyXFxuUXVpei4gXFxyXFxuZ2V0WChFKeqwkuydhCDrs4DsiJjsl5Ag64Sj7Ja07IScIOy2nOugpe2VnOuLpOuptCwg7Ja866eI64KYIOuCmOyYrOq5jD9cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNC01LiDsu7TtjIzsnbwg7Iuc7KCQ7JeQ7ISc7J2YIOydtOuEmCDtirnsp5VcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5lbnVtIExvZ0xldmVsIHtcXHJcXG4gIEVSUk9SLCBXQVJOLCBJTkZPLCBERUJVR1xcclxcbn1cXHJcXG5cXHJcXG4vLyAnRVJST1InIHwgJ1dBUk4nIHwgJ0lORk8nIHwgJ0RFQlVHJztcXHJcXG50eXBlIExvZ0xldmVsU3RyaW5ncyA9IGtleW9mIHR5cGVvZiBMb2dMZXZlbDtcXHJcXG5cXHJcXG5mdW5jdGlvbiBwcmludEltcG9ydGFudChrZXk6IExvZ0xldmVsU3RyaW5ncywgbWVzc2FnZTogc3RyaW5nKSB7XFxyXFxuICAgIGNvbnN0IG51bSA9IExvZ0xldmVsW2tleV07XFxyXFxuICAgIGlmIChudW0gPD0gTG9nTGV2ZWwuV0FSTikge1xcclxcbiAgICAgICBjb25zb2xlLmxvZygnTG9nIGxldmVsIGtleSBpczogJywga2V5KTtcXHJcXG4gICAgICAgY29uc29sZS5sb2coJ0xvZyBsZXZlbCB2YWx1ZSBpczogJywgbnVtKTtcXHJcXG4gICAgICAgY29uc29sZS5sb2coJ0xvZyBsZXZlbCBtZXNzYWdlIGlzOiAnLCBtZXNzYWdlKTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5wcmludEltcG9ydGFudCgnRVJST1InLCAnVGhpcyBpcyBhIG1lc3NhZ2UnKTtcXHJcXG5cXHJcXG4tLS0tLS0tXFxyXFxuW0xPR106IFxcXCJMb2cgbGV2ZWwga2V5IGlzOiBcXFwiLCAgXFxcIkVSUk9SXFxcIiBcXHJcXG5bTE9HXTogXFxcIkxvZyBsZXZlbCB2YWx1ZSBpczogXFxcIiwgIDAgXFxyXFxuW0xPR106IFxcXCJMb2cgbGV2ZWwgbWVzc2FnZSBpczogXFxcIiwgIFxcXCJUaGlzIGlzIGEgbWVzc2FnZVxcXCJcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNC02LiBUeXBlc2NyaXB0IGVudW3snYQg7IKs7Jqp7ZWY64qUIOydtOycoFxcclxcblxcclxcbkVudW3snYAg7LaU7IOB7ZmU7J2YIOyImOuLqOydtOuLpC5cXHJcXG5cXHJcXG7ri6Tqta3slrQg7L2U65OcIChMYW5ndWFnZSBDb2RlKeulvCDtlaDri7ntlZzri6Tqs6Ag7IOd6rCB7ZW067O07J6QXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxudHlwZSBMYW5ndWFnZUNvZGUgPSAna28nIHwgJ2VuJyB8ICdqYScgfCAnemgnIHwgJ2VzJ1xcclxcblxcclxcbmNvbnN0IGNvZGU6IExhbmd1YWdlQ29kZSA9ICdrbydcXHJcXG5cXHJcXG5jb25zb2xlLmxvZyhjb2RlKSAvLyBbTE9HXTogXFxcImtvXFxcIlxcclxcblxcclxcbu2VmOyngOunjCBcXHJcXG5jb3N0IGNvZGU6IExhbmd1YWdlQ29kZSA9ICdoYWhhaGFoYSdcXHJcXG7smYAg6rCZ7J20IOy9lOuTnOulvCDsp5zrqbQgdHlwZXNjcmlwdOyXkOyEnCDsl5Drn6zroZwg7ZGc7Iuc7ZW07KSA64ukLlxcclxcbmBgYFxcclxcblxcclxcbuydtOqyg+uPhCDsoovsp4Drp4wg642w7J207YSwIOyWkeydtCDrp47slYTsp4DrqbQg6rCA64+F7ISx7J20IOunjuydtCDrlqjslrTsp4Tri6QuXFxyXFxuXFxyXFxu7Jqw66as6rCAIOybkO2VmOuKlCDqsoPsnYAga29yZWFu7J2EIOqygOyDie2VmOuptCAna28n652864qUIOy9lOuTnOqwgCDrgpjsmZTsnLzrqbQg7ZWY64qUIOqyg+ydtOqzoCDquLDsobQg67Cp7Iud7Jy866Gc64qUIOuLpOydjOqzvCDqsJnsnbQg65GQIOqwgOyngCDrsKnrspXsnbQg7J6I64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbi8vIOydtOugh+qyjCDtlZjrqbQg7Ja47Ja0IOy9lOuTnOqwgCDsnITslYTrnpjsl5Ag7KSR67O165CY6rOgXFxyXFxuY29uc3Qga29yZWFuID0gJ2tvJ1xcclxcbmNvbnN0IGVuZ2xpc2ggPSAnZW4nXFxyXFxuY29uc3QgamFwYW5lc2UgPSAnamEnXFxyXFxuY29uc3QgY2hpbmVzZSA9ICd6aCdcXHJcXG5jb25zdCBzcGFuaXNoID0gJ2VzJ1xcclxcbnR5cGUgTGFuZ3VhZ2VDb2RlID0gJ2tvJyB8ICdlbicgfCAnamEnIHwgJ3poJyB8ICdlcydcXHJcXG5sZXQgY29kZTogTGFuZ3VhZ2VDb2RlID0gZW5nbGlzaFxcclxcbmNvbnNvbGUubG9nKGNvZGUpIC8vIFxcXCJlblxcXCJcXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG4vLyDsnbTroIfqsowg7ZWY66m0IOy9lOuTnOqwgCDrhIjrrLQg6ri47Ja07KeR64uI64ukXFxyXFxuY29uc3Qga29yZWFuID0gJ2tvJ1xcclxcbmNvbnN0IGVuZ2xpc2ggPSAnZW4nXFxyXFxuY29uc3QgamFwYW5lc2UgPSAnamEnXFxyXFxuY29uc3QgY2hpbmVzZSA9ICd6aCdcXHJcXG5jb25zdCBzcGFuaXNoID0gJ2VzJ1xcclxcbnR5cGUgTGFuZ3VhZ2VDb2RlID0gdHlwZW9mIGtvcmVhbiB8IHR5cGVvZiBlbmdsaXNoIHwgdHlwZW9mIGphcGFuZXNlIHwgdHlwZW9mIGNoaW5lc2UgfCB0eXBlb2Ygc3BhbmlzaFxcclxcbmxldCBjb2RlOiBMYW5ndWFnZUNvZGUgPSBzcGFuaXNoXFxyXFxuY29uc29sZS5sb2coY29kZSkgLy8gXFxcImVzXFxcIlxcclxcbmBgYFxcclxcblxcclxcbuydtOufrO2VnCDsnbTsnKAg65WM66y47JeQIOumrO2EsOuftOydmCDtg4DsnoXqs7wg6rCS7JeQIOydtOumhOydhCDrtpnsnbggYGVudW1g7J2EIO2ZnOyaqe2VmOuptCDqsIDrj4XshLHsnYQg7YGs6rKMIOuGkuydvCDsiJgg7J6I7Iq164uI64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmVudW0gTGFuZ3VhZ2VDb2RlIHtcXHJcXG4gIGtvcmVhbiA9ICdrbycsXFxyXFxuICBlbmdsaXNoID0gJ2VuJyxcXHJcXG4gIGphcGFuZXNlID0gJ2phJyxcXHJcXG4gIGNoaW5lc2UgPSAnemgnLFxcclxcbiAgc3BhbmlzaCA9ICdlcycsXFxyXFxufVxcclxcbi8vIOyXrOq4sOyEnCBcXHJcXG4vLyBMYW5ndWFnZUNvZGUua29yZWFuID09PSAna28nXFxyXFxuLy8gKOydmOuvuOyDgSkgTGFuZ3VhZ2VDb2RlID09PSAna28nIHwgJ2VuJyB8ICdqYScgfCAnemgnIHwgJ2VzJ1xcclxcbmNvbnN0IGNvZGU6IExhbmd1YWdlQ29kZSA9IExhbmd1YWdlQ29kZS5rb3JlYW5cXHJcXG5jb25zb2xlLmxvZyhjb2RlKSAvLyBcXFwia29cXFwiXFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIDQtNy4gVHlwZXNjcmlwdCBlbnVt7J2EIOyCrOyaqe2VmOyngCDslYrripQg7J207JygXFxyXFxuXFxyXFxuIyMjIFRyZWUtc2hha2luZ+ydgCDrrLTsl4fsnbjqsIDsmpQ/XFxyXFxuXFxyXFxuVHJlZS1zaGFraW5n7J20656AIOqwhOuLqO2VmOqyjCDrp5DtlbQg7IKs7Jqp7ZWY7KeAIOyViuuKlCDsvZTrk5zrpbwg7IKt7KCc7ZWY64qUIOq4sOuKpeydhCDrp5Dtlanri4jri6QuIOuCmOustOulvCDtnZTrk6TrqbQg7KO97J2AIOyejuyCrOq3gOuTpOydtCDrlqjslrTsp4DripQg66qo7Iq17JeQIOywqeyViO2VtCBUcmVlLXNoYWtpbmfsnbTrnbzqs6Ag67aA66aF64uI64ukLiBUcmVlLXNoYWtpbmfsnYQg7Ya17ZW0IGV4cG9ydO2WiOyngOunjCDslYTrrLQg642w7ISc64+EIGltcG9ydO2VmOyngCDslYrsnYAg66qo65OI7J2064KYIOyCrOyaqe2VmOyngCDslYrripQg7L2U65Oc66W8IOyCreygnO2VtOyEnCDrsojrk6Qg7YGs6riw66W8IOykhOyXrCDtjpjsnbTsp4DqsIAg7ZGc7Iuc65CY64qUIOyLnOqwhOydhCDri6jstpXtlaAg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG7tlZjsp4Drp4wgZW51beydhCDsgqzsmqntlZjqsowg65CY66m0IFRyZWUtc2hha2luZ+ydtCDrkJjsp4Ag7JWK7Iq164uI64ukLlxcclxcblxcclxcbuqysOuhoOyggeycvOuhnCAgVHJlZS1zaGFraW5nIOq0gOygkOyXkOyEnCDrs7TslZjsnYQg65WMIOyVhOuemOyZgCDqsJnsnYAg7Iic7ISc66GcIOyCrOyaqe2VmOyLnOq4uCDstpTsspztlZjrqbAg6riA7J2EIOuniOy5mOqyoOyKteuLiOuLpC5cXHJcXG5cXHJcXG4+IFVuaW9uIFR5cGVzID4gY29uc3QgZW51bSA+IGVudW1cXHJcXG5cXHJcXG4qKuygleumrCoqXFxyXFxuXFxyXFxuLSDqsJnsnYAg4oCY7KKF66WY4oCZ66W8IOuCmO2DgOuCtOuKlCDsl6zrn6wg6rCc7J2YIOyIq+yekCDtmLnsnYAg66y47J6Q7Je07J2EIOuLpOukhOyVvCDtlZjripTrjbAsIFxcclxcbuqwgeqwgSDsoIHri7ntlZwg7J2066aE7J2EIOu2meyXrOyEnCDsvZTrk5zsnZgg6rCA64+F7ISx7J2EIOuGkuydtOqzoCDsi7bri6TrqbQgZW51beydhCDsgqzsmqkhXFxyXFxuXFxyXFxuIyMgNS4g7Jew7IKw7J6Q66W8IOydtOyaqe2VnCDtg4DsnoUg7KCV7J2YXFxyXFxuXFxyXFxuIyMjIDUtMS4gVW5pb24gVHlwZSAoIHwgKVxcclxcblxcclxcbuycoOuLiOyYqCDtg4DsnoUoVW5pb24gVHlwZSnsnbTrnoAg7J6Q67CU7Iqk7YGs66a97Yq47J2YIE9SIOyXsOyCsOyekCh8fCnsmYAg6rCZ7J20IEHsnbTqsbDrgpggQuydtOuLpCDrnbzripQg7J2Y66+47J2YIO2DgOyehVxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIGxvZ1RleHQodGV4dDogc3RyaW5nIHwgbnVtYmVyKSB7XFxyXFxuICAvLyAuLi5cXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuLSB0ZXh064qUIHN0cmluZ+ydtOqxsOuCmCAoT1IgfHwgKSBudW1iZXLsnbTri6QuIOymiSwg65GYIOuLpCDsmKwg7IiYIOyeiOuLpOuKlCDrnLsuXFxyXFxuLSDsnbTsspjrn7wgYHxgIOyXsOyCsOyekOulvCDsnbTsmqntlZjsl6wg7YOA7J6F7J2EIOyXrOufrCDqsJwg7Jew6rKw7ZWY64qUIOuwqeyLneydhCBg7Jyg64uI7JioIO2DgOyehSDsoJXsnZgg67Cp7IudYCDsnbTrnbwg67aA66W464ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmZ1bmN0aW9uIGdldEFnZShhZ2U6IG51bWJlciB8IHN0cmluZykge1xcclxcbiAgaWYgKHR5cGVvZiBhZ2UgPT09ICdudW1iZXInKSB7XFxyXFxuICAgIGFnZS50b0ZpeGVkKCk7IC8vIOygleyDgSDrj5nsnpEsIGFnZeydmCDtg4DsnoXsnbQgYG51bWJlcmDroZwg7LaU66Gg65CY6riwIOuVjOusuOyXkCDsiKvsnpAg6rSA66Co65CcIEFQSeulvCDsib3qsowg7J6Q64+Z7JmE7ISxIO2VoCDsiJgg7J6I64ukLlxcclxcbiAgICByZXR1cm4gYWdlO1xcclxcbiAgfVxcclxcbiAgaWYgKHR5cGVvZiBhZ2UgPT09ICdzdHJpbmcnKSB7XFxyXFxuICAgIHJldHVybiBhZ2U7XFxyXFxuICB9XFxyXFxuICByZXR1cm4gbmV3IFR5cGVFcnJvcignYWdlIG11c3QgYmUgbnVtYmVyIG9yIHN0cmluZycpO1xcclxcbn1cXHJcXG5jb25zb2xlLmxvZyhnZXRBZ2UoMTApKVxcclxcbmNvbnNvbGUubG9nKGdldEFnZSgnSGVsbG8gV29ybGQnKSlcXHJcXG5jb25zb2xlLmxvZyhnZXRBZ2UodHJ1ZSkpXFxyXFxuLS0tIOy2nOugpSAtLS1cXHJcXG5bTE9HXTogMTAgXFxyXFxuW0xPR106IFxcXCJIZWxsbyBXb3JsZFxcXCIgXFxyXFxuW0xPR106IGFnZSBtdXN0IGJlIG51bWJlciBvciBzdHJpbmdcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNS0yLiBJbnRlcnNlY3Rpb24gVHlwZSAoICYgKVxcclxcblxcclxcbuyXrOufrCDtg4DsnoXsnYQg66qo65GQIOunjOyhse2VmOuKlCDtlZjrgpjsnZgg7YOA7J6F7J2EIOydmOuvuC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5pbnRlcmZhY2UgUGVyc29uIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIGFnZTogbnVtYmVyO1xcclxcbn1cXHJcXG5pbnRlcmZhY2UgRGV2ZWxvcGVyIHtcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIHNraWxsOiBudW1iZXI7XFxyXFxufVxcclxcbnR5cGUgQ2FwdCA9IFBlcnNvbiAmIERldmVsb3BlcjtcXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG4vLyBDYXB07J2YIO2DgOyeheydgFxcclxcblxcclxcbntcXHJcXG4gIG5hbWU6IHN0cmluZztcXHJcXG4gIGFnZTogbnVtYmVyO1xcclxcbiAgc2tpbGw6IHN0cmluZztcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIVtJbnRlcnNlY3Rpb24gVHlwZV0oaHR0cHM6Ly9qb3NodWExOTg4LmdpdGh1Yi5pby90cy9hc3NldHMvaW1nL2ludGVyc2VjdGlvbi1kaWFncmFtLjAxZjRmZGZlLnBuZylcXHJcXG5cXHJcXG4jIyMgNS0zLiBVbmlvbiBUeXBl7J2EIOyTuCDrlYwg7KO87J2Y7ZWgIOygkFxcclxcblxcclxcbmBgYHRzeFxcclxcbmludGVyZmFjZSBQZXJzb24ge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgYWdlOiBudW1iZXI7XFxyXFxufVxcclxcbmludGVyZmFjZSBEZXZlbG9wZXIge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgc2tpbGw6IHN0cmluZztcXHJcXG59XFxyXFxuZnVuY3Rpb24gaW50cm9kdWNlKHNvbWVvbmU6IFBlcnNvbiB8IERldmVsb3Blcikge1xcclxcbiAgc29tZW9uZS5uYW1lOyAvLyBPIOygleyDgSDrj5nsnpFcXHJcXG4gIHNvbWVvbmUuYWdlOyAvLyBYIO2DgOyehSDsmKTrpZggLT4g7YOA7J6F7Iqk7YGs66a97Yq47JeQ7IScIOu5qOqwhOykhOuhnCDtkZzsi5ztlbTspIxcXHJcXG4gIHNvbWVvbmUuc2tpbGw7IC8vIFgg7YOA7J6FIOyYpOulmCAtPiDtg4DsnoXsiqTtgazrpr3tirjsl5DshJwg67mo6rCE7KSE66GcIO2RnOyLnO2VtOykjFxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG7snKDri4jsmKgg7YOA7J6F7J2AIEHrj4Qg65CgIOyImCDsnojqs6AgQuuPhCDrkKAg7IiYIOyeiOuKlCDtg4DsnoXsnbTsp4Drnbzqs6Ag7IOd6rCB7ZWY66m0IO2MjOudvOuvuO2EsOydmCDtg4DsnoXsnbQgUGVyc29u64+EIOuQmOqzoCBEZXZlbG9wZXLrj4Qg65Cg7YWM64uI6rmMIO2VqOyImCDslYjsl5DshJwg64u57Jew7Z6IIOydtCDsnbjthLDtjpjsnbTsiqTrk6TsnbQg7KCc6rO17ZWY64qUIOyGjeyEseuTpOyduCBhZ2Xrgpggc2tpbGzrpbwg7IKs7Jqp7ZWgIOyImCDsnojqsqDsp4Drnbzqs6Ag7IOd6rCB7ZWgIOyImCDsnojsirXri4jri6QuIFxcclxcblxcclxcbu2VmOyngOunjCwg7YOA7J6F7Iqk7YGs66a97Yq4IOq0gOygkOyXkOyEnOuKlCBpbnRyb2R1Y2UoKSDtlajsiJjrpbwg7Zi47Lac7ZWY64qUIOyLnOygkOyXkCBQZXJzb24g7YOA7J6F7J20IOyYrOyngCBEZXZlbG9wZXIg7YOA7J6F7J20IOyYrOyngCDslYwg7IiY6rCAIOyXhuq4sCDrlYzrrLjsl5Ag7Ja064qQIO2DgOyeheydtCDrk6TslrTsmKTrk6Ag6rCE7JeQIOyYpOulmOqwgCDslYgg64KY64qUIOuwqe2WpeycvOuhnCDtg4DsnoXsnYQg7LaU66Gg7ZWY6rKMIOuQqeuLiOuLpC5cXHJcXG5cXHJcXG7rlLDrnbzshJwg7JyE7J2YIOyYiOyLnCDqsJnsnYAg6rK97Jqw7JeQ64qUIOydmOuPhOyZgOuKlCDri6zrpqwgW3NvbWVvbmUubmFtZV0oaHR0cDovL3NvbWVvbmUubmFtZSkg66eMIOygleyDgeyggeycvOuhnCDsnpHrj5ntlZjqsowg65Cp64uI64ukLlxcclxcblxcclxcbiMjIDYuIENsYXNzXFxyXFxuXFxyXFxuIyMjIDYtMS4gUmVhZG9ubHlcXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5jbGFzcyBEZXZlbG9wZXIge1xcclxcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XFxyXFxuICAgIGNvbnN0cnVjdG9yKHRoZU5hbWU6IHN0cmluZykge1xcclxcbiAgICAgICAgdGhpcy5uYW1lID0gdGhlTmFtZTtcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5sZXQgam9obiA9IG5ldyBEZXZlbG9wZXIoXFxcIkpvaG5cXFwiKTtcXHJcXG5qb2huLm5hbWUgPSBcXFwiSm9oblxcXCI7IC8vIGVycm9yISBuYW1lIGlzIHJlYWRvbmx5LlxcclxcbmNvbnNvbGUubG9nKGpvaG4pXFxyXFxuLS0tIOy2nOugpSAtLS1cXHJcXG5bTE9HXTogRGV2ZWxvcGVyOiB7XFxyXFxuICBcXFwibmFtZVxcXCI6IFxcXCJKb2huXFxcIlxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNi0yLiBBY2Nlc3Nvclxcclxcblxcclxcbu2DgOyeheyKpO2BrOumve2KuOuKlCDqsJ3ssrTsnZgg7Yq57KCVIOyGjeyEseydmCDsoJHqt7zqs7wg7ZWg64u57JeQIOuMgO2VtCDsoJzslrTtlaAg7IiYIOyeiOyKteuLiOuLpC4g7J2066W8IOychO2VtOyEoCDtlbTri7kg6rCd7LK06rCAIO2BtOuemOyKpOuhnCDsg53shLHtlZwg6rCd7LK07Jes7JW8IO2VqeuLiOuLpC4g7JWE656Y7J2YIOqwhOuLqO2VnCDsmIjsoJzrpbwg67SF7Iuc64ukLlxcclxcblxcclxcbmBgYHRzeFxcclxcbmNsYXNzIERldmVsb3BlciB7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxufVxcclxcbmNvbnN0IGpvc2ggPSBuZXcgRGV2ZWxvcGVyKCk7XFxyXFxuam9zaC5uYW1lID0gJ0pvc2ggQm9sdG9uJztcXHJcXG5gYGBcXHJcXG5cXHJcXG7snIQg7L2U65Oc64qUIO2BtOuemOyKpOuhnCDsg53shLHtlZwg6rCd7LK07J2YIGBuYW1lYCDsho3shLHsl5AgYEpvc2ggQm9sdG9uYOydtOudvOuKlCDqsJLsnYQg64yA7J6F7ZWcIOy9lOuTnOyeheuLiOuLpC4g7J207KCcIGBqb3NoYOudvOuKlCDqsJ3ssrTsnZggYG5hbWVgIOyGjeyEseydgCBgSm9zaCBCb2x0b25g7J20652864qUIOqwkuydhCDqsJbqsqDso6AuXFxyXFxuXFxyXFxu7Jes6riw7IScIOunjOyVvSBgbmFtZWAg7IaN7ISx7JeQIOygnOyVvSDsgqztla3snYQg7LaU6rCA7ZWY6rOgIOyLtuuLpOuptCDslYTrnpjsmYAg6rCZ7J20IGBnZXRg6rO8IGBzZXRg7J2EIO2ZnOyaqe2VqeuLiOuLpC5cXHJcXG5cXHJcXG5gYGB0c3hcXHJcXG5jbGFzcyBEZXZlbG9wZXIge1xcclxcbiAgcHJpdmF0ZSBuYW1lOiBzdHJpbmc7XFxyXFxuICBcXHJcXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XFxyXFxuICAgIHJldHVybiB0aGlzLm5hbWU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBzZXQgbmFtZShuZXdWYWx1ZTogc3RyaW5nKSB7XFxyXFxuICAgIGlmIChuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5sZW5ndGggPiA1KSB7XFxyXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCfsnbTrpoTsnbQg64SI66y0IOq5geuLiOuLpCcpO1xcclxcbiAgICB9XFxyXFxuICAgIHRoaXMubmFtZSA9IG5ld1ZhbHVlO1xcclxcbiAgfVxcclxcbn1cXHJcXG5jb25zdCBqb3NoID0gbmV3IERldmVsb3BlcigpO1xcclxcbmpvc2gubmFtZSA9ICdKb3NoIEJvbHRvbic7IC8vIEVycm9yXFxyXFxuam9zaC5uYW1lID0gJ0pvc2gnO1xcclxcbmBgYFxcclxcblxcclxcblRJUCFcXHJcXG5nZXTrp4wg7ISg7Ja47ZWY6rOgIHNldOydhCDshKDslrjtlZjsp4Ag7JWK64qUIOqyveyasOyXkOuKlCDsnpDrj5nsnLzroZwgcmVhZG9ubHnroZwg7J247Iud65Cp64uI64ukLlxcclxcblxcclxcbiMjIyA2LTMuIEFic3RyYWN0IENsYXNzXFxyXFxuXFxyXFxu7LaU7IOBIO2BtOuemOyKpChBYnN0cmFjdCBDbGFzcynripQg7J247YSw7Y6Y7J207Iqk7JmAIOu5hOyKt+2VnCDsl63tlaDsnYQg7ZWY66m07ISc64+EIOyhsOq4iCDri6Trpbgg7Yq57KeV7J2EIOqwluqzoCDsnojsirXri4jri6QuIOy2lOyDgSDtgbTrnpjsiqTripQg7Yq57KCVIO2BtOuemOyKpOydmCDsg4Hsho0g64yA7IOB7J20IOuQmOuKlCDtgbTrnpjsiqTsnbTrqbAg7KKAIOuNlCDsg4HsnIQg66CI67Ko7JeQ7IScIOyGjeyEsSwg66mU7ISc65Oc7J2YIOuqqOyWkeydhCDsoJXsnZjtlanri4jri6QuXFxyXFxuXFxyXFxuYGBgdHN4XFxyXFxuYWJzdHJhY3QgY2xhc3MgRGV2ZWxvcGVyIHtcXHJcXG4gIGFic3RyYWN0IGNvZGluZygpOiB2b2lkOyAvLyAnYWJzdHJhY3Qn6rCAIOu2meycvOuptCDsg4Hsho0g67Cb7J2AIO2BtOuemOyKpOyXkOyEnCDrrLTsobDqsbQg6rWs7ZiE7ZW07JW8IO2VqFxcclxcbiAgZHJpbmsoKTogdm9pZCB7XFxyXFxuICAgIGNvbnNvbGUubG9nKCdkcmluayBzdGgnKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuY2xhc3MgRnJvbnRFbmREZXZlbG9wZXIgZXh0ZW5kcyBEZXZlbG9wZXIge1xcclxcbiAgY29kaW5nKCk6IHZvaWQge1xcclxcbiAgICAvLyBEZXZlbG9wZXIg7YG0656Y7Iqk66W8IOyDgeyGjSDrsJvsnYAg7YG0656Y7Iqk7JeQ7IScIOustOyhsOqxtCDsoJXsnZjtlbTslbwg7ZWY64qUIOuplOyEnOuTnFxcclxcbiAgICBjb25zb2xlLmxvZygnZGV2ZWxvcCB3ZWInKTtcXHJcXG4gIH1cXHJcXG4gIGRlc2lnbigpOiB2b2lkIHtcXHJcXG4gICAgY29uc29sZS5sb2coJ2Rlc2lnbiB3ZWInKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuY29uc3QgZGV2ID0gbmV3IERldmVsb3BlcigpOyAvLyBlcnJvcjogY2Fubm90IGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBhYnN0cmFjdCBjbGFzc1xcclxcbmNvbnN0IGpvc2ggPSBuZXcgRnJvbnRFbmREZXZlbG9wZXIoKTtcXHJcXG5qb3NoLmNvZGluZygpOyAvLyBkZXZlbG9wIHdlYlxcclxcbmpvc2guZHJpbmsoKTsgLy8gZHJpbmsgc3RoXFxyXFxuam9zaC5kZXNpZ24oKTsgLy8gZGVzaWduIHdlYlxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcblxcclxcbi0tLVxcclxcblJlZmVyZW5jZXNcXHJcXG5odHRwczovL2pvc2h1YTE5ODguZ2l0aHViLmlvL3RzL1xcclxcblxcclxcbltUeXBlU2NyaXB0IGVudW3snYQg7IKs7Jqp7ZWY64qUIOydtOycoF0oaHR0cHM6Ly9tZWRpdW0uY29tL0BzZXVuZ2hhX2tpbV9JVC90eXBlc2NyaXB0LWVudW3snYQt7IKs7Jqp7ZWY64qULeydtOycoC0zYjNjY2Q4ZTU1NTIpXFxyXFxuXFxyXFxuW1R5cGVTY3JpcHQgZW51beydhCDsgqzsmqntlZjsp4Ag7JWK64qUIOqyjCDsoovsnYAg7J207JygXShodHRwczovL2VuZ2luZWVyaW5nLmxpbmVjb3JwLmNvbS9rby9ibG9nL3R5cGVzY3JpcHQtZW51bS10cmVlLXNoYWtpbmcvKVxcclxcblxcclxcbltD7Ja47Ja0IEVudW1dKGh0dHBzOi8vZG9qYW5nLmlvL21vZC9wYWdlL3ZpZXcucGhwP2lkPTQ4MClcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwi7YOA7J6F7Iqk7YGs66a97Yq4IOyLpOyKtSBRVUlaXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA0LjI4XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSB0eXBlc2NyaXB0XFxyXFxuICAtIHRzXFxyXFxuICAtIO2DgOyeheyKpO2BrOumve2KuFxcclxcbiAgLSBxdWl6XFxyXFxuLS0tXFxyXFxuIyDrgpjrpbwg7JyE7ZW0IOuCtOqwgCDsp4HsoJEg66eM65OgIFFVSVpcXHJcXG5cXHJcXG4jIyBRMS4g64uk7J2MIOu5iOy5uOyXkCDrk6TslrTqsIgg7JWM66ee7J2AIOqyg+ydgD9cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5mdW5jdGlvbiBqb2luU3R1ZHkobmFtZTogc3RyaW5nLCBhZ2U6IG51bWJlcik6ICgg67mI7Lm4ICkge1xcclxcbiAgaWYgKGFnZSA+IDIzKSB7XFxyXFxuICAgIGNvbnNvbGUubG9nKG5hbWUpXFxyXFxuICB9XFxyXFxufVxcclxcbmpvaW5TdHVkeSgnSm9obiBEb2UnLCAzNSlcXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBRMi4g7JWE656YIGFycuuKlCDsiKvsnpDroZwg7J2066Oo7Ja07KeEIOuwsOyXtOydtOqzoCDsiJjsoJXsnbQg67aI6rCA64ql7ZWY64ukLiDsnbTrlYwg67mI7Lm47JeQIOuTpOyWtOqwiCDqsoPsnLzroZwg6rCA7J6lIOyVjOunnuydgCDqsoPsnYA/XFxyXFxuXFxyXFxuYGBganN4XFxyXFxubGV0IGFycjogKCAgICAgIOu5iOy5uCAgICAgKSA9IFsxLDIsM107XFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgUTMuIE9Y7YC07KaIXFxyXFxuXFxyXFxuLSAoICAgKSDtgbTrnpjsiqTrgbzrpqzripQg7IOB7IaN7J20IOqwgOuKpe2VmOyngOunjCDsnbjthLDtjpjsnbTsiqTqsITsl5DripQg7IOB7IaN7J20IOu2iOqwgOuKpe2VmOuLpC5cXHJcXG4tICggICApIGVudW3snYAgamF2YXNjcmlwdOuhnCDsu7TtjIzsnbwg65CcIO2bhOyXkOuPhCDrgqjslYTsnojri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgUTQuIOuLpOydjOykkSBDYXB0IO2DgOyeheydgCDslrTrlqQg66qo7Iq17J246rCAP1xcclxcblxcclxcbmBgYGpzeFxcclxcbmludGVyZmFjZSBQZXJzb24ge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgYWdlOiBudW1iZXI7XFxyXFxufVxcclxcbmludGVyZmFjZSBEZXZlbG9wZXIge1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcbiAgc2tpbGw6IG51bWJlcjtcXHJcXG59XFxyXFxudHlwZSBDYXB0ID0gUGVyc29uICYgRGV2ZWxvcGVyO1xcclxcblxcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbi8vIENhcHTtg4DsnoVcXHJcXG57XFxyXFxuXFx0Ly8g7Jes6riw7JeQIOuLteyViOydhCDsnpHshLHtlbTso7zshLjsmpQuXFxyXFxuXFx0XFxyXFxuXFx0XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcbiMjIFE1LiDri6TsnYwg67mI7Lm47JeQIOuTpOyWtOqwiCDsiJgg7J6I64qUIOqyg+ydhCDrqqjrkZAg7J6R7ISx7ZW07KO87IS47JqULlxcclxcblxcclxcbmBgYGpzeFxcclxcbmludGVyZmFjZSBBbmltYWx7XFxyXFxuICBuYW1lOiBzdHJpbmc7XFxyXFxuXFx0YWdlOiBudW1iZXIsXFxyXFxuICBtb3ZlOiBudW1iZXI7XFxyXFxufVxcclxcbmludGVyZmFjZSBCaXJke1xcclxcbiAgbmFtZTogc3RyaW5nO1xcclxcblxcdGFnZTogbnVtYmVyO1xcclxcbiAgZmx5OiBzdHJpbmc7XFxyXFxufVxcclxcbmZ1bmN0aW9uIGhhd2soc3RoOiBBbmltYWwgJiBCaXJkKSB7XFxyXFxuIC8vIOyXrOq4sOyXkCDri7XslYjsnYQg7J6R7ISx7ZW07KO87IS47JqULlxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBRNi4g64uk7J2MIOy9lOuTnOqwgCBjb25zb2xl7JeQIOy2nOugpeuQmOuKlCDqsrDqs7zripQg66y07JeH7J286rmM7JqUP1xcclxcblxcclxcbmBgYGpzeFxcclxcbmNsYXNzIEFuaW1hbCB7XFxyXFxuICAgIG5hbWU6IHN0cmluZztcXHJcXG4gICAgY29uc3RydWN0b3IodGhlTmFtZTogc3RyaW5nKSB7IHRoaXMubmFtZSA9IHRoZU5hbWU7IH1cXHJcXG4gICAgbW92ZShkaXN0YW5jZUluTWV0ZXJzOiBudW1iZXIgPSAwKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhgJHt0aGlzLm5hbWV9IG1vdmVkICR7ZGlzdGFuY2VJbk1ldGVyc31tLmApO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmNsYXNzIFNuYWtlIGV4dGVuZHMgQW5pbWFsIHtcXHJcXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nKSB7IHN1cGVyKG5hbWUpOyB9XFxyXFxuICAgIG1vdmUoZGlzdGFuY2VJbk1ldGVycyA9IDUpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJTbGl0aGVyaW5nLi4uXFxcIik7XFxyXFxuICAgICAgICBzdXBlci5tb3ZlKGRpc3RhbmNlSW5NZXRlcnMpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmNsYXNzIEhvcnNlIGV4dGVuZHMgQW5pbWFsIHtcXHJcXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nKSB7IHN1cGVyKG5hbWUpOyB9XFxyXFxuICAgIG1vdmUoZGlzdGFuY2VJbk1ldGVycyA9IDQ1KSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiR2FsbG9waW5nLi4uXFxcIik7XFxyXFxuICAgICAgICBzdXBlci5tb3ZlKGRpc3RhbmNlSW5NZXRlcnMpO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmxldCBzYW0gPSBuZXcgU25ha2UoXFxcIlNhbW15IHRoZSBQeXRob25cXFwiKTtcXHJcXG5sZXQgdG9tOiBBbmltYWwgPSBuZXcgSG9yc2UoXFxcIlRvbW15IHRoZSBQYWxvbWlub1xcXCIpO1xcclxcblxcclxcbnNhbS5tb3ZlKCk7XFxyXFxudG9tLm1vdmUoMzQpO1xcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbi8v64u17JWIXFxyXFxuXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgUTcuIO2DgOyeheyKpO2BrOumve2KuOyXkOyEnCDslrTrlqDtlZwg7YG0656Y7IqkIO2YueydgCDtlajsiJjsl5DshJwg7IKs7Jqp7ZWgIO2DgOyeheydhCDqt7gg7ZWo7IiY64KYIO2BtOuemOyKpOulvCDsgqzsmqntlaAg65WMIOqysOygle2VmOuKlCDtlITroZzqt7jrnpjrsI0g6riw67KV7J2AP1xcclxcblxcclxcbi0gXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgUTgtMS4g64uk7J2MIOuRkCDqsIDsp4Ag67Cp67KVIOykkSDslrTrlqQg67Cp67KV7J20IOy7tO2PrOuEjO2KuCDsnqzsgqzsmqnshLHsnYQg64aS7J28IOyImCDsnojripQg67Cp67KV7J2065286rOgIOyDneqwge2VmOuKlOqwgD8g6re466as6rOgIOq3uCDsnbTsnKDripQg66y07JeH7J246rCAP1xcclxcblxcclxcbmBgYGpzeFxcclxcbi8vIDHrsohcXHJcXG5jbGFzcyBTdGFjayB7XFxyXFxuICBwcml2YXRlIGRhdGE6IGFueVtdID0gW107XFxyXFxuXFxyXFxuICBjb250cnVjdG9yKCkge31cXHJcXG5cXHJcXG4gIHB1c2goaXRlbTogYW55KTogdm9pZCB7XFxyXFxuICAgIHRoaXMuZGF0YS5wdXNoKGl0ZW0pO1xcclxcbiAgfVxcclxcblxcclxcbiAgcG9wKCk6IGFueSB7XFxyXFxuICAgIHJldHVybiB0aGlzLmRhdGEucG9wKCk7XFxyXFxuICB9XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbi8vIDLrsohcXHJcXG5cXHJcXG5jbGFzcyBTdGFjazxUPiB7XFxyXFxuICBwcml2YXRlIGRhdGE6IFRbXSA9IFtdO1xcclxcblxcclxcbiAgY29uc3RydWN0b3IoKSB7fVxcclxcblxcclxcbiAgcHVzaChpdGVtOiBUKTogdm9pZCB7XFxyXFxuICAgIHRoaXMuZGF0YS5wdXNoKGl0ZW0pO1xcclxcbiAgfVxcclxcblxcclxcbiAgcG9wKCkge1xcclxcbiAgICByZXR1cm4gdGhpcy5kYXRhLnBvcCgpO1xcclxcbiAgfVxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4tIFxcclxcblxcclxcblxcclxcblxcclxcbiMjIDA4LTIuIOuniOyngOuniSDroZzqt7jsl5Ag7LCN7Z6I64qUIG51bWJlclN0YWNr6rO8IHN0cmluZ1N0YWNr7J2YIOuNsOydtO2EsOulvCDtkZzquLDtlZjsi5zsmKQuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuY2xhc3MgU3RhY2s8VD4ge1xcclxcbiAgcHJpdmF0ZSBkYXRhOiBUW10gPSBbXTtcXHJcXG5cXHJcXG4gIGNvbnN0cnVjdG9yKCkge31cXHJcXG5cXHJcXG4gIHB1c2goaXRlbTogVCk6IHZvaWQge1xcclxcbiAgICB0aGlzLmRhdGEucHVzaChpdGVtKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHBvcCgpIHtcXHJcXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5wb3AoKTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuY29uc3QgbnVtYmVyU3RhY2sgPSBuZXcgU3RhY2s8bnVtYmVyPigpO1xcclxcbmNvbnN0IHN0cmluZ1N0YWNrID0gbmV3IFN0YWNrPHN0cmluZz4oKTtcXHJcXG5udW1iZXJTdGFjay5wdXNoKDEpO1xcclxcbm51bWJlclN0YWNrLnB1c2goMik7XFxyXFxubnVtYmVyU3RhY2sucHVzaCgzKTtcXHJcXG5zdHJpbmdTdGFjay5wdXNoKCdhJyk7XFxyXFxuc3RyaW5nU3RhY2sucHVzaCgnYicpO1xcclxcbm51bWJlclN0YWNrLnBvcCgpO1xcclxcbnN0cmluZ1N0YWNrLnBvcCgpO1xcclxcbmNvbnNvbGUubG9nKG51bWJlclN0YWNrKTtcXHJcXG5jb25zb2xlLmxvZyhzdHJpbmdTdGFjayk7XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8gc3RyaW5nU3RhY2tcXHJcXG5cXFwiZGF0YVxcXCI6IFtcXHJcXG5cXHJcXG5dXFxyXFxuXFxyXFxuLy8gbnVtYmVyU3RhY2tcXHJcXG5cXFwiZGF0YVxcXCI6IFtcXHJcXG5cXHJcXG5dXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIO2AtOymiOyXkCDrjIDtlZwg7ZW07ISk7J2AIOyVhOuemCDrhbjshZgg66eB7YGs7JeQ7IScIO2ZleyduO2VoCDsiJgg7J6I7Iq164uI64ukIVxcclxcblxcclxcblvtgLTspogg64u17JWIIOuztOufrOqwgOq4sF0oaHR0cHM6Ly93d3cubm90aW9uLnNvL1R5cGVzY3JpcHQtN2I0NDE2M2Y5MWZjNDExZTk3OGVjYzBjM2Y1MjcxNzMpXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuUmVmZXJlbmNlcy5cXHJcXG5cXHJcXG5odHRwczovL3R5cGVzY3JpcHQta3IuZ2l0aHViLmlvL1xcclxcblxcclxcbmh0dHBzOi8vam9zaHVhMTk4OC5naXRodWIuaW8vdHMvXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIuyLpOyghCDrpqzslaHtirgg7ZSE66Gc6re4656Y67CNIHNlY3Rpb24gMS4g66as7JWh7Yq4IO2UhOuhnOygne2KuCDsi5zsnpHtlZjquLAgXFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjA0LjI4XFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSByZWFjdFxcclxcbiAgLSByZWFjdC1qc1xcclxcbiAgLSDrpqzslaHtirhcXHJcXG4gIC0g7ZSE66Gg7Yq47JeU65OcXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyBzZWN0aW9uIDEuIOumrOyVoe2KuCDtlITroZzsoJ3tirgg7Iuc7J6R7ZWY6riwXFxyXFxuXFxyXFxuIyMgMS4g66as7JWh7Yq4656AIOustOyXh+yduOqwgD/wn5KhXFxyXFxuXFxyXFxuLSDsnpDrj5nsnLzroZwg7JeF642w7J207Yq465CY64qUIFVJXFxyXFxuLSBVSSA9IHJlbmRlcihzdGF0ZSlcXHJcXG4tIHJlbmRlcu2VqOyImOuKlCDsiJzsiJjtlajsiJjroZwg7J6R7ISxXFxyXFxuICAgIC0g7Iic7IiY7ZWo7IiY656ALCDsnoXroKXqsJLsnbQg6rCZ7Jy866m0IOy2nOugpeqwkuydtCDqsJnsnYAg7ZWo7IiYXFxyXFxuICAgIC0g656c642k7ZWo7IiYIOyCrOyaqSBYXFxyXFxuICAgIC0g7Jm467aAIOyDge2DnCDrs4Dqsr0gWFxcclxcbiAgICAtIOyInOyImO2VqOyImOyZgCDrtojrs4Drs4DsiJjrpbwg7J207Jqp7ZWY64qUIOydtOycoD9cXHJcXG4gICAgICAgIC0g67O17J6h64+E6rCAIOuCruyVhOyngOqzoCwg67KE6re4IOuwnOyDne2ZleuloOydtCDrgq7slYTsp5AuXFxyXFxuICAgICAgICAtIOugjOuNlOungSDshLHriqXsnYQg7YGs6rKMIO2WpeyDgeyLnO2CrCDsiJgg7J6I7J2MLlxcclxcbi0gc3RhdGXripQg67aI67OAIOuzgOyImOuhnCDqtIDrpqxcXHJcXG4tIOqwgOyDgSDrj5QgKHZpcnR1YWwgZG9tKVxcclxcbiAgICAtIOydtOyghCBVSeyDge2DnOulvCDrqZTrqqjrpqzsl5Ag7Jyg7KeA7ZWcIOuSpCDrs4Dqsr3rkJwg67aA67aE66eMIOyLpOygnCBET03sl5DshJwg67OA6rK97ZWoXFxyXFxuXFxyXFxuIyMgMi4g66as7JWh7Yq4IOqwnOuwnCDtmZjqsr0g6rWs7LaV7ZWY6riw8J+SoVxcclxcblxcclxcbiFbc2VjdGlvbiUyMDElMjAlRTElODQlODUlRTElODUlQjUlRTElODQlOEIlRTElODUlQTIlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlOTElRTElODUlQjMlRTElODQlODUlRTElODUlQTklRTElODQlOEMlRTElODUlQTYlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlODklRTElODUlQjUlRTElODQlOEMlRTElODUlQTElRTElODYlQTglRTElODQlOTIlRTElODUlQTElRTElODQlODAlRTElODUlQjUlMjA2NzYyMjA0NjNjZjY0MDk2OTU1ZGE0NTBjNzY1NTg3ZC9VbnRpdGxlZC5wbmddKC9hc3NldHMvaW1nL3JlYWN0LnBuZylcXHJcXG5cXHJcXG5gYGBodG1sXFxyXFxuPCFET0NUWVBFIGh0bWw+XFxyXFxuPGh0bWwgbGFuZz1cXFwia29cXFwiPlxcclxcbjxoZWFkPlxcclxcbiAgPG1ldGEgY2hhcnNldD1cXFwiVVRGLThcXFwiPlxcclxcbiAgPG1ldGEgaHR0cC1lcXVpdj1cXFwiWC1VQS1Db21wYXRpYmxlXFxcIiBjb250ZW50PVxcXCJJRT1lZGdlXFxcIj5cXHJcXG4gIDxtZXRhIG5hbWU9XFxcInZpZXdwb3J0XFxcIiBjb250ZW50PVxcXCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXFxcIj5cXHJcXG4gIDx0aXRsZT5Eb2N1bWVudDwvdGl0bGU+XFxyXFxuPC9oZWFkPlxcclxcbjxib2R5PlxcclxcbiAgPGgyPuyViOuFle2VmOyEuOyalC48L2gyPlxcclxcbiAgPGgzPnJvb3QxPC9oMz5cXHJcXG4gIDxkaXYgaWQ9XFxcInJvb3QxXFxcIj48L2Rpdj5cXHJcXG4gIDxoMz5yb290MjwvaDM+XFxyXFxuICA8ZGl2IGlkPVxcXCJyb290MlxcXCI+PC9kaXY+XFxyXFxuICA8aDM+cm9vdDM8L2gzPlxcclxcbiAgPGRpdiBpZD1cXFwicm9vdDNcXFwiPjwvZGl2PlxcclxcbiAgPHNjcmlwdCBzcmM9XFxcInJlYWN0LmRldmVsb3BtZW50LmpzXFxcIj48L3NjcmlwdD5cXHJcXG4gIDxzY3JpcHQgc3JjPVxcXCJyZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcXFwiPjwvc2NyaXB0PlxcclxcbiAgPHNjcmlwdCBzcmM9XFxcInNpbXBsZTEuanNcXFwiPjwvc2NyaXB0PlxcclxcbjwvYm9keT5cXHJcXG48L2h0bWw+XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8g67Cp67KVMS4g6re464OlIOuwmOuzte2VtOyEnCDrp4zrk6TquLBcXHJcXG5cXHJcXG5mdW5jdGlvbiBMaWtlQnV0dG9uKCkge1xcclxcbiAgY29uc3QgW2xpa2VkLCBzZXRMaWtlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XFxyXFxuICBjb25zdCB0ZXh0ID0gbGlrZWQgPyAn7KKL7JWE7JqUIOy3qOyGjCc6ICfsoovslYTsmpQnO1xcclxcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXFxyXFxuICAgICdidXR0b24nLFxcclxcbiAgICB7IG9uQ2xpY2s6ICgpID0+IHNldExpa2VkKCFsaWtlZCkgfSxcXHJcXG4gICAgdGV4dCxcXHJcXG4gICk7XFxyXFxufVxcclxcbmNvbnN0IGRvbUNvbnRhaW5lcjEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdDEnKTtcXHJcXG5SZWFjdERPTS5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChMaWtlQnV0dG9uKSwgZG9tQ29udGFpbmVyMSlcXHJcXG5jb25zdCBkb21Db250YWluZXIyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QyJyk7XFxyXFxuUmVhY3RET00ucmVuZGVyKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlrZUJ1dHRvbiksIGRvbUNvbnRhaW5lcjIpXFxyXFxuY29uc3QgZG9tQ29udGFpbmVyMyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290MycpO1xcclxcblJlYWN0RE9NLnJlbmRlcihSZWFjdC5jcmVhdGVFbGVtZW50KExpa2VCdXR0b24pLCBkb21Db250YWluZXIzKVxcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbi8vIOuwqeuylTIuIOumrOyVoe2KuCByZW5kZXIg64K07JeQ7IScIOuwmOuzte2VmOq4sFxcclxcblxcclxcbmZ1bmN0aW9uIExpa2VCdXR0b24oKSB7XFxyXFxuICBjb25zdCBbbGlrZWQsIHNldExpa2VkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcXHJcXG4gIGNvbnN0IHRleHQgPSBsaWtlZCA/ICfsoovslYTsmpQg7Leo7IaMJzogJ+yii+yVhOyalCc7XFxyXFxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcXHJcXG4gICAgJ2J1dHRvbicsXFxyXFxuICAgIHsgb25DbGljazogKCkgPT4gc2V0TGlrZWQoIWxpa2VkKSB9LFxcclxcbiAgICB0ZXh0LFxcclxcbiAgKTtcXHJcXG59XFxyXFxuY29uc3QgZG9tQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKTtcXHJcXG5SZWFjdERPTS5yZW5kZXIoXFxyXFxuICBSZWFjdC5jcmVhdGVFbGVtZW50KFxcclxcbiAgICAnZGl2JyxcXHJcXG4gICAgbnVsbCxcXHJcXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChMaWtlQnV0dG9uKSxcXHJcXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChMaWtlQnV0dG9uKSxcXHJcXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChMaWtlQnV0dG9uKSxcXHJcXG4gICksIFxcclxcbiAgZG9tQ29udGFpbmVyXFxyXFxuKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyAzLiDrsJTrsqgg7IKs7Jqp7ZW067O06riw8J+SoVxcclxcblxcclxcbi0g7LSI6riw7JeQ64qUIEVTNeusuOuyleydhCBFUzbroZwg67CU6r+U7KO864qUIOyXre2VoOydhCDrp47snbQg7IiY7ZaJ7ZaI7J2MLlxcclxcbi0g7LWc6re87JeQ64qUIOy9lOuTnCDso7zshJ3snYQg7KCc6rGw7ZWY6rGw64KYIOy9lOuTnOulvCDslZXstpXtlZjripQg7Jqp64+E66GcIOyCrOyaqeuQmOq4sOuPhCDtlZzri6QuXFxyXFxuLSDrpqzslaHtirjsl5DshJzripQgSlNY66y467KV7J2EIGNyZWF0ZUVsZW1lbnTtlajsiJjrpbwg7Zi47Lac7ZWY64qUIOy9lOuTnOuhnCDrs4DtmZjtlZjquLAg7JyE7ZW0IOuwlOuyqCDsgqzsmqlcXHJcXG4tIEpTWOusuOuyleydgCBqYXZhc2NyaXB07ZGc7KSA7J20IOyVhOuLiOq4sCDrlYzrrLjsl5Ag7JeQ65+s6rCAIOuCmOyngCDslYrrj4TroZ0gYmFiZWzsnYQg7IKs7Jqp7ZWc64ukLlxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4kIG5weCBiYWJlbCAtLXdhdGNoIHNyYyAtLW91dC1kaXIgLiAtLXByZXNldHMgQGJhYmVsL3ByZXNldC1yZWFjdFxcclxcblxcclxcbmBgYFxcclxcblxcclxcbiMjIDQuIOybue2MqSDquLDrs7gg6rCc64WQIOydtO2VtO2VmOq4sPCfkqFcXHJcXG5cXHJcXG4tIO2MjOydvCDrgrTsmqkg6riw67O47Jy866GcIO2MjOydvOydtOumhOyXkCDtlbTsi5zqsJLsnYQg7LaU6rCA7ZW07KO86riw64+EIO2VqC5cXHJcXG5cXHJcXG4gICAg4oaSIOydtOqyg+ydgCDtmqjsnKjsoIHsnLzroZwg67iM65287Jqw7KCAIOy6kOyLseydhCDsnbTsmqntlaAg7IiYIOyeiOqyjCDrj4TsmYDso7zripQg7Jet7ZWg7J2EIO2VqC5cXHJcXG5cXHJcXG4tIOyCrOyaqeuQmOyngCDslYrsnYAg7L2U65OcIOygnOqxsFxcclxcbi0g7J6Q67CU7Iqk7YGs66a97Yq4IOyVley2lVxcclxcbi0gSlPsl5DshJwgQ1NTLCBKU09OLCDthY3siqTtirgg7YyM7J28IOuTseydhCDsnbzrsJgg66qo65OI7LKY65+8IOu2iOufrOyYpOq4sFxcclxcbi0g7ZmY6rK967OA7IiYIOyjvOyehVxcclxcbi0g6re4IOykkeyXkOyEnOuPhCDsm7ntjKnsnYQg7IKs7Jqp7ZWY64qUIOqwgOyepSDtgbAg7J207Jyg64qUIGDrqqjrk4gg7Iuc7Iqk7YWcYCAoRVNNLCBjb21tb25KUynsnYQg7IKs7Jqp7ZWY6rOgIOyLtuyWtOyEnOyehC5cXHJcXG4tIOyXrOufrOqwnOydmCBqcyDtjIzsnbzsl5DshJwg6rCZ7J2AIOyghOyXrSDrs4DsiJjrpbwg7IKs7Jqp7ZWY66m0IOusuOygnOqwgCDsg53quLDquLDrj4Qg7ZWc64ukLiDrlLDrnbzshJwganPtjIzsnbzsnYAg67aI65+s7Jik64qUIOyInOyEnOuPhCDspJHsmpTtlZjri6QuXFxyXFxuICBcXHJcXG4gICAgLSDsnbTrlYwsIOybue2MqeydhCDsk7DrqbQg7J2065+s7ZWcIOqyg+uTpOydhCDsu7TtjIzsnbwg64uo6rOE7JeQ7IScIOyeoeyVhOyjvOq4sCDrlYzrrLjsl5Ag7Lap64+MIOychO2XmOydhCDrr7jrpqwg7YyM7JWF7ZWgIOyImCDsnojri6QuXFxyXFxuXFxyXFxuIyMjIEVTTSDrrLjrspVcXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG4vLyBmaWxlMS5qc1xcclxcblxcclxcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZ1bmMxKCkge31cXHJcXG5leHBvcnQgZnVuY3Rpb24gZnVuYzIoKSB7fVxcclxcbmV4cG9ydCBjb25zdCB2YXJpYWJsZTEgPSAxMjM7XFxyXFxuZXhwb3J0IGxldCB2YXJpYWJsZTIgPSAnaGVsbG8nO1xcclxcblxcclxcbi8vIGZpbGUyLmpzXFxyXFxuaW1wb3J0IG15RnVuYzEsIHsgZnVuYzIsIHZhcmlhYmxlMSwgdmFyaWFibGUyIH0gZnJvbSAnLi9maWxlMS5qcyc7XFxyXFxuXFxyXFxuLy8gZmlsZTMuanNcXHJcXG5pbXBvcnQgeyBmdW5jMiBhcyBteUZ1bmMyIH0gZnJvbSAnLi9maWxlMS5qcyc7XFxyXFxuYGBgXFxyXFxuXFxyXFxuLSBmaWxlMeyXkOyEnCBkZWZhdWx066GcIGV4cG9ydO2VtOyjvOuKlCBmdW5jMSgpIOydgCDqsIDsoLjsmKwg65WMIOykkeq0hO2YuCDsl4bsnbQg67CU66GcIOqwgOyguOyYrCDsiJgg7J6I64ukLlxcclxcbi0g67CY66m0IGZ1bmMyLCB2YXJpYWJsZTEsIHZhcmlhYmxlMuuKlCDspJHqtITtmLgg7JWI7JeQIOqwgOyguOyZgOyVvO2VnOuLpC5cXHJcXG4tIOqwgOyguOyYqCDtm4Tsl5DripQgYGFzYCDroZwg67OE7Lmt7J2EIOyEpOygle2VtCDsk7gg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG4jIyA1LiBjcmVhdGUtcmVhY3QtYXBw7Jy866GcIOyLnOyeke2VmOq4sPCfkqFcXHJcXG5cXHJcXG4tIOydtCDrqoXroLnslrTroZwgcmVhY3Qg7ZSE66Gc7KCd7Yq466W8IOyLnOyeke2VoCDrlYzsnZgg7J6l7KCQXFxyXFxuICAgIC0gYmFiZWwsIHdlYnBhY2sg66qw652864+EIOyVjOyVhOyEnCDtlbTspIDri6QuXFxyXFxuICAgIC0gamVzdOqwmeydgCDthYzsiqTtirgg7ZSE66CI7J6E7JuM7YGs66W8IOuUsOuhnCDsgqzsmqntlZjsp4Ag7JWK6rOg64+EIO2FjOyKpO2KuOulvCDtlaAg7IiYIOyeiOuLpC5cXHJcXG4tIOq4sO2DgCDqsJzrsJwg7ZmY6rK9IOq1rOy2lSDrk7HsnYQg7JWM7JWE7IScIO2VtOykgOuLpC4gKOyYiOyghOyXkOuKlCBjcmVhdGUtcmVhY3QtYXBwIOyXhuyXiOydjOOFoClcXHJcXG4gICAgLSBwb2x5ZmlsbCA6IOyYpOuemOuQnCDruIzrnbzsmrDsoIDrpbwg7KeA7JuQXFxyXFxuICAgIC0gZXNsaW50IDog7L2U65SpIOy7qOuypOyFmFxcclxcbiAgICAtIEhNUiAoSG90IE1vZHVsZSBSZXBsYWNlbWVudCkgOiDsvZTrk5wg7IiY7KCVIOyLnCDtmZTrqbTsl5Ag67CU66GcIOyggeyaqeuQmOuKlCDqsoNcXHJcXG4gICAgLSBDU1Mg7ZuE7LKY66asOiBzYXNzIOy7tO2MjOydvCwg67Kk642UIOygkeuRkOyCrCDrk7EuLi5cXHJcXG5cXHJcXG4jIyMgQ3JlYXRlLXJlYWN0LWFwcCBWUyBOZXh0LmpzXFxyXFxuXFxyXFxuLSDrpqzslaHtirgg7ZSE66Gc7KCd7Yq466W8IOyLpO2Wie2VoCDrlYwg7YGs6rKMIOuRkCDqsIDsp4Ag7Ji17IWY7J20IOyeiOuLpC4gKOuNlCDrp47quLQg7ZWY7KeA66eMIOydvOuLqCApXFxyXFxuLSDsnbQg65GY7J2YIOywqOydtCDspJEg6rCA7J6lIO2BsCDqsoPsnYAgTmV4dC5qc+uKlCDshJzrsoTsgqzsnbTrk5wg66CM642U66eB7J2EIOyngOybkO2VmOyngOunjCBjcmVhdGUtcmVhY3QtYXBw7J2AIOyngOybkO2VmOyngCDslYrslYQg6rmU64GU7ZWY6rKMIOyEnOuyhOyCrOydtOuTnCDroIzrjZTrp4HsnYQg7ZWY6riwIOyWtOugteuLpOuKlCDqsoPsnbTri6QuIOuUsOudvOyEnCDshJzrsoTsgqzsnbTrk5wg66CM642U66eB7J20IO2VhOyalO2VmOuptCBuZXh0Lmpz66W8IO2ZnOyaqe2VmOuKlOqyjCDtm6jslKwg64Kr64ukLlxcclxcbi0g65iQIENSQeuKlCDruYzrk5wg7Iuc7Iqk7YWc7J2064KYIGVzbGludOuTseydmCDshKTsoJXsnYQg6rGw7J2YIOuzgOqyve2VmOq4sCDslrTroLXri6TripQg6rKD7J2064ukLiBOZXh0Lmpz64qUIOybue2MqSwgZXNsaW50LCDrsJTrsqgg65Ox7J2YIOyEpOygleydhCDrs4Dqsr3tlZjquLAg7Ims7Jq0IO2OuOydtOuLpC5cXHJcXG5cXHJcXG4jIyMgcGFja2FnZS5qc29uIO2DkOuwqVxcclxcblxcclxcbiFbc2VjdGlvbiUyMDElMjAlRTElODQlODUlRTElODUlQjUlRTElODQlOEIlRTElODUlQTIlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlOTElRTElODUlQjMlRTElODQlODUlRTElODUlQTklRTElODQlOEMlRTElODUlQTYlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlODklRTElODUlQjUlRTElODQlOEMlRTElODUlQTElRTElODYlQTglRTElODQlOTIlRTElODUlQTElRTElODQlODAlRTElODUlQjUlMjA2NzYyMjA0NjNjZjY0MDk2OTU1ZGE0NTBjNzY1NTg3ZC9VbnRpdGxlZCUyMDEucG5nXSgvYXNzZXRzL2ltZy9yZWFjdF8xLnBuZylcXHJcXG5cXHJcXG4tIGNyZWF0ZS1yZWFjdC1hcHAg7JeQ7IScIHJlYWN0LXNjcmlwdHMg66qF66C57Ja066W8IOyCrOyaqe2VmOuKlOuNsCwg66eM7JW9IOyDiOuhnOyatCDrsoTsoITsnZgg6riw64ql7J2EIOyCrOyaqe2VmOqzoCDsi7bri6TrqbQgcmVhY3Qtc2NyaXB0c+ydmCDrsoTsoITsnYQg67CU6r+U7KO866m0IOuQnOuLpC5cXHJcXG5cXHJcXG4hW3NlY3Rpb24lMjAxJTIwJUUxJTg0JTg1JUUxJTg1JUI1JUUxJTg0JThCJUUxJTg1JUEyJUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTkxJUUxJTg1JUIzJUUxJTg0JTg1JUUxJTg1JUE5JUUxJTg0JThDJUUxJTg1JUE2JUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTg5JUUxJTg1JUI1JUUxJTg0JThDJUUxJTg1JUExJUUxJTg2JUE4JUUxJTg0JTkyJUUxJTg1JUExJUUxJTg0JTgwJUUxJTg1JUI1JTIwNjc2MjIwNDYzY2Y2NDA5Njk1NWRhNDUwYzc2NTU4N2QvVW50aXRsZWQlMjAyLnBuZ10oL2Fzc2V0cy9pbWcvcmVhY3RfMi5wbmcpXFxyXFxuXFxyXFxuLSAncG9seWZpbGzsnbQg67iM65287Jqw7KCAIOygkOycoOycqCAwLjIlIOydtOyDgeyduCDruIzrnbzsmrDsoIDrk6TsnYQg7KeA7JuQ7ZWY6rKg64ukJyDripQg65y7XFxyXFxuXFxyXFxuIyMjIO2aqOycqOyggeyduCByZWFjdOydmCDrjbDsnbTthLAg67aI65+s7Jik6riwIC0g642w7J207YSw6rCAIO2VhOyalO2VnCDsiJzqsIQg65SxIOu2iOufrOyYrCDsiJgg7J6I64ukLlxcclxcblxcclxcbiFbc2VjdGlvbiUyMDElMjAlRTElODQlODUlRTElODUlQjUlRTElODQlOEIlRTElODUlQTIlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlOTElRTElODUlQjMlRTElODQlODUlRTElODUlQTklRTElODQlOEMlRTElODUlQTYlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlODklRTElODUlQjUlRTElODQlOEMlRTElODUlQTElRTElODYlQTglRTElODQlOTIlRTElODUlQTElRTElODQlODAlRTElODUlQjUlMjA2NzYyMjA0NjNjZjY0MDk2OTU1ZGE0NTBjNzY1NTg3ZC9VbnRpdGxlZCUyMDMucG5nXSgvYXNzZXRzL2ltZy9yZWFjdF8zLnBuZylcXHJcXG5cXHJcXG7snbTsoJwg7KCAIOuyhO2KvOydhCDriITrpbTrqbQg7J207KCE7JeQIOyXhuuNmCBgMS5jaHVua3MuanNg6rCAIOy2lOqwgOuQqC5cXHJcXG5cXHJcXG4hW3NlY3Rpb24lMjAxJTIwJUUxJTg0JTg1JUUxJTg1JUI1JUUxJTg0JThCJUUxJTg1JUEyJUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTkxJUUxJTg1JUIzJUUxJTg0JTg1JUUxJTg1JUE5JUUxJTg0JThDJUUxJTg1JUE2JUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTg5JUUxJTg1JUI1JUUxJTg0JThDJUUxJTg1JUExJUUxJTg2JUE4JUUxJTg0JTkyJUUxJTg1JUExJUUxJTg0JTgwJUUxJTg1JUI1JTIwNjc2MjIwNDYzY2Y2NDA5Njk1NWRhNDUwYzc2NTU4N2QvVW50aXRsZWQlMjA0LnBuZ10oL2Fzc2V0cy9pbWcvcmVhY3RfNC5wbmcpXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuZnVuY3Rpb24gQXBwKCkge1xcclxcbiAgZnVuY3Rpb24gb25DbGljayAoKSB7XFxyXFxuICAgIGltcG9ydCgnLi9kYXRhLmpzb24nKS50aGVuKCh7ZGVmYXVsdDogZGF0YX0pID0+IHtcXHJcXG4gICAgICBjb25zb2xlLmxvZyh7ZGF0YX0pXFxyXFxuICAgIH0pXFxyXFxuICB9XFxyXFxuICByZXR1cm4gKFxcclxcbiAgICA8ZGl2IGNsYXNzTmFtZT1cXFwiQXBwXFxcIj5cXHJcXG4gICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cXFwiQXBwLWhlYWRlclxcXCI+XFxyXFxuICAgICAgICA8aW1nIHNyYz17bG9nb30gY2xhc3NOYW1lPVxcXCJBcHAtbG9nb1xcXCIgYWx0PVxcXCJsb2dvXFxcIiAvPlxcclxcbiAgICAgICAgPHA+XFxyXFxuICAgICAgICAgIEVkaXQgPGNvZGU+c3JjL0FwcC5qczwvY29kZT4gYW5kIHNhdmUgdG8gcmVsb2FkLlxcclxcbiAgICAgICAgPC9wPlxcclxcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkNsaWNrfT4g642w7J207YSwIOuztOyXrOyjvOyEuOyalDwvYnV0dG9uPlxcclxcbiAgICAgICAgPGFcXHJcXG4gICAgICAgICAgY2xhc3NOYW1lPVxcXCJBcHAtbGlua1xcXCJcXHJcXG4gICAgICAgICAgaHJlZj1cXFwiaHR0cHM6Ly9yZWFjdGpzLm9yZ1xcXCJcXHJcXG4gICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiXFxyXFxuICAgICAgICAgIHJlbD1cXFwibm9vcGVuZXIgbm9yZWZlcnJlclxcXCJcXHJcXG4gICAgICAgID5cXHJcXG4gICAgICAgICAgTGVhcm4gUmVhY3RcXHJcXG4gICAgICAgIDwvYT5cXHJcXG4gICAgICA8L2hlYWRlcj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICApO1xcclxcbn1cXHJcXG5cXHJcXG4tPiBQcm9taXNl7LKY65+8IO2GteyLoCDtm4QgdGhlbiDrrLjrspXsnYQg7JO4IOyImOqwgCDsnojri6QuIFxcclxcbuuUsOudvOyEnCDrjbDsnbTthLDrpbwgaW1wb3J07ZWY6rOgLCDsnbTqsowg7ISx6rO17ZWY66m0IOq3uCDrkqTsl5Ag642w7J207YSw66W8IOu2iOufrOyZgCByZW5kZXJpbmftlaAg7IiYIOyeiOuLpC5cXHJcXG5gYGBcXHJcXG5cXHJcXG7quLDrs7jsoIHsnLzroZwgaHR0cOuhnCDsi6TtlonsnbQg65CY7KeA66eMIGh0dHBz66GcIOyLpO2Wie2VmOqzoCDsi7bsnYQg65WMIOuLpOydjOydmCDrqoXroLnslrTroZwg7Iuk7ZaJ7ZWc64ukLlxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4vLyBtYWMgT1NcXHJcXG4kIEhUVFBTPXRydWUgbnBtIHN0YXJ0XFxyXFxuXFxyXFxuLy8gd2luZG93cyBPU1xcclxcbiQgc2V0IEhUVFBTPXRydWUgJiYgbnBtIHN0YXJ0XFxyXFxuYGBgXFxyXFxuXFxyXFxuIVtzZWN0aW9uJTIwMSUyMCVFMSU4NCU4NSVFMSU4NSVCNSVFMSU4NCU4QiVFMSU4NSVBMiVFMSU4NiVBOCVFMSU4NCU5MCVFMSU4NSVCMyUyMCVFMSU4NCU5MSVFMSU4NSVCMyVFMSU4NCU4NSVFMSU4NSVBOSVFMSU4NCU4QyVFMSU4NSVBNiVFMSU4NiVBOCVFMSU4NCU5MCVFMSU4NSVCMyUyMCVFMSU4NCU4OSVFMSU4NSVCNSVFMSU4NCU4QyVFMSU4NSVBMSVFMSU4NiVBOCVFMSU4NCU5MiVFMSU4NSVBMSVFMSU4NCU4MCVFMSU4NSVCNSUyMDY3NjIyMDQ2M2NmNjQwOTY5NTVkYTQ1MGM3NjU1ODdkL1VudGl0bGVkJTIwNS5wbmddKC9hc3NldHMvaW1nL3JlYWN0XzUucG5nKVxcclxcblxcclxcbiMjIyBidWlsZCDsi5wg7J2066+47KeAIOyymOumrFxcclxcblxcclxcbiFbc2VjdGlvbiUyMDElMjAlRTElODQlODUlRTElODUlQjUlRTElODQlOEIlRTElODUlQTIlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlOTElRTElODUlQjMlRTElODQlODUlRTElODUlQTklRTElODQlOEMlRTElODUlQTYlRTElODYlQTglRTElODQlOTAlRTElODUlQjMlMjAlRTElODQlODklRTElODUlQjUlRTElODQlOEMlRTElODUlQTElRTElODYlQTglRTElODQlOTIlRTElODUlQTElRTElODQlODAlRTElODUlQjUlMjA2NzYyMjA0NjNjZjY0MDk2OTU1ZGE0NTBjNzY1NTg3ZC9VbnRpdGxlZCUyMDYucG5nXSgvYXNzZXRzL2ltZy9yZWFjdF82LnBuZylcXHJcXG5cXHJcXG4tIOu5jOuTnO2VoCDrlYwg7YGwIOyCrOydtOymiOydmCDsnbTrr7jsp4DsmYAg7J6R7J2AIOyCrOydtOymiCDsnbTrr7jsp4DsnZgg7LKY66as6rCAIOuLpOultOuLpC5cXHJcXG4gICAgLSDtgbAg7IKs7J207KaIIOydtOuvuOyngOuKlCAvZGlzdC9tZWRpYS/rnbzripQg7Y+0642U7JeQIOydtOuvuOyngOqwgCDstpTqsIDrkJzri6QuXFxyXFxuICAgIC0g67CY66m0IOyekeydgCDsgqzsnbTspogg7J2066+47KeA64qUIGphdmFzY3JpcHTtjIzsnbwg64K067aA7JeQIOuCtOyepeuQnOuLpC5cXHJcXG4gICAgLSDsnbTroIfqsowg7ZWY64qUIOydtOycoOuKlCBodHRw7JqU7LKtIO2an+yImOulvCDspITsl6wg7ISx64ql7J2EIO2WpeyDgeyLnO2CpOq4sCDsnITtlajsnbTri6QuXFxyXFxuICAgICAgICAtIO2VmOyngOunjCBodHRwIDIuMOu2gO2EsOuKlCDrs4TroZwg7ISx64qlIOywqOydtCDsl4bslrTshJwg64uk7IaMIOu2iO2VhOyalO2VtOyngOq4tCDtlojri6QgOztcXHJcXG5cXHJcXG4jIyMg7ZmY6rK967OA7IiYIOq0gOumrOuylVxcclxcblxcclxcbi0gZGV2ZWxvcG1lbnQ6IHJvb3TsnITsuZjsl5AgLmVudi5kZXZlbG9wbWVudCDtjIzsnbzroZwg6rSA66asXFxyXFxuLSBwcm9kdWN0aW9uOiByb290IOychOy5mOyXkCAuZW52LnByb2R1Y3Rpb24g7YyM7J2866GcIOq0gOumrFxcclxcbi0g7KCR6re87ZWgIOuVjOuKlCBgcHJvY2Vzcy5lbnYue+uzgOyImOuqhX1gIOydtOufsOyLneycvOuhnCDsoJHqt7ztlbTshJwg7IKs7Jqp7ZWgIOyImCDsnojri6QuXFxyXFxuXFxyXFxuIyMgNi4gQ1NTIOyekeyEsSDrsKnrspUg6rKw7KCV7ZWY6riw8J+SoVxcclxcblxcclxcbiMjIyA2LTEuIOydvOuwmCBDU1PtjIzsnbzroZwg7J6R7ISx7ZWY6riwXFxyXFxuXFxyXFxuYGBgY3NzXFxyXFxuLmJpZyB7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0aGVpZ2h0OiAxMDBweDtcXHJcXG59XFxyXFxuLnNtYWxsIHtcXHJcXG5cXHR3aWR0aDogNTAlO1xcclxcblxcdGhlaWdodDogNTBweDtcXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuLy8gQm94LmpzXFxyXFxuXFxyXFxuaW1wb3J0ICcuL0JveC5jc3MnOyAvLyDsnbTroIfqsowg67aI65+s7JisIOyImCDsnojri6QuXFxyXFxuYGBgXFxyXFxuXFxyXFxuLSDsnbQg67Cp7Iud7J2AIOyXrOufrCBDU1PtjIzsnbzsl5Ag6rCZ7J2AIO2BtOuemOyKpOuqheycvOuhnCDsoJXsnZjrkJwg6rKD7J20IOyeiOycvOuptCDrgpjspJHsl5Ag67aI65+s7JmA7KeA64qUIO2BtOuemOyKpOuqheydmCDsho3shLHrp4wg7KCB7Jqp65Cc64uk64qUIOygkOydtCDsnojri6QuXFxyXFxuXFxyXFxuIyMjIDYtMi4gY3NzLW1vZHVsZeuhnCDsnpHshLHtlZjquLBcXHJcXG5cXHJcXG5gYGBjc3NcXHJcXG5Cb3gubW9kdWVsLmNzc1xcclxcblxcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbmltcG9ydCBTdHlsZSBmcm9tICcuL0J1dHRvbi5tb2R1bGUuY3NzJztcXHJcXG4vLyBDU1Prqqjrk4jsnYQg7JOw66m0IOydtOugh+qyjCDqsJ3ssrTtmJXtg5zroZwg67aI65+s7JisIOyImOqwgCDsnojri6QuXFxyXFxuXFxyXFxuPGJ1dHRvbiBjbGFzc05hbWU9e2Ake1N0eWxlLmJ1dHRvbn0gJHtTdHlsZS5iaWd9fT7tgbAg67KE7Yq8PC9idXR0b24+XFxyXFxuYGBgXFxyXFxuXFxyXFxuLSDrqqjrk4gg7ZiV7Iud7Jy866GcIOyCrOyaqe2VmOuptCwg7Jes65+sIENTU+2MjOydvCDrgrTsnZgg7YG0656Y7Iqk66qF7J20IOuPmeydvO2VmOuNlOudvOuPhCDqsIHqsIHsnZggQ1NTIOyKpO2DgOydvOydhCDsoIHsmqnrsJvsnYQg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG4hW3NlY3Rpb24lMjAxJTIwJUUxJTg0JTg1JUUxJTg1JUI1JUUxJTg0JThCJUUxJTg1JUEyJUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTkxJUUxJTg1JUIzJUUxJTg0JTg1JUUxJTg1JUE5JUUxJTg0JThDJUUxJTg1JUE2JUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTg5JUUxJTg1JUI1JUUxJTg0JThDJUUxJTg1JUExJUUxJTg2JUE4JUUxJTg0JTkyJUUxJTg1JUExJUUxJTg0JTgwJUUxJTg1JUI1JTIwNjc2MjIwNDYzY2Y2NDA5Njk1NWRhNDUwYzc2NTU4N2QvVW50aXRsZWQlMjA3LnBuZ10oL2Fzc2V0cy9pbWcvcmVhY3RfNy5wbmcpXFxyXFxuXFxyXFxuLSDsnbTroIfqsowg7YG0656Y7Iqk66qFIOuSpOyXkCDtlbTsi5zqsJLsnbQg67aZ6riwIOuVjOusuOyXkCDqtazrs4TrkJzri6QuXFxyXFxuXFxyXFxuIyMjIDYtMy4gc2Fzc+uhnCDsnpHshLHtlZjquLBcXHJcXG5cXHJcXG4+IO2VhOyImOyalOyGjDogbm9kZS1zYXNzXFxyXFxuXFxyXFxuYGBgYmFzaFxcclxcbiQgbnBtIGluc3RhbGwgbm9kZS1zYXNzXFxyXFxuYGBgXFxyXFxuXFxyXFxuYGBgc2Nzc1xcclxcbi8vIEJveC5tb2R1bGUuc2Nzc1xcclxcblxcclxcbkBpbXBvcnQgJy4vc2hhcmVkLnNjc3MnO1xcclxcblxcclxcbi5ib3gge1xcclxcblxcdGhlaWdodDogNTBweDtcXHJcXG5cXHRjb2xvcjogJGluZm9Db2xvcjsgIC8vIDwtIHNoYXJlZC5zY3Nz7JeQ7IScIOuwm+yVhOyYqCBpbmZvQ29sb3LrnbzripQg67OA7IiY6rCS7J2EIOyCrOyaqe2VoCDsiJgg7J6I7J2MLlxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4jIyMgNi00LiBjc3MtaW4tanProZwg7J6R7ISx7ZWY6riwXFxyXFxuXFxyXFxuPiBDU1Prpbwg7J6Q67CU7Iqk7YGs66a97Yq4IOuCtOyXkOyEnCDrp4zrk6Tqs6Ag7IKs7JqpLiDrqqjrk6Ag6rCc67Cc7J6Q6rCAIEpT66W8IOuLpOujsCDsiJgg7J6I64uk66m0IOyii+ydgCDshKDtg53snbTsp4Drp4wsIOuniO2BrOyXhSDsoITri7TtlZjsi5zripQg67aE7J20IOuUsOuhnCDsnojri6TrqbQg67mE7LaUIVxcclxcblxcclxcbmBgYGpzeFxcclxcbmNvbnN0IEJveENvbW1vbiA9IHN0eWxlZC5kaXZgXFxyXFxuXFx0aGVpZ2h0OiA1MHB4O1xcclxcbmA7XFxyXFxuXFxyXFxuY29uc3QgQm94QmlnID0gc3R5bGVkKEJveENvbW1vbilgIFxcclxcblxcdHdpZHRoOiAyMDBweDtcXHJcXG5gO1xcclxcbmBgYFxcclxcblxcclxcbi0g66+466asIOunjOuTpOyWtOuRlCBCb3hDb21tb27snYQgQm94Qmln7JeQ7IScIOu2iOufrOyZgOyEnCDtmZzsmqntlaAg7IiYIOyeiOuLpC4g7J207LKY65+8IO2Zleyepe2VtOyEnCDrmJAg64uk66W4IOy7tO2PrOuEjO2KuOulvCDrp4zrk6TquLAg7Im964uk64qUIOqyg+ydtCDsnqXsoJDsnbTri6QuXFxyXFxuXFxyXFxuIyMgNy4gU1BBIOunjOuTpOq4sPCfkqFcXHJcXG5cXHJcXG4hW3NlY3Rpb24lMjAxJTIwJUUxJTg0JTg1JUUxJTg1JUI1JUUxJTg0JThCJUUxJTg1JUEyJUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTkxJUUxJTg1JUIzJUUxJTg0JTg1JUUxJTg1JUE5JUUxJTg0JThDJUUxJTg1JUE2JUUxJTg2JUE4JUUxJTg0JTkwJUUxJTg1JUIzJTIwJUUxJTg0JTg5JUUxJTg1JUI1JUUxJTg0JThDJUUxJTg1JUExJUUxJTg2JUE4JUUxJTg0JTkyJUUxJTg1JUExJUUxJTg0JTgwJUUxJTg1JUI1JTIwNjc2MjIwNDYzY2Y2NDA5Njk1NWRhNDUwYzc2NTU4N2QvVW50aXRsZWQlMjA4LnBuZ10oL2Fzc2V0cy9pbWcvcmVhY3RfOC5wbmcpXFxyXFxuXFxyXFxuIyMjIHJlYWN0LXJvdXRlci1kb20g65287J2067iM65+s66asIO2ZnOyaqe2VtOyEnCDrnbzsmrDtjIXtlZjquLBcXHJcXG5cXHJcXG4tIFNQQeydmCDqsr3smrAg7LSI6riw7ZmU66m07JeQ7IScIOunjuydgCDtjIzsnbzsnYQg67aI65+s7Jik6riwIOuVjOusuOyXkCDroZzrlKnsnbQg6ri47Ja07KeIIOyImCDsnojri6TripQg64uo7KCQ7J20IOyeiOuLpC5cXHJcXG4tIOydtOuVjCByZWFjdC1yb3V0ZXItZG9t7J2EIOyCrOyaqe2VmOuptCDsvZTrk5wg67aE7ZWg7J2EIOydtOyaqe2VtCDtjpjsnbTsp4Ag64uo7JyE66GcIOu2iOufrOyYpOq4sCDrlYzrrLjsl5Ag7LSI6riw66Gc65Sp7J2EIOykhOydvCDsiJgg7J6I64ukLlxcclxcblxcclxcbmBgYGJhc2hcXHJcXG4kIG5wbSBpbnN0YWxsIHJlYWN0LXJvdXRlci1kb21cXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5pbXBvcnQgeyBCcm93c2VyUm91dGVyLCBMaW5rfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcXHJcXG5cXHJcXG48QnJvd3NlclJvdXRlcj5cXHJcXG4gICAgPExpbmsgdG89XFxcIi9cXFwiPkhvbWU8L0xpbms+XFxyXFxuICAgIDxMaW5rIHRvPVxcXCIvcm9vbXNcXFwiPlJvb21zPC9MaW5rPlxcclxcbjwvQnJvd3NlclJvdXRlcj5cXHJcXG5gYGBcXHJcXG5cXHJcXG4tIOydtOugh+qyjCByZWFjdC1yb3V0ZXItZG9t7JeQ7IScIGJyb3N3ZXJSb3V0ZXLsmYAgTGlua+ulvCDrtojrn6zsmKTqs6Ag7Zmc7Jqp7ZWY66m0IOudvOyasO2MheydhCDsl7DqsrDtlaAg7IiYIOyeiOuLpC5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwi66as7JWh7Yq4IOuUlOyekOyduCDtjKjthLQgMS4gQ29udGFpbmVyK1ByZXNlbnRlclxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wNS4wNFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gcmVhY3RcXHJcXG4gIC0gcmVhY3QtanNcXHJcXG4gIC0g66as7JWh7Yq4XFxyXFxuICAtIO2UhOuhoO2KuOyXlOuTnFxcclxcbiAgLSDrlJTsnpDsnbjtjKjthLRcXHJcXG4tLS1cXHJcXG5cXHJcXG4jIOumrOyVoe2KuCDrlJTsnpDsnbgg7Yyo7YS0IDEuIOy7qO2FjOydtOuEiCAtIO2UhOumrOygoO2EsFxcclxcblxcclxcbuumrOyVoe2KuOyXkOyEnCDsvZTrk5wg7Kec64qUIOuwqeyLneydgCDsg4Hri7ntnogg7J6Q7Jyg66Gc7Jq0IO2OuOydtOuLpC4g6raM7J6l7ZWY64qUIOuwqeyLneydtCDsnojquLQg7ZWY7KeA66eMIENTU+yKpO2DgOydvOungeyXkCDrjIDtlZwgU3RyaWN07ZWcIOygnOyVveydgCDsl4bri6QuXFxyXFxuXFxyXFxu7J2065+wIOyekOycoOuPhOqwgCDqsJzrsJzsnpDsl5Dqsowg7KKL7J2EIOuVjOuPhCDsnojsp4Drp4wg65WM65WM66GcIOuEiOustCDspJHqtazrgpzrsKnsnLzroZwg7L2U65Oc6rCAIOyekeyEseuQoCDqsIDriqXshLHsnbQg7J6I64ukLlxcclxcblxcclxcbuydtOufsCDri6jsoJDsnYQg7JiI67Cp7ZWY64qUIOuwqeuylSDspJEg7ZWY64KY64qUIOuUlOyekOyduCDtjKjthLTsnYQg7IKs7Jqp7ZWY64qUIOqyg+ydtOuLpC4g7Jik64qY7J2AIOq3uCDspJEg64yA7ZGc7KCB7J24IGDsu6jthYzsnbTrhIggLSDtlITrpqzsoKDthLBgIOuUlOyekOyduCDtjKjthLTsnYQg7JWM7JWE67O07J6QXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgOmJ1bGI6IOy7qO2FjOydtOuEiCDtlITrpqzsoKDthLAg65SU7J6Q7J24IO2MqO2EtOydtOuegD9cXHJcXG5cXHJcXG7rjbDsnbTthLAg7LKY66asIOuhnOyngSAgLSAg642w7J207YSwIOy2nOugpSAo65SU7J6Q7J24KSAqKuu2hOumrCEqKlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyBDb250YWluZXLsu6jthYzsnbTrhIhcXHJcXG5cXHJcXG4qKjx1PkxvZ2ljPC91PioqIDogQVBJIFJlcXVlc3QsIEV4Y2VwdGlvbiBFcnJvciwgc2V0U3RhdGUuLi4gRVRDLi4uXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIFByZXNlbnRlciDtlITrpqzsoKDthLBcXHJcXG5cXHJcXG5EYXRhIGNvbWVzIGZyb20gcHJvcHMuICoqPHU+Tm8gbG9naWMuIE9ubHkgVUk8L3U+KipcXHJcXG5cXHJcXG4hW+uUlOyekOyduO2MqO2EtOuPhOyLnV0oaHR0cHM6Ly9pbWcxLmRhdW1jZG4ubmV0L3RodW1iL1IxMjgweDAvP3Njb2RlPW10aXN0b3J5MiZmbmFtZT1odHRwcyUzQSUyRiUyRmJsb2cua2FrYW9jZG4ubmV0JTJGZG4lMkZiV3N4YzElMkZidHF6bWs1VVZ2bSUyRkZndnpWOU5id09FdkNDMG1kaHJrTmslMkZpbWcucG5nKVxcclxcblxcclxcblxcclxcblxcclxcbiMjIDpjb21wdXRlcjog7L2U65Oc66GcIOyVjOyVhOuztOq4sFxcclxcblxcclxcbiFbY29udGFpbmVycHJlc2VudGVyXSgvYXNzZXRzL2ltZy9jb250YWluZXJwcmVzZW50ZXIucG5nKVxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5pbXBvcnQgUmVhY3QgZnJvbSBcXFwicmVhY3RcXFwiO1xcclxcbmltcG9ydCBIb21lUHJlc2VudGVyIGZyb20gXFxcIi4vSG9tZVByZXNlbnRlclxcXCI7XFxyXFxuaW1wb3J0IHsgbW92aWVzQXBpIH0gZnJvbSBcXFwiLi4vLi4vYXBpXFxcIjtcXHJcXG5cXHJcXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XFxyXFxuICBzdGF0ZSA9IHtcXHJcXG4gICAgbm93UGxheWluZzogbnVsbCxcXHJcXG4gICAgdXBjb21pbmc6IG51bGwsXFxyXFxuICAgIHBvcHVsYXI6IG51bGwsXFxyXFxuICAgIGVycm9yOiBudWxsLFxcclxcbiAgICBsb2FkaW5nOiB0cnVlXFxyXFxuICB9O1xcclxcblxcclxcbiAgYXN5bmMgY29tcG9uZW50RGlkTW91bnQoKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgY29uc3Qge1xcclxcbiAgICAgICAgZGF0YTogeyByZXN1bHRzOiBub3dQbGF5aW5nIH1cXHJcXG4gICAgICB9ID0gYXdhaXQgbW92aWVzQXBpLm5vd1BsYXlpbmcoKTtcXHJcXG4gICAgICBjb25zdCB7XFxyXFxuICAgICAgICBkYXRhOiB7IHJlc3VsdHM6IHVwY29taW5nIH1cXHJcXG4gICAgICB9ID0gYXdhaXQgbW92aWVzQXBpLnVwY29taW5nKCk7XFxyXFxuICAgICAgY29uc3Qge1xcclxcbiAgICAgICAgZGF0YTogeyByZXN1bHRzOiBwb3B1bGFyIH1cXHJcXG4gICAgICB9ID0gYXdhaXQgbW92aWVzQXBpLnBvcHVsYXIoKTtcXHJcXG4gICAgICB0aGlzLnNldFN0YXRlKHtcXHJcXG4gICAgICAgIG5vd1BsYXlpbmcsXFxyXFxuICAgICAgICB1cGNvbWluZyxcXHJcXG4gICAgICAgIHBvcHVsYXJcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSBjYXRjaCB7XFxyXFxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XFxyXFxuICAgICAgICBlcnJvcjogXFxcIkNhbid0IGZpbmQgbW92aWVzIGluZm9ybWF0aW9uLlxcXCJcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSBmaW5hbGx5IHtcXHJcXG4gICAgICB0aGlzLnNldFN0YXRlKHtcXHJcXG4gICAgICAgIGxvYWRpbmc6IGZhbHNlXFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHJlbmRlcigpIHtcXHJcXG4gICAgY29uc3QgeyBub3dQbGF5aW5nLCB1cGNvbWluZywgcG9wdWxhciwgZXJyb3IsIGxvYWRpbmcgfSA9IHRoaXMuc3RhdGU7XFxyXFxuICAgIHJldHVybiAoXFxyXFxuICAgICAgPEhvbWVQcmVzZW50ZXJcXHJcXG4gICAgICAgIG5vd1BsYXlpbmc9e25vd1BsYXlpbmd9XFxyXFxuICAgICAgICB1cGNvbWluZz17dXBjb21pbmd9XFxyXFxuICAgICAgICBwb3B1bGFyPXtwb3B1bGFyfVxcclxcbiAgICAgICAgZXJyb3I9e2Vycm9yfVxcclxcbiAgICAgICAgbG9hZGluZz17bG9hZGluZ31cXHJcXG4gICAgICAvPlxcclxcbiAgICApO1xcclxcbiAgfVxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwicmVhY3QtcmV3aXJlZCDsgqzsmqntlbTshJwgZWplY3Tsl4bsnbQgQ1JB7JeQYmFiZWzshKTsoJUg7LaU6rCA7ZWY6riwXFxcIlxcbmRhdGU6IFxcXCIyMDIyLjAzLjIzXFxcIlxcbnRhZ3M6XFxuXFx0LSBiYWJlbFxcblxcdC0gY3JhXFxuXFx0LSByZWFjdC1yZXdpcmVkXFxuLS0tXFxuXFxuXFxuXFxuIyByZWFjdC1yZXdpcmVkIOyCrOyaqe2VtOyEnCBlamVjdOyXhuydtCBDUkHsl5BiYWJlbOyEpOyglSDstpTqsIDtlZjquLBcXG5cXG5cXG5cXG4jIyAx77iP4oOjLiDsnbQg7J6R7JeF7J2EIOynhO2Wie2VnCDrqqnsoIFcXG5cXG5SZWFjdOuhnCDsnpHsl4XtlZwg7ZqM7IKs7J2YIO2UhOuhnOygne2KuCDsvZTrk5zsl5DshJwgT2JqZWN0IOuNsOydtO2EsOydmCDqsJLsnbQg7KG07J6s7ZWY64qU7KeAIOyVhOuLjOyngCDslYzslYQg67O06riwIOychO2VtOyEnOuKlCBgJiZgIOyXsOyCsOyekOulvCDtmZzsmqntlZjqsbDrgpggYGlmIGVsc2VgIOq1rOusuOydhCDtmZzsmqntlbTslbwg7ZWY64qUIOuTsSDsvZTrk5zqsIAg64uk7IaMIOu2iO2VhOyalO2VmOqyjCDquLjslrTsp4DripQg66y47KCc6rCAIOyeiOyXiOyKteuLiOuLpC5cXG5cXG7tlbTri7kg642w7J207YSw6rCAIOyhtOyerO2VmOuKlCDqsr3smrDsmYAg7JWE64uMIOqyveyasOyXkCDrlLDrnbwgcmVuZGVyaW5n65CY64qUIOqyg+ydtCDri6zrnbzsp4DquLAg65WM66y47JeQIHJlYWN07JeQ7IScIOydtCBjb21wb25lbnTrpbwg66CM642U66eBIO2VmOq4sCDsoITsl5Ag642w7J207YSw7J2YIOyhtOyerCDsl6zrtoDrpbwg7Yq57KCVIOyngOydhCDsiJgg7J6I64qUIOy9lOuTnOqwgCDtlYTsmpTtlZwg6rKD7J207KOgLlxcblxcbuyYiOulvCDrk6TrqbQg64uk7J2M6rO8IOqwmeyKteuLiOuLpC5cXG5cXG5gYGBqc3hcXG5jb25zdCBsYW5ndWFnZSA9IHtcXG5cXHRuYW1lOiBcXFwiamF2YXNjcmlwdFxcXCIsXFxuXFx0YmVzdF9mcmllbmQ6IHtcXG5cXHRcXHRuYW1lOiBcXFwiVHlwZXNjcmlwdFxcXCIsXFxuXFx0fVxcbn1cXG5cXG57XFxuXFx0bGFuZ3VhZ2UgJiYgbGFuZ3VhZ2UuYmVzdF9mcmllbmQgJiYgbGFuZ3VhZ2UuYmVzdF9mcmllbmQubmFtZSA9PT0gXFxcIlR5cGVzY3JpcHRcXFwiICYmIFxcblxcdDxoMT5IZWxsbyB7bGFuZ3VhZ2UuYmVzdF9mcmllbmQubmFtZX08L2gxPlxcbn1cXG5gYGBcXG5cXG5sYW5ndWFnZeudvOuKlCDqsJ3ssrTsnZggYmVzdF9mcmllbmTsnZggbmFtZeqwkuydtCDsnojripQg6rK97Jqw7JeQIEhlbGxvIOuSpOyXkCDtlbTri7kg642w7J207YSw66W8IOugjOuNlOungSDtlZjroKTripQg6rK97JqwIOq4sOyhtOyXkOuKlCDsnITsmYAg6rCZ7J2AIOuwqeyLneycvOuhnCBsYW5ndWFnZeyViOyXkCBiZXN0X2ZyaWVuZOqwgCDsnojripTsp4Drpbwg67O07J6l7ZWY64qUIOqyveyasOyXkOunjCDroIzrjZTrp4Eg7ZWgIOyImCDsnojrj4TroZ0g7ZW07JW8IO2WiOyKteuLiOuLpC5cXG5cXG7spJHsmpTtlZwg6rG0IOydtCDqsr3smrDsl5Ag66y47KCc6rCAIOuQmOuKlCDqsoPsnYAgYG5hbWVg6rCS7J20IOyVhOuLiOudvCBgYmVzdF9mcmllbmRg7J6F64uI64ukLiBiZXN0X2ZyaWVuZOydmCBuYW1l6rCS7J20IOu5hOyWtOyeiOuNlOudvOuPhCByZWFjdOyXkOyEnCDroIzrjZTrp4HtlZjripTrjbAg66y47KCc6rCAIOyXhuyKteuLiOuLpC4g6re47KCAIHVuZGVmaW5lZOulvCDtlaDri7ntlZjqs6Ag67mIIOqwkuydhCDrnYTsm4zso7zrqbQg65CY64uI6rmM7JqULiDtlZjsp4Drp4wgYmVzdF9mcmllbmTsnpDssrTqsIAg7JeG7Jy866m0IOq3uOqyg+ydgCDrrLjsoJzqsIAg65Cp64uI64ukLiB1bmRlZmllbmTsnZgg4oCcbmFtZeKAneydhCDssL7slYTsmKTrnbzripQg7J6Y66q765CcIOy9lOuTnOulvCDsnpHshLHtlojquLAg65WM66y47J207KOgLlxcblxcbiMjIyBvcHRpb25hbCBjaGFpbmluZyAoPylcXG5cXG7smLXshZTrhJAg7LK07J2064ud7J20652864qUIOqyg+ydgCAyMDIw64WEIGphdmFzY3JpcHTsl5Ag7LaU6rCA65CcIOyDiOuhnOyatCDrrLjrspXsnoXri4jri6QuIOuwlOuhnCDsnITsnZggbGFuZ3VhZ2Ug6rCd7LK07JmAIOqwmeydtCDqsJ3ssrTrgrTrtoDsl5Ag65iQ64uk66W4IOqwneyytOulvCDssrTsnbTri53snLzroZwg7Jew6rKw7ZWgIOuVjCDrsJzsg53tlZjripQg7JyE7JmAIOqwmeydgCDrrLjsoJzrpbwg6rCE7Y647ZWcIOusuOuyleycvOuhnCDtlbTqsrDtlZjquLAg7JyE7ZWcIOq4sOuKpeydtOudvCDrs7wg7IiYIOyeiOyKteuLiOuLpC4gYD9gIOyVnuydmCDtj4nqsIDrjIDsg4HsnbQgYHVuZGVmaW5lZGDsnbTqsbDrgpggYG51bGxg7J28IOqyveyasCDtj4nqsIDrpbwg66mI7LaU6rOgIOq3uCDrkZAg6rCA7KeA6rCAIOyVhOuLjCDqsr3smrAg65Kk7J2YIO2PieqwgOulvCAg7J207Ja064KY6rCR64uI64ukLiDsmLXshZTrhJAg7LK07J2064ud7J2EIO2ZnOyaqe2VmOuptCDri6Tshowg7KeA7KCA67aE7ZWcIOuwqeyWtOuhnOyngeydtOuCmCDsmbjrtoAg65287J2067iM65+s66as66W8IOyCrOyaqe2VoCDtlYTsmpTsl4bsnbQg6rmU64GU7ZWcIOy9lOuTnOulvCDsp6Qg7IiYIOyeiOyKteuLiOuLpC4g7JWE656Y7JmAIOqwmeydtCDsgqzsmqnrkKnri4jri6QuXFxuXFxuYGBganN4XFxue1xcblxcdGxhbmd1YWdlLmJlc3RfZnJpZW5kPy5uYW1lICYmIFxcblxcdDxoMT5IZWxsbyB7bGFuZ3VhZ2UuYmVzdF9mcmllbmQubmFtZX0gPC9oMT5cXG59XFxuYGBgXFxuXFxu7Zuo7JSsIOq5lOuBlO2VtOyhjOyjoD9cXG5cXG7so7zsnZjtlaAg7KCQ7J2AICoq7Ji17IWU64SQIOyytOydtOuLneydhCDrgqjsmqntlZjsp4Ag7JWK64qUIOqygyoq7J6F64uI64ukKiouKipcXG5cXG5gPy5g64qUIOyhtOyerO2VmOyngCDslYrslYTrj4Qg6rSc7LCu7J2AIOuMgOyDgeyXkOunjCDsgqzsmqntlbTslbwg7ZWp64uI64ukLlxcblxcbuyCrOyaqeyekCDso7zshozrpbwg64uk66Oo64qUIOychCDsmIjsi5zsl5DshJwg64W866as7IOBwqBgbGFuZ3VhZ2Vg64qUIOuwmOuTnOyLnCDsnojslrTslbwg7ZWY64qU642wwqBgYmVzdF9mcmllbmRg7ZWE7IiY6rCS7J20IOyVhOuLmeuLiOuLpC4g6re465+s64uIIGBsYW5ndWFnZS5iZXN0X2ZyaWVuZD8ubmFtZWAg66W8IOyCrOyaqe2VmOuKlCDqsoPsnbQg67CU656M7KeB7ZWp64uI64ukLlxcblxcbuyLpOyImOuhnCDsnbjtlbTCoGBsYW5ndWFnZWDqsJLsnYQg7ZWg64u57ZWY7KeAIOyViuyVmOuLpOuptCDrsJTroZwg7JWM7JWE64K8IOyImCDsnojrj4TroZ0g7ZW07JW8IO2VqeuLiOuLpC4g6re466CH7KeAIOyViuycvOuptCDsl5Drn6zrpbwg7KGw6riw7JeQIOuwnOqyrO2VmOyngCDrqrvtlZjqs6Ag65SU67KE6rmF7J20IOyWtOugpOybjOynkeuLiOuLpC5cXG5cXG7qsrDqs7zsoIHsnLzroZwg7J20IOyekeyXheydhCDsp4TtlontlZjripQg6rKD7J2AIOu5jOuTnOyehyDtlITroZzsoJ3tirjsl5DshJwg7J20IOy1nOyLoCDrrLjrspXsnbggb3B0aW9uYWwgY2hhaW5pbmfsnYQg7Zmc7Jqp7ZWgIOyImCDsnojrj4TroZ0g7ZWY6riwIOychO2VtCDshKTsoJXqsJLsnYQg67OA6rK97ZWY64qUIOqyg+ydtCDrqqnsoIHsnbTsl4jsirXri4jri6QuXFxuXFxuIyMgMu+4j+KDoy4gcmVhY3QtcmV3aXJlZFxcblxcbu2ajOyCrOydmCBwcm9qZWN064qUIENSQShucG0gY3JlYXRlLXJlYWN0LWFwcCBidWlsZGl0LWNvLWtyLXJlYWN0KSDrqoXroLnslrTroZwg7ISk7LmY65CcIO2UhOuhnOygne2KuOyeheuLiOuLpC4g7KaJIOq4sOuzuOyggeyduCDshKTsoJXrk6TsnYQg7KeB7KCRIOyEpOygle2VmOq4sCDrs7Tri6TripQg7J6Q64+Z7KCB7Jy866GcIOyEuO2Mhe2VtOyjvOuKlCDqsJLsnLzroZwg7LSI6riwIO2UhOuhnOygne2KuOulvCDshLjtjIXtlojsirXri4jri6QuIFxcblxcbkNSQeuKlCDruaDrpbgg7ZSE66Gc7KCd7Yq4IOyEpOygleydhCDrj4TsmYDspIDri6TripQg7J6l7KCQKGJhYmVsLCB3ZWJwYWNrIOuTsSDsgqzsi6Tsg4HsnZgg7ZSE66Gc7KCd7Yq4IO2VhOyImCDshKTsoJUp7J20IOyeiOyngOunjCDsnbTrn6ztlZwg7IS47YyF6rCS65Ok7J2EIO2UhOuhnOygne2KuCDrlJTroInthqDrpqzsl5DshJwg7Im96rKMIOywvuydhCDsiJgg7JeG6rKMIOuQmOyWtCDsm5DtlZjripTrjIDroZwg67CU6r+AIOyImCDsl4bri6TripQg64uo7KCQ7J20IOyeiOyKteuLiOuLpC4g7J20IENSQSDshKTsoJXsnYQg6rmo6rOgIOuLpOyLnCDshKTsoJXtlZjripQg6rKD7J2EIGBlamVjdGDrnbwg7ZGc7ZiE7ZWY64qU642wIOydtOugh+qyjCDtlZjrqbQgQ1JB7J2YIOyepeygkOyduCAoKipvbmUgQnVpbGQgRGVwZW5kZW5jeSoqKeqwgCDquajsp4Dqsowg65Cp64uI64ukLiDrlLDrnbzshJwgZWplY3TtlZjrqbQg7ISc66Gc6rCE7J2YIGRlcGVuZGVuY3nqsIAg7Ja065a76rKMIOq8rOydvCDsp4Ag7JWE64qUIOqyg+ydtCDslrTroLXri6TripQg64uo7KCQ7J20IOyeiOyKteuLiOuLpC5cXG5cXG4hW2VqZWN064qUIOutlOqwgCDrkZDroLXri6RdKC9hc3NldHMvaW1nL2VqZWN0LnBuZylcXG5cXG4o7J2MLi4uIGVqZWN064qUIOutlOqwgCDrkZDroLXri6QpXFxuXFxuIyMjIHJlYWN0LXJld2lyZWTsnZgg7J6l7KCQXFxuXFxucmVhY3QtcmV3aXJlZOuKlCBgZWplY3Rg66W8IO2VmOyngCDslYrqs6AgQ1JB7J2YIOyEpOygleqwkuydhCDrsJTqvrjrj4TroZ0g64+E7JmA7KO864qUIOudvOydtOu4jOufrOumrCDsnoXri4jri6QuXFxuXFxu7LWc64yA7ZWcIENSQSDshKTsoJXsnYQg6re464yA66GcIOycoOyngO2VnOyxhCDtirnsoJUg67aA67aE66eMIEN1c3Rvbe2VmOuKlCDqsoPsnYQg64+E7JmA7KSN64uI64ukLlxcblxcbltodHRwczovL2dpdGh1Yi5jb20vdGltYXJuZXkvcmVhY3QtYXBwLXJld2lyZWRdKGh0dHBzOi8vZ2l0aHViLmNvbS90aW1hcm5leS9yZWFjdC1hcHAtcmV3aXJlZClcXG5cXG4jIyMgcmVhY3QtcmV3aXJlZOydmCDri6jsoJBcXG5cXG7tlZjsp4Drp4wg7JWE66y066asIHJlYWN0LXJld2lyZWTrpbwg7IKs7Jqp7ZWc64uk7ZW064+EIENSQeqwgCDsoJzqs7XtlZjripQg6riw64ql7J2EIOyZhOyghO2eiCBwcm92aWRl7ZWY7KeA64qUIOyViuyKteuLiOuLpC5cXG5cXG7imqDvuI/CoCoqUGxlYXNlIE5vdGU6KipcXG5gYGBcXG7wn5KhIFxcXCJTdHVmZiBjYW4gYnJlYWtcXFwiIC0gRGFuIEFicmFtb3ZcXG5gYGBcXG5cXG4+IEJ5IGRvaW5nIHRoaXMgeW91J3JlIGJyZWFraW5nIHRoZcKgXFxcImd1YXJhbnRlZXNcXFwiwqB0aGF0IENSQSBwcm92aWRlcy4gVGhhdCBpcyB0byBzYXkgeW91IG5vdyBcXFwib3duXFxcIiB0aGUgY29uZmlncy7CoE5vIHN1cHBvcnTCoHdpbGwgYmUgcHJvdmlkZWQuIFByb2NlZWQgd2l0aCBjYXV0aW9uLlxcblxcblVzaW5nIHRoaXMgbGlicmFyeSB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGFuZCBjb25maWd1cmF0aW9uIG9mwqBgY3JlYXRlLXJlYWN0LWFwcGBcXG4sIHRoZXJlZm9yZSBpbnZhbGlkYXRpbmcgdGhlIGd1YXJhbnRlZXMgdGhhdCBjb21lIHdpdGggaXQuIFVzZSB3aXRoIGRpc2NyZXRpb24hXFxuXFxuXFxuXFxuIyMgM++4j+KDoy4g7J6R7JeFIOynhO2WiVxcblxcbiMjIyAxLiByZWFjdC1yZXdpcmVkXFxuXFxuIyMjIyDshKTsuZhcXG5cXG5gYGBiYXNoXFxuJCBucG0gaW5zdGFsbCByZWFjdC1hcHAtcmV3aXJlZCAtLXNhdmUtZGV2XFxuYGBgXFxuXFxuIyMjIyDtlITroZzsoJ3tirggcm9vdCDrlJTroInthqDrpqzsl5AgKioqKmBjb25maWctb3ZlcnJpZGVzLmpzYCDshKTsoJUqKlxcblxcbmBgYGpzeFxcbi8qIGNvbmZpZy1vdmVycmlkZXMuanMgKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG92ZXJyaWRlKGNvbmZpZywgZW52KSB7XFxuICAvL2RvIHN0dWZmIHdpdGggdGhlIHdlYnBhY2sgY29uZmlnLi4uXFxuICByZXR1cm4gY29uZmlnO1xcbn1cXG5gYGBcXG5cXG4jIyMjIGBwYWNrYWdlLmpzb25gIO2MjOydvOyXkOyEnCBzY3JpcHRzIOu2gOu2hCDrqoXroLnslrQg7IiY7KCVXFxuXFxuYGBganN4XFxuXFxcInNjcmlwdHNcXFwiOiB7XFxuLSAgIFxcXCJzdGFydFxcXCI6IFxcXCJyZWFjdC1zY3JpcHRzIHN0YXJ0XFxcIixcXG4rICAgXFxcInN0YXJ0XFxcIjogXFxcInJlYWN0LWFwcC1yZXdpcmVkIHN0YXJ0XFxcIixcXG4tICAgXFxcImJ1aWxkXFxcIjogXFxcInJlYWN0LXNjcmlwdHMgYnVpbGRcXFwiLFxcbisgICBcXFwiYnVpbGRcXFwiOiBcXFwicmVhY3QtYXBwLXJld2lyZWQgYnVpbGRcXFwiLFxcbi0gICBcXFwidGVzdFxcXCI6IFxcXCJyZWFjdC1zY3JpcHRzIHRlc3RcXFwiLFxcbisgICBcXFwidGVzdFxcXCI6IFxcXCJyZWFjdC1hcHAtcmV3aXJlZCB0ZXN0XFxcIixcXG4gICAgXFxcImVqZWN0XFxcIjogXFxcInJlYWN0LXNjcmlwdHMgZWplY3RcXFwiXFxufVxcbmBgYFxcblxcbiMjIyAyLiBDdXN0b21pemUtY3JhXFxuXFxuW2N1c3RvbWl6ZS1jcmFdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2N1c3RvbWl6ZS1jcmEpXFxuXFxuIyMjIyDshKTsuZhcXG5cXG5gYGBiYXNoXFxuJCBucG0gaSBjdXN0b21pemUtY3JhXFxuYGBgXFxuXFxuIyMjIyBgY29uZmlnLW92ZXJyaWRlcy5qc2Ag7ISk7KCVIE92ZXJyaWRlXFxuXFxuYGBganN4XFxuY29uc3QgeyBvdmVycmlkZSwgdXNlQmFiZWxSYyB9ID0gcmVxdWlyZSgnY3VzdG9taXplLWNyYScpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gb3ZlcnJpZGUodXNlQmFiZWxSYygpKTtcXG5gYGBcXG5cXG4tIGJhYmVscmMg7ISk7KCV7J2EIOyCrOyaqe2VmOq4sCDsnITtlbQgY29uZmlnLW92ZXJyaWRlcy5qc+ydmCDshKTsoJXsnYQg67OA6rK97ZW07KSN64uI64ukLlxcblxcbiMjIyAzLiBiYWJlbCDtlIzrn6zqt7jsnbgg4oCccGx1Z2luLXByb3Bvc2FsLW9wdGlvbmFsLWNoYWluaW5n4oCdXFxuXFxuIyMjIyDshKTsuZhcXG5cXG5gYGBiYXNoXFxuJCBucG0gaW5zdGFsbCAtLXNhdmUtZGV2IEBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtb3B0aW9uYWwtY2hhaW5pbmdcXG5gYGBcXG5cXG4jIyMjIC5iYWJlbHJjXFxuXFxuYGBganN4XFxue1xcbiAgXFxcInBsdWdpbnNcXFwiOiBbXFxcIkBiYWJlbC9wbHVnaW4tcHJvcG9zYWwtb3B0aW9uYWwtY2hhaW5pbmdcXFwiXVxcbn1cXG5gYGBcXG5cXG7snbTsoJwgKioqb3B0aW9uYWwgY2hhaW5pbmcqKirsnYQg7JO4IOyImCDsnojsirXri4jri6Qu4pyM77iPXFxuXFxuXFxuXFxu64uk7J2M7JeQ64qUIHJlYWN0LXJld2lyZeulvCDtlZjsp4Ag7JWK6rOgIOyngeygkSBub2RlanMg67KE7KCE6rO8IHJlYWN0LXNjcmlwdHMsIOq3uOumrOqzoCDri6Trpbgg65287J2067iM65+s66as7JmA7J2YIOydmOyhtOyEsSDrrLjsoJzrpbwg7ZW06rKw7ZWcIOuCtOyaqeydhCDsl4XroZzrk5wg7ZWY6rKg7Iq164uI64ukLlxcblxcbi0tLVxcblxcbuywuOqzoFxcblxcbltodHRwczovL2dpdGh1Yi5jb20vYXJhY2thZi9jdXN0b21pemUtY3JhXShodHRwczovL2dpdGh1Yi5jb20vYXJhY2thZi9jdXN0b21pemUtY3JhKVxcblxcbltNaWNhbGdlbnVzXShodHRwczovL21pY2FsZ2VudXMuZ2l0aHViLmlvL2FydGljbGVzLzIwMTktMDIvUmVhY3QtZWplY3QtJUVDJTk3JTg2JUVDJTlEJUI0LWJhYmVscmMtJUVDJUEwJTgxJUVDJTlBJUE5KVxcblxcbltAYmFiZWwvcHJlc2V0LXJlYWN0IMK3IEJhYmVsXShodHRwczovL2JhYmVsanMuaW8vZG9jcy9lbi9iYWJlbC1wcmVzZXQtcmVhY3QpXFxuXFxuW0BiYWJlbC9wbHVnaW4tc3ludGF4LW9wdGlvbmFsLWNoYWluaW5nIMK3IEJhYmVsXShodHRwczovL3dlYnBhY2suanMub3JnL2NvbnRyaWJ1dGUvd3JpdGluZy1hLXBsdWdpbi8jYmFzaWMtcGx1Z2luLWFyY2hpdGVjdHVyZSlcIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwiQ1JB7JeG7J20IOumrOyVoe2KuCDtlITroZzsoJ3tirgg7ISk7KCV7ZWY6riwXFxcIlxcbmRhdGU6IFxcXCIyMDIyLjA0LjAxXFxcIlxcbnRhZ3M6XFxuICAtIHJlYWN0XFxuICAtIGNyYVxcbiAgLSBjcmVhdGUtcmVhY3QtYXBwXFxuLS0tXFxuXFxuXFxuIyMgMS4gQ1JBIChDcmVhdGUtUmVhY3QtQXBwKeyXhuydtCDrpqzslaHtirgg7ZSE66Gc7KCd7Yq4IOyEpOygle2VmOq4sFxcblxcbiMjIyBDUkHrpbwg7IKs7Jqp7ZWY64qUIOydtOycoD9cXG5cXG4tIO2UhOuhnOygne2KuCDshLjtjIXsnYQg7JyE7ZW0IOuUsOuhnCDtlZnsirXtlaAg7ZWE7JqU6rCAIOyXhuyKteuLiOuLpC5cXG4tIOqzoOuvvO2VmOyngCDslYrqs6Ag67mg66W06rKMIOyEpOygle2VoCDsiJgg7J6I7Iq164uI64ukLlxcbi0g7IS47YyF67O064uk64qUIOy9lOuTnOyXkCDsooAg642UIOqzoOuvvO2VoCDsi5zqsITsnYQg66eI66Co7ZWgIOyImCDsnojsirXri4jri6QuXFxuLSDsnpgg7JWI7JOw64qUIO2MjOydvOuTpOydhCDqtbPsnbQg7IOd7ISx7ZWY7KeAIOyViuyVhOyEnCDrlLDroZwg7KeA7Jq4IO2VhOyalOqwgCDsl4bsirXri4jri6QuXFxuXFxuIyMjIENSQeyXkOyEnCDshLjtjIXtlbTso7zripQg64K07Jqp7J2AIOustOyXh+ydtCDsnojsnYTquYw/XFxuXFxuLSDsm7ntjKlcXG4tIOuwlOuyqFxcbi0gZXNsaW50XFxuXFxu4oCLXFx07Jm4IOq4sO2DgCDrk7Hrk7FcXG5cXG5DUkEg66qF66C57Ja0IOyXhuydtCDsm7ntjKnqs7wg67CU67KoIOyEpOygleunjOycvOuhnCBsb2NhbGhvc3TroZwg66as7JWh7Yq4IO2UhOuhnOygne2KuOulvCDrnYTsm4zrs7TqsqDsirXri4jri6QuXFxuXFxuXFxuXFxuIyMgMi4gQ1JB7JeG7J20IFJlYWN0IFByb2plY3Trpbwg7IS47YyF7ZW067O06riwXFxuXFxuPGFzaWRlPlxcbvCfkqEg66e566qp7KCB7J24IENSQeydmOyhtOydhCDtlZjsp4Ag7JWK6rOgIOyngeygkSDrpqzslaHtirgg7ZSE66Gc7KCd7Yq466W8IOyEuO2Mhe2VtOuztOuptOyEnCDtlITroZzsoJ3tirjrpbwg7Iuc7J6R7ZWgIOuVjCDtlITroZzsoJ3tirjsnZgg66qp7KCB7JeQIOqwgOyepSDsnpgg67aA7ZWp7ZWY64qUIOyEuO2MheydhCDsp4TtlontlaAg7IiYIOyeiOuKlCDqsoPsnbQg66qp7ZGcLlxcbjwvYXNpZGU+XFxuXFxuXFxuIyMjIDEuIO2UhOuhnOygne2KuCDsi5zsnpHtlZjquLBcXG5cXG5gYGBiYXNoXFxuJCBta2RpciBuby1jcmFcXG4kIGNkIG5vLWNyYVxcbiQgbm8tY3JhID4gbnBtIGluaXQgLXlcXG4kIG5vLWNyYSA+IG1rZGlyIHNyYyBwdWJsaWNcXG4kIG5vLWNyYSA+IGNkIHNyY1xcbiQgbm8tY3JhID4gc3JjID4gdG91Y2ggaW5kZXguanMgaW5kZXguY3NzXFxuJCBuby1jcmEgPiBwdWJsaWMgPiB0b3VjaCBpbmRleC5odG1sXFxuYGBgXFxuXFxuLSBuby1jcmFcXG4gIC0gcHVibGljXFxuICAgIC0gaW5kZXguaHRtbFxcbiAgLSBzcmNcXG4gICAgLSBpbmRleC5qc1xcbiAgICAtIGluZGV4LmNzc1xcbiAgLSBwYWNrYWdlLmpzb25cXG5cXG4jIyMgMi4gbnBtIO2MqO2CpOyngCDshKTsuZhcXG5cXG5gYGBiYXNoXFxuJCBuby1jcmEgPiBucG0gaSByZWFjdCByZWFjdC1kb21cXG4kIG5vLWNyYSA+IG5wbSBpIHdlYnBhY2sgd2VicGFjay1jbGkgd2VicGFjay1kZXYtc2VydmVyXFxuJCBuby1jcmEgPiBucG0gaSBiYWJlbC1sb2FkZXIgY3NzLWxvYWRlciBzdHlsZS1sb2FkZXJcXG4kIG5vLWNyYSA+IG5wbSBpIEBiYWJlbC9jb3JlIEBiYWJlbC9wcmVzZXQtcmVhY3QgQGJhYmVsL3ByZXNldC1lbnZcXG4kIG5vLWNyYSA+IG5wbSBpbnN0YWxsIC0tc2F2ZS1kZXYgaHRtbC13ZWJwYWNrLXBsdWdpblxcbiQgbm8tY3JhID4gbnBtIGluc3RhbGwgLS1zYXZlLWRldiBjbGVhbi13ZWJwYWNrLXBsdWdpblxcbmBgYFxcblxcbiMjIyAzLiBiYWJlbCDshKTsoJUg7L2U65OcIOyekeyEsVxcblxcbmBgYGpzeFxcbi8vIGJhYmVsLmNvbmZpZy5qcyBcXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gICAgcHJlc2V0czogWydAYmFiZWwvcHJlc2V0LWVudicsICdAYmFiZWwvcHJlc2V0LXJlYWN0J10gXFxufVxcbmBgYFxcblxcbiMjIyA0LiB3ZWJwYWNrIOyEpOyglSDsvZTrk5wg7J6R7ISxXFxuXFxuYGBganN4XFxuLy8gd2VicGFjay5jb25maWcuanNcXG5jb25zdCB3ZWJwYWNrID0gcmVxdWlyZSgnd2VicGFjaycpO1xcbmNvbnN0IEh0bWxXZWJwYWNrUGx1Z2luID0gcmVxdWlyZSgnaHRtbC13ZWJwYWNrLXBsdWdpbicpO1xcbmNvbnN0IHsgQ2xlYW5XZWJwYWNrUGx1Z2luIH0gPSByZXF1aXJlKCdjbGVhbi13ZWJwYWNrLXBsdWdpbicpO1xcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIG1vZGU6IHByb2Nlc3MuZW52Lm1vZGUsXFxuICAgIGVudHJ5OiAnLi9zcmMvaW5kZXguanMnLFxcbiAgICBvdXRwdXQ6IHtcXG4gICAgICBwYXRoOiBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnZGlzdCcpLFxcbiAgICAgIGZpbGVuYW1lOiAnW2hhc2hdLmpzJyxcXG4gICAgICBwdWJsaWNQYXRoOiAnLydcXG4gICAgfSxcXG4gICAgcmVzb2x2ZToge1xcbiAgICAgIC8vIHBhdGgucmVzb3ZlIO2Yle2DnOuhnCDsgqzsmqntlaAg7IiY64+EIOyeiOuLpC5cXG4gICAgICAvLyDqt7jrn6zrqbQgbm9kZeydmCDquLDrs7gg66qo65OIICdwYXRoJ+ulvCDrtojrn6zsmYDslbwg7ZWc64ukLlxcbiAgICAgIGV4dGVuc2lvbnM6IFsnLmpzJywgJy5qc3gnLCAnLmNzcyddXFxuICAgIH0sXFxuICAgIG1vZHVsZToge1xcbiAgICAgICAgcnVsZXM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHRlc3Q6IC9cXFxcLihqc3xqc3gpJC8sXFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGU6ICcvbm9kZV9tb2R1bGVzLycsXFxuICAgICAgICAgICAgICAgIGxvYWRlcjogJ2JhYmVsLWxvYWRlcidcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgdGVzdDogL1xcXFwuY3NzJC8sXFxuICAgICAgICAgICAgICAgIHVzZTogW1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlcjogJ3N0eWxlLWxvYWRlcicsIFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZXI6ICdjc3MtbG9hZGVyJywgXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBdXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgXVxcbiAgICB9LFxcbiAgICBwbHVnaW5zOiBbXFxuICAgICAgICBuZXcgQ2xlYW5XZWJwYWNrUGx1Z2luKCksXFxuICAgICAgICBuZXcgSHRtbFdlYnBhY2tQbHVnaW4oe1xcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnLi9wdWJsaWMvaW5kZXguaHRtbCdcXG4gICAgICAgIH0pXFxuICAgIF0sXFxuICAgIGRldlNlcnZlcjoge1xcbiAgICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXFxuICAgICAgICBwb3J0OiAzMDAwLFxcbiAgICAgICAgaG90OiB0cnVlLFxcbiAgICAgICAgb3BlbjogdHJ1ZVxcbiAgICB9XFxufTtcXG5gYGBcXG5cXG5cXG5cXG4jIyMgNS4gcGFja2FnZS5qc29uXFxuXFxuYGBgamF2YXNjcmlwdFxcbntcXG4gIFxcXCJuYW1lXFxcIjogXFxcIm5vLWNyYVxcXCIsXFxuICBcXFwidmVyc2lvblxcXCI6IFxcXCIxLjAuMFxcXCIsXFxuICBcXFwiZGVzY3JpcHRpb25cXFwiOiBcXFwiXFxcIixcXG4gIFxcXCJtYWluXFxcIjogXFxcImluZGV4LmpzXFxcIixcXG4gIFxcXCJzY3JpcHRzXFxcIjoge1xcbiAgICBcXFwidGVzdFxcXCI6IFxcXCJlY2hvIFxcXFxcXFwiRXJyb3I6IG5vIHRlc3Qgc3BlY2lmaWVkXFxcXFxcXCIgJiYgZXhpdCAxXFxcIixcXG4gICAgXFxcInN0YXJ0OmRldlxcXCI6IFxcXCJ3ZWJwYWNrIHNlcnZlIC0tcHJvZ3Jlc3MgLS1tb2RlIGRldmVsb3BtZW50XFxcIixcXG4gICAgXFxcInN0YXJ0OmJ1aWxkXFxcIjogXFxcIndlYnBhY2tcXFwiXFxuICB9LFxcbiAgXFxcImtleXdvcmRzXFxcIjogW10sXFxuICBcXFwiYXV0aG9yXFxcIjogXFxcIlxcXCIsXFxuICBcXFwibGljZW5zZVxcXCI6IFxcXCJJU0NcXFwiLFxcbiAgXFxcImRlcGVuZGVuY2llc1xcXCI6IHtcXG4gICAgXFxcIkBiYWJlbC9jb3JlXFxcIjogXFxcIl43LjE3LjhcXFwiLFxcbiAgICBcXFwiQGJhYmVsL3ByZXNldC1lbnZcXFwiOiBcXFwiXjcuMTYuMTFcXFwiLFxcbiAgICBcXFwiQGJhYmVsL3ByZXNldC1yZWFjdFxcXCI6IFxcXCJeNy4xNi43XFxcIixcXG4gICAgXFxcImJhYmVsLWxvYWRlclxcXCI6IFxcXCJeOC4yLjRcXFwiLFxcbiAgICBcXFwiY3NzLWxvYWRlclxcXCI6IFxcXCJeNi43LjFcXFwiLFxcbiAgICBcXFwicmVhY3RcXFwiOiBcXFwiXjE3LjAuMlxcXCIsXFxuICAgIFxcXCJyZWFjdC1kb21cXFwiOiBcXFwiXjE3LjAuMlxcXCIsXFxuICAgIFxcXCJzdHlsZS1sb2FkZXJcXFwiOiBcXFwiXjMuMy4xXFxcIixcXG4gICAgXFxcIndlYnBhY2tcXFwiOiBcXFwiXjUuNzAuMFxcXCIsXFxuICAgIFxcXCJ3ZWJwYWNrLWNsaVxcXCI6IFxcXCJeNC45LjJcXFwiLFxcbiAgICBcXFwid2VicGFjay1kZXYtc2VydmVyXFxcIjogXFxcIl40LjcuNFxcXCJcXG4gIH0sXFxuICBcXFwiZGV2RGVwZW5kZW5jaWVzXFxcIjoge1xcbiAgICBcXFwiY2xlYW4td2VicGFjay1wbHVnaW5cXFwiOiBcXFwiXjQuMC4wXFxcIixcXG4gICAgXFxcImh0bWwtd2VicGFjay1wbHVnaW5cXFwiOiBcXFwiXjUuNS4wXFxcIlxcbiAgfVxcbn1cXG5cXG5gYGBcXG5cXG5cXG5cXG7snbTroIfqsowg7ISk7KCV7ZWY6rOg7IScIGBucG0gcnVuIHN0YXJ0OmRldmAg66qF66C57Ja066W8IOyeheugpe2VtOyjvOyLnOuptCDroZzsu6zsl5DshJwg66as7JWh7Yq4IO2UhOuhnOygne2KuOulvCDsi6TtlontlbTrs7wg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG5cXG5cXG4tLS1cXG5cXG5bW0NvJ1RhbGtdIENyZWF0ZS1SZWFjdC1BcHAg7JeG7J20IOumrOyVoe2KuCDtlITroZzsoJ3tirgg7Iuc7J6R7ZWY6riwIC0g7L2U65Oc7Iqk7YWM7J207LigIOqwle2VnOqysCDqtZDsnKEg66ek64uI7KCAXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PXdTemg4aVNkWVVRKVxcblxcbltDcmVhdGUtUmVhY3QtQXBwIOyXhuydtCDrpqzslaHtirgg7ZSE66Gc7KCd7Yq4IOuztOydvOufrCDtlIzroIjsnbTsiqQg7IS47YyF7ZWY6riwXShodHRwczovL2hhbmt5ZW9say5naXRodWIuaW8vMjAyMS8wOC8wOC93aXRob3V0Q1JBLmh0bWwpXFxuXFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIuumrOyVoe2KuCDsvZjshpTssL0g7JeQ65+sIOq3uOuMgOuhnCDrhpTrkZDqs6Ag6rOE7Iug6rCA7JqUP1xcXCJcXG5kYXRlOiBcXFwiMjAyMi4xMC4wN1xcXCJcXG50YWdzOlxcbiAgLSDrpqzslaHtirhcXG4gIC0g7L2Y7IaUXFxuICAtIOyXkOufrFxcbi0tLVxcblxcblxcblxcbiMg66as7JWh7Yq4IGNvbnNvbGUgd2FybmluZywgZXJyb3Ig7KCc6rGw7ZWY6riwXFxuXFxu7Y+J7IaMIOqwnOuwnO2VoCDrlYwg66eI64ukIOy8nOuKlCDtgazroazqsJzrsJzsnpDrj4TqtazsnZgg7L2Y7IaU7LC97JeQ64qUIOyImCDrp47snYAg7JeQ65+s7JmAIOqyveqzoCDrqZTsi5zsp4DqsIAg65yo6rOgIOyeiOyXiOyKteuLiOuLpC4g6rCc67Cc7J6Q66W8IOuPhOyZgOyjvOuKlCDqs6Drp4jsmrQg66mU7Iuc7KeA65Ok7J207KeA66eMIOyCrOyLpCDrs7wg65WMIOuniOuLpCDsooAg6ry067WI6riwIOyLq+yXiOuLpOqzoCg/KSDtkZztmITtlZjripTqsowg6rCA7J6lIOyggOydmCDsoJXtmZXtlZwg7Ius7KCV7J207JeI7Iq164uI64ukLiDsp6zsnbQg7KKAIOuCmOuptCDqsoDrj4QgOeuLqOydtCDrjIDrgpjrrLQg7I2w65Ov7J20IOyNsOyWtOuztOqyoOuLpOqzoCDri6Tsp5Drp4wg7ZaI7JeI64uk6rCAIOuTnOuUlOyWtCDquLDri6TrpqzrjZgg6riw7ZqM6rCAIOyZgOyEnCjsp6zsnbQg64KY7IScOykg7ZWcIOuyiCDsspjrpqztlbTrtKTsirXri4jri6QuXFxuXFxuIVvsl5Drn6wg66mU7Iuc7KeA66W8IOyNsOq4sCDsoIQg64KY7J2YIOyDgeyDgSDsho0g64K0IOuqqOyKtSA7XShodHRwczovL2Nkbi1hay5mLnN0LWhhdGVuYS5jb20vaW1hZ2VzL2ZvdG9saWZlL2cvZ2FvdTIvMjAxNzA2MTEvMjAxNzA2MTEwMjAzMDguZ2lmKVxcblxcbuyXkOufrCDrqZTsi5zsp4Drpbwg7I2w6riwIOyghCDrgpjsnZgg7IOB7IOBIOyGjSDrgrQg66qo7Iq1IDtcXG5cXG4jIyDtmITsg4HtmalcXG5cXG4hW0JVSUxESVQtZXJyb3JdKC9hc3NldHMvaW1nL0JVSUxESVQtZXJyb3IucG5nKVxcblxcbiFbQlVJTERJVC1lcnJvcjFdKC9hc3NldHMvaW1nL0JVSUxESVQtZXJyb3IxLnBuZylcXG5cXG4jIyBFcnJvciDtlbTqsrBcXG5cXG4jIyMgMS4gTXVpVGhlbWVQcm92aWRlclxcblxcbmBgYHRzeFxcbi8vIEVycm9yIGxvZ1xcblxcbldhcm5pbmc6IEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIGB0aGVtZWAgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluIGBNdWlUaGVtZVByb3ZpZGVyT2xkYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC5cXG5gYGBcXG5cXG5gYGB0c3hcXG5jb25zdCBqc3MgPSBjcmVhdGUoanNzUHJlc2V0KCkpO1xcblxcbmZ1bmN0aW9uIHdpdGhSb290KENvbXBvbmVudCkge1xcbiAgZnVuY3Rpb24gV2l0aFJvb3QocHJvcHMpIHtcXG4gICAgLy8gSnNzUHJvdmlkZXIgYWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBKU1Mgc3R5bGluZyBzb2x1dGlvbi5cXG4gICAgcmV0dXJuIChcXG4gICAgICA8SnNzUHJvdmlkZXIganNzPXtqc3N9ID5cXG4gICAgICAgIHsvKiBNdWlUaGVtZVByb3ZpZGVyIG1ha2VzIHRoZSB0aGVtZSBhdmFpbGFibGUgZG93biB0aGUgUmVhY3QgdHJlZVxcbiAgICAgICAgICB0aGFua3MgdG8gUmVhY3QgY29udGV4dC4gKi99XFxuICAgICAgICA8TXVpVGhlbWVQcm92aWRlcj5cXG4gICAgICAgICAgey8qIENzc0Jhc2VsaW5lIGtpY2tzdGFydCBhbiBlbGVnYW50LCBjb25zaXN0ZW50LCBhbmQgc2ltcGxlIGJhc2VsaW5lIHRvIGJ1aWxkIHVwb24uICovfVxcbiAgICAgICAgICA8Q3NzQmFzZWxpbmUgLz5cXG4gICAgICAgICAgPENvbXBvbmVudCB7Li4ucHJvcHN9IC8+XFxuICAgICAgICA8L011aVRoZW1lUHJvdmlkZXI+XFxuICAgICAgPC9Kc3NQcm92aWRlcj5cXG4gICAgKTtcXG4gIH1cXG5cXG4gIHJldHVybiBXaXRoUm9vdDtcXG59XFxuYGBgXFxuXFxuYGBgXFxuY29uc3QganNzID0gY3JlYXRlKGpzc1ByZXNldCgpKTtcXG5jb25zdCB0aGVtZSA9IGNyZWF0ZU11aVRoZW1lKHt9KVxcblxcbmZ1bmN0aW9uIHdpdGhSb290KENvbXBvbmVudCkge1xcbiAgZnVuY3Rpb24gV2l0aFJvb3QocHJvcHMpIHtcXG4gICAgLy8gSnNzUHJvdmlkZXIgYWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBKU1Mgc3R5bGluZyBzb2x1dGlvbi5cXG4gICAgcmV0dXJuIChcXG4gICAgICA8SnNzUHJvdmlkZXIganNzPXtqc3N9ID5cXG4gICAgICAgIHsvKiBNdWlUaGVtZVByb3ZpZGVyIG1ha2VzIHRoZSB0aGVtZSBhdmFpbGFibGUgZG93biB0aGUgUmVhY3QgdHJlZVxcbiAgICAgICAgICB0aGFua3MgdG8gUmVhY3QgY29udGV4dC4gKi99XFxuICAgICAgICA8TXVpVGhlbWVQcm92aWRlciB0aGVtZT17dGhlbWV9PlxcbiAgICAgICAgICB7LyogQ3NzQmFzZWxpbmUga2lja3N0YXJ0IGFuIGVsZWdhbnQsIGNvbnNpc3RlbnQsIGFuZCBzaW1wbGUgYmFzZWxpbmUgdG8gYnVpbGQgdXBvbi4gKi99XFxuICAgICAgICAgIDxDc3NCYXNlbGluZSAvPlxcbiAgICAgICAgICA8Q29tcG9uZW50IHsuLi5wcm9wc30gLz5cXG4gICAgICAgIDwvTXVpVGhlbWVQcm92aWRlcj5cXG4gICAgICA8L0pzc1Byb3ZpZGVyPlxcbiAgICApO1xcbiAgfVxcblxcbiAgcmV0dXJuIFdpdGhSb290O1xcbn1cXG5gYGBcXG5cXG4tIE11aVRoZW1lUHJvdmlkZXIg7JeQIHRoZW1lIOyGjeyEseydhCB1bmRlZmluZWTroZwg7KO86rOgIOyeiOq4sCDrlYzrrLjsl5Ag67Cc7IOd7ZWcIOyXkOufrOyYgOyKteuLiOuLpC5cXG4tIHRoZW1l7JeQIGNyZWF0ZU11aVRoZW1lIOuplOyGjOuTnOulvCDthrXtlbQg66eM65OgIOqwneyytOulvCDrhKPslrTspJjshJwg7ZW06rKw7ZaI7Iq164uI64ukLlxcblxcbiMjIDIuIE11aUlucHV0TGFiZWxcXG5cXG5gYGB0c3hcXG4vLyBFcnJvciBsb2dcXG5cXG5XYXJuaW5nOiBNYXRlcmlhbC1VSTogdGhlIGBNdWlJbnB1dGxhYmVsYCBjb21wb25lbnQgaW5jcmVhc2VzIHRoZSBjc3Mgc3BlY2lmaWNpdHkgb2YgdGhlIGBmb2N1c2VkYCBpbnRlcm5hbCBzdGF0ZS4geW91IGNhbiBub3Qgb3ZlcnJpZGUgaXQgbGlrZSB0aGlzIC4uLlxcbmBgYFxcblxcbmBgYHRzeFxcbmNvbnN0IGRhcmtUaGVtZSA9IGNyZWF0ZU11aVRoZW1lKHtcXG4gIG92ZXJyaWRlczoge1xcblxcdFxcdC4uLlxcbiAgICBNdWlJbnB1dExhYmVsOiB7XFxuICAgICAgcm9vdDoge1xcbiAgICAgICAgY29sb3I6IFxcXCIjY2NjXFxcIixcXG4gICAgICAgIGZvbnRTaXplOiBcXFwiMTJweFxcXCIsXFxuICAgICAgICBtYXJnaW5Ub3A6IC0zLFxcbiAgICAgIH0sXFxuICAgICAgZm9jdXNlZDoge1xcbiAgICAgICAgZGlzcGxheTogXFxcIm5vbmVcXFwiLFxcbiAgICAgIH0sXFxuICAgICAgc2hyaW5rOiB7XFxuICAgICAgICBkaXNwbGF5OiBcXFwibm9uZVxcXCIsXFxuICAgICAgfSxcXG4gICAgfSxcXG4gICAgTXVpSW5wdXQ6IHtcXG4gICAgICB1bmRlcmxpbmU6IHtcXG4gICAgICAgIFxcXCImOmhvdmVyXFxcIjoge1xcbiAgICAgICAgICBcXFwiOiZiZWZvcmVcXFwiOiB7XFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBcXFwiMXB4IHNvbGlkICNjY2NcXFwiLFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBtYXJnaW46IFxcXCIwICFpbXBvcnRhbnRcXFwiLFxcbiAgICAgICAgICBib3JkZXJCb3R0b206IFxcXCIxcHggc29saWQgI2NjY1xcXCIsXFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcIiY6YWZ0ZXJcXFwiOiB7XFxuICAgICAgICAgIGJvcmRlckJvdHRvbTogXFxcIjFweCBzb2xpZCAjY2NjXFxcIixcXG4gICAgICAgIH0sXFxuICAgICAgfSxcXG4gICAgfSxcXG4gIH0sXFxufSk7XFxuYGBgXFxuXFxuLSDrtojtlYTsmpTtlZwgb3ZlcnJpZGUgdGhlbWUg6rCd7LK066W8IOyCreygnO2VmOyXrCDtlbTqsrDtlojsirXri4jri6QuXFxuXFxuIyMjIDMuIFdhcm5pbmc6IFJlY2VpdmVkIGBmYWxzZWAgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGBkaXNwbGF5YC5cXG5cXG4+IOydtCB3YXJuaW5n7J2AIHN0eWxlZCBjb21wb25lbnTsl5DshJwg7J6Q7KO8IOuwnOyDne2VmOuKlCDsmKTrpZjsnbTri6QuIGh0bWwsY3NzIGVsZW1lbnQg7IaN7ISxIOykkeyXkOyEnCBub24tYm9vbGVhbiBhdHRyaWJ1dGVz7JeQIGJvb2xlYW7sho3shLHsnYQg64SY6rKo7KSY7IScIOuwnOyDne2VmOuKlCDsmKTrpZjsnbjrjbAsIOyYiOulvCDrk6TrqbQgaW1nIO2DnOq3uOydmCBzcmPsl5Agc3RyaW5n7YOA7J6F7J20IOyZgOyVvCDrp57sp4Drp4wgYm9vbGVhbuydtOuCmCDsiKvsnpDrpbwg64Sj64qUIOqyveyasCDrsJzsg53tlaAg7IiYIOyeiOuLpC5cXG4+IO2YhOyerCDtg4DsnbTti4Ag66mU7Iuc7KeA64qUIGJvb2xlYW7qsJLsnbQg7JWE64uMIGRpc3BsYXnsl5AgdHJ1ZS9mYWxzZSDrk7HsnZggYm9vbGVhbuydhCDrhKPsl4jri6Tqs6Ag7ZW07IScIOyXkOufrOuplOyLnOyngOulvCDrv5zqs6Ag7J6I64qUIOqyg+ydtOuLpC4gXFxuPiDssLjqs6AuXFxuPiBbaHR0cHM6Ly9teWd1bWkudGlzdG9yeS5jb20vMzgyXShodHRwczovL215Z3VtaS50aXN0b3J5LmNvbS8zODIpXFxuXFxuSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggZGlzcGxheT17Y29uZGl0aW9uICYmIHZhbHVlfSwgcGFzcyBkaXNwbGF5PXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC5cXG5cXG7ihpIgZGlzcGxheeulvCDsobDqsbTrtoDroZwg67OA6rK97ZWY6rOgIOyLtuuLpOuptCAmJiDsl7DsgrDsnpDrpbwg7IKs7Jqp7ZWY6riw67O064uk64qUIOyCvO2VreyXsOyCsOyekOulvCDsgqzsmqntlaAg6rKD7J2EIOq2jOyepe2VmOqzoCDsnojri6QuXFxuXFxu7ZWY7KeA66eMIOuqqOuToCBzdHlsZWTsu7Ttj6zrhIztirjsnZggZGlzcGxheeulvCDsgrTtjrTrtKTripTrjbAg66qo65OgIOqzs+yXkOyEnCBkaXNwbGF5IOyGjeyEseyXkCDsgrztla3sl7DsgrDsnpDroZwg7KCc64yA66GcIOyEpOygleydtCDrkJjslrTsnojsl4jsirXri4jri6QuXFxuXFxuIVvrrZDsp4A/IO2KuOumreyduOqwgD9dKGh0dHBzOi8vZDNreHM2a3BiaDU5aHAuY2xvdWRmcm9udC5uZXQvY29tbXVuaXR5L0NPTU1VTklUWS81OTgwNjBmMmFjMTg0M2IxYmE4OTc5ZjRlZDI5MmRlMi9hYmQ5ZjQ5Y2RmNzI0ODVhOGQ1Y2I4OTJiY2U4NTkzN18xNjE3MTAxNTUxLmpwZylcXG5cXG7rrZDsp4A/IO2KuOumreyduOqwgD9cXG5cXG7rrLjsoJwg7JuQ7J247J2AIEJhbm5lciDsu7Ttj6zrhIztirjsnZggZGlzcGxheSDsho3shLEg7J207JeI7Iq164uI64ukLiDsgrztla3sl7DsgrDsnpDqsIAg7ZW06rKw7J2YIO2CpOuKlCDslYTri4jsl4jrjZgg6rKD7J207KOgLlxcblxcbmBgYHRzeFxcbjxCYW5uZXJcXG4gIG9uQ2xvc2U9eygpID0+IHtcXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dCYW5uZXI6IGZhbHNlIH0pO1xcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2hvd0Jhbm5lcicsICdmYWxzZScpO1xcbiAgfX1cXG4gIGRpc3BsYXk9e3RoaXMuc3RhdGUuc2hvd0Jhbm5lciF9XFxuICBocmVmPVxcXCIvbXlQYWdlL2luZm9ybWF0aW9uXFxcIlxcbiAgYnV0dG9uQ29udGVudD1cXFwi6rKw7KCcIOyImOuLqCDrs4Dqsr3tlZjquLBcXFwiXFxuICBpY29uPXs8RXJyb3JPdXRsaW5lIC8+fVxcbiAgY29udGVudD17YOygleq4sOq1rOuPhSDsnpDrj5nqsrDsoJzqsIAg7Iuk7Yyo7ZaI7Iq164uI64ukLiDqsrDsoJwg7IiY64uo7J2EIOuzgOqyvSDrtoDtg4Hrk5zrpr3ri4jri6QhIFxcbiAg6rKw7KCc7IiY64uoIOuzgOqyvSDsoITquYzsp4Ag7IOIIO2UhOuhnOygne2KuOulvCDsi5zsnpHtlaAg7IiYIOyXhuycvOupsCAke21vbWVudChBcHAuc2Vzc2lvbi5wbGFuX2ZpbmlzaGVkX2F0KS5hZGQoOCwgJ2RheXMnKS5mb3JtYXQoJ1lZWVktTU0tREQnKX0gMjM6NTk6NTkg6rmM7KeAIOyLpO2MqCDsi5wg7J6Q64+Z7Jy866GcIO2UjOuenOydtCDtlbTsp4DrkKnri4jri6QuYH0gLz5cXG5gYGBcXG5cXG4tIOychCDrsLDrhIgg7Lu07Y+s64SM7Yq464qUIHNob3dCYW5uZXIgc3RhdGXqsJLsl5Ag65Sw65287IScIGRpc3BsYXnrpbwg7ZWY64qQ64OQIOuniOuKkOuDkOqwgCDqsrDsoJXrkKnri4jri6QuXFxuLSDslYTrp4jrj4Qg7J20IOy7tO2PrOuEjO2KuOulvCDsp5zsi6Ag67aE6ruY7IScIO2VtOuLuSBwcm9wc+yXkCDrlLDrnbzshJwgY3Nz7J2YIGRpc3BsYXnsho3shLHsnYQg67OA6rK97ZWY66+A66GcIOq3uOuMgOuhnCBkaXNwbGF5IGF0dHJpYnV0ZXPrpbwg7IKs7Jqp7ZWY7IWo642YIOqygyDqsJnsirXri4jri6QuIO2VmOyngOunjCBkaXNwbGF5652864qUIOuPmeydvO2VnCDsnbTrpoTsnZggYXR0cmlidXRlc+qwgCDsnojslrTshJwg7J20IOu2gOu2hOyXkOyEnCDsl5Drn6zrpbwg67Cc7IOd7Iuc7YKk64qUIOusuOygnOqwgCDsnojsl4jsirXri4jri6QuIGRpc3BsYXnripQg67aI66as7Ja4IO2DgOyeheydtCDslYTri4jquLAg65WM66y47J207KOgLlxcbi0g7J20IOy9lOuTnOulvCBkaXNwbGF5PXt+fSDih5Igc2hvdz17fn3roZwgYXR0cmlidXRlc+ydmCDsnbTrpoTsnYQg67OA6rK97ZW07KO87Ja0IO2VtOqysO2WiOyKteuLiOuLpC4gKOyggeycvOuptOyEnCDri6Tsi5wg7IOd6rCB7ZW067O064uIIGlzU2hvd+uhnCDsnbTrpoTsnYQg7KeA7J2E6rG4IO2VmOuKlCDtm4TtmozqsIAg7IK07KedIOuQmOuEpOyalClcXG5cXG4jIyMgNC4gZWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUga2V5IHByb3BcXG5cXG7snbQg7JeQ65+s64qUIOumrOyVoe2KuOyXkOyEnCDsg4Hri7ntnogg7J6Q7KO8IOuCmOyYpOuKlCDsl5Drn6zroZwgbWFwIOuwmOuzteusuOycvOuhnCByZW5kZXLtlaAg6rK97JqwIO2VtOuLuSBlbGVtZW507JeQIOqzoOycoO2VnCBrZXnqsJLsnYQg64Sj7Ja064us652864qUIOucu+ydtOuLiCDrhKPslrTso7zslrQg7ZW06rKw7ZWgIOyImCDsnojsirXri4jri6QuXFxuXFxuIyMjIDUuIGluZGV4LmpzOjE0MjAgV2FybmluZzogQnVpbGRpdElucHV0IGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgdGV4dCB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy5cXG5cXG5odG1sIGBpbnB1dGAg7YOc6re47J2YIGRlZmF1bHRWYWx1ZeuKlCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZCDtg4DsnoXsnoXri4jri6QuIO2VmOyngOunjCBkZWZhdWx0VmFsdWXqsIAgcHJvcHProZwg64K066Ck7Jik7KeAIOyViuuKlCDqsr3smrAg4oCc4oCd66GcIOu5iCDsiqTtirjrp4HsnYQg64Sj64+E66GdIO2VmOyYgOuKlOuNsCDsnbQg6rK97Jqw7JeQ64qUIOyYpO2eiOugpCB1bmRlZmluZWTroZwg7ISg7Ja47ZWY64qUIOqyg+ydtCDrjZQg7KCB7KCI7ZWp64uI64ukLiDrlLDrnbzshJwgdW5kZWZpbmVk66GcIOyImOygle2VmOyXrCDtlbTqsrDtlojsirXri4jri6QuXFxuXFxuIVtCVUlMRElULWVycm9yMl0oL2Fzc2V0cy9pbWcvQlVJTERJVC1lcnJvcjIucG5nKVxcblxcbi0g4oCc4oCdIOuMgOyLoCB1bmRlZmluZWTroZwg7YOA7J6F7Iqk7YGs66a97Yq4IO2DgOyehSDsmKTrpZjrpbwg7KCc6rGw7ZWY7JiA7Iq164uI64ukLlxcblxcbiMjIyA2LiAqKldhcm5pbmc6IFJlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgWFhYIHByb3Agb24gYSBET00gZWxlbWVudCoqXFxuXFxuIVtCVUlMRElULWVycm9yM10oL2Fzc2V0cy9pbWcvQlVJTERJVC1lcnJvcjMucG5nKVxcblxcbj4g7LC46rOgOiBcXG4+ICoqW0hvdyB0byBzb2x2ZSBXYXJuaW5nOiBSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIFggcHJvcCBvbiBhIERPTSBlbGVtZW50XShodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDQ2ODUzNS9ob3ctdG8tc29sdmUtd2FybmluZy1yZWFjdC1kb2VzLW5vdC1yZWNvZ25pemUtdGhlLXgtcHJvcC1vbi1hLWRvbS1lbGVtZW50KSoqIFxcbj4gW2h0dHBzOi8va28ucmVhY3Rqcy5vcmcvd2FybmluZ3MvdW5rbm93bi1wcm9wLmh0bWxdKGh0dHBzOi8va28ucmVhY3Rqcy5vcmcvd2FybmluZ3MvdW5rbm93bi1wcm9wLmh0bWwpXFxuXFxu7Jis67CU66W4IERPTSDslrTtirjrpqzrt7Dtirgv7ZSE66Gc7Y287Yuw66GcIOyduOyLneuQmOyngCDslYrripQgRE9NIOyXmOumrOuovO2KuOulvCDroIzrjZTrp4HtlZjroKTqs6Ag7ZWY66m0IHVua25vd24tcHJvcCDqsr3qs6DqsIAg67Cc7IOd7ZWp64uI64ukLiBET00g7JeY66as66i87Yq47JeQIOyemOuqu+uQnCBwcm9wc+qwgCDstpTqsIDrkJjsp4Ag7JWK64+E66GdIO2VtOyVvCDtlanri4jri6QuIO2VmOyngOunjCBib3JkZXJSYWRpdXMsIGp1c3RpZnlDb250ZW507JmAIOqwmeydgCDsvZTrk5zqsIAg7J6I7Jy866m0IOumrOyVoe2KuOyXkOyEnCDsnbTrn7Ag7JeQ65+s66W8IOuCtOuxieyKteuLiOuLpC4g65Sw65287IScIOuLpOydjOqzvCDqsJnsnbQgKGJvcmRlcnJhZGl1cywganVzdGlmeWNvbnRlbnQpIOyGjOusuOyekOuhnCDrs4Dqsr3tlbTso7zrqbQg7ZW06rKw7ZWgIOyImCDsnojsirXri4jri6QuXFxuXFxuIyMgV2FybmluZyDtlbTqsrBcXG5cXG4jIyMgMS4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcywgY29tcG9uZW50V2lsbG1vdW50IOudvOydtO2UhOyCrOydtO2BtCDrs4Dqsr3tlZjquLBcXG5cXG5gYGB0c3hcXG5XYXJuaW5nOiBjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLlxcblxcbldhcm5pbmc6IGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlXFxuYGBgXFxuXFxuLSDsnbTsoITsl5Drj4Qg67Sk642YIOqyveqzoCDrqZTsi5zsp4DsnoXri4jri6QuIGNvbXBvbmVudFdpbGxtb3VudCwgY29tcG9uZW50V2lsbFJlY2lldmVQcm9wc+qwmeydgCDrnbzsnbTtlITsgqzsnbTtgbTsnYAg64uk7J2M67KE7KCE7J2YIOumrOyVoe2KuOyXkOyEnOuKlCDrjZQg7J207IOBIOyTsOydtOyngCDslYrsnLzri4gg67OA6rK97ZW064us652864qUIOuCtOyaqeyeheuLiOuLpC5cXG5cXG4tIGBucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIOuqheugueyWtOuhnCDrqqjrkZAgVU5TQUZFXyBwcmVmaXjrpbwg7JWe7JeQIOuLrOyVhOykrOyKteuLiOuLpC4g7ZWY7KeA66eMIOyViO2DgOq5neqyjCDqt7jrn7zsl5Drj4Qg67aI6rWs7ZWY6rOgIOydtCDrqZTsi5zsp4DqsIAg6rOE7IaNIOucqOqzoCDsnojsirXri4jri6QuXFxuXFxuLSBbaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg3Njk3NTIvY29tcG9uZW50d2lsbG1vdW50LXdhcm5pbmdzLXZpc2libGUtZXZlbi10aG91Z2gtY29tcG9uZW50d2lsbG1vdW50LWlzLW5vdC1leF0oaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg3Njk3NTIvY29tcG9uZW50d2lsbG1vdW50LXdhcm5pbmdzLXZpc2libGUtZXZlbi10aG91Z2gtY29tcG9uZW50d2lsbG1vdW50LWlzLW5vdC1leClcXG5cXG4gIC0g7Jes6riwIOuLteuzgOydhCDsgrTtjrTrs7TrqbQgWW91J3JlIGdldHRpbmcgdGhpcyB3YXJuaW5nIGJlY2F1c2XCoGBjb21wb25lbnRXaWxsTW91bnRgXFxuICAgIGlzIGRlcHJlY2F0ZWQgaW4gbmV3ZXIgUmVhY3QgdmVyc2lvbnMuIElmIHlvdSdyZSBub3QgdXNpbmfCoGBjb21wb25lbnRXaWxsTW91bnRgXFxuICAgIMKgYW55d2hlcmUgdGhlbiBvbmUgb2YgeW91ciBsaWJyYXJpZXMgaXMgYW5kIGl0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuXFxuXFxuICAgICDspoksIO2UhOuhnOygne2KuCDrgrTrtoAg7L2U65Oc6rCAIOyVhOuLjCDri6Trpbgg65287J2067iM65+s66as7J2YIOyYiOyghCDrsoTsoITsl5DshJwg7J20IGhvb2vrk6TsnYQg7IKs7Jqp7ZWY6rOgIOyeiOq4sCDrlYzrrLjsl5Ag67Cc7IOd7ZWY64qUIOuplOyLnOyngOudvOuKlCDrgrTsmqnsnbTrhKTsmpQuIOq3uOuemOyEnCDtlbTri7kg65287J2067iM65+s66as7J2YIOuyhOyghOydhCDqsJnsnbQg7Jis66Ck7IScIO2VtOqysO2VoCDsiJgg7J6I64uk6rOgIO2VqeuLiOuLpC5cXG5cXG4gICAgIOyWtOuWpCDrnbzsnbTruIzrn6zrpqzsnbjsp4Drj4Qg66qo66W06rOgLCDtlbTri7kg65287J2067iM65+s66asIOuyhOyghOydhCDsmKzroLjri6TqsIAg7Lap64+M7J20IOuCoCDsiJjrj4Qg7J6I7Ja0IOydtCB3YXJuaW5nIOuplOyLnOyngOuKlCDqt7jrjIDroZwg65GQ64qU6rKMIOyii+qyoOyKteuLiOuLpC5cXG5cXG4jIyMgMi4gcmVhY3QuZGV2ZWxvcG1lbnQuanM6MjE3IFdhcm5pbmc6IFJlYWN0LmNyZWF0ZUZhY3RvcnkoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYIG9yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC5cXG5cXG4tIOydtCDsl5Drn6zrqZTsi5zsp4Drj4Qg7JyE7J2YIDHrsojqs7wg67mE7Iq37ZWcIO2YhOyDgeuVjOusuOyXkCDrsJzsg53tlZjripQg6rKD7Jy866GcIO2MjOyVheuQqeuLiOuLpC4g7ZiEIOy9lOuTnOyXkOyEnCBSZWFjdC5jcmVhdGVGYWN0b3J5KCkg652864qUIOy9lOuTnOulvCDsgqzsmqntlZjripQg6rOz7J20IOyXhuuKlOuNsCDsnbQg6riw64ql7J20IOqzpyDsgqzrnbzsp4Dri4jquYwg67CU6r64652864qUIOqxuOuhnCDrtJDshJzripQg65287J2067iM65+s66asIOuCtOyXkOyEnCDtmZzsmqntlZjqs6Ag7J6I64qUIOqyg+ycvOuhnCDrs7wg7IiYIOyeiOqyoOyKteuLiOuLpC5cXG5cXG4jIyMgMy4gbWFwcy5qcz9uY3BDbGllbnRJZD1uaHRod2RqYnptJnN1Ym1vZHVsZXM9Z2VvY29kZXIsZHJhd2luZyxzdHlsZW1hcDoxNSBBIHBhcnNlci1ibG9ja2luZywgY3Jvc3Mgc2l0ZSAoaS5lLiBkaWZmZXJlbnQgZVRMRCsxKSBzY3JpcHQsIFtodHRwczovL29wZW5hcGkubWFwLm5hdmVyLmNvbS9vcGVuYXBpL3YzL21hcHMtZ2VvY29kZXIuanNdKGh0dHBzOi8vb3BlbmFwaS5tYXAubmF2ZXIuY29tL29wZW5hcGkvdjMvbWFwcy1nZW9jb2Rlci5qcyksIGlzIGludm9rZWQgdmlhIGRvY3VtZW50LndyaXRlLiBUaGUgbmV0d29yayByZXF1ZXN0IGZvciB0aGlzIHNjcmlwdCBNQVkgYmUgYmxvY2tlZCBieSB0aGUgYnJvd3NlciBpbiB0aGlzIG9yIGEgZnV0dXJlIHBhZ2UgbG9hZCBkdWUgdG8gcG9vciBuZXR3b3JrIGNvbm5lY3Rpdml0eS4gSWYgYmxvY2tlZCBpbiB0aGlzIHBhZ2UgbG9hZCwgaXQgd2lsbCBiZSBjb25maXJtZWQgaW4gYSBzdWJzZXF1ZW50IGNvbnNvbGUgbWVzc2FnZS4gU2VlIFtodHRwczovL3d3dy5jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNTcxODU0Nzk0Njc5OTEwNF0oaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzU3MTg1NDc5NDY3OTkxMDQpIGZvciBtb3JlIGRldGFpbHMuXFxuXFxuLSDsnbQg7J207IqI64qUIOuEpOydtOuyhCDrv5Drp4wg7JWE64uI6528IOy5tOy5tOyYpCDsp4Drj4Qg66Gc65OcIOyLnOyXkOuPhCDrsJzsg53tlZjripQg66y47KCc7J24IOqygyDqsJnsnYDrjbAsIOyaqeufieydtCDtgbAg65287J2067iM65+s66as66W8IOuhnOuTnO2VoCDrlYwg6re4IOudvOydtOu4jOufrOumrCDrgrTsl5AgZG9jdW1lbnQud3JpdGXsnbQg65Ok7Ja07J6I7Jy866m0IOuCmOuouOyngCBodG1sIHBhcnNpbmfsnbTrgpggSlPrpbwgYmxvY2vtlZjsl6wg7Z2w7ZmU66m07J20IOyYpOuemCDrgpjsmKwg7IiYIOyeiOyKteuLiOuLpC4g7J2065+s66m0IOyCrOyaqeyekOuKlCDsmKTrpZjrnbzqs6Ag64qQ64KEIOyImCDsnojripTrjbDsmpQg7Yq57Z6I64KYIOuKkOumsCDrhKTtirjsm4ztgawg7ZmY6rK97JeQ7ISc64qUIOygleuPhOqwgCDrjZQg7Ius7ZWgIOqyg+yeheuLiOuLpC4g65WM66y47JeQIO2BrOuhrOyXkOyEnCDso7zsnZjtlZjrnbzqs6Ag7JWM66Ck7KO864qUIOuCtOyaqeyeheuLiOuLpC5cXG5cXG4tIFtodHRwczovL2dpdGh1Yi5jb20vbmF2ZXJtYXBzL21hcHMuanMvaXNzdWVzLzI5OF0oaHR0cHM6Ly9naXRodWIuY29tL25hdmVybWFwcy9tYXBzLmpzL2lzc3Vlcy8yOTgpIOyXkOuKlCDrhKTsnbTrsoTsl5DshJwg64u167OA7ZWcIOuCtOyaqeydtCDsnojripTrjbAg7ZW06rKw7JeQIOuPhOybgOydtCDrkJjsp4Ag7JWK7Iq164uI64ukLlxcblxcbi0gW2h0dHBzOi8vZGV2dGFsay5rYWthby5jb20vdC90b3BpYy81Mzc2M10oaHR0cHM6Ly9kZXZ0YWxrLmtha2FvLmNvbS90L3RvcGljLzUzNzYzKSDsl5Ag7J6I64qUIOy5tOy5tOyYpOydmCDri7Xrs4Dsl5Ag65Sw66W066m0IOyngOuPhOqwgCDrnKzri6TrqbQg6re464ulIO2BsCDrrLjsoJzripQg7JWE64uI64uIIOustOyLnO2VtOuPhCDqtJzssK7ri6Tqs6Ag7ZWp64uI64ukLiDsubTsubTsmKTqsIAg7KeB7KCRIOustOyLnO2VtOuPhCDrkJzri6Tqs6Ag7ZWY64uIIOyigCDslYjsi6woPynsnbQg65CY6ri0IO2VmOuEpOyalC4g7JWE66y07Yq8IOydtCB3YXJuaW5n64+EIOustOyLnO2VmOqzoCDrhJjslrTqsJHri4jri6QuXFxuXFxuICAhW0JVSUxESVQtZXJyb3I0XSgvYXNzZXRzL2ltZy9CVUlMRElULWVycm9yNC5wbmcpXFxuXFxuIyMg6rKw6rO8XFxuXFxuIVtCVUlMRElULWVycm9yNV0oL2Fzc2V0cy9pbWcvQlVJTERJVC1lcnJvcjUucG5nKVxcblxcbuy9mOyGlOywveydtCDsmYTsoITtnogg6rmo64GX7ZW07KeA7KeA64qUIOyViuyVmOyngOunjCDqt7jrnpjrj4Qg7ZWcIO2OmOydtOyngCDrgrTroZwg7KSE7Ja065Ok7JeI7Iq164uI64ukLlxcblxcbuydtOygnCDsiqTsiqTroZwg7ZW06rKw7ZWgIOyImOuKlCDsl4bqsbDrgpgg66y07Iuc7ZW064+EIOuQmOuKlCDrqZTsi5zsp4Drk6Tqs7wg64K067aAIEFQSSDsmKTrpZjrp4wg64Ko7JWY64Sk7JqULiDrqqjrk6Ag7Y6Y7J207KeA66W8IOu4jOujqO2KuO2PrOyKpO2VmOqyjCDtg5Dsg4ntlZjsp4DripQg7JWK7JWY6riwIOuVjOusuOyXkCDri6Trpbgg65287Jqw7Yq465Ok7J2EIOuPjOyVhOuLpOuLiOupsCDtmZXsnbjtlbTrs7Tqs6Ag7LKY7J2MIOuztOuKlCDsmKTrpZjrqZTsi5zsp4DsnbTrqbQg7LaU6rCA7ZWY64+E66GdIO2VmOqyoOyKteuLiOuLpPCfmY9cXG5cXG5cXG5cXG5cXG5cXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcbnRpdGxlOiBcXFwiSmVzdOuhnCDrpqzslaHtirjsl5DshJwg7Jyg64ubIO2FjOyKpO2KuCDtlZjquLBcXFwiXFxuZGF0ZTogXFxcIjIwMjIuMDcuMDhcXFwiXFxudGFnczpcXG4gIC0gamF2YXNjcmlwdFxcbiAgLSB0ZXN0XFxuICAtIGplc3RcXG4gIC0gdGRkXFxuLS0tXFxuXFxuIyBSZWFjdCBUZXN0ICgxKSBVbml0IHRlc3RcXG5cXG4jIyBUZXN0IO2ZmOqyvSDshKTsoJUgLSBKRVNUXFxuXFxuYENSQWDrpbwg7ZWY66m0IOyekOuPmeycvOuhnCDshKTsuZjtlbTso7zripQgamVzdOuhnCDsi5zsnpHtlbTrs7TsnpAuIGplc3TripQgamFzbWluZSDquLDrsJgg7YWM7Iqk7YyF65287J2067iM65+s66as7J2064ukLiBcXG5cXG7snbQg7Jm47JeQ64+EIG1vY2hhLCBLYXJtYSDrk7Eg64uk7JaR7ZWcIFvthYzsiqTtjIUg65287J2067iM65+s66as6rCEIOu5hOq1kF0oaHR0cHM6Ly9tZWRpdW0uY29tL3dlbGxkb25lLXNvZnR3YXJlL2FuLW92ZXJ2aWV3LW9mLWphdmFzY3JpcHQtdGVzdGluZy1pbi0yMDE5LTI2NGUxOTUxNGQwYSkg6riA7J2EIOydveqzoCDsi7bsnLzrqbQg66eB7YGs66W8IO2BtOumre2VtOuztOyekC5cXG5cXG5cXG5cXG5DUkHroZwg66eM65OgIHJlYWN0IO2UhOuhnOygne2KuOyXkOyEnCBqZXN066W8IO2FjOyKpO2KuCDtlbTrs7wg7JiI7KCV7J2064ukLiDqt4DssK7snLzrqbQg7J2066+4IO2VtOuGk+ydgCDslYTrnpgg7ZSE66Gc7KCd7Yq466W8IO2BtOuhoO2VmOuptOyEnCDrlLDrnbztlbTrs7TsnpAuXFxuXFxuYGBgYmFzaFxcbiQgZ2l0IGNsb25lIGh0dHBzOi8vZ2l0aHViLmNvbS9saWtlbGlvblN1bmdHdWsvdG9kb2xpc3RSVEt0eXBlc2NyaXB0LmdpdFxcbmBgYFxcblxcblxcblxcbiMjIDpvbmU6IE1hdGNoZXJzXFxuXFxuIyMjIDEuIHRvQmVcXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gZm4uanNcXG5leHBvcnQgY29uc3QgZm4gPSB7XFxuICBhZGQ6IChudW0xLCBudW0yKSA9PiBudW0xICsgbnVtMixcXG4gIG1ha2VVc2VyOiAobmFtZSwgYWdlKT0+ICh7XFxuICAgIG5hbWUsXFxuICAgIGFnZVxcbiAgfSlcXG59XFxuYGBgXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIGZuLnRlc3QuanNcXG5cXG50ZXN0KCdhICsgYiA9JywgKCk9PiB7XFxuICAvLyBmbi5hZGQoMSwgMinrpbwg7ZWY66m0IDPsnbQg65Cg6rGw6528IOq4sOuMgO2VnOuLpC5cXG4gIGV4cGVjdChmbi5hZGQoMSwgMikpLnRvQmUoMylcXG59KVxcbmBgYFxcblxcbuychCDsspjrn7wgdGVzdOydmCDssqvrsojsp7gg7J247J6Q64qUIO2ZlOuptOyXkCDtkZzsi5zrkKAg7YWN7Iqk7Yq466W8IOuEo+yWtOyjvOuptCDrkJzri6QuIOuRkCDrsojsp7gg7J247J6Q7JeQ64qUIOy9nOuwse2VqOyImOulvCDsl7TslrTso7zqs6Ag6re4IOyViOyXkOyEnCBleHBlY3QoKS5gbWF0Y2hlcnNgIO2YleyLneycvOuhnCDsjajspIDri6QuIOyXrOq4sOyEnCDsgrTtjrTrs7wgYHRvQmVgIG1hdGNoZXLripQgZXhwZWN064K067aA7J2YIOqwkuydtCDrgpjtg4Drgrwg6riw64yA6rCS7J2EIOydmOuvuO2VnOuLpC4g6rKw6rO86rCAIHRvQmXrgrTrtoDsmYAg6rCZ64uk66m0IHRydWXroZwg7YWM7Iqk7Yq466W8IO2GteqzvO2VnOuLpC5cXG5cXG5cXG5cXG46YnVsYjog6rCE64uoIFRpcCFcXG5cXG4+ICDqsIDsnqUg7LKY7J2M7JeQIOyTsOuKlCBgdGVzdGDripQgYGl0YOycvOuhnCDsjajrj4Qg65iR6rCZ7J20IOuPmeyeke2VnOuLpC4g7JiB7Ja0IOusuOyepeyXkOyEnCBgaXRg7Jy866GcIOyTsOuptCDtlZjrgpjsnZgg7JmE6rKw65CcIOusuOyepeydhCDrp4zrk6TquLAg7Im96riwIOuVjOusuOyXkCBpdOycvOuhnOuPhCDsk7DripQg6rK97Zal7J20IOyeiOuLpOqzoCDtlZzri6QuIOuRmCDspJEg7Leo7Zal7JeQIOuUsOudvCDqs6jrnbwg7JOw7J6QIVxcblxcblxcblxcbiMjIyAyLiB0b0VxdWFsIC8gdG9TdHJpY3RFcXVhbFxcblxcbmBgYGphdmFzY3JpcHRcXG50ZXN0KCdtYWtlIHVzZXI6IOydtOumhOqzvCDrgpjsnbTrpbwg7KCE64us67Cb7JWE7IScIOqwneyytOulvCDrsJjtmZgnLCAoKT0+e1xcbiAgZXhwZWN0KGZuLm1ha2VVc2VyKFxcXCJNaWtlXFxcIiwgMjUpKS50b0VxdWFsKHtcXG4gIC8vIGV4cGVjdChmbi5tYWtlVXNlcihcXFwiTWlrZVxcXCIsIDI1KSkudG9CZSh7IC8vIFhcXG4gICAgbmFtZTogXFxcIk1pa2VcXFwiLFxcbiAgICBhZ2U6IDI1XFxuICB9KVxcbn0pXFxuYGBgXFxuXFxu7J2066CH6rKMIOqwneyytOulvCDrp4zrk5zripQg6rK97Jqw7JeQ64qUIHRvQmXrpbwg7JOw66m0IGZhbHNl6rCAIOuCmOyYqOuLpC4gYOqwneyytOuKlCBkZXB0aOqwgCDquYrsnYQg7IiYIOyeiOq4sCDrlYzrrLjsl5BgIOyerOq3gOyggeycvOuhnCDtg4Dqs6Ag65Ok7Ja06rCA64qUIGB0b0VxdWFsL3RvU3RyaWN0RXF1YWxg7J2EIHRvQmXrjIDsi6Ag7I2o7KSY7JW8IO2VnOuLpC5cXG5cXG5cXG5cXG4jIyMgMy4g6riw7YOAIGplc3QgbWF0Y2hlcuuTpFxcblxcbuychCDrkZAg6rCA7KeAIOyZuOyXkOuPhCDri6TslpHtlZwgbWF0Y2hlcuuTpOydtCDsnojri6QuIO2ZnOyaqeuyleuTpOydhCDtlZwg67KIIOytiSDsgrTtjrTrs7TripQg6rKD7J20IOyii+yngOunjCDsnbQg6riA7JeQ7ISc64qUIOyGjOqwnOunjCDtlZjqs6Ag64SY7Ja06rCE64ukLlxcblxcbjEuIEJvb2xlYW4gXFxuXFxuICAgIC0gdG9CZU51bGxcXG5cXG4gICAgLSB0b0JlVW5kZWZpbmVkXFxuXFxuICAgIC0gdG9CZURlZmluZWRcXG5cXG5cXG4yLiBGYWxzeS9UcnV0aHlcXG5cXG4gICAgLSB0b0JlRmFsc3lcXG5cXG4gICAgLSB0b0JlVHJ1dGh5XFxuXFxuXFxuMy4g64yA7IaM67mE6rWQXFxuXFxuICAgIC0gdG9CZUdyZWF0ZXJUaGFuICjtgazri6QpXFxuXFxuICAgIC0gdG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCAo7YGs6rGw64KYIOqwmeuLpClcXG5cXG4gICAgLSB0b0JlTGVzc1RoYW5cXG5cXG4gICAgLSB0b0JlTGVzc1RoYW5PckVxdWFsXFxuXFxuXFxuNC4gZXBzaWxvbiBjaGVja1xcbiAgICAtIHRvQmVDbG9zZVRvIC8vIGV4OiBhZGQoMC4xLCAwLjIpLnRvQmVDbG9zZVRvKDAuMykgLT4gdHJ1ZSAodG9CZSgwLDMpIC0+IGZhbHNlKVxcblxcblxcblxcblxcblxcbiMjIDp0d286IERlc2NyaWJlXFxuXFxuYGRlc2NyaWJlYCDrnbzripQg7YKk7JuM65Oc66W8IOyCrOyaqe2VmOuptCDsl6zrn6wg7YWM7Iqk7Yq4IOy8gOydtOyKpOulvCDrrLbsnYQg7IiYIOyeiOyKteuLiOuLpC4gXFxuXFxuJ3N1bScg7J20652864qUIOqzte2GtSDtgqTsm4zrk5zroZwg66y27J2EIOyImCDsnojripQg7YWM7Iqk7Yq47J2YIOqyveyasCBkZXNjcmliZSDtgqTsm4zrk5zrpbwg7IKs7Jqp7ZW0IO2VmOuCmOuhnCDrrLbslrTshJwg7YWM7Iqk7Yq47ZWgIOyImCDsnojsirXri4jri6QuXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIHN1bS5qc1xcbmZ1bmN0aW9uIHN1bShhLCBiKSB7XFxuICByZXR1cm4gYSArIGI7XFxufVxcblxcbmZ1bmN0aW9uIHN1bU9mKG51bWJlcnMpIHtcXG4gIGxldCByZXN1bHQgPSAwO1xcbiAgbnVtYmVycy5mb3JFYWNoKG4gPT4ge1xcbiAgICByZXN1bHQgKz0gbjtcXG4gIH0pO1xcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuLy8g6rCB6rCBIOuCtOuztOuCtOq4sFxcbmV4cG9ydHMuc3VtID0gc3VtO1xcbmV4cG9ydHMuc3VtT2YgPSBzdW1PZjtcXG5gYGBcXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gc3VtLnRlc3QuanNcXG5jb25zdCB7IHN1bSwgc3VtT2YgfSA9IHJlcXVpcmUoJy4vc3VtJyk7XFxuXFxuZGVzY3JpYmUoJ3N1bScsICgpID0+IHtcXG4gIGl0KCdjYWxjdWxhdGVzIDEgKyAyJywgKCkgPT4ge1xcbiAgICBleHBlY3Qoc3VtKDEsIDIpKS50b0JlKDMpO1xcbiAgfSk7XFxuXFxuICBpdCgnY2FsY3VsYXRlcyBhbGwgbnVtYmVycycsICgpID0+IHtcXG4gICAgY29uc3QgYXJyYXkgPSBbMSwgMiwgMywgNCwgNV07XFxuICAgIGV4cGVjdChzdW1PZihhcnJheSkpLnRvQmUoMTUpO1xcbiAgfSk7XFxufSk7XFxuYGBgXFxuXFxuIVtkZXNjcmliZeuhnCDthYzsiqTtirjtlZjrqbQg7ZWY64KY66GcIOustuyWtOykgOuLpC5dKGh0dHBzOi8vaS5pbWd1ci5jb20vQ1AxSjc3UC5wbmcpXFxuXFxuXFxuXFxuIyMjIHN1bU9mIO2VqOyImCDrpqztjKnthqDrp4HtlbTshJwg7YWM7Iqk7Yq47L2U65Oc7J2YIOynhOyImCDrp5vrs7TquLBcXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gc3VtLmpzXFxuZnVuY3Rpb24gc3VtKGEsIGIpIHtcXG4gIHJldHVybiBhICsgYjtcXG59XFxuXFxuZnVuY3Rpb24gc3VtT2YobnVtYmVycykge1xcbiAgcmV0dXJuIG51bWJlcnMucmVkdWNlKChhY2MsIGN1cnJlbnQpID0+IGFjYyArIGN1cnJlbnQsIDApO1xcbn1cXG5cXG4vLyDqsIHqsIEg64K067O064K06riwXFxuZXhwb3J0cy5zdW0gPSBzdW07XFxuZXhwb3J0cy5zdW1PZiA9IHN1bU9mO1xcbmBgYFxcblxcbuychOyZgCDqsJnsnbQgcmVkdWNl66W8IOyCrOyaqe2VtOyEnCBzdW1PZuulvCDrpqztjKnthqDrp4HtlZwg7ZuEIOq3uOuMgOuhnCDthYzsiqTtirjrpbwg64+M66as66m0IO2GteqzvO2VnOuLpC4g7J2066CH6rKMIOy9lOuTnOulvCDrpqztjKnthqDrp4HtlbTrj4Qg7YWM7Iqk7Yq46rCAIOyeiOuLpOuptCDtkojsp4jsnYQg67O07J6l7ZWgIOyImCDsnojri6TripQg6rKD7J20IOyepeygkOydtOuLpC5cXG5cXG5cXG5cXG5cXG5cXG4jIyA6dGhyZWU6IOu5hOuPmeq4sCDtlajsiJjsnZgg6rK97JqwIOyWtOuWu+qyjCDthYzsiqTtirjrpbwg7ZWgIOyImCDsnojsnYTquYw/XFxuXFxuIyMjIDEuIGRvbmUoKSBcXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gZm4uanNcXG5leHBvcnQgY29uc3QgZm4gPSB7XFxuICAuLi4sXFxuICBnZXROYW1lOiAoY2FsbGJhY2spID0+IHtcXG4gICAgY29uc3QgbmFtZSA9IFxcXCJNaWtlXFxcIjtcXG4gICAgc2V0VGltZW91dCgoKT0+IHtcXG4gICAgICBjYWxsYmFjayhuYW1lKVxcbiAgICB9LCAzMDAwKTtcXG4gIH1cXG59XFxuYGBgXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIGZuLnRlc3QuanNcXG5pdCgnbmFtZSBpcyBNaWtlJywgKGRvbmUpID0+IHtcXG4gIGZuLmdldE5hbWUoKG5hbWUpID0+IHtcXG4gICAgZXhwZWN0KG5hbWUpLnRvQmUoXFxcIk1pa2VcXFwiKTtcXG4gICAgZG9uZSgpO1xcbiAgfSk7XFxufSlcXG5gYGBcXG5cXG7sl6zquLDshJwgZG9uZeydhCDsk7Dsp4Ag7JWK7Jy866m0IOyWtOuWu+qyjCDrkKDquYw/XFxuXFxuYGBgYmFzaFxcblBBU1MgIHNyYy9jb21wb25lbnRzL19fdGVzdHNfXy9mbi50ZXN0LmpzXFxuUEFTUyAgc3JjL2NvbXBvbmVudHMvX190ZXN0c19fL1RvZG9MaXN0LnRlc3QuanNcXG5cXG5UZXN0IFN1aXRlczogMiBwYXNzZWQsIDIgdG90YWxcXG5UZXN0czogICAgICAgNSBwYXNzZWQsIDUgdG90YWxcXG5TbmFwc2hvdHM6ICAgMSBwYXNzZWQsIDEgdG90YWxcXG5UaW1lOiAgICAgICAgMi43MTUgc1xcblxcblJhbiBhbGwgdGVzdCBzdWl0ZXMgcmVsYXRlZCB0byBjaGFuZ2VkIGZpbGVzLlxcblxcbldhdGNoIFVzYWdlOiBQcmVzcyB3IHRvIHNob3cgbW9yZS5cXG5cXG5gYGBcXG5cXG5zZXRUaW1lb3V07J2EIDMwMDBtcyDroZwg7KSs64qU642w64+EIOu2iOq1rO2VmOqzoCAyLjcxNXMg66eM7JeQIO2FjOyKpO2KuOqwgCDrgZ3rgpjrsoTroLjri6QuIOqysOqzvOuKlCDqt7jrg6UgUEFTUy5cXG5cXG7tlbTri7kg7L2c67Cx7J2EIOq4sOuLpOumrOyngCDslYrqs6Ag7KeA64KY7LOk6riwIOuVjOusuOyduOuNsCwg7J20IOuVjOusuOyXkCBgZG9uZSgpYOydhCDtmZzsmqntlZzri6QuIFxcblxcbmRvbmUoKeyXkCDrj4TssKntlZjquLAg7KCE6rmM7KeA7J2YIOuPmeyekeydhCDsoITrtoAg6riw64uk66as64uk6rCAIGRvbmXsl5Ag64+E7LCp7ZWY66m0IOuBneuCnOuLpC5cXG5cXG5cXG5cXG4jIyMgMi4gUHJvbWlzZSByZXNvbHZlXFxuXFxuKDEpIHRoZW5cXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gZm4uanNcXG5leHBvcnQgY29uc3QgZm4gPSB7XFxuLi4uLFxcbiAgZ2V0TmFtZTogKGNhbGxiYWNrKSA9PiB7XFxuICAgIGNvbnN0IG5hbWUgPSBcXFwiTWlrZVxcXCI7XFxuICAgIHNldFRpbWVvdXQoKCk9PiB7XFxuICAgICAgY2FsbGJhY2sobmFtZSlcXG4gICAgfSwgMzAwMCk7XFxuICB9LFxcbiAgZ2V0QWdlOiAoKSA9PiB7XFxuICAgIGNvbnN0IGFnZSA9IDMwO1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgIHNldFRpbWVvdXQoKCk9PiB7XFxuICAgICAgICByZXNvbHZlKGFnZSlcXG4gICAgICB9LCAzMDAwKTtcXG4gICAgfSlcXG4gIH1cXG59XFxuYGBgXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIGZuLnRlc3QuanNcXG5pdCgnYWdlIGlzIDMwJywgKCkgPT4ge1xcbiAgLy8gYXN5bmMgMi4gUHJvbWlzZSgpXFxuICByZXR1cm4gZm4uZ2V0QWdlKCkudGhlbiggYWdlID0+IHtcXG4gICAgZXhwZWN0KGFnZSkudG9CZSgzMCk7XFxuICB9KTtcXG59KVxcbmBgYFxcblxcbmZuLmdldEFnZSgp7ZWo7IiY64qUIFByb21pc2XqsJ3ssrTrpbwg66as7YS07ZW07KSA64ukLiDtlbTri7kg7ZWo7IiY7J2YIHJldHVybiDqsJLsnYQg67Cb7JWE7JW8IO2VmOq4sCDrlYzrrLjsl5Ag7YWM7Iqk7Yq4IO2VqOyImOyXkOyEnOuPhCByZXR1cm7snYQg67Cb7JWE7KSY7JW8IO2VnOuLpC5cXG5cXG5cXG5cXG4oMikgTWF0Y2hlciDtmZzsmqkgLSByZXNvbHZlc1xcblxcbmBgYGphdmFzY3JpcHRcXG4vLyBmbi50ZXN0LmpzXFxuaXQoJ2FnZSBpcyAzMCcsICgpID0+IHtcXG4gIC8vIGFzeW5jIDIuIFByb21pc2UoKVxcbiAgICByZXR1cm4gZXhwZWN0KGZuLmdldEFnZSgpKS5yZXNvbHZlcy50b0JlKDMwKVxcbiAgfSk7XFxufSlcXG5gYGBcXG5cXG7snITsmYAg6rCZ7J20IGByZXNvbHZlc2AgbWF0Y2hlcuulvCDtmZzsmqntlbTshJwg7KKAIOuNlCDqsITri6jtnogg7J6R7ISx7ZWgIOyImCDsnojri6QuXFxuXFxuXFxuXFxuIyMjIDMuIGFzeW5jIC8gYXdhaXRcXG5cXG5gYGBqYXZhc2NyaXB0XFxuLy8gZm4udGVzdC5qc1xcbml0KCdhZ2UgaXMgMzAnLCBhc3luYyAoKSA9PiB7XFxuICAvLyBhc3luYyAzLiBhc3luYy9hd2FpdFxcblxcdGF3YWl0IGV4cGVjdChmbi5nZXRBZ2UoKSkucmVzb2x2ZXMudG9CZSgzMClcXG59KTtcXG5gYGBcXG5cXG7sl63si5zrgpggYXN5bmMvYXdhaXTsnYQg7IKs7Jqp7ZWY66m0IOqwgOyepSDqsITri6jtlZjqsowg67mE64+Z6riw7LKY66as66W8IO2VoCDsiJgg7J6I64ukLlxcblxcblxcblxcbiMjIDpmb3VyOiDthYzsiqTtirgg7KCEL+2bhCDsspjrpqxcXG5cXG4jIyMgYmVmb3JlRWFjaCAvIGFmdGVyRWFjaFxcblxcbmBgYGphdmFzY3JpcHRcXG4vLyBmYWlsXFxubGV0IG51bSA9IDE7IFxcbnRlc3QoJzErMSA9IDInLCAoKSA9PiB7XFxuICBudW0gPSBmbi5hZGQobnVtLCAxKVxcbiAgZXhwZWN0KG51bSkudG9CZSgyKVxcbn0pXFxudGVzdCgnMSsyID0gMycsICgpID0+IHtcXG4gIGZuLmFkZChudW0sIDIpXFxuICBleHBlY3QobnVtKS50b0JlKDMpXFxufSlcXG5gYGBcXG5cXG7snbQg6rK97JqwIG51bSDsnbQg66ekIO2FjOyKpO2KuOuniOuLpCDsnqztlaDri7nrkJjrqbTshJwg65GQ67KI7Ke4IO2FjOyKpO2KuOqwgCDsi6TtjKjtlZjqsowg65Cc64ukLlxcblxcbuydtOuftCDrlYzripQg66qo65OgIO2FjOyKpO2KuCDsnbTsoITsl5AgbnVt7J2EIDHroZwg7KeA7KCV7ZW07KO864qUIG1hdGNoZXLsnbggYmVmb3JlRWFjaOulvCDtmZzsmqntlZjrqbQg65Cc64ukLlxcblxcbmBgYGphdmFzY3JpcHRcXG4vLyBzdWNjZXNzISFcXG5sZXQgbnVtO1xcbmJlZm9yZUVhY2goKCk9PntcXG4gIG51bSA9IDE7XFxufSlcXG50ZXN0KCcxKzEgPSAyJywgKCkgPT4ge1xcbiAgbnVtID0gZm4uYWRkKG51bSwgMSlcXG4gIGV4cGVjdChudW0pLnRvQmUoMilcXG59KVxcbnRlc3QoJzErMiA9IDMnLCAoKSA9PiB7XFxuICBudW0gPSBmbi5hZGQobnVtLCAyKVxcbiAgZXhwZWN0KG51bSkudG9CZSgzKVxcbn0pXFxuYGBgXFxuXFxuLSBhZnRlckVhY2jripQg66qo65OgIO2FjOyKpO2KuCDsp4Htm4Tsl5Ag7Iuk7ZaJ65CY64qUIOuhnOyngeydtOuLpC5cXG4tIOyyqyBudW3qsJLrp4wg64uk66W06rKMIOyjvOqzoCDsi7bsnYAg6rK97Jqw7JeQIO2ZnOyaqe2VoCDsiJgg7J6I64ukLlxcblxcblxcblxcbiMjIyBiZWZvcmVBbGwgLyBhZnRlckFsbFxcblxcbuunjOyVvSDqsIHqsIHsnZgg7YWM7Iqk7Yq4IOyghC/tm4Tsl5Ag7ZW065Gs7JW8IO2VoCDsnpHsl4XsnbQg7KSR67O165CY66m07IScIOq9pCDsi5zqsITsnbQg6rG466as64qUIOyekeyXheydtOudvOuptCDsnbTrn7Ag6rK97Jqw7JeQ64qUIGJlZm9yZUFsbC9hZnRlckFsbCDsnYQg7Zmc7Jqp7ZW07IScIO2FjOyKpO2KuCDsoIQv7ZuE7JeQIO2VnCDrsojrp4wg7ZW065GQ6rOgIO2FjOyKpO2KuOqwgCDrgZ3rgqDrlYzquYzsp4Ag7Jyg7KeA7ZWgIOyImCDsnojri6QuXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIGZuXFxuZXhwb3J0IGNvbnN0IGZuID0ge1xcbiAuLi5cXG4gIGNvbm5lY3RVc2VyREI6ICgpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICBzZXRUaW1lb3V0KCgpPT4ge1xcbiAgICAgICAgcmVzb2x2ZSh7XFxuICAgICAgICAgIG5hbWU6IFxcXCJNaWtlXFxcIixcXG4gICAgICAgICAgYWdlOiAzMFxcbiAgICAgICAgfSlcXG4gICAgICB9LCAzMDAwKVxcbiAgICB9KVxcbiAgfSxcXG4gIGRpc0Nvbm5lY3RVc2VyREI6ICgpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICBzZXRUaW1lb3V0KCgpPT4ge1xcbiAgICAgICAgcmVzb2x2ZSgpXFxuICAgICAgfSwgMzAwMClcXG4gICAgfSlcXG4gIH1cXG59XFxuYGBgXFxuXFxudXNlciBEQuulvCDsl7DqsrDtlZjripQg7IOB7Zmp7J206528IOqwgOygle2VtOuztOyekC4gdXNlciBEQuyXkCDsl7DqsrDtlZjripTrjbAgM+y0iCwgZGlzY29ubmVjdO2VmOuKlOuNsCAz7LSI6rCAIOqxuOumsOuLpC4g7J206rG4IGJlZm9yZUVhY2gsIGFmdGVyRWFjaOuhnCDrp6Qg7YWM7Iqk7Yq466eI64ukIOy0iOq4sO2ZlCDtlZzri6TrqbQg66ek7JqwIOu5hO2aqOycqOyggeydtOuLpC4gYWZ0ZXJBbGzqs7wgYmVmb3JlQWxs7J2EIO2FjOyKpO2KuOqwgCDsoITrtoAg7Iuk7ZaJ65CY6riwIOyghOqzvCDsoITrtoAg7Iuk7ZaJ65CY6rOgIOuCmOyEnCDtlZwg67KI7JSpIOyLpO2WieuQmOuKlCBtYXRjaGVy7J2066+A66GcIOyVhOuemOyZgCDqsJnsnbQg7IKs7Jqp7ZWY66m0IOuQnOuLpC5cXG5cXG5gYGBqYXZhc2NyaXB0XFxubGV0IHVzZXI7XFxuYmVmb3JlQWxsKGFzeW5jKCk9PntcXG4gIHVzZXIgPSBhd2FpdCBmbi5jb25uZWN0VXNlckRCKCk7XFxufSlcXG5cXG5hZnRlckFsbChhc3luYyAoKSA9PiB7XFxuICByZXR1cm4gYXdhaXQgZm4uZGlzQ29ubmVjdFVzZXJEQigpO1xcbn0pXFxuXFxudGVzdCgnVXNlciBuYW1lIGlzIE1pa2UnLCAoKSA9PiB7XFxuICBleHBlY3QodXNlci5uYW1lKS50b0JlKFxcXCJNaWtlXFxcIilcXG59KVxcbnRlc3QoJ01pa2UgaXMgMzAnLCAoKSA9PiB7XFxuICBleHBlY3QodXNlci5hZ2UpLnRvQmUoMzApXFxufSlcXG5gYGBcXG5cXG5cXG5cXG5cXG5cXG4jIyA6Zml2ZTogTW9ja+2VqOyImFxcblxcbmBgYGphdmFzY3JpcHRcXG5jb25zdCBtb2NrQ2FsbGJhY2sgPSBqZXN0LmZuKHggPT4gNDIgKyB4KTtcXG5mb3JFYWNoKFswLCAxXSwgbW9ja0NhbGxiYWNrKTtcXG5cXG4vLyBUaGUgbW9jayBmdW5jdGlvbiBpcyBjYWxsZWQgdHdpY2VcXG5leHBlY3QobW9ja0NhbGxiYWNrLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKDIpO1xcblxcbi8vIFRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgZmlyc3QgY2FsbCB0byB0aGUgZnVuY3Rpb24gd2FzIDBcXG5leHBlY3QobW9ja0NhbGxiYWNrLm1vY2suY2FsbHNbMF1bMF0pLnRvQmUoMCk7XFxuXFxuLy8gVGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBzZWNvbmQgY2FsbCB0byB0aGUgZnVuY3Rpb24gd2FzIDFcXG5leHBlY3QobW9ja0NhbGxiYWNrLm1vY2suY2FsbHNbMV1bMF0pLnRvQmUoMSk7XFxuXFxuLy8gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbCB0byB0aGUgZnVuY3Rpb24gd2FzIDQyXFxuZXhwZWN0KG1vY2tDYWxsYmFjay5tb2NrLnJlc3VsdHNbMF0udmFsdWUpLnRvQmUoNDIpO1xcbmBgYFxcblxcblxcblxcbm1vY2vtlajsiJjripQg7JmcIOyCrOyaqe2VmOuKlCDqsoPsnbzquYw/XFxuXFxu7JiI66W8IOuTpOyWtCBjcmVhdGVVc2Vy7ZWo7IiY6rCAIOyeiOuLpOqzoCDqsIDsoJXtlbTrs7TsnpAuIOydtCDtlajsiJjqsIAg7Iuk7ZaJ65CY66m0IGRi7JeQIOyLpOygnOuhnCDsnKDsoIDqsIAg7IOd7ISx65Cc64ukLiBjcmVhdGVVc2Vy7ZWo7IiY66W8IO2FjOyKpO2KuO2VmOq4sCDsnITtlbTshJwgY3JlYXRlVXNlcu2VqOyImOulvCDtmLjstpztlZzri6TrqbQg7JuQ7LmY7JWK64qUIOycoOyggOqwgCBEQuyXkCDqs4Tsho0g7IOd7ISx65CgIOyImCDsnojri6QuIOuVjOusuOyXkCBjcmVhdGVVc2Vy7ZWo7IiY66W8IOuqqOuwqe2VnCDtlajsiJgobW9ja0NyZWF0ZVVzZXIp66W8IO2VmOuCmCDrp4zrk6TslrTshJwg66qo67Cp7ZWcIO2VqOyImOqwgCDthYzsiqTtirjrpbwg7J6YIO2GteqzvO2VmOuptCBjcmVhdGVVc2Vy64+EIOustOyCrO2eiCDthrXqs7zrkKAg6rKD7J206528IOyYiOyDge2VoCDsiJgg7J6I64ukLlxcblxcblxcblxcbmBgYGphdmFzY3JpcHRcXG4vL1xcbmplc3QubW9jaygnLi4vZm4nKVxcbmZuLmNvbm5lY3RVc2VyREIoKS5tb2NrUmV0dXJuVmFsdWUoe25hbWU6IFxcXCJNaWtlXFxcIiwgYWdlOiAzMH0pXFxuXFxudGVzdCgndGVzdCcsIGFzeW5jICgpPT57XFxuICBjb25zdCB1c2VyID0gYXdhaXQgZm4uY29ubmVjdFVzZXJEQigpO1xcbiAgZXhwZWN0KHVzZXIubmFtZSkudG9FcXVhbChcXFwiTWlrZVxcXCIpO1xcbn0pXFxuYGBgXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLS0tXFxuXFxucmVmZXJlbmNlcy5cXG5cXG5odHRwczovL2xlYXJuLXJlYWN0LXRlc3QudmxwdC51cy8jLzAxLWphdmFzY3JpcHQtdGVzdGluZ1xcblxcbmh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3BsYXlsaXN0P2xpc3Q9UExaS1RYUG1hSms4TDF4Q2dfMWNSakw1aHVJTmxQMkpLdFxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCJWdWVqc+yXkOyEnCBBV1MgTGFtYmRh7JmAIFNFU+ulvCDsgqzsmqntlbTshJwg66mU7J28IOuztOuCtOq4sFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wMi4wOVxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gQVdTXFxyXFxuICAtIExhbWJkYVxcclxcbiAgLSBWdWVqc1xcclxcbiAgLSBqYXZhc2NyaXB0XFxyXFxuICAtIGVtYWlsXFxyXFxuLS0tXFxyXFxuXFxyXFxuXFxyXFxuIyDrs7Tqs6Ag6re464yA66GcIOuUsOudvO2VmOq4sCDsjInqsIDriqVcXHJcXG5cXHJcXG4jIyAwLiDsnbQg66y47ISc66W8IOyekeyEse2VmOuKlCDsnbTsnKBcXHJcXG5cXHJcXG4o7JqU7JW9OiDruJTroZzqt7gg7J6Y66q7IOydveycvOuptCDqs6jroZzqsITri6QuLi4pXFxyXFxuXFxyXFxuIVvsnpHshLHsnbTsnKBdKC9hc3NldHMvaW1nL1VudGl0bGVkIDIucG5nKVxcclxcblxcclxcbuyymOydjCDsnbTrqZTsnbwg6riw64ql7J2EIOuEo+ycvOugpCDtlojsnYQg65WMIO2VnCDruJTroZzqsbDsnZgg6riA7J2EIOydveyXiOyKteuLiOuLpC4g66eI7KeA66eJIOupmO2KuOq5jOyngCDsgrTtjrTrs7gg6rKw6rO8ICfslYQg6re464yA66GcIOuUsOudvO2VmOuptCDsib3qsowg7ZWgIOyImCDsnojqsqDqtazrgpgnLCAn7J20IOygleuPhOuptCDslrzrp4gg7JWI6rG466as6rKg64ukJyDsg53qsIHtlZjqs6Ag7LCp7IiY7ZaI7Iq164uI64ukLiBcXHJcXG7tlZjsp4Drp4wg7J20IOq4gOydgCBBV1MgTGFtYmRhIOyCrOyaqeyXkCDtj6zsu6TsiqTrpbwg66ee7LaU6rOgIOydtOuplOydvOungeyXkCDrjIDtlbTshJzripQg7YGs6rKMIOyEpOuqhe2VmOyngCDslYrslZjsirXri4jri6QuIFxcclxcbuuVjOusuOyXkCDsmKTtnojroKQg7J20IOu4lOuhnOq3uOq4gOydhCDrs7Tqs6Ag65Sw65287ZWY64uk6rCAIOykkeqwhOykkeqwhCDrp47snYAg64K07Jqp65Ok7J20IOyDneueteuQmOyWtCDsnojslrTshJwg7Jik7Z6I66CkIOunjuydtCDtl6Trp7jsirXri4jri6QuXFxyXFxu66+/6rOgIOq3uOuMgOuhnCDrlLDrnbztlojri6TqsIAg7IK97KeI7J2EIOunjuydtCDtlojsp4Drp4wsIOydtOygnOuKlCDsmKTtnojroKQg7J20IOuqqeyggeydhCDsp4HsoJEg64us7ISx7ZWY6riwIOychO2VtCDri6Tsi5wg6riA7J2EIOyekeyEse2VmOqyjCDrkJjsl4jsirXri4jri6QuXFxyXFxuXFxyXFxuIVvquLDshLHro6Hsoowg7KekXShodHRwczovL3Bwc3Mua3Ivd3AtY29udGVudC91cGxvYWRzLzIwMTMvMDcvMjAxMzA0MDJfMDI1MzAzLnBuZylcXHJcXG5cXHJcXG4ofn7ri7Xri7XtlZjrqbQg64uI6rCAIOyngeygkSDrm7DrjZjqsIB+fiB+fiApXFxyXFxuXFxyXFxuYEFXUyBsYW1iZGEsIEFXUyBTRVMsIG5vZGVtYWlsZXIsIFZ1ZWpz66W8IO2ZnOyaqe2VnCDsnbTrqZTsnbwg7KCE7IahIOq4sOuKpWDsl5Ag64yA7ZW0IOydtCDquIDrp4wg67O06rOgIOuUsOudvO2VtOuPhCDstqnrtoTtlaAg7KCV64+E66GcIOygleumrO2VtOuztOqyoOyKteuLiOuLpC5cXHJcXG5HbyBHbyBHbyFcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyAxLiDsmZwgQVdTIGxhbWJkYeulvCDsgqzsmqntlbTslbwg7ZWg6rmMP1xcclxcblxcclxcbuuplOydvCDquLDriqUuLi4g6rCE64uo7ZWcIOqygyDqsJnsnLzrqbTshJzrj4Qg6re466CH6rKMIOqwhOuLqO2VmOyngOunjOydgCDslYrsnYAg6riw64qlLlxcclxcblxcclxcbuydtOqxuCBFQzLsl5Ag7Jis66Ck7IScIOuplOydvCDsoITshqHrp4wg7ZW07KO86riw7JeQ64qUIOuEiOustCDrpqzshozsiqQg64Kt67mE7J206rOgLCDqt7jroIfri6Tqs6Ag7ZSE66Gg7Yq47JeQ7IScIOygleyggeycvOuhnCDrj5nsnpHtlZjqsozrp4wg66eM65Oc64qUIOqyg+uPhCDslaDrp6TtlZjri6QuXFxyXFxuXFxyXFxu7J2065+0IOuVjCDsk7Drnbzqs6Ag7J6I64qU6rKMIGBBV1PsnZggTGFtYmRhIOq4sOuKpWDsnbTri6QuXFxyXFxuXFxyXFxuPiBBV1MgbGFtYmRh656AIOqwhOuLqO2eiCDrp5DtlbTshJwgJ+2VqOyImCcg64uo7JyE7J2YIGRlcGxveeydtOuLpC5cXHJcXG5cXHJcXG7slrTrlqQg7J2067Kk7Yq46rCAIOuwnOyDne2WiOydhCDrlYzsl5Drp4wg7ZWE7JqU7ZWcIO2VqOyImOuTpOydgCDtgbTrnbzsmrDrk5wg7ISc67KE7JeQIGRlcGxvee2VmOuptCDsi5zqsITri7kg6rO86riI7J2EIOusu+qyjOuQnOuLpC4g7J20IOqyveyasCDshJzrsoQg7Zi47Lac7J20IOyekOyjvCDrsJzsg53tlZjsp4Ag7JWK64qUIOqyveyasCDruYTtmqjsnKjsoIEoYS5rLmEuIOuPiOuCreu5hCnsnbTri6QuXFxyXFxuXFxyXFxu67CY66m0LCBBV1MgbGFtYmRh66W8IOyCrOyaqe2VmOuptCDtlajsiJjqsIAg7Zi47Lac65CY64qUIO2an+yImOyXkCDrlLDrnbwg6rO86riI7J20IOu2gOqzvOuQmOq4sCDrlYzrrLjsl5Ag66mU7J2866eBIOyEnOu5hOyKpCDqsJnsnbQg7J6Q7KO8IOu2iOumrOyngCDslYrripQg7ZWo7IiY65Ok7J2AIOuUsOuhnCDrlrzrgrTslrQg6rSA66as7ZWY66m0IOuNlOyasSDqsr3soJzsoIHsnbTqs6Ag7Zqo7Jyo7KCB7Jy866GcIOyEnOuyhOulvCDsmrTsmIHtlaAg7IiYIOyeiOqyjCDrkJjripQg7J6l7KCQ7J20IOyeiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4oMjAyMS4gMuyblCDquLDspIAsIOyngOybkO2VmOuKlCDslrjslrTripQgQyMsIEdvLCBKYXZhLCBgSmF2YXNjcmlwdChub2RlLmpzKWAsIFBlcmwsIFBIUCwgUHl0aG9uLCBSdWJ57J2064ukLilcXHJcXG5cXHJcXG7snbTrsojsl5DripQgamF2YXNjcmlwdOulvCDtmZzsmqntlbTrs7TslZjri6QuICjspJHqsITsl5AgamF2YXNjcmlwdOyXkCDrjIDtlZwg67aA7KGx7ZWcIOydtO2VtOugpeuVjOusuOyXkCDsgr3sp4jsnYQg66eO7J207ZW07IScIOyInOqwhOyggeycvOuhnCBweXRob27snLzroZwg7ZWg6rmMIOqzoOuvvO2WiOuNmCDsiJzqsITsnYQg6rCE7Iug7Z6IIOuEmOqyvOuLpCA7OzspXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMi4g66Gc7Lus7ZmY6rK97JeQ7IScIOuovOyggCDthYzsiqTtirgg7ZW067O06riwXFxyXFxuXFxyXFxuIyMjIDItMS4g66Gc7Lus7JeQ7IScIOuplOydvCDrs7TrgrTquLBcXHJcXG5cXHJcXG7rqLzsoIAsIGBub2RlbWFpbGVyYCDsmYAgYG5vZGVtYWlsZXItc210cC10cmFuc3BvcnRg652864qUIG5wbSDrnbzsnbTruIzrn6zrpqzrpbwg66i87KCAIOyEpOy5mO2VmOqzoCDslYTrnpgg7JiI7KCcIO2MjOydvOydhCBgaW5kZXguanNgIOuhnCDsoIDsnqXtlZzri6QuXFxyXFxuXFxyXFxuYGBgYmFzaFxcclxcbiQgbnBtIGluc3RhbGwgbm9kZW1haWxlclxcclxcbiQgbnBtIGkgbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydFxcclxcbmBgYFxcclxcblxcclxcbmBgYGpzeFxcclxcbi8vIGluZGV4LmpzXFxyXFxuLypcXHJcXG7stpzsspg6IGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9rb19rci9zZXMvbGF0ZXN0L0RldmVsb3Blckd1aWRlL2V4YW1wbGVzLXNlbmQtdXNpbmctc210cC5odG1sXFxyXFxuVGhpcyBjb2RlIHVzZXMgY2FsbGJhY2tzIHRvIGhhbmRsZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gcmVzcG9uc2VzLlxcclxcbkl0IGN1cnJlbnRseSBkZW1vbnN0cmF0ZXMgdXNpbmcgYW4gYXN5bmMtYXdhaXQgcGF0dGVybi5cXHJcXG5BV1Mgc3VwcG9ydHMgYm90aCB0aGUgYXN5bmMtYXdhaXQgYW5kIHByb21pc2VzIHBhdHRlcm5zLlxcclxcbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIGZvbGxvd2luZzpcXHJcXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9TdGF0ZW1lbnRzL2FzeW5jX2Z1bmN0aW9uXFxyXFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9Vc2luZ19wcm9taXNlc1xcclxcbmh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9zZGstZm9yLWphdmFzY3JpcHQvdjIvZGV2ZWxvcGVyLWd1aWRlL2NhbGxpbmctc2VydmljZXMtYXN5bmNocm9ub3VzbHkuaHRtbFxcclxcbmh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9sYW1iZGEvbGF0ZXN0L2RnL25vZGVqcy1wcm9nLW1vZGVsLWhhbmRsZXIuaHRtbFxcclxcbiovXFxyXFxuXFxyXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcclxcbmNvbnN0IG5vZGVtYWlsZXIgPSByZXF1aXJlKFxcXCJub2RlbWFpbGVyXFxcIik7XFxyXFxuXFxyXFxuLy8gSWYgeW91J3JlIHVzaW5nIEFtYXpvbiBTRVMgaW4gYSByZWdpb24gb3RoZXIgdGhhbiBVUyBXZXN0IChPcmVnb24pLFxcclxcbi8vIHJlcGxhY2UgZW1haWwtc210cC51cy13ZXN0LTIuYW1hem9uYXdzLmNvbSB3aXRoIHRoZSBBbWF6b24gU0VTIFNNVFBcXHJcXG4vLyBlbmRwb2ludCBpbiB0aGUgYXBwcm9wcmlhdGUgQVdTIFJlZ2lvbi5cXHJcXG5jb25zdCBzbXRwRW5kcG9pbnQgPSBcXFwiZW1haWwtc210cC51cy13ZXN0LTIuYW1hem9uYXdzLmNvbVxcXCI7XFxyXFxuXFxyXFxuLy8gVGhlIHBvcnQgdG8gdXNlIHdoZW4gY29ubmVjdGluZyB0byB0aGUgU01UUCBzZXJ2ZXIuXFxyXFxuY29uc3QgcG9ydCA9IDU4NztcXHJcXG5cXHJcXG4vLyBSZXBsYWNlIHNlbmRlckBleGFtcGxlLmNvbSB3aXRoIHlvdXIgXFxcIkZyb21cXFwiIGFkZHJlc3MuXFxyXFxuLy8gVGhpcyBhZGRyZXNzIG11c3QgYmUgdmVyaWZpZWQgd2l0aCBBbWF6b24gU0VTLlxcclxcbmNvbnN0IHNlbmRlckFkZHJlc3MgPSBcXFwiTWFyeSBNYWpvciA8c2VuZGVyQGV4YW1wbGUuY29tPlxcXCI7XFxyXFxuXFxyXFxuLy8gUmVwbGFjZSByZWNpcGllbnRAZXhhbXBsZS5jb20gd2l0aCBhIFxcXCJUb1xcXCIgYWRkcmVzcy4gSWYgeW91ciBhY2NvdW50XFxyXFxuLy8gaXMgc3RpbGwgaW4gdGhlIHNhbmRib3gsIHRoaXMgYWRkcmVzcyBtdXN0IGJlIHZlcmlmaWVkLiBUbyBzcGVjaWZ5XFxyXFxuLy8gbXVsdGlwbGUgYWRkcmVzc2VzLCBzZXBhcmF0ZSBlYWNoIGFkZHJlc3Mgd2l0aCBhIGNvbW1hLlxcclxcbnZhciB0b0FkZHJlc3NlcyA9IFxcXCJyZWNpcGllbnRAZXhhbXBsZS5jb21cXFwiO1xcclxcblxcclxcbi8vIENDIGFuZCBCQ0MgYWRkcmVzc2VzLiBJZiB5b3VyIGFjY291bnQgaXMgaW4gdGhlIHNhbmRib3gsIHRoZXNlXFxyXFxuLy8gYWRkcmVzc2VzIGhhdmUgdG8gYmUgdmVyaWZpZWQuIFRvIHNwZWNpZnkgbXVsdGlwbGUgYWRkcmVzc2VzLCBzZXBhcmF0ZVxcclxcbi8vIGVhY2ggYWRkcmVzcyB3aXRoIGEgY29tbWEuXFxyXFxudmFyIGNjQWRkcmVzc2VzID0gXFxcImNjLXJlY2lwaWVudDBAZXhhbXBsZS5jb20sY2MtcmVjaXBpZW50MUBleGFtcGxlLmNvbVxcXCI7XFxyXFxudmFyIGJjY0FkZHJlc3NlcyA9IFxcXCJiY2MtcmVjaXBpZW50QGV4YW1wbGUuY29tXFxcIjtcXHJcXG5cXHJcXG4vLyBSZXBsYWNlIHNtdHBfdXNlcm5hbWUgd2l0aCB5b3VyIEFtYXpvbiBTRVMgU01UUCB1c2VyIG5hbWUuXFxyXFxuY29uc3Qgc210cFVzZXJuYW1lID0gXFxcIkFLSUFJT1NGT0ROTjdFWEFNUExFXFxcIjtcXHJcXG5cXHJcXG4vLyBSZXBsYWNlIHNtdHBfcGFzc3dvcmQgd2l0aCB5b3VyIEFtYXpvbiBTRVMgU01UUCBwYXNzd29yZC5cXHJcXG5jb25zdCBzbXRwUGFzc3dvcmQgPSBcXFwid0phbHJYVXRuRkVNSS9LN01ERU5HL2JQeFJmaUNZRVhBTVBMRUtFWVxcXCI7XFxyXFxuXFxyXFxuLy8gKE9wdGlvbmFsKSB0aGUgbmFtZSBvZiBhIGNvbmZpZ3VyYXRpb24gc2V0IHRvIHVzZSBmb3IgdGhpcyBtZXNzYWdlLlxcclxcbnZhciBjb25maWd1cmF0aW9uU2V0ID0gXFxcIkNvbmZpZ1NldFxcXCI7XFxyXFxuXFxyXFxuLy8gVGhlIHN1YmplY3QgbGluZSBvZiB0aGUgZW1haWxcXHJcXG52YXIgc3ViamVjdCA9IFxcXCJBbWF6b24gU0VTIHRlc3QgKE5vZGVtYWlsZXIpXFxcIjtcXHJcXG5cXHJcXG4vLyBUaGUgZW1haWwgYm9keSBmb3IgcmVjaXBpZW50cyB3aXRoIG5vbi1IVE1MIGVtYWlsIGNsaWVudHMuXFxyXFxudmFyIGJvZHlfdGV4dCA9IGBBbWF6b24gU0VTIFRlc3QgKE5vZGVtYWlsZXIpXFxyXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxyXFxuVGhpcyBlbWFpbCB3YXMgc2VudCB0aHJvdWdoIHRoZSBBbWF6b24gU0VTIFNNVFAgaW50ZXJmYWNlIHVzaW5nIE5vZGVtYWlsZXIuXFxyXFxuYDtcXHJcXG5cXHJcXG4vLyBUaGUgYm9keSBvZiB0aGUgZW1haWwgZm9yIHJlY2lwaWVudHMgd2hvc2UgZW1haWwgY2xpZW50cyBzdXBwb3J0IEhUTUwgY29udGVudC5cXHJcXG52YXIgYm9keV9odG1sID0gYDxodG1sPlxcclxcbjxoZWFkPjwvaGVhZD5cXHJcXG48Ym9keT5cXHJcXG4gIDxoMT5BbWF6b24gU0VTIFRlc3QgKE5vZGVtYWlsZXIpPC9oMT5cXHJcXG4gIDxwPlRoaXMgZW1haWwgd2FzIHNlbnQgd2l0aCA8YSBocmVmPSdodHRwczovL2F3cy5hbWF6b24uY29tL3Nlcy8nPkFtYXpvbiBTRVM8L2E+XFxyXFxuICAgICAgICB1c2luZyA8YSBocmVmPSdodHRwczovL25vZGVtYWlsZXIuY29tJz5Ob2RlbWFpbGVyPC9hPiBmb3IgTm9kZS5qcy48L3A+XFxyXFxuPC9ib2R5PlxcclxcbjwvaHRtbD5gO1xcclxcblxcclxcbi8vIFRoZSBtZXNzYWdlIHRhZ3MgdGhhdCB5b3Ugd2FudCB0byBhcHBseSB0byB0aGUgZW1haWwuXFxyXFxudmFyIHRhZzAgPSBcXFwia2V5MD12YWx1ZTBcXFwiO1xcclxcbnZhciB0YWcxID0gXFxcImtleTE9dmFsdWUxXFxcIjtcXHJcXG5cXHJcXG5hc3luYyBmdW5jdGlvbiBtYWluKCl7XFxyXFxuXFxyXFxuICAvLyBDcmVhdGUgdGhlIFNNVFAgdHJhbnNwb3J0LlxcclxcbiAgbGV0IHRyYW5zcG9ydGVyID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoe1xcclxcbiAgICBob3N0OiBzbXRwRW5kcG9pbnQsXFxyXFxuICAgIHBvcnQ6IHBvcnQsXFxyXFxuICAgIHNlY3VyZTogZmFsc2UsIC8vIHRydWUgZm9yIDQ2NSwgZmFsc2UgZm9yIG90aGVyIHBvcnRzXFxyXFxuICAgIGF1dGg6IHtcXHJcXG4gICAgICB1c2VyOiBzbXRwVXNlcm5hbWUsXFxyXFxuICAgICAgcGFzczogc210cFBhc3N3b3JkXFxyXFxuICAgIH1cXHJcXG4gIH0pO1xcclxcblxcclxcbiAgLy8gU3BlY2lmeSB0aGUgZmllbGRzIGluIHRoZSBlbWFpbC5cXHJcXG4gIGxldCBtYWlsT3B0aW9ucyA9IHtcXHJcXG4gICAgZnJvbTogc2VuZGVyQWRkcmVzcyxcXHJcXG4gICAgdG86IHRvQWRkcmVzc2VzLFxcclxcbiAgICBzdWJqZWN0OiBzdWJqZWN0LFxcclxcbiAgICBjYzogY2NBZGRyZXNzZXMsXFxyXFxuICAgIGJjYzogYmNjQWRkcmVzc2VzLFxcclxcbiAgICB0ZXh0OiBib2R5X3RleHQsXFxyXFxuICAgIGh0bWw6IGJvZHlfaHRtbCxcXHJcXG4gICAgLy8gQ3VzdG9tIGhlYWRlcnMgZm9yIGNvbmZpZ3VyYXRpb24gc2V0IGFuZCBtZXNzYWdlIHRhZ3MuXFxyXFxuICAgIGhlYWRlcnM6IHtcXHJcXG4gICAgICAnWC1TRVMtQ09ORklHVVJBVElPTi1TRVQnOiBjb25maWd1cmF0aW9uU2V0LFxcclxcbiAgICAgICdYLVNFUy1NRVNTQUdFLVRBR1MnOiB0YWcwLFxcclxcbiAgICAgICdYLVNFUy1NRVNTQUdFLVRBR1MnOiB0YWcxXFxyXFxuICAgIH1cXHJcXG4gIH07XFxyXFxuXFxyXFxuICAvLyBTZW5kIHRoZSBlbWFpbC5cXHJcXG4gIGxldCBpbmZvID0gYXdhaXQgdHJhbnNwb3J0ZXIuc2VuZE1haWwobWFpbE9wdGlvbnMpXFxyXFxuXFxyXFxuICBjb25zb2xlLmxvZyhcXFwiTWVzc2FnZSBzZW50ISBNZXNzYWdlIElEOiBcXFwiLCBpbmZvLm1lc3NhZ2VJZCk7XFxyXFxufVxcclxcblxcclxcbm1haW4oKS5jYXRjaChjb25zb2xlLmVycm9yKTtcXHJcXG5gYGBcXHJcXG5cXHJcXG7qsIHqsIHsnZgg67OA7IiY65Ok7J20IOustOyXh+ydhCDrnLvtlZjripTsp4DripQg7KO87ISd7JeQIOyekOyEuO2eiCDri6zroKTsnojri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu66i87KCAIOqwhOuLqO2VmOqyjCDrqocg6rCA7KeA66eMIOyCtO2OtOuztOyekC5cXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG4vLyAxLiBhd3MtZW1haWwgcmVnaW9u7J2064ukLiDquLDrs7jsoIHsnLzroZwgdXMtd2VzdOuhnCDshKTsoJXrkJjslrTsnojripTrjbAg7ISc7Jq47J2AIGVtYWlsLXN0bXAuYXAtbm9ydGhlYXN0LTLsnbTri6QuXFxyXFxuY29uc3Qgc210cEVuZHBvaW50ID0gXFxcImVtYWlsLXNtdHAudXMtd2VzdC0yLmFtYXpvbmF3cy5jb21cXFwiO1xcclxcblxcclxcbi8vIDIuIOuztOyViOyCrO2VrVxcclxcbmNvbnN0IHNtdHBVc2VybmFtZSA9IFxcXCJBWFhYWFhYWFhYWFhYWFhYRVxcXCI7XFxyXFxuLy8gUmVwbGFjZSBzbXRwX3Bhc3N3b3JkIHdpdGggeW91ciBBbWF6b24gU0VTIFNNVFAgcGFzc3dvcmQuXFxyXFxuY29uc3Qgc210cFBhc3N3b3JkID0gXFxcIndYWFhYWFhYWFhYWFhYWFhYWFhFWVxcXCI7XFxyXFxuXFxyXFxuLypcXHJcXG7snbTrqZTsnbzsnYQg7KCR7IaN7ZWY6riwIOychO2VtOyEnOuKlCDrs7Trgrwg7J2066mU7J287J20IOyeiOyWtOyVvO2VnOuLpC4gXFxyXFxu6rCE64uo7ZWY6rKMIOyekOyLoOydmCDsnbTrqZTsnbzsnYQg7Zmc7Jqp7ZWc64uk66m0IOyVhOydtOuUlOyZgCDruYTrsIDrsojtmLjqsIAg7ZWE7JqU7ZWY64ukLlxcclxcbu2VmOyngOunjCDslYTsnbTrlJTsmYAg67mE67CA67KI7Zi466W8IOy9lOuTnOyXkCDqt7jrjIDroZwg64W47Lac7Iuc7YKk64qUIOqyg+ydgCDrs7TslYjsl5Ag7KKL7KeAIOyViuycvOuvgOuhnCxcXHJcXG5BV1Psl5DshJwg7KCc6rO17ZWY64qUIFNFUyh+fuyalOyglSl+fiDquLDriqXsnYQg7IKs7Jqp7ZWY7JesIHVzZXJuYW1l6rO8IHBhc3N3b3Jk66W8IOyCrOyaqe2VoCDsiJgg7J6I64ukLlxcclxcbiovXFxyXFxuYGBgXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMjIDItMi4gQVdTIFNFUyBTTVRQ7IKs7Jqp7ZWY6riwXFxyXFxuXFxyXFxuQVdT7J2YIFNFUyh+fuyalOyglT9+finripQg662U6rCAIOyVveyekOuhnCDsk7DrqbQg66mL7J6I6rOgIOuzteyeoe2VnCDquLDriqXqsJnsp4Drp4wg6re4IOucu+ydhCDrs7TrqbQg7IOd6rCB67O064ukIOy5nOq3vCg/Ke2VmOuLpC4gU2ltcGxlIEVtYWlsIFNlcnZpY2XsnZgg7JW97J6Q66GcIOunkOq3uOuMgOuhnCDqsITri6jtlZwgZW1haWwg7ISc67mE7Iqk64ukLiBcXHJcXG5cXHJcXG4hW1NFU10oL2Fzc2V0cy9pbWcvVW50aXRsZWQlMjAzLnBuZylcXHJcXG5cXHJcXG5TRVPrpbwg6rKA7IOJ7ZWY6rOgIO2BtOumrSFcXHJcXG5cXHJcXG4hW2VtYWlsIHZlcmlmeTJdKC9hc3NldHMvaW1nL1VudGl0bGVkIDQucG5nKVxcclxcblxcclxcbkVtYWlsIEFkZHJlc3PtgbTrpq0hXFxyXFxuXFxyXFxuIVtlbWFpbCB2ZXJpZnkyXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCA1LnBuZylcXHJcXG5cXHJcXG5lbWFpbCDsnbjspp0g44Sx44SxIVxcclxcblxcclxcbiFbQVdT7J247Kad66mU7J28XSgvYXNzZXRzL2ltZy9VbnRpdGxlZCA2LnBuZylcXHJcXG5cXHJcXG4q7J20IO2ZlOuptOydgCBHbWFpbOyXkOyEnCBBV1ProZzrtoDthLAg67Cb7J2AIOuplOydvCDtmZTrqbTsnbTri6QuIOu2ieydgCDrtoDrtoTsnZgg66eB7YGs66W8IO2BtOumre2VmOuptCDsnbjspp3snbQg7JmE66OM65Cc64ukLipcXHJcXG5cXHJcXG4hW2VtYWlsIHZlcmlmeTNdKC9hc3NldHMvaW1nL1VudGl0bGVkIDcucG5nKVxcclxcblxcclxcbirsnbjspp3snbQg7JmE66OM65CY66m0IHBlbmRpbmcgdmVyaWZpY2F0aW9u7J20IGB2ZXJpZmllZGDroZwg67OA6rK965Cc64ukLipcXHJcXG5cXHJcXG4hW2VtYWlsIFNNVFBdKC9hc3NldHMvaW1nL1VudGl0bGVkIDgucG5nKVxcclxcblxcclxcblxcclxcblxcclxcbuyduOymneydtCDsmYTro4zrkJjrqbQgU01UUCBjcmVkZW50aWFsc+ulvCDsg53shLHtlZzri6QuXFxyXFxuXFxyXFxu7J20IOqzvOygleydhCDqsbDsuZjrqbQgYGNyZWRlbnRpYWxzLmNzdmAg7YyM7J287J20IOyDneyEseuQmOqzoCDsnbQg7YyM7J287J2EIOuLpOyatOuhnOuTnCDrsJvslYQg7Je066m0IOychOydmCBgc210cFVzZXJuYW1lYCDqs7wgYHNtdHBQYXNzd29yZGDqsIAg7J6I7Jy866+A66GcIGluZGV4LmpzIO2MjOydvOydmCDtlbTri7kg7JyE7LmY7JeQIOuzteu2me2VnOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG7sl6zquLDquYzsp4Ag7KeE7ZaJ7ZWY6rOg7IScIHRlcm1pbmFs7JeQ7IScIGBub2RlIGluZGV4YCDrpbwg7J6F66Cl7ZWY66m0IGluZGV4Lmpz6rCAIOyLpO2WieuQmOuptOyEnCDrgrTqsIAgc2VuZFRv66GcIOyEpOygle2WiOuNmCDrqZTsnbzroZwg66mU7J287J20IOuCoOudvOqwgCDsnojsnYQg6rKD7J2064ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIDMuICBMYW1iZGEg7IKs7Jqp7ZW067O06riwXFxyXFxuXFxyXFxuIyMjIDMtMS4gQVdTIExhbWJkYeyXkOyEnCDtlajsiJgg7IOd7ISxXFxyXFxuXFxyXFxuIVthd3MgbGFtYmRhMV0oL2Fzc2V0cy9pbWcvVW50aXRsZWQgOS5wbmcpXFxyXFxuXFxyXFxuKidMYW1iZGEg7ISc67KE7JeQIOuMgO2VnCDqsbHsoJXsl4bsnbQg7L2U65OcIOyLpO2WiScg7YG066atKlxcclxcblxcclxcbiFbYXdzIGxhbWJkYTJdKC9hc3NldHMvaW1nL1VudGl0bGVkIDEwLnBuZylcXHJcXG5cXHJcXG4q7Jqw7IOB64uoICftlajsiJgg7IOd7ISxJyDrsoTtirwg7YG066atKlxcclxcblxcclxcbiFbYXdzIGxhbWJkYTNdKC9hc3NldHMvaW1nL1VudGl0bGVkJTIwMTEucG5nKVxcclxcblxcclxcbirtlajsiJjsnbTrpoQsIOufsO2DgOyehOydhCDshKDtg53tlZjqs6Ag7ZWo7IiY7IOd7ISxICjsnbTrsojsl5DripQgZXhhbXBsZeydtOudvOuKlCDtlajsiJjrqoXqs7wgbm9kZTE0LnjroZwg66eM65Ok7JeI7Iq164uI64ukLikqXFxyXFxuXFxyXFxuIVthd3MgbGFtYmRhNF0oL2Fzc2V0cy9pbWcvVW50aXRsZWQgMTIucG5nKVxcclxcblxcclxcbirtirjrpqzqsbAg7LaU6rCAIOuyhO2KvCDtgbTrpq0qXFxyXFxuXFxyXFxuIVthd3MgbGFtYmRhNV0oL2Fzc2V0cy9pbWcvVW50aXRsZWQgMTMucG5nKVxcclxcblxcclxcbipBUEkg6rKM7J207Yq47Juo7J20KlxcclxcblxcclxcbiFbYXdzIGdhdGV3YXkxXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCAxNC5wbmcpXFxyXFxuXFxyXFxuKuuztOyViCAtIOyXtOq4sCwgQ09SUyDssrTtgazripQg7J2864uoIO2VmOyngOyViuqzoCDrhpTrkZDqs6Ag64KY7KSR7JeQIOyymOumrCDjhLHjhLEqXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7JWE656Y66GcIOuCtOugpOyZgOyEnCAn7ZWo7IiYIOy9lOuTnCfsqr3snLzroZwg64K066Ck7JioIOuSpCBpbmRleC5qc+ulvCDtgbTrpq3tlbTspIDri6QuXFxyXFxuXFxyXFxu7J20IHBhcnTqsIAgbGFtYmRhIO2VqOyImOulvCDsnpHshLHtlZjripQg66mU7J24IOqzteqwhOydtOuLpC5cXHJcXG5cXHJcXG4hW2F3cyBsYW1iZGE2XSgvYXNzZXRzL2ltZy9VbnRpdGxlZCAxNS5wbmcpXFxyXFxuXFxyXFxuKuuwneydgCDtmZTrqbTsnYQg64iI65yo6rOgIOyngOy8nOuzvCDsiJgg7JeG7Ja0IGF3c+yXkOyEnOuPhCBkYXJrIHRoZW1l66GcIOuwlOq/lOyEnCDsk7DripTspJHsnbTrnbwg7ZmU66m07J20IOuLpOultOqyjCDrs7Tsnbwg7IiYIOyeiOydjCA7OypcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG7qsITri6jtlZwg7JiI7IucIOy9lOuTnOqwgCDsoIHtmIDsnojri6RcXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG5leHBvcnRzLmhhbmRsZXIgPSBhc3luYyAoZXZlbnQpID0+IHtcXHJcXG4gICAgLy8gVE9ETyBpbXBsZW1lbnRcXHJcXG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XFxyXFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXFxyXFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSgnSGVsbG8gZnJvbSBMYW1iZGEhJyksXFxyXFxuICAgIH07XFxyXFxuICAgIHJldHVybiByZXNwb25zZTtcXHJcXG59O1xcclxcblxcclxcbuuejOuLpOuKlCDsnbQgZXhwb3J0cy5oYW5kbGVy6rCAIO2VhOyImOyggeydtOuLpC4gXFxyXFxu7J207ZuEIHJlc3BvbnNl7JeQIOyDge2DnOuyiO2YuCAyMDDqs7wgXFxcImhlbGxvIGZyb20gTGFtYmRhIVxcXCLrnbzripQg66y47J6Q7Je07J2EIEpTT07snLzroZwg7J6R7ISx7ZW0IOuLtOyVhOyjvOqzoFxcclxcbuydtCByZXNwb25zZeulvCByZXR1cm7tlbTspIDri6QuXFxyXFxuXFxyXFxuYGBgXFxyXFxuXFxyXFxuW2hhbmRsZXLsl5Ag64yA7ZWcIOyEpOuqhV0oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2xhbWJkYS9sYXRlc3QvZGcvbm9kZWpzLWhhbmRsZXIuaHRtbClb7JiB66y4XVxcclxcblxcclxcblRlc3TrsoTtirzsnYQg64iE66W066m0IGV4ZWN1dGlvbiByZXN1bHRzIOywveydtCDrgpjsmKTrqbTshJwg7ZWo7IiYIOyLpO2WiSDqsrDqs7zrpbwg67O07Jes7KSA64ukXFxyXFxuXFxyXFxuIVthd3MgbGFtYmRhN10oL2Fzc2V0cy9pbWcvVW50aXRsZWQgMTYucG5nKVxcclxcblxcclxcbuyEseqzteyggeycvOuhnCDthrXsi6DsnbQg65Cc64uk66m0IFJlc3BvbnNl7JeQIHN0YXR1c0NvZGXsmYAgQm9keeyXkCDrrLjsnpDsl7TsnbQg64u06rKo7J6I64qUIOqyg+ydhCDtmZXsnbjtlaAg7IiYIOyeiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyMgMy0yLiBBV1MgbGFtZGHsl5Ag66Gc7LusIO2ZmOqyveqzvCDrmJHqsJnsnbQg7ZmY6rK97ISk7KCV7ZWY6riwXFxyXFxuXFxyXFxuIVvroZzsu6ztjIzsnbztirjrpqxdKC9hc3NldHMvaW1nL1VudGl0bGVkIDE3LnBuZylcXHJcXG5cXHJcXG4q66Gc7Lus7ZmY6rK97J2YIO2MjOydvO2KuOumrCpcXHJcXG5cXHJcXG4hW2xhbWJkYSDtjIzsnbztirjrpqxdKC9hc3NldHMvaW1nL1VudGl0bGVkIDE4LnBuZylcXHJcXG5cXHJcXG4qQVdTIOuejOuLpCDtmZjqsr3snZgg7YyM7J287Yq466asKlxcclxcblxcclxcblxcclxcblxcclxcbuuhnOy7rCDtmZjqsr3sl5DshJzripQgYG5wbWDsnYQg7Zmc7Jqp7ZW07IScIG5vZGVtYWlsZXLrpbwg7ISk7LmY7ZW0IO2ZnOyaqe2WiOuLpC5cXHJcXG5cXHJcXG7qsIDsnqUg66y47KCc64qUIOydtCDrnbzsnbTruIzrn6zrpqzrpbwg7Ja065a76rKMIGF3cyDtmZjqsr3sl5DshJzrj4Qg6rWs7ISx7ZWgIOyImCDsnojsnYTquYzsmIDri6QuXFxyXFxuXFxyXFxuQVdTIGxhbWJkYeyXkOyEnCDthLDrr7jrhJDsnYQg7LC+7JWEIO2XpOunuOyngOunjCDrs7TsnbTsp4Ag7JWK7JWEIOydtCDrtoDrtoTsl5DshJwg66eO7J20IOuLue2Zqe2WiOuLpC5cXHJcXG5cXHJcXG7tlbTqsrDrsKnrspXsnYAg7IOd6rCB67O064ukIOqwhOuLqO2WiOuLpC4g66Gc7Lus7J2YIOydtCDrlJTroInthqDrpqzrpbwg7Ya17Ke466GcIHppcO2MjOydvOuhnCDslZXstpXtlZwg65KkIOyXheuhnOuTnO2VmOuptCDrkJjripQg6rKD7J207JeI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbltIb3cgdG8gaW5zdGFsbCBucG0gbW9kdWxlcyBpbiBBV1MgTGFtYmRhP10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1SbkZvd0oxMzBwYylcXHJcXG5cXHJcXG7snbQg7Jyg7Yqc67iMIOuPmeyYgeyDgeydhCDrs7TrqbAg7Z6M7Yq466W8IOyWu+qzoCDrlLDrnbztlaAg7IiYIOyeiOyXiOuLpC5cXHJcXG5cXHJcXG4xLiDroZzsu6ztmZjqsr3sl5DshJwgemlwIO2MjOydvOydhCDrp4zrk6Dri6QuXFxyXFxuMi4gIOyekeyXhSDrsoTtirzsnYQg64iE66W06rOgIOuCmOyYpOuKlCBgLnppcO2MjOydvCDsl4XroZzrk5xg66GcIOyVley2le2VtOuGk+ydgCB6aXDtjIzsnbzsnYQgQVdT7JeQIOyYrOumsOuLpC5cXHJcXG5cXHJcXG4hW2luZGV4LmpzXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCAxOS5wbmcpXFxyXFxuXFxyXFxuKOydtOugh+qyjCDsiazsmrQg67Cp67KV7J20IOyeiOyXiOuKlOuNsCDtlZjtlYQgYXdzLXNka+ulvCDsgqzsmqntlbQgQ0xJ7ZmY6rK97JeQ7IScIO2VmOuKlCDrsKnrspXsnbQg6rWs6riA66eB7JeQ7IScIOuovOyggCDrgpjsmYAg6rOg7IOd7KKAIO2WiOyXiOuLpC4uLuOFoClcXHJcXG5cXHJcXG4hW+yXheuhnOuTnOyZhOujjF0oL2Fzc2V0cy9pbWcvVW50aXRsZWQgMjAucG5nKVxcclxcblxcclxcbuydtOygnCDroZzsu6wg7ZmY6rK96rO8IEFXUyBsYW1iZGHtmZjqsr3snbQg6rCZ7JWE7KGM64ukLiDsl6zquLDquYzsp4Ag7JmU64uk66m0IOqxsOydmCDri6TsmZTri6QhXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgNC4gVnVlanProZwg7J2066mU7J28IOyghOyGoSDtj7wg66eM65Ok6riwXFxyXFxuXFxyXFxuIyMjIDQtMS4gLnZ1Ze2MjOydvCDrp4zrk6TquLBcXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG4vLyBGZWVkYmFjay52dWUg7KCE7LK0IOy9lOuTnOuKlCDri6TsnYzqs7wg6rCZ64ukXFxyXFxuXFxyXFxuPHRlbXBsYXRlPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXHJcXG4gICAgPGgzPuuJtO2VmO2MgOyXkCDtlLzrk5zrsLEg66mU7J28IOuztOuCtOq4sDwvaDM+XFxyXFxuICAgIDx2LWZvcm0gQHN1Ym1pdC5wcmV2ZW50PVxcXCJzdWJtaXRcXFwiPlxcclxcbiAgICAgIDx2LXRleHQtZmllbGRcXHJcXG4gICAgICAgIHYtbW9kZWw9XFxcImVtYWlsXFxcIlxcclxcbiAgICAgICAgOnJ1bGVzPVxcXCJlbWFpbFJ1bGVzXFxcIlxcclxcbiAgICAgICAgbGFiZWw9XFxcIuuLteyepSDrsJvsnYQg7J2066mU7J28XFxcIlxcclxcbiAgICAgICAgcmVxdWlyZWRcXHJcXG4gICAgICA+PC92LXRleHQtZmllbGQ+XFxyXFxuXFxyXFxuICAgICAgPHYtdGV4dC1maWVsZFxcclxcbiAgICAgICAgdi1tb2RlbD1cXFwidGl0bGVcXFwiXFxyXFxuICAgICAgICBsYWJlbD1cXFwi7KCc66qpXFxcIlxcclxcbiAgICAgICAgcmVxdWlyZWRcXHJcXG4gICAgICAgIGF1dG9jYXBpdGFsaXplPVxcXCJvZmZcXFwiXFxyXFxuICAgICAgPjwvdi10ZXh0LWZpZWxkPlxcclxcblxcclxcbiAgICAgIDx2LXRleHRhcmVhXFxyXFxuICAgICAgICB2LW1vZGVsPVxcXCJjb250ZW50XFxcIlxcclxcbiAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXHJcXG4gICAgICAgIGxhYmVsPVxcXCLrs7jrrLhcXFwiXFxyXFxuICAgICAgICByZXF1aXJlZFxcclxcbiAgICAgID48L3YtdGV4dGFyZWE+XFxyXFxuICAgICAgPGJyIC8+XFxyXFxuICAgICAgPHYtYnRuXFxyXFxuICAgICAgICA6ZGlzYWJsZWQ9XFxcIiF2YWxpZFxcXCJcXHJcXG4gICAgICAgIGNvbG9yPVxcXCIjZmY5ODAwXFxcIlxcclxcbiAgICAgICAgQGNsaWNrPVxcXCJzdWJtaXRcXFwiXFxyXFxuICAgICAgICA+7KCE7Iah7ZWY6riwPC92LWJ0blxcclxcbiAgICAgID5cXHJcXG4gICAgPC92LWZvcm0+IFxcclxcbiAgPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxyXFxuY29uc3QgQVBJX0ZST01fQVdTX0FQSV9HQVRFV0FZID0gJ2h0dHBzOi8vPz8/Pz8/LmFwLW5vcnRoZWFzdC0yLmFtYXpvbmF3cy5jb20vZGVmYXVsdC887ZWo7IiY66qFPic7XFxyXFxuXFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgbmFtZTogJ0ZlZWRiYWNrJyxcXHJcXG4gIG1ldGhvZHM6IHtcXHJcXG4gICAgaXNWYWxpZDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIGlmICh0aGlzLnRpdGxlID09ICcnIHx8IHRoaXMuY29udGVudCA9PSAnJykge1xcclxcbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlXFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlXFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBzdWJtaXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICBheGlvcy5wb3N0KEFQSV9GUk9NX0FXU19BUElfR0FURVdBWSwgSlNPTi5zdHJpbmdpZnkoe1xcclxcbiAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXFxyXFxuICAgICAgICB0aXRsZTogdGhpcy50aXRsZSxcXHJcXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICApKVxcclxcbiAgICAgIC50aGVuKChyZXMpID0+IHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHJlcylcXHJcXG4gICAgICB9KVxcclxcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coZSlcXHJcXG4gICAgICB9KVxcclxcbiAgICB9LFxcclxcbiAgfSxcXHJcXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgcmV0dXJuIHtcXHJcXG4gICAgICBlbWFpbDogJycsXFxyXFxuICAgICAgdGl0bGU6ICcnLFxcclxcbiAgICAgIGNvbnRlbnQ6ICcnLFxcclxcbiAgICAgIHZhbGlkOiBmYWxzZSxcXHJcXG4gICAgICBlbWFpbFJ1bGVzOiBbXFxyXFxuICAgICAgICB2ID0+ICEhdiB8fCAnRS1tYWlsIGlzIHJlcXVpcmVkJyxcXHJcXG4gICAgICAgIHYgPT4gLy4rQC4rLy50ZXN0KHYpIHx8ICdFLW1haWwgbXVzdCBiZSB2YWxpZCcsXFxyXFxuICAgICAgXSxcXHJcXG4gICAgfVxcclxcbiAgfSxcXHJcXG4gIHdhdGNoOiB7XFxyXFxuICAgIHRpdGxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdGhpcy5pc1ZhbGlkKCk7XFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLmlzVmFsaWQoKTtcXHJcXG4gICAgfSxcXHJcXG4gIH1cXHJcXG59XFxyXFxuPC9zY3JpcHQ+XFxyXFxuYGBgXFxyXFxuXFxyXFxuMS4gdi1mb3Jt7J2EIO2ZnOyaqe2VtCDqsITri6jtnogg7IS4IOykhCDsp5zrpqwgaW5wdXTsnYQg66eM65Ok7JeI64ukLlxcclxcbiAgICAtIGVtYWlsXFxyXFxuICAgIC0gdGl0bGVcXHJcXG4gICAgLSBjb250ZW50XFxyXFxuMi4gdi1tb2RlbOuhnCBlbWFpbCwgdGl0bGUsIGNvbnRlbnTrpbwg6rCB6rCBIOyeheugpeuwm+uKlCDqsJLsnYQgc3RyaW5n7Jy866GcIGJpbmRpbmftlojri6QuXFxyXFxuMy4gQVdT656M64uk7ZWo7IiY7J2YIOyjvOyGjOqwkuydhCDrhKPslrTspIDri6RcXHJcXG40LiBheGlvc+ulvCBpbXBvcnQg7ZWc64ukXFxyXFxuXFxyXFxuIVvso7zshowxXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCUyMDIxLnBuZylcXHJcXG5cXHJcXG4qbGFtYmRhIO2ZlOuptOyXkOyEnCBBUEnqsozsnbTtirjsm6jsnbTrpbwg7YG066at7ZWc64ukKlxcclxcblxcclxcbiFb7KO87IaMMl0oL2Fzc2V0cy9pbWcvVW50aXRsZWQgMjIucG5nKVxcclxcblxcclxcbuydtCDrtonsnYDsg4kg7ZGc7Iuc66W8IO2VnCBVUkzsnbQg7ZWo7IiY7Zi47LacIOqyjOydtO2KuOybqOydtOqwkuydtOuLpC5cXHJcXG5cXHJcXG7snbQg7KO87IaM6rCS7J2EIGNvbnN0IEFQSV9GUk9NX0FXU19BUElfR0FURVdBWeyXkCDrhKPslrTspIDri6QuXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXHJcXG5jb25zdCBBUElfRlJPTV9BV1NfQVBJX0dBVEVXQVkgPSAnaHR0cHM6Ly8/Pz8/Pz8uYXAtbm9ydGhlYXN0LTIuYW1hem9uYXdzLmNvbS9kZWZhdWx0LzztlajsiJjrqoU+JztcXHJcXG5gYGBcXHJcXG5cXHJcXG41LiBzdWJtaXQg7J20652864qUIOyghOyGoSDtlajsiJjrpbwgbWV0aG9kc+yXkCDstpTqsIDtlZzri6QuXFxyXFxuXFxyXFxuLSBBUEkg6rKM7J207Yq47Juo7J20IOyjvOyGjOuhnCBQT1NU67Cp7Iud7J2YIGF4aW9zIOu5hOuPmeq4sCDsmpTssq3snYQg7ZWc64ukLlxcclxcblxcclxcbmBgYGpzeFxcclxcbnN1Ym1pdDogZnVuY3Rpb24gKCkge1xcclxcbiAgICBheGlvcy5wb3N0KEFQSV9GUk9NX0FXU19BUElfR0FURVdBWSwgSlNPTi5zdHJpbmdpZnkoe1xcclxcbiAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxcclxcbiAgICAgIHRpdGxlOiB0aGlzLnRpdGxlLFxcclxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcXHJcXG4gICAgICB9XFxyXFxuICAgICkpXFxyXFxuICAgIC50aGVuKChyZXMpID0+IHtcXHJcXG4gICAgICBjb25zb2xlLmxvZyhyZXMpXFxyXFxuICAgIH0pXFxyXFxuICAgIC5jYXRjaCgoZSkgPT4ge1xcclxcbiAgICAgIGNvbnNvbGUubG9nKGUpXFxyXFxuICAgIH0pXFxyXFxuICB9LFxcclxcbn0sXFxyXFxuYGBgXFxyXFxuXFxyXFxu7Jes6riw6rmM7KeAIOynhO2Wie2VmOqzoCDtgazroazsnZggY29uc29sZeywveydhCDsl7TslrTrs7TrqbQgc3RhdHVzOjIwMOydmCDrqZTsi5zsp4DqsIAg64+E7LCp7ZW0IOyeiOydhCDqsoPsnLzroZwg6riw64yA66W8IO2WiOqyoOyngOunjCBcXHJcXG5cXHJcXG7tgaztnaAuLi4u7Jet7Iuc64KYIO2VnCDrsojsl5Ag65CY7KeAIOyViuuKlOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA1LiBDT1JTIO2XiOyaqe2VtOyjvOq4sFxcclxcblxcclxcbkFQSSBHYXRld2F57JeQ7IScIENPUlPrpbwg7ZeI7Jqp7ZW0IOykmOyVvO2VnOuLpC4gXFxyXFxuXFxyXFxuIVtDT1JTXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCAyMy5wbmcpXFxyXFxuXFxyXFxuKkNPUlMg7YG066atKlxcclxcblxcclxcbiFbQ09SUzJdKC9hc3NldHMvaW1nL1VudGl0bGVkIDI0LnBuZylcXHJcXG5cXHJcXG4hW0NPUlMzXSgvYXNzZXRzL2ltZy9VbnRpdGxlZCAyNS5wbmcpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7LKrIOuyiOynuCBpbnB1dOywveyXkCDsm5DtlZjripQg7KO87IaM6rCS7J2EIOuEo+yWtOykgOuLpC4g7JiI7Iuc66Gc64qUIGh0dHA6Ly9bbG9jYWxob3N0OjgwODBdKGh0dHA6Ly9sb2NhbGhvc3Q6ODA4MCkg7J2EIOy2lOqwgO2VnCDrqqjsirXsnbjrjbAsIFxcclxcblxcclxcbj4g7KO87J2YISDwn5GPXFxyXFxuPiAqKuuniOyngOunieyXkCAnLyfsiqzrnpjsi5zrpbwg67aZ7J207KeAIOyViuuKlOuLpC4qKlxcclxcblxcclxcbuydtOycoOq5jOyngOuKlCDsnpgg66qo66W06rKg7KeA66eMICBodHRwOi8vW2xvY2FsaG9zdDo4MDgwXShodHRwOi8vbG9jYWxob3N0OjgwODApLyDqs7wg6rCZ7J2AIO2Yle2DnOuhnCDtlojsnYQg65WMIOyemCDsnpHrj5ntlZjsp4Ag7JWK64qUIOusuOygnOqwgCDsnojsnLzri4gg7J20IOygkOydhCDqvK0g7Jyg7J2Y7ZWc64ukLlxcclxcblxcclxcbuydtOugh+qyjCDtlZjqs6Ag64uk7IucIO2PvOydhCDsoITshqHtlbTrs7TrqbQg67CY6rCA7Jq0IHN0YXR1c0NvZGUgMjAw7J2EIOuwm+ydhCDsiJgg7J6I7J2EIOqyg+ydtOuLpC5cXHJcXG5cXHJcXG7sl6zquLDquYzsp4Ag7ISx6rO17ZaI64uk66m0IOqxsOydmCDrp4nrsJTsp4Dsl5Ag64uk64uk656Q64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIDYuIGluZGV4LmpzIOygleumrFxcclxcblxcclxcbiMjIyA2LTEgZXZlbnQgaGFuZGxlclxcclxcblxcclxcbu2YhOyerCBgaW5kZXguanNgIO2MjOydvOydgCBBV1PsoJzqs7XtlbTso7zripQg6riw67O4IO2YleyLnSDqt7jrjIDroZzsnbwg6rKD7J2064ukLlxcclxcblxcclxcbu2VmOyngOunjCBMYW1iZGHsl5DshJwgZXZlbnTqsIAg67Cc7IOd7ZWY6rOgIOydtOqyg+ydhCDtlbjrk6TtlZjquLAg7JyE7ZW07ISc64qUIGV2ZW50IGhhbmRsZXLqsIAg67CY65Oc7IucIO2VhOyalO2VmOuLpFxcclxcblxcclxcbuuUsOudvOyEnCDsi5zsnpEg67aA67aE7J2EIFxcclxcblxcclxcbidleHBvcnRzLmhhbmRsZXIgPSBhc3luYyAoZXZlbnQsIGNhbGxiYWNrKSA9PiB7J1xcclxcblxcclxcbuyZgCDqsJnsnbQg7IiY7KCV7ZW07KSA64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyA2LTIuIOq4sO2DgCDshKTsoJXtlZjquLBcXHJcXG5cXHJcXG7slYTrnpgg7JmE7ISx65CcIOy9lOuTnCDsmIjsi5zrpbwg67O066m07IScIOyekOyLoOyXkOqyjCDrp57rj4TroZ0g7ISk7KCV65CcIOuzgOyImCDqsJLrk6TsnYQg7IiY7KCV7ZW07KSA64ukLlxcclxcblxcclxcbvCfkY8qKuydtOuVjCDrsJjrk5zsi5wg7KO87J2Y7ZWgIOygkOydgCDsi5zsnpHsnYAgZXhwb3J0cy5oYW5kbGVy66GcIOyXtOyWtOyjvOqzoCwg66eI7KeA66eJ7J2AIOq8rSByZXR1cm7qsJLsnYQg64Sj7Ja07KO864+E66GdIO2VnOuLpC4qKlxcclxcbihoYW5kbGVyIOyKpOy9lO2UhCDrsJTquaXsqr3sl5Ag67OA7IiY6rCZ7J2A6rG0IOyEpOyglSDqsIDriqXtlZjri6QpXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuZXhwb3J0cy5oYW5kbGVyID0gYXN5bmMgKGV2ZW50LCBjYWxsYmFjaykgPT4ge1xcclxcbi0tLVxcclxcbmxldCBpbmZvID0gdHJhbnNwb3J0ZXIuc2VuZE1haWwobWFpbE9wdGlvbnMpOyAgIC8vIOuplOydvOydhCDsoITshqHtlZjripQg66eI7KeA66eJIOy9lOuTnFxcclxcbnJldHVybiBpbmZvOyAgICAgLy8g6re466as6rOgIOuniOyngOunieyXkCByZXR1cm7tlbTspJjslbwg7ZWo7IiY6rCAIOygnOuMgOuhnCDsi6TtlonrkJzri6QuXFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcblxcclxcblxcclxcbiMjIyA2LTMuIOyZhOyEsSDsvZTrk5wg7JiI7IucXFxyXFxuXFxyXFxuYGBganN4XFxyXFxuZXhwb3J0cy5oYW5kbGVyID0gYXN5bmMgKGV2ZW50LCBjYWxsYmFjaykgPT4ge1xcclxcbiAgLy8gXFxcInVzZSBzdHJpY3RcXFwiO1xcclxcbiAgY29uc3Qgbm9kZW1haWxlciA9IHJlcXVpcmUoXFxcIm5vZGVtYWlsZXJcXFwiKTtcXHJcXG4gIGNvbnN0IHNtdHBUcmFuc3BvcnQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Jyk7XFxyXFxuXFxyXFxuICAvLyBJZiB5b3UncmUgdXNpbmcgQW1hem9uIFNFUyBpbiBhIHJlZ2lvbiBvdGhlciB0aGFuIFVTIFdlc3QgKE9yZWdvbiksXFxyXFxuICAvLyByZXBsYWNlIGVtYWlsLXNtdHAudXMtd2VzdC0yLmFtYXpvbmF3cy5jb20gd2l0aCB0aGUgQW1hem9uIFNFUyBTTVRQXFxyXFxuICAvLyBlbmRwb2ludCBpbiB0aGUgYXBwcm9wcmlhdGUgQVdTIFJlZ2lvbi5cXHJcXG4gIGNvbnN0IHNtdHBFbmRwb2ludCA9IFxcXCJlbWFpbC1zbXRwLmFwLW5vcnRoZWFzdC0yLmFtYXpvbmF3cy5jb21cXFwiOyAvLyDshJzsmrggcmVnaW9u7J2EIOyCrOyaqe2VmOqzoCDsnojri6TrqbQg6re464yA66GcIOyNqOuPhCDsoovri6QuXFxyXFxuICBcXHJcXG4gIC8vIFRoZSBwb3J0IHRvIHVzZSB3aGVuIGNvbm5lY3RpbmcgdG8gdGhlIFNNVFAgc2VydmVyLlxcclxcbiAgY29uc3QgcG9ydCA9IDU4NztcXHJcXG4gIFxcclxcbiAgLy8gUmVwbGFjZSBzZW5kZXJAZXhhbXBsZS5jb20gd2l0aCB5b3VyIFxcXCJGcm9tXFxcIiBhZGRyZXNzLlxcclxcbiAgLy8gVGhpcyBhZGRyZXNzIG11c3QgYmUgdmVyaWZpZWQgd2l0aCBBbWF6b24gU0VTLlxcclxcbiAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IFxcXCItLS0tQGdtYWlsLmNvbVxcXCI7XFxyXFxuICBcXHJcXG4gIC8vIFJlcGxhY2UgcmVjaXBpZW50QGV4YW1wbGUuY29tIHdpdGggYSBcXFwiVG9cXFwiIGFkZHJlc3MuIElmIHlvdXIgYWNjb3VudFxcclxcbiAgLy8gaXMgc3RpbGwgaW4gdGhlIHNhbmRib3gsIHRoaXMgYWRkcmVzcyBtdXN0IGJlIHZlcmlmaWVkLiBUbyBzcGVjaWZ5XFxyXFxuICAvLyBtdWx0aXBsZSBhZGRyZXNzZXMsIHNlcGFyYXRlIGVhY2ggYWRkcmVzcyB3aXRoIGEgY29tbWEuXFxyXFxuICB2YXIgdG9BZGRyZXNzZXMgPSBcXFwiLS0tLUBnbWFpbC5jb21cXFwiO1xcclxcbiAgXFxyXFxuICAvLyBSZXBsYWNlIHNtdHBfdXNlcm5hbWUgd2l0aCB5b3VyIEFtYXpvbiBTRVMgU01UUCB1c2VyIG5hbWUuXFxyXFxuICBjb25zdCBzbXRwVXNlcm5hbWUgPSBcXFwiQVhYWFhYWFhYWFhYWEVcXFwiO1xcclxcbiAgXFxyXFxuICAvLyBSZXBsYWNlIHNtdHBfcGFzc3dvcmQgd2l0aCB5b3VyIEFtYXpvbiBTRVMgU01UUCBwYXNzd29yZC5cXHJcXG4gIGNvbnN0IHNtdHBQYXNzd29yZCA9IFxcXCJCWFhYWFhYWFhYWFhYWFhYWFhYWFhYWE9cXFwiO1xcclxcbiAgXFxyXFxuICAvLyBUaGUgc3ViamVjdCBsaW5lIG9mIHRoZSBlbWFpbFxcclxcbiAgXFxyXFxuICAvLyBUaGUgZW1haWwgYm9keSBmb3IgcmVjaXBpZW50cyB3aXRoIG5vbi1IVE1MIGVtYWlsIGNsaWVudHMuXFxyXFxuICBcXHJcXG4gIFxcclxcbiAgY29uc3QgYmFzZTY0Ym9keSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmJvZHkpXFxyXFxuICBjb25zdCBib2R5ID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShiYXNlNjRib2R5LCAnYmFzZTY0JykudG9TdHJpbmcoJ3V0ZjgnKSlcXHJcXG4gIGNvbnN0IGRhdGEgPSB7XFxyXFxuICAgIGVtYWlsOiBib2R5LmVtYWlsLFxcclxcbiAgICB0aXRsZTogYm9keS50aXRsZSxcXHJcXG4gICAgY29udGVudDogYm9keS5jb250ZW50LFxcclxcbiAgfVxcclxcbiAgdmFyIHN1YmplY3QgPSBgJHtkYXRhLnRpdGxlfWA7XFxyXFxuICB2YXIgYm9keV90ZXh0ID0gYCR7ZGF0YS5jb250ZW50fWA7XFxyXFxuICAvLyBUaGUgYm9keSBvZiB0aGUgZW1haWwgZm9yIHJlY2lwaWVudHMgd2hvc2UgZW1haWwgY2xpZW50cyBzdXBwb3J0IEhUTUwgY29udGVudC5cXHJcXG4gIHZhciBib2R5X2h0bWwgPSBgPGh0bWw+XFxyXFxuICA8aGVhZD48L2hlYWQ+XFxyXFxuICA8Ym9keT5cXHJcXG4gICAgPGgyPiAke2RhdGEuZW1haWx9IOuLmOycvOuhnOu2gO2EsCBOZXdzSGkg7ZS865Oc67Cx7J20IOuPhOywqe2WiOyKteuLiOuLpC48L2gyPlxcclxcbiAgICA8cD4gJHtkYXRhLmNvbnRlbnR9PC9wPlxcclxcbiAgPC9ib2R5PlxcclxcbiAgPC9odG1sPmA7XFxyXFxuICBcXHJcXG4gIC8vIFRoZSBtZXNzYWdlIHRhZ3MgdGhhdCB5b3Ugd2FudCB0byBhcHBseSB0byB0aGUgZW1haWwuXFxyXFxuICB2YXIgdGFnMCA9IFxcXCJrZXkwPXZhbHVlMFxcXCI7XFxyXFxuICB2YXIgdGFnMSA9IFxcXCJrZXkxPXZhbHVlMVxcXCI7XFxyXFxuICBcXHJcXG5cXHJcXG4gIC8vIENyZWF0ZSB0aGUgU01UUCB0cmFuc3BvcnQuXFxyXFxuICBsZXQgdHJhbnNwb3J0ZXIgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChzbXRwVHJhbnNwb3J0KHtcXHJcXG4gICAgaG9zdDogc210cEVuZHBvaW50LFxcclxcbiAgICBwb3J0OiBwb3J0LFxcclxcbiAgICBzZWN1cmU6IGZhbHNlLCAvLyB0cnVlIGZvciA0NjUsIGZhbHNlIGZvciBvdGhlciBwb3J0c1xcclxcbiAgICBhdXRoOiB7XFxyXFxuICAgICAgdXNlcjogc210cFVzZXJuYW1lLFxcclxcbiAgICAgIHBhc3M6IHNtdHBQYXNzd29yZFxcclxcbiAgICB9XFxyXFxuICB9KSk7XFxyXFxuXFxyXFxuICAvLyBTcGVjaWZ5IHRoZSBmaWVsZHMgaW4gdGhlIGVtYWlsLlxcclxcbiAgbGV0IG1haWxPcHRpb25zID0ge1xcclxcbiAgICBmcm9tOiBzZW5kZXJBZGRyZXNzLFxcclxcbiAgICB0bzogdG9BZGRyZXNzZXMsXFxyXFxuICAgIHN1YmplY3Q6IHN1YmplY3QsXFxyXFxuICAgIHRleHQ6IGJvZHlfdGV4dCxcXHJcXG4gICAgaHRtbDogYm9keV9odG1sLFxcclxcbiAgICBzZXJ2aWNlOiBcXFwiR21haWxcXFwiLFxcclxcbiAgICAvLyBDdXN0b20gaGVhZGVycyBmb3IgY29uZmlndXJhdGlvbiBzZXQgYW5kIG1lc3NhZ2UgdGFncy5cXHJcXG4gICAgaGVhZGVyczoge1xcclxcbiAgICAgICdYLVNFUy1NRVNTQUdFLVRBR1MnOiB0YWcwLFxcclxcbiAgICAgICdYLVNFUy1NRVNTQUdFLVRBR1MnOiB0YWcxXFxyXFxuICAgIH1cXHJcXG4gIH07XFxyXFxuICAvLyBTZW5kIHRoZSBlbWFpbC5cXHJcXG4gIC8vIGxldCBpbmZvID0gYXdhaXQgdHJhbnNwb3J0ZXIuc2VuZE1haWwobWFpbE9wdGlvbnMpO1xcclxcbiAgXFxyXFxuICBsZXQgaW5mbyA9IHRyYW5zcG9ydGVyLnNlbmRNYWlsKG1haWxPcHRpb25zKTtcXHJcXG4gIHJldHVybiBpbmZvO1xcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4qPOyZhOyEsSDrqqjsirU+KlxcclxcblxcclxcbiFb7JmE7ISxMV0oL2Fzc2V0cy9pbWcvVW50aXRsZWQucG5nKVxcclxcblxcclxcbirsgqzsnbTtirjsl5DshJwg7J2066mU7J28IOyekeyEse2VmOuKlCDtj7wqXFxyXFxuXFxyXFxuIVvsmYTshLEyXSgvYXNzZXRzL2ltZy9tYWlsY29tcGxldGUucG5nKVxcclxcblxcclxcbipH66mU7J2866GcIOuCoOyVhOyYpOuKlCDqsrDqs7wqXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu64GdLlxcclxcblxcclxcbi0tLVxcclxcblxcclxcbiMjIyBSZWZlcmVuY2VzLlxcclxcblxcclxcbioq7Jus66eM7ZWY66m0IOydtCDsiJzshJzrjIDroZwg7LC46rOg7ZWY64qUIOqyg+ydhCDstpTsspwuKipcXHJcXG5cXHJcXG4qKu2Kue2eiCwg66eI7KeA66eJ7JeQIOyeiOuKlCB2ZWxvZyDruJTroZzqt7gg6riA7J2AIOq8rSDrp4jsp4Drp4nsl5Ag7J297J2EIOqyg+ydhCDstpTsspztlaguKipcXHJcXG5cXHJcXG5bQW1hem9uIFNFUyBTTVRQIOyduO2EsO2OmOydtOyKpOulvCDsgqzsmqntlZjsl6wg7J2066mU7J28IOyghOyGoV0oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2tvX2tyL3Nlcy9sYXRlc3QvRGV2ZWxvcGVyR3VpZGUvZXhhbXBsZXMtc2VuZC11c2luZy1zbXRwLmh0bWwpXFxyXFxuXFxyXFxuW0FtYXpvbiBTRVMgU01UUCDsnbjthLDtjpjsnbTsiqTrpbwg7IKs7Jqp7ZWY7JesIOydtOuplOydvCDsoITshqFdKGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9rb19rci9zZXMvbGF0ZXN0L0RldmVsb3Blckd1aWRlL2V4YW1wbGVzLXNlbmQtdXNpbmctc210cC5odG1sKVxcclxcblxcclxcbltBV1MgTGFtYmRhIOuwsO2PrCDtjKjtgqTsp4AoTm9kZS5qcyldKGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9rb19rci9sYW1iZGEvbGF0ZXN0L2RnL25vZGVqcy1wYWNrYWdlLmh0bWwpXFxyXFxuXFxyXFxuW0FXUyBMYW1iZGEg7ZWo7IiYIO2VuOuTpOufrChOb2RlLmpzKV0oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2tvX2tyL2xhbWJkYS9sYXRlc3QvZGcvbm9kZWpzLWhhbmRsZXIuaHRtbClcXHJcXG5cXHJcXG5bU2VuZGluZyBlbWFpbCB3aXRoIE5vZGVtYWlsZXIgdXNpbmcgYSBsYW1iZGEgLSBFZHdhcmQgQmVhemVyIEJsb2ddKGh0dHBzOi8vd3d3LmVkd2FyZGJlYXplci5jb20vc2VuZGluZy1lbWFpbC11c2luZy1ub2RlbWFpbGVyLXVzaW5nLWEtbGFtYmRhLylcXHJcXG5cXHJcXG5bSG93IHRvIGxvYWQgbnBtIG1vZHVsZXMgaW4gQVdTIExhbWJkYT9dKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0NDM3OTAwL2hvdy10by1sb2FkLW5wbS1tb2R1bGVzLWluLWF3cy1sYW1iZGEpXFxyXFxuXFxyXFxuW1Z1ZS5qc+yZgCBBV1MgTGFtYmRhLCBOb2RlbWFpbGVyIOuhnCDsnbTrqZTsnbwg7KCE7IahIO2PvCDrp4zrk6TquLBdKGh0dHBzOi8vdmVsb2cuaW8vQGJsdWVzdHJhZ2dsci9WdWUuanMlRUMlOTklODAtQVdTLUxhbWJkYS1Ob2RlbWFpbGVyLSVFQiVBMSU5Qy0lRUMlOUQlQjQlRUIlQTklOTQlRUMlOUQlQkMtJUVDJUEwJTg0JUVDJTg2JUExLSVFRCU4RiVCQy0lRUIlQTclOEMlRUIlOTMlQTQlRUElQjglQjApXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIlZ1ZXjqsIAg66y07JeH7J206rOgIOyZnCDsk7DripTqsoPsnbjqsIA/XFxcIlxcclxcbmRhdGU6IFxcXCIyMDIxLjAzLjEyXFxcIlxcclxcbnRhZ3M6IFxcclxcbiAgLSB2dWVqc1xcclxcbiAgLSB2dWV4XFxyXFxuICAtIGphdmFzY3JpcHRcXHJcXG4gIC0gZXM2XFxyXFxuLS0tXFxyXFxuXFxyXFxuIyMgMS4g67ew7JeR7Iqk64qUIOyZnCDtlYTsmpTtlZzqsIA/XFxyXFxuXFxyXFxuMS4gVnVl7J247Iqk7YS07IqkXFxyXFxuXFxyXFxuIVt2dWXsnbjsiqTthLTsiqRdKC9hc3NldHMvaW1nL3Z1ZeyduOyKpO2EtOyKpC5wbmcpXFxyXFxuXFxyXFxu7ZmU66m0KFZpZXcpIC0+IO2ZlOuptOyXkOyEnOydmCDsnbTrsqTtirgg67Cc7IOdKEFjdGlvbnMpIC0+IOuNsOydtO2EsCDrs4Dqsr0oU3RhdGUp7J2YICoq64uo67Cp7ZalIOuNsOydtO2EsCDtnZDrpoQqKuydtCDtirnsp5XsnoXri4jri6QuXFxyXFxuXFxyXFxu7ZWY7KeA66eMLCBDb21wb25lbnQg6rSA6rOE6rCAIOuzteyeoe2VtOyniOyImOuhnSDsg4Htg5zqtIDrpqzqsIAg7Ja066C164ukXFxyXFxuXFxyXFxuIVvsg4Htg5zqtIDrpqxdKC9hc3NldHMvaW1nL3Z1ZXN0YXRlLnBuZylcXHJcXG5cXHJcXG5gYGBqc3hcXHJcXG4vLyDssLjqs6ApIFByb3Bz66W8IOygleydmO2VoCDrlYwgVnVl7Iqk7YOA7J28IOqwgOydtOuTnOyXkOyEnCDstpTsspztlZjripQg7Iqk7YOA7J28Li4uIFxcclxcbi8vIOyXrOufrOuyiCDrsJjrs7XrkJjrqbQg7L2U65Oc6rCAIOyDgeuLue2eiCDrs7XsnqHtlbTsp4jrk69cXHJcXG5wcm9wczoge1xcclxcbiAgc3RhdHVzOiB7XFxyXFxuICAgIHR5cGU6IFN0cmluZyxcXHJcXG4gICAgcmVxdWlyZWQ6IHRydWUsXFxyXFxuICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gKHZhbHVlKSB7XFxyXFxuICAgICAgcmV0dXJuIFtcXHJcXG4gICAgICAgICdzeW5jaW5nJyxcXHJcXG4gICAgICAgICdzeW5jZWQnLFxcclxcbiAgICAgICAgJ3ZlcnNpb24tY29uZmxpY3QnLFxcclxcbiAgICAgICAgJ2Vycm9yJ1xcclxcbiAgICAgIF0uaW5kZXhPZih2YWx1ZSkgIT09IC0xXFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuMi4g6riA66Gc67KMIOydtOuypO2KuCDrsoTsiqRcXHJcXG5cXHJcXG7snbTrn7Ag7IOB7YOc6rSA66as7J2YIOyWtOugpOybgOydhCDtlbTqsrDtlZjquLAg7JyE7ZW0IOyGjOq3nOuqqCBWdWUg7ZSE66Gc7KCd7Yq47JeQ7ISc64qUIGDsnbTrsqTtirgg67KE7IqkYOulvCDsgqzsmqntlZzri6QuXFxyXFxuXFxyXFxuIVt2dWXsnbjsiqTthLTsiqRdKC9hc3NldHMvaW1nL2V2ZW50YnVzLnBuZylcXHJcXG5cXHJcXG7tlZjsp4Drp4wg6riA66Gc67KMIOydtOuypO2KuCDrsoTsiqTsl5Drj4Qg7ZWc6rOE6rCAIOyeiOuLpC5cXHJcXG5cXHJcXG4hW3Z1ZeyduOyKpO2EtOyKpF0oL2Fzc2V0cy9pbWcvYnVzbGltaXQucG5nKVxcclxcblxcclxcbiMjIDIuIFZ1ZXjrnoA/XFxyXFxuXFxyXFxuPiBBcHBsaWNhdGlvbuydhCDqtazshLHtlZjripQg66qo65OgIOy7tO2PrOuEjO2KuOqwgCDssLjsobDqsIDriqXtlZwg7IOB7YOc66W8IOykkeyVmeyXkOyEnCDqtIDrpqztlZjripQg7KCA7J6l7IaMXFxyXFxuPiBWdWUuanPqsIAg7Zqo7Jyo7KCB7J24IOyXheuNsOydtO2KuOulvCDsnITtlbQg7IS467aE7ZmU65CcIOuwmOydkSDsi5zsiqTthZzsnYQg7Zmc7Jqp7ZWY64+E66GdIO2KueuzhO2eiCDqs6DslYjrkJwgVnVleOuKlCDrt7DsnZgg7IOB7YOc6rSA66asIO2MqO2EtOydtOyekCDrnbzsnbTruIzrn6zrpqzsnbTri6QuIFxcclxcbj4g7KO866GcIOykkeuMgO2YlSDtlITroZzsoJ3tirjsl5Ag7KCB7ZWp7ZWY64ukLlxcclxcblxcclxcblZ1ZXjripQg7J20IOusuOygnOulvCDslrTrlrvqsowg7ZW06rKw7ZWY64qU6rCAPyDihpIg7KCE7JetIOyDge2DnCDqtIDrpqwg66ek64uI7KCAIChTdG9yZSnsl5Ag6rCB6rCB7J2YIENvbXBvbmVudOuTpOydtCDsoJHqt7ztlZjripQg67Cp7IudXFxyXFxuXFxyXFxuIVt2dWXsnbjsiqTthLTsiqRdKC9hc3NldHMvaW1nL3N0b3JlY29uY2VwdC5wbmcpXFxyXFxuXFxyXFxuIVt2dWXsnbjsiqTthLTsiqRdKC9hc3NldHMvaW1nL3Z1ZXN0cnVjdHVyZS5wbmcpXFxyXFxuXFxyXFxu7JWE656Y7JeQ7IScIOqwgeqwgeydmCDso7zsmpQg7Jik7IaM65Ok7J2EIOyekOyEuO2eiCDsgrTtjrTrtIXsi5zri6QuXFxyXFxuXFxyXFxuIyMgMy4g7KO87JqUIOyalOyGjFxcclxcblxcclxcbiMjIyBBLiBTdGF0ZVxcclxcblxcclxcbj4g7Jes65+sIOy7tO2PrOuEjO2KuCDqsITsl5Ag6rO17Jyg65CY64qUIOuNsOydtO2EsOulvCDsnZjrr7jtlanri4jri6RcXHJcXG5cXHJcXG4xLiBzdGF0ZeyEoOyWuFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5uZXcgVnVleC5TdG9yZSh7XFxyXFxuICBzdGF0ZToge1xcclxcbiAgICBtZXNzYWdlOiAnSGVsbG8gVnVlLmpzJ1xcclxcbiAgfVxcclxcbn0pXFxyXFxuYGBgXFxyXFxuXFxyXFxuLSBtZXNzYWdl7J2YIOyDge2DnOqwkiDsoJXsnZhcXHJcXG5cXHJcXG7soJHqt7zrspXsnYA/XFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbjxkaXY+e3sgdGhpcy4kc3RvcmUuc3RhdGUubWVzc2FnZSB9fTwvZGl2PlxcclxcbmBgYFxcclxcblxcclxcbjIuIHN0YXRlIO2YuOy2nFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5kYXRhOiBmdW5jdGlvbiAoKSB7XFxyXFxuXFx0cmV0dXJuIHtcXHJcXG4gICAgICAgIHNoYXJlZFN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGUubWVzc2FnZTtcXHJcXG5cXHR9XFxyXFxufVxcclxcbmBgYFxcclxcblxcclxcbuydtOugh+qyjCDspJHslZnsl5Ag7J6I64qUIHN0b3Jl7J2YIHN0YXRlIOykkSBtZXNzYWdl7JeQIOygkeq3vO2VtOyEnCDtlbTri7kg642w7J207YSw66W8IO2YuOy2nO2VoCDsiJgg7J6I64ukLlxcclxcblxcclxcbu2VmOyngOunjCwg7J20IOuwqeyLneycvOuhnCDtmLjstpztlZjripQg6rKD7J2AIOu5hOy2lOyynCFcXHJcXG5cXHJcXG4jIyMgQi4gR2V0dGVyc1xcclxcblxcclxcbj4g7IOB7YOcKHN0YXRlKSDqsJLsnbQg67OA6rK965CY7JeI7J2EIOuVjCDrs4DtmZTsl5Ag65Sw66W4IOywqOydtOulvCDsnpDrj5nsnLzroZwg67CY7JiB7ZWY7JesIOqwkuydhCDqs4TsgrDtlbTspI3ri4jri6QuXFxyXFxuPiAqKkNvbXB1dGVkIOyGjeyEseqzvCDrp6Tsua0qKlxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5uZXcgVnVleC5TdG9yZSh7XFxyXFxuICBzdGF0ZToge1xcclxcbiAgICBtZXNzYWdlOiAnSGVsbG8gVnVlLmpzJ1xcclxcbiAgfSxcXHJcXG4gIGdldHRlcnM6IHtcXHJcXG4gICAgcmV2ZXJzZU1lc3NhZ2Uoc3RhdGUpIHtcXHJcXG4gICAgICByZXR1cm4gc3RhdGUubWVzc2FnZS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxufSlcXHJcXG5gYGBcXHJcXG5cXHJcXG7snITsl5DshJwgYFN0YXRlYOulvCDshKTrqoXtlaAg65WMIO2YuOy2nO2VmOuKlCDrsKnsi53snYQg7J207JW86riwIO2WiOuKlOuNsCwgVnVl7JeQ7IScIOy2lOyynO2VmOuKlCDrsKnsi53snYAg7J20IGBHZXR0ZXJzYCDrpbwg7Zmc7Jqp7ZW07IScJ+unjCcg7Zi47Lac7ZWgIOqyg+ydhCDqsJXtlZjqsowg7LaU7LKc7ZWc64ukLlxcclxcblxcclxcbiMjIyBDLiBNdXRhdGlvbnNcXHJcXG5cXHJcXG4+IOu3sOyXkeyKpOyXkOyEnCAqKuyDge2DnCDqsJLsnYQg67OA6rK97ZWY64qUIOycoOydvO2VnCDrsKnrspUqKuyeheuLiOuLpC4g7IOB7YOc64qUIO2VreyDgSDrrqTthYzsnbTshZjsnLzroZwg67OA6rK965Cp64uI64ukXFxyXFxuPiAqKk1ldGhvZOyGjeyEseqzvCDrp6Tsua0qKlxcclxcblxcclxcbjEuIE11dGF0aW9uIOyEoOyWuFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5uZXcgVnVleC5TdG9yZSh7XFxyXFxuICBzdGF0ZToge1xcclxcbiAgICBtZXNzYWdlOiAnSGVsbG8gVnVlLmpzJ1xcclxcbiAgfSxcXHJcXG4gIG11dGF0aW9uczoge1xcclxcbiAgICByZXZlcnNlTWVzc2FnZShzdGF0ZSkge1xcclxcbiAgICAgIHN0YXRlLm1lc3NhZ2UgPSBzdGF0ZS5tZXNzYWdlLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59KVxcclxcbmBgYFxcclxcblxcclxcbjIuIE11dGF0aW9uIO2YuOy2nFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5uZXcgVnVlKHtcXHJcXG4gIG1ldGhvZHM6IHtcXHJcXG4gICAgcmV2ZXJzZU1zZygpIHtcXHJcXG4gICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3JldmVyc2VNZXNzYWdlJyk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59KVxcclxcbmBgYFxcclxcblxcclxcbiMjIyBELiBBY3Rpb25zXFxyXFxuXFxyXFxuPiDrrqTthYzsnbTshZgg7KSR7JeQ7IScICoq67mE64+Z6riwIOyymOumrCDroZzsp4Hrk6TsnYQg7KCV7J2YKirtlZjripQg7IaN7ISxXFxyXFxuPiDrj5nquLAg7LKY66as64qUIOuupO2FjOydtOyFmCwg67mE64+Z6riwIOyymOumrOuKlCDslaHshZhcXHJcXG5cXHJcXG4xLiBhY3Rpb25zIOyEoOyWuFxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG5uZXcgVnVleC5TdG9yZSh7XFxyXFxuICBzdGF0ZToge1xcclxcbiAgICBtZXNzYWdlOiAnJ1xcclxcbiAgfSxcXHJcXG4gIG11dGF0aW9uczoge1xcclxcbiAgICByZXZlcnNlTWVzc2FnZShzdGF0ZSwgZGF0YSkge1xcclxcbiAgICAgIHN0YXRlLm1lc3NhZ2UgPSBkYXRhLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJyk7XFxyXFxuICAgIH1cXHJcXG4gIH0sXFxyXFxuICBhY3Rpb25zOiB7XFxyXFxuICAgIGZldGNoTWVzc2FnZShjb250ZXh0KSB7XFxyXFxuICAgICAgYXhpb3MuZ2V0KHVybCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xcclxcbiAgICAgICAgY29udGV4dC5jb21taXQoJ3JldmVyc2VNZXNzYWdlJywgcmVzcG9uc2UubWVzc2FnZSk7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59KVxcclxcbmBgYFxcclxcblxcclxcbjIuIGFjdGlvbnMg7Zi47LacXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbm5ldyBWdWUoe1xcclxcbiAgbWV0aG9kczoge1xcclxcbiAgICBnZXRNZXNzYWdlKCkge1xcclxcbiAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmZXRjaE1lc3NhZ2UnKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbn0pXFxyXFxuYGBgXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyMjIOyalOyVvVxcclxcblxcclxcbi0gVnVlLmpz7JeQ7IScIOykkeyVmSBTdG9yZeyXkCDsoIDsnqXrkJwgU3RhdGXrpbwg7Zi47Lac7ZWgIOuVjOuKlCBgdGhpcy4kc3RvcmUuc3RhdGUubWVzc2FnZWAg7JmAIOqwmeydtCDtmLjstpztlZjripQg6rKD7J20IOyVhOuLiOudvCBgdGhpcy4kc3RvcmUuZ2V0dGVycy5gIOyXkOyEnCBgcmV0dXJuYCDtlbTso7zripQg6rCS7J2EIOqwgOyguOuLpOqwgCDsjajslbwg7ZWc64ukLlxcclxcbi0gU3RhdGUg6rCS7J2EIOuzgOqyve2VmOq4sCDsnITtlbTshJzripQg7Lu07Y+s64SM7Yq47JeQ7IScIOy7pOuwi+ycvOuhnCBgTXV0YXRpb25gIG9yIGBBY3Rpb25g7J2EIO2YuOy2nO2VtOyEnCDrs4Dqsr3tlbTspIDri6QuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyMgNC4g7Zes7Y28IO2VqOyImFxcclxcblxcclxcbj4g7Zes7Y28IO2VqOyImOuKlCDrt7Dsl5HsiqQg6riw7IigIOyalOyGjOuTpOydhCAqKuy7tO2PrOuEjO2KuOyXkOyEnCDrjZQg7Y647ZWY6rKMIOyTuCDsiJgg7J6I64+E66GdIOuPhOyZgOyjvOuKlCBBUEkqKlxcclxcblxcclxcbiMjIyBBLiDsnbzrsJjsoIHsnbgg7KCR6re8IOuwqeuylVxcclxcblxcclxcbmBgYGphdmFzY3JpcHRcXHJcXG48ZGl2Pnt7IHRoaXMuJHN0b3JlLmdldHRlcnMucmV2ZXJzZU1lc3NhZ2UgfX08L2Rpdj5cXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgcmV2ZXJzZU1lc3NhZ2UoKSB7XFxyXFxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMucmV2ZXJzZU1lc3NhZ2U7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG59XFxyXFxuYGBgXFxyXFxuXFxyXFxuIyMjIEIuIO2XrO2NvCDtlajsiJgg7IKs7JqpXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbjxkaXY+e3sgcmV2ZXJzZU1lc3NhZ2UgfX08L2Rpdj5cXHJcXG5gYGBcXHJcXG5cXHJcXG5gYGBqYXZhc2NyaXB0XFxyXFxuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xcclxcblxcclxcbmV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gIGNvbXB1dGVkOiB7XFxyXFxuICAgIC4uLm1hcEdldHRlcnMoWydyZXZlcnNlTWVzc2FnZSddKVxcclxcbiAgfVxcclxcbn1cXHJcXG5gYGBcXHJcXG5cXHJcXG4tIGB0aGlzLiRzdG9yZS4gfn5+YCDsmYAg6rCZ7J20IOuzteyeoe2VnCDrsKnsi51YIOKGkiDqsIDrj4XshLEg7KKL7JWE7KeQXFxyXFxuXFxyXFxuYGBgamF2YXNjcmlwdFxcclxcbmltcG9ydCB7IG1hcFN0YXRlLCBtYXBHZXR0ZXJzLCBtYXBNdXRhdGlvbnMsIG1hcEFjdGlvbnMgfSBmcm9tICd2dWV4J1xcclxcbuuTsSBtYXBHZXR0ZXJz67+Q66eMIOyVhOuLiOudvCBtYXBTdGF0ZSwgbWFwTXV0YXRpb25zLCBtYXBBY3Rpb25zIOuqqOuRkCDsgqzsmqkg6rCA64qlIVxcclxcbmBgYFxcclxcblxcclxcbiMjIDUuIOy2lOqwgCDtlZnsirUg7ZWE7JqUIOyCrO2VrVxcclxcblxcclxcbiMjIyDsiqTthqDslrQg66qo65OI7ZmUXFxyXFxuXFxyXFxuPiDslaDtlIzrpqzsvIDsnbTshZjsl5Ag7Iqk7Yag7Ja066W8IOyggeyaqe2VtOyEnCDsgqzsmqntlZjri6TqsIAg67O066m0IOq4iOuwqSDsiqTthqDslrTsnZgg642p7Ja066as6rCAIOy7pOynhOuLpC4g6re465+065WMIOuNsOydtO2EsCjsg4Htg5wp7J2YIOyEseqyqeuzhOuhnCDsiqTthqDslrTrpbwg66qo65OI7ZmUIO2VtOyjvOuptCDqtIDrpqztlZjquLAg7IiY7JuU7ZWY64ukLlxcclxcblxcclxcbltNb2R1bGVzIC0gQ3JhY2tpbmcgVnVlLmpzXShodHRwczovL2pvc2h1YTE5ODguZ2l0aHViLmlvL3Z1ZS1jYW1wL3Z1ZXgvbW9kdWxlcy5odG1sIyVFQyU4QSVBNCVFRCU4NiVBMCVFQyU5NiVCNC0lRUIlQUElQTglRUIlOTMlODglRUQlOTklOTQtJUVDJUJEJTk0JUVCJTkzJTlDLSVFRCU5OCU5NSVFQyU4QiU5RClcXHJcXG5cXHJcXG4jIyMgRVM2IC0g7Iqk7ZSE66CI65OcIOyYpO2NvOugiOydtO2EsFxcclxcblxcclxcbltbRVM2XSBTcHJlYWQgT3BlcmF0b3IgKOyKpO2UhOugiOuTnCDsl7DsgrDsnpApXShodHRwczovL3BhcGVyYmxvY2sudGlzdG9yeS5jb20vNjIpXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxuUmVmZXJlbmNlc1xcclxcblxcclxcbltTdGF0ZSAtIENyYWNraW5nIFZ1ZS5qc10oaHR0cHM6Ly9qb3NodWExOTg4LmdpdGh1Yi5pby92dWUtY2FtcC92dWV4L3N0YXRlLmh0bWwpXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIjIwMjEg7ZSE66Gg7Yq47JeU65OcIOqwnOuwnOyekCDsp4HsoJEg67Cb7J2AIOq4sOyIoCDrqbTsoJEg7KeI66y4IOumrOyKpO2KuOyZgCDripDrgoDsoJBcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDYuMDJcXFwiXFxyXFxudGFnczogXFxyXFxuICAtIHJlYWN0XFxyXFxuICAtIOumrOyVoe2KuFxcclxcbiAgLSDtlITroaDtirjsl5Trk5xcXHJcXG4gIC0gVnVlXFxyXFxuICAtIFZ1ZWpzXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyAyMDIxIOq4sOyIoOuptOygkSDsp4jrrLjqs7wg64qQ64KA7KCQXFxyXFxuXFxyXFxu7KGw6riIIOq5jOuoueyXiOuKlOuNsCwg7LWc64yA7ZWcIOq4sOyWteuCmOuKlCDqsoPrk6TsnYQg7KCB7Ja067O06rKg7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIDpib29rOiDsp4jrrLjrpqzsiqTtirhcXHJcXG5cXHJcXG4tIOuvuOuTpOybqOyWtOuegCDrrLTsl4fsnbjqsIDsmpQ/XFxyXFxuLSBSZWFjdCBIb29r7JeQIOuMgO2VtCDshKTrqoXtlbTso7zshLjsmpQuXFxyXFxuLSBDRE7snbQg66y07JeH7J246rCA7JqUP1xcclxcbi0g6rWQ7LCp7IOB7YOcKERlYWRsb2NrKeydhCDtlbTqsrDtlZjripQg67Cp67KV7J20IOustOyXh+yduOqwgOyalD9cXHJcXG5cXHJcXG4tIEhUVFDsl5Ag64yA7ZW0IOyEpOuqhe2VtCDso7zshLjsmpQuXFxyXFxuICAtIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGXsl5Ag64yA7ZW0IOyEpOuqhe2VtOyjvOyEuOyalC5cXHJcXG4tIOyekOujjOq1rOyhsCBMaW5rZWQgTGlzdOyXkCDrjIDtlbQg7ISk66qF7ZW07KO87IS47JqULlxcclxcbiAgLSBMaW5rZWQgTGlzdOyZgCBBcnJheeydmCDssKjsnbTripQg66y07JeH7J246rCA7JqUP1xcclxcbiAgLSDsg4jroZzsmrQg6rKD7J2EIOyCveyehSwg7IKt7KCc7ZWY64qUIO2KuOuenOyereyFmOydmCDqsr3smrAgQXJyYXnsmYAgTGlua2VkIExpc3TspJEg7Ja065akIOqyg+ydmCDshLHriqXsnbQg642UIOyii+uCmOyalD9cXHJcXG4tIFJlc3RmdWwgQVBJ7JeQIOuMgO2VtCDshKTrqoXtlbTso7zshLjsmpQuXFxyXFxuICAtIFJlc3RmdWwgQVBJ7J2YIOyepeygkOydgD9cXHJcXG4gIC0gUmVzdGZ1bCBBUEnsnZgg64uo7KCQ7J2AP1xcclxcbi0gamF2YXNjcmlwdCB2YXIsIGxldCwgY29uc3TsnZgg7LCo7J2064qUP1xcclxcbi0gamF2YXNjcmlwdCBzY29wZeyXkCDrjIDtlbQg7ISk66qF7ZW0IOyjvOyEuOyalFxcclxcbi0gZXZlbnQgbG9vcOyXkCDrjIDtlbQg7J6Q7IS47Z6IIOyEpOuqhe2VtOyjvOyEuOyalC5cXHJcXG4gIC0gd2ViIEFQSeyXkOyEnCDro6jtlIQg64+M6rOgIFF1ZXVl66GcIOuTpOyWtOqwgOuKlOuNsCDsnbQg65WMIFF1ZXVl7J2YIOyiheulmOuKlCDrrLTsl4fsnbQg7J6I64KY7JqUP1xcclxcbi0gQ1NS6rO8IFNTUuydmCDssKjsnbTsoJDsl5Ag64yA7ZW0IOunkO2VtOyjvOyEuOyalC5cXHJcXG4tIChWdWUuanMpIENvbXB1dGVk7JmAIFdhdGNo7J2YIOywqOydtOulvCDrp5DtlbTso7zshLjsmpQuXFxyXFxuICAtIOyEseuKpeyggeycvOuhnCDslrTrlqQg6rKD7J20IOuNlCDrm7DslrTrgpzqsIDsmpQ/XFxyXFxuLSAoVnVlLmpzKSDsu7Ttj6zrhIztirjqsIAgUmUtcmVuZGVyaW5nIOuQmOuKlCDqsr3smrDripQg7Ja065akIOqyveyasOyduOqwgOyalD9cXHJcXG4tIChWdWUuanMpIFZVRVjsl5Ag64yA7ZW0IOyEpOuqhe2VtOyjvOyEuOyalC5cXHJcXG5cXHJcXG4tLS1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA6c3dlYXQ6IOuKkOuCgOygkFxcclxcblxcclxcbuuptOygkeyXkOyEnCDsooAg6rec66qo6rCAIOyeiOuKlO2ajOyCrOyZgCDqt5zrqqjqsIAg7J6R7J2AIO2ajOyCrOyZgOydmCDssKjsnbTsoJDsnbQg64qQ6ru07KeEIOygkOydgCDtgbAg7ZqM7IKs7J287IiY66GdIOyWuOyWtOuCmCDsu7Ttk6jthLAg6rO17ZWZ7KCBIOyngOyLnSDqt7jrpqzqs6Ag6re46rKD7J20IOyekeuPme2VmOuKlCAn7JuQ66asJ+yZgCAn7J207JygJ+ulvCDslYTripTsp4Drpbwg66y764qUIOyniOusuOydtCDrp47slZjsirXri4jri6QuIOyDgeuMgOyggeycvOuhnCDqt5zrqqjqsIAg7KGw6riIIOyekeydgCDtmozsgqzsnbzsiJjroZ0g7Iqk7YKs7IWL6rO8IOyWtOuWpCDtlITroZzsoJ3tirgg6rK97ZeY7J20IOyeiOuKlOyngCwg6rGw6riw7JeQ7IScIOunoeydgCDsl63tlaDqs7wg64u064u57ZWcIOu2gOu2hOydhCDrp47snbQg66y87Ja067O464uk64qUIOuKkOuCjOydhCDrsJvslZjsirXri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7ZSE66Gg7Yq47JeU65OcIOqwnOuwnOyXkCDstIjsoJDsnYQg66ee7Law7IScIOyigCDrjZQg7J6Q7IS47Z6IIOyWmOq4sO2VmOyekOuptCwgXFxyXFxuXFxyXFxuIyMjIOyDgeuMgOyggeycvOuhnCDtgbAg7ZqM7IKs7J287IiY66GdIFxcclxcblxcclxcbi0g7J6Q67CU7Iqk7YGs66a97Yq4IOyWuOyWtFxcclxcblxcclxcbiAgLSB2YXIsIGxldCwgY29uc3TsnZgg7LCo7J20ICggW+yXrOq4sOyXkCDsnpgg7KCV66as65CY7Ja07J6I64Sk7JqUIV0oaHR0cHM6Ly9saWtlbGlvbnN1bmdndWsuZ2l0aHViLmlvLzIxLTA4LTA5LyVFQyU5RSU5MCVFQiVCMCU5NCVFQyU4QSVBNCVFRCU4MSVBQyVFQiVBNiVCRCVFRCU4QSVCOC12YXItbGV0LWNvbnN0LSVFQyVBNyU4NCVFQyVBNyU5Qy0lRUMlQjAlQTglRUMlOUQlQjQlRUMlQTAlOTAtJUVBJUI1JUFDJUVCJUIzJTg0JUVEJTk1JTk4JUVBJUI4JUIwKSApXFxyXFxuICAtIO2YuOydtOyKpO2MhVxcclxcbiAgLSB0aGlzXFxyXFxuXFxyXFxuLSDruIzrnbzsmrDsoIAg64+Z7J6RIOybkOumrFxcclxcblxcclxcbiAgLSBcXFwi67iM65287Jqw7KCAIOqygOyDieywveyXkCB3d3cuZ29vZ2xlLmNvbeydhCDqsoDsg4ntlZjqs6Ag64KY66m0IOq3uCDri6TsnYwg7J2066SE7KeA64qUIOuPmeyekeydhCDshKTrqoXtlbTrs7TshLjsmpRcXFwiXFxyXFxuICAtIOydtOuypO2KuCDro6jtlIRcXHJcXG5cXHJcXG4tIERPTe2KuOumrFxcclxcblxcclxcbiAgLSBSZWZsb3cgJiBSZXBhaW50XFxyXFxuXFxyXFxuICDsmYAg6rSA66Co65CcIOy1nOygge2ZlOyXkCDqtIDtlZwg64K07Jqp7JeQIOuMgO2VnCDsp4jrrLjsnYQg67Cb7JWY7Iq164uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIyDsg4HrjIDsoIHsnLzroZwg7J6R7J2AIO2ajOyCrOydvOyImOuhnVxcclxcblxcclxcbi0g7ZSE66Gg7Yq47JeU65OcIO2UhOugiOyehOybjO2BrCDqtIDroKgg7KeI66y4XFxyXFxuICAtIFNQQeuegCDrrLTsl4fsnbjqsIDsmpQ/XFxyXFxuICAgIC0g6re466CH64uk66m0IFNQQeulvCDsk7DripQg7J207Jyg64qUIOustOyXh+yduOqwgOyalD9cXHJcXG4gICAgLSBTUEHsnZgg7J6l64uo7KCQ7J2EIOyEpOuqhe2VtOuztOyEuOyalC5cXHJcXG4gIC0gKFJlYWN0KSDrpqzslaHtirgg7Lu07Y+s64SM7Yq4IOudvOydtO2UhCDsgqzsnbTtgbRcXHJcXG4gIC0gKFJlYWN0KSDtgbTrnpjsiqTtmJUg7Lu07Y+s64SM7Yq47JmAIO2VqOyImO2YlSDsu7Ttj6zrhIztirjsnZgg7LCo7J2066W8IOyVjOqzoCDsnojripTqsIA/XFxyXFxuICAtIChWdWVqcykgVnVlIOyduOyKpO2EtOyKpCDrnbzsnbTtlIQg7IKs7J207YG0XFxyXFxuLSDsoJXsoIEg7Ja47Ja0IOyCrOyaqSDqsr3tl5ggXFxyXFxuICAtIFxcXCJUeXBlc2NyaXB0IOyNqOuzuOyggSDsnojsnLzsi6DqsIDsmpQ/XFxcIlxcclxcbiAgLSBUeXBlc2NyaXB07J2YIGludGVyZmFjZeyZgCBjbGFzc+ywqOydtOulvCDshKTrqoXtlbTso7zshLjsmpQuXFxyXFxuICAtIFR5cGVzY3JpcHQg7KCc64Sk66at7J2AIOustOyXh+ydtOqzoCDslrjsoJwg7IKs7Jqp7ZWY64KY7JqUP1xcclxcbiAgICAtIOycoOuLiOyWuCDtg4DsnoXsnLzroZwg7JO4IOyImOuPhCDsnojripTrjbAg6rWz7J20IOygnOuEpOumreydhCDsk7DripQg7J207Jyg6rCAIOutmOq5jOyalD9cXHJcXG4tIO2UhOuhnOygne2KuCDqtIDroKgg6rK97ZeY7JeQ7IScIOuNlCDquYrsnYAg64K07JqpIOyniOusuFxcclxcbiAgLSBcXFwi6rKA7IOJIOq4sOuKpeydhCDqsJzrsJztlZjshajrjZjrjbAsIOyeheugpeywveyXkCDsnbjtkovsnbQg7J6I7J2EIOuVjOuniOuLpCBzdGF0ZeqwkuydhCDrs4Dqsr3tlojsl4jrgpjsmpQ/IOyVhOuLiOuptCDri6Trpbgg67Cp7Iud7J2EIOyCrOyaqe2WiOyXiOuCmOyalD9cXFwiICsgXFxcIuyWtOuWu+qyjCDtlZjrqbQg642UIO2aqOycqOyggeycvOuhnCDrp4zrk6Qg7IiYIOyeiOydhOq5jOyalD9cXFwiXFxyXFxuICAgIC0g64KY7KSR7JeQIOyVjOqzoOuztOuLiCDsnbQg7KeI66y47J2AIGRlYm91bmNl7JeQIOuMgO2VtCDslYzqs6Ag7J6I64OQ64qUIOyniOusuOydtOyXiOyKteuLiOuLpC4g7IKs64K07JeQ7IScIOqygOyDieq4sOuKpeyXkOyEnCDsnbQgYGRlYm91bmNlYCDqtIDroKgg7J207IqI6rCAIOyeiOyXiOqzoCDrp4jsuagg6re465WMIOuptOygkeydtOyWtOyEnCDsg53qsIHrgpjshJwg7KeI66y47ZWY7IWo64uk6rOgIO2VmOuNlOudvOq1rOyalCDjhY7jhY4uXFxyXFxuICAtIOuLpO2BrOuqqOuTnOulvCDqsJzrsJztlZjshajripTrjbAg7J2065WMIOuLpO2BrOuqqOuTnOyduOyngCDslYTri4zsp4Ag64KY7YOA64K064qUIHRydWUvZmFsc2Ug7ZSM656Y6re464qUIOyWtOuUlOyXkCDsoIDsnqXtlZjshajrgpjsmpQ/IFxcclxcbiAgICAtIGxvY2FsU3RvcmFnZeuDkCBzZXNzaW9uU3RvcmFnZeuDkCBjYWNoZeuDkOulvCDrrLvripQg7KeI66y4XFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7Zi87J6Q66eM7J2YIOuHjO2UvOyFnOydtOyngCDslYrsnYTquYwg7Iu27J2A642wLCDslYTrp4jrj4Qg7J6R7J2AIOq3nOuqqOydvOyImOuhnSDsp4DquIjquYzsp4Ag66eM65Ok7Ja07JioIOqyg+uztOuLpOuKlCDslZ7snLzroZwg66eM65Ok7Ja0IOuCmOqwgOyVvCDtlaAg6rKD7J20IOuNlCDrp47quLAg65WM66y47JeQIOuwlOuhnCDtlanrpZjtlbTshJwg67mI7YuI7JeG7J20IOyekeyXheydhCDsnbTslrTrgpjqsIgg7IiYIOyeiOuPhOuhnSDqtIDroKgg6riw7Iig7Iqk7YOd7J2EIO2ZnOyaqe2VnCDtlITroZzsoJ3tirgg6rK97ZeY7J20IOyeiOyWtCDsvZTrk5zrpbwg67O06rOgIOu5oOultOqyjCDtjIzslYXtlaAg7IiYIOyeiOuKlCDsnbTrpbjrsJQgYOymieyLnCDsoITroKXqsJBg7J2EIOywvuuKlCDqsr3tlqXshLHsnbQg7J6I64uk6rOgIOuKkOq7tOyhjOyKteuLiOuLpC5cXHJcXG5cXHJcXG7rsJjrqbQsIO2BsCDquLDsl4XsnbzsiJjroZ0g7J2466Cl7J20IOunjuqzoCDsnbTrr7gg7Kec7Jes7KeEIOy9lOuTnOydmCDslpHrj4Qg7IOB64u57Z6IIOuwqeuMgO2VqeuLiOuLpC4g7KO864uI7Ja0IOqwnOuwnOyekOqwgCDrs4Qg7IOd6rCB7JeG7J20IOynoCDsvZTrk5zqsIAg7J2Y64+E7LmYIOyViuydgCDsl7Dsh4TsnpHsmqnsnYQg7J287Jy87LycIOuMgOq3nOuqqCDsi5zsiqTthZzsl5Ag7JWI7KKL7J2AIOyYge2WpeydhCDrgbzsuZjsp4Ag7JWK64+E66GdIO2VmOuKlCDqsoPsnbQg642UIOykkeyalO2VmOqyjCDsg53qsIHtlZjsp4Ag7JWK7J2E6rmMIOyLtuyKteuLiOuLpC4g65WM66y47JeQIOuLpOyWke2VnCDquLDstIgg64K07Jqp6rO8IOybkOumrOulvCDsnbTtlbTtlZjsl6wg67KE6re466W8IOy1nOyGjO2ZlCDtlZjripQg7J6YIOynoCDsvZTrk5zqsIAg7KSR7JqU7ZWY66+A66GcIOydtOufsCDrgrTsmqnsnYQg7J2066+4IOyemCDslYzqs6Ag7J6I6rOgIOu5oOuluCDtlZnsirXsnYQg7ZWgIOyImCDsnojripQg7J6g7J6s66Cl7J2EIOqwluqzoCDsnojripQg7J247J6s65Ok7J2EIOywvuyVhOyEnCDsnbTrn7Ag6rK97Zal7ISx7J20IOyeiOyngCDslYrsnYTquYwg7LaU7Lih7ZW067SF64uI64ukLi4uXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxu7JWE66y07Kq866GdIOydtOq4gOydgCDrs7Tsi6Ag67aE65Ok7J2AIOuqqOuRkCDsoIAg67O064ukIOuNlCDsoovsnYAg64u167OAIO2VmOyLnOq4uCDrsJTrno3ri4jri6QuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXHJcXG50aXRsZTogXFxcIjQ164WEIOuPmeyViCDqsJzrsJzsnpDroZwg7J287ZWY66mwIOuwsOyatOqyg+uTpFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wMS4xMFxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gZGV2ZWxvcGVyXFxyXFxuICAtIEN1cnNlIG9mIEtub3dsZWRnZVxcclxcbi0tLVxcclxcblxcclxcbiMgV2hhdCBJ4oCZdmUgTGVhcm5lZCBpbiA0NSBZZWFycyBpbiB0aGUgU29mdHdhcmUgSW5kdXN0cnlcXHJcXG5cXHJcXG40NeuFhCDrj5nslYgg7IaM7ZSE7Yq47Juo7Ja0IOyCsOyXheyXkOyEnCDsnbztlojrjZggSm9lbCBHb2xkYmVyZ+qwgCDsnYDth7TtlZjrqbAg7IKs64K0IOuPmeujjOuTpOyXkOqyjCDrp4jsp4Drp4nsnLzroZwg64Ko6ri0IOyii+ydgCDquIDsnbQg7J6I7Ja0IOqzteycoOuTnOumveuLiOuLpC5cXHJcXG5cXHJcXG5bV2hhdCBJ4oCZdmUgTGVhcm5lZCBpbiA0NSBZZWFycyBpbiB0aGUgU29mdHdhcmUgSW5kdXN0cnldKGh0dHBzOi8vd3d3LmJ0aTM2MC5jb20vd2hhdC1pdmUtbGVhcm5lZC1pbi00NS15ZWFycy1pbi10aGUtc29mdHdhcmUtaW5kdXN0cnkvKVxcclxcblxcclxcblxcclxcblxcclxcbi0tLVxcclxcblxcclxcbiMjICpJTlRSTypcXHJcXG5cXHJcXG7shoztlITtirjsm6jslrQg7IKw7JeF7JeQ7ISc7J2YIDQw7JesIOuFhOydhCDrkJjrj4zslYQg67O066m0IOyWvOuniOuCmCDrp47snYAg67OA7ZmU6rCAIOyeiOyXiOuKlOyngCDrhoDrnpDsirXri4jri6QuIOyggOuKlCAq7Y6A7LmYIOy5tOuTnCoo7JWE656YIOydtOuvuOyngCnroZwg6rK966Cl7J2EIOyLnOyeke2VtOyEnCDrp4jsp4Drp4nsnYAg7YG065287Jqw65OcIOy7tO2TqO2MhSDsi5zrjIDroZwg64Gd7J2EIOunuuqzoCDsnojsirXri4jri6QuIOydtOufrO2VnCDrqqjrk6Ag67OA7ZmU7JeQ64+EIOu2iOq1rO2VmOqzoCDsoJwg7Luk66as7Ja0IOyghOuwmOyXkCDqsbjss5Ag7KCA66W8IOuPhOyZlOuNmCDrp47snYAg7JuQ7LmZ7J2AIOuzgO2VmOyngCDslYrslZjsirXri4jri6QuIOydtOygnCDtgqTrs7Trk5zsl5DshJwg66y865+s64KY66m07IScIOyGjO2UhO2KuOybqOyWtCDsl5Tsp4Dri4jslrTroZzshJzsnZgg6rK966Cl7JeQ7IScIOuwsOyatCBgNiDqsIDsp4Ag7JWE7J2065SU7Ja0YOulvCDqs7XsnKDtlZjqs6Ag7Iu27Iq164uI64ukLlxcclxcblxcclxcbiFbUHVuY2hlZCBjYXJkXSgvYXNzZXRzL2ltZy8zMDBweC1Vc2VkX1B1bmNoY2FyZF8oNTE1MTI4NjE2MSkuanBnKVxcclxcblxcclxcblxcclxcblxcclxcbiMjIDEuICpCZXdhcmUgb2YgdGhlIEN1cnNlIG9mIEtub3dsZWRnZSpcXHJcXG5cXHJcXG4+ICrsp4Dsi53snZgg7KCA7KO866W8IOyhsOyLrO2VmOudvCpcXHJcXG5cXHJcXG7ri7nsi6DsnbQg66y07Ja46rCA66W8IOyVjOqzoOyeiOydhCDrlYwg6re4IOqyg+ydhCDrqqjrpbTripQg6rKD7J20IOyWtOuWpCDqsoPsnbjsp4Ag7IOB7IOB7ZWY64qUIOqyg+ydgCDqsbDsnZgg67aI6rCA64ql7JeQIOqwgOq5neyKteuLiOuLpC4g7J206rKD7J2AIOyngOyLneydmCDsoIDso7zsnbTrqbAg7IiY66eO7J2AIOyYpO2VtOyZgCDruYTtmqjsnKjshLHsnZgg6re87JuQ7J6F64uI64ukLiDrs7XsnqHshLHsl5Ag7J217IiZ7ZWcIOuYkeuYke2VnCDsgqzrnozrk6TsnYAg7Yq57Z6IIOydtOqyg+yXkCDst6jslb3tlaAg7IiYIOyeiOyKteuLiOuLpCFcXHJcXG5cXHJcXG7sp4Dsi53snZgg7KCA7KO866W8IOqyveqzhO2VmOyngCDslYrsnLzrqbQg7L2U65Oc66W8IO2PrO2VqO2VnCDrqqjrk6Ag7ZiV7YOc7J2YIOy7pOuupOuLiOy8gOydtOyFmOydhCDrs7XsnqHtlZjqsowg7ZWgIOqwgOuKpeyEseydtCDsnojsirXri4jri6QuIOyXheustOqwgCDsoITrrLjtmZQg65Cg7IiY66GdIOy0iOuztOyekOqwgCDsnbTtlbTtlaAg7IiYIOyXhuuKlCDrsKnsi53snLzroZwg7J2Y7IKs7IaM7Ya1IO2VoCDsnITtl5jsnbQg7Luk7KeR64uI64ukLiBcXHJcXG5cXHJcXG7rgYrsnoTsl4bsnbQg7KeA7Iud7J2YIOyggOyjvOyZgCDsi7jsmrDshLjsmpQuIOuTo+uKlCDsgqzrnozsnbQg7J207ZW07ZWgIOyImCDsnojqsowg66eQ7ZWY6riwIOychO2VtCDrhbjroKXtlZjshLjsmpQuIOyymOydjOycvOuhnCDshozthrXtlZjripQg64K07Jqp7J2EIOuwsOyasOuKlCDqsoPsnbQg7Ja065akIOqyg+yduOyngCDsg4Hsg4HtlbTrs7TshLjsmpQuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMi4gKkZvY3VzIG9uIHRoZSBGdW5kYW1lbnRhbHMqXFxyXFxuXFxyXFxuPiAq7ZW17Ius7JeQIOynkeykke2VtOudvCpcXHJcXG5cXHJcXG7quLDsiKDsnYAg64GK7J6E7JeG7J20IOuzgO2ZlO2VmOyngOunjCDshoztlITtirjsm6jslrQg6rCc67Cc7JeQIOuMgO2VnCDrqocg6rCA7KeAIOq4sOuzuOyggeyduCDsoJHqt7wg67Cp7Iud7J2AIOydtOufrO2VnCDtirjroIzrk5zrpbwg7LSI7JuU7ZWp64uI64ukLiDri6TsnYzsnYAg7Jik656r64+Z7JWIIOycoOyngOuQoCA2IOqwgOyngCDquLDrs7gg7IKs7ZWt7J6F64uI64ukLlxcclxcblxcclxcbi0gKirtjIDsm4ztgawqKiDigJQg7ZuM66Wt7ZWcIO2MgOydgCDtm4zrpa3tlZwg7IaM7ZSE7Yq47Juo7Ja066W8IOq1rOy2le2VqeuLiOuLpC4g7YyA7JuM7YGs66W8IOuLueyXsO2VmOqyjCDsg53qsIHtlZjsp4Ag66eI7IS47JqULlxcclxcbi0gKirsi6DrorAqKiDigJQg7YyA7J2AIOyLoOuisOydmCDsho3rj4TroZwg7JuA7KeB7J6F64uI64ukLiDtlajqu5gg7J287ZWY6rOgIOyLtuydgCDsi6DrorDtlaAg7IiYIOyeiOuKlCDsgqzrnozsnbQg65CY7IS47JqULlxcclxcbi0gKirsnZjsgqwg7IaM7Ya1Kiog4oCUIOygleynge2VmOqzoCDsoIHqt7nsoIHsnLzroZwg7J2Y7IKsIOyGjO2Gte2VmOyEuOyalC4g6re466as6rOgIOyngOyLneydmCDsoIDso7zrpbwg7ZS87ZWY7IS47JqULlxcclxcbi0gKirtlansnZgg7LaU6rWsKiog4oCUIOyghOyytCDtjIDsnbQg7ZWo6ruYIO2VoCDsi5zqsITsnYQg6rCA7KeA7IS47JqULiDthqDroaDqs7wg67aI7J287LmY6rCAIOy1nOyDgeydmCDshpTro6jshZjsnYQg7KCc6rO17ZWY64+E66GdIO2VmOyEuOyalC5cXHJcXG4tICoq7J6Q64+Z7ZmUIOuQnCDthYzsiqTtirgqKiDigJQg7J6YIO2FjOyKpO2KuCDrkJwg7L2U65Oc66W8IOyCrOyaqe2VmOuptCDtjIDsnbQg7J6Q7Iug6rCQ7J2EIOqwgOyngOqzoCDruaDrpbTqsowg64uk7J2MIOugiOuyqOuhnCDsnbTrj5ntlaAg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG4tICoq6rmU64GU7ZWY6rOgIOydtO2VtO2VmOq4sCDsiazsmrAg66mwIO2DkOyDiSDqsIDriqXtlZwg7L2U65OcIOuwjyDrlJTsnpDsnbgqKiDigJQg7L2U65Oc66W8IOyduOyImCDrsJvsnYQg64uk7J2MIOyXlOyngOuLiOyWtOulvCDqs6DqsJ3snLzroZwg7IOd6rCB7ZWY7IS47JqULiDtm4TsnoTsnpDqsIAg7J296riwLCDsnKDsp4Ag6rSA66asIOuwjyDsl4XrjbDsnbTtirjtlZjripQg642wIOusuOygnOqwgCDsl4bripQg7L2U65Oc66W8IOu5jOuTnO2VmOuPhOuhnSDrhbjroKXtlZjshLjsmpQuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgMy4gKlNpbXBsaWNpdHkqXFxyXFxuXFxyXFxu67O17J6h7ISx6rO87J2YIOyLuOybgOydgCDrgZ3snbQg7JeG64qUIOybkOyduOyeheuLiOuLpC4g7IaU66Oo7IWY7J2AIOqwgOuKpe2VnCDtlZwg6rCE64uo7ZW07JW8IO2VqeuLiOuLpC4g7L2U65Oc66W8IOq0gOumrCDtlaAg64uk7J2MIOyCrOuejOydtCDri7nsi6Drp4ztgbwg65iR65iR7ZWY7KeAIOyViuuLpOqzoCDqsIDsoJXtlanri4jri6QuIOuNlCDsoIHsnYAg7IiY7J2YIOq4sOyIoOydhCDsgqzsmqntlaAg7IiYIOyeiOycvOuptCDqt7jroIfqsowg7ZWY7Iut7Iuc7JikLlxcclxcblxcclxcbj4gICrigJxBIGRlc2lnbmVyIGtub3dzIGhlIGhhcyBhY2hpZXZlZCBwZXJmZWN0aW9uIG5vdCB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgbGVmdCB0byBhZGQsIGJ1dCB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgbGVmdCB0byB0YWtlIGF3YXku4oCdKiAtKkFudG9pbmUgZGUgU2FpbnQtRXh1cGVyeSpcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA0LiAqU2VlayBGaXJzdCB0byBVbmRlcnN0YW5kKlxcclxcblxcclxcbj4gKuydtO2VtO2VmOq4sCDsnITtlbQg66i87KCAIOywvuyVhOu0kOudvCogLSDri6Trpbgg7IKs656M7J2YIOunkOydhCDsnbTtlbTtlZjquLAg7JyE7ZW0IOq3uOuTpOydmCDrp5DsnYQg66i87KCAIOuTpOyWtOudvFxcclxcblxcclxcbmDsiqTti7DruJAg7L2U67mE7J2YIDfqsIDsp4Ag7Iq16rSAYCAoVGhlIDcgSGFiaXRzIG9mIEhpZ2hseSBFZmZlY3RpdmUgUGVvcGxlIC0g7Iqk7Yuw67iQIOy9lOu5hOqwgCDsk7Qg67mE7KaI64uI7IqkL+yekOq4sOqzhOuwnOyEnOydtOuLpC4g7J20IOyxheydgCDsoIQg7IS46rOE7JeQ7IScIDM46rCcIOyWuOyWtOuhnCDrsojsl63rkJjsl4jsnLzrqbAsIOy0nSAxNTAw66eM67aAIOydtOyDgSDtjJDrp6TrkJjsl4jri6QuIOuMgO2VnOuvvOq1reyXkOyEnOuKlCAxOTk064WEIOy1nOy0iOuhnCDstpzqsITrkJjslrQgMjAyMeuFhCDtmITsnqzquYzsp4Ag7JW9IDMwMOunjOu2gOqwgCDtjJTrprAg67Kg7Iqk7Yq4IOyFgOufrOydtOuLpC4p7KSRIO2VmOuCmOuKlCBcXFwi66i87KCAIOydtO2VtO2VmOugpOqzoCDrhbjroKXtlbTrnbwsIOq3uOufrOuptCDsnbTtlbTrkKAg6rKD7J2064ukLlxcXCLsnoXri4jri6QuIOydtCDqsqnslrjsnYAg7ZuM66Wt7ZWcIOyyrey3qOyekChMaXN0ZW5lcinqsIAg65CY6riwIOychO2VtOyEnCwg65iQIOyii+ydgCDrj5nro4zqsIAg65CY6riwIOychO2VtCDquLDtg4Ag64uk66W4IOyWtOuWpCDsobDslrjrs7Tri6Trj4Qg64KY7JeQ6rKMIOuPhOybgOydtCDrkJjsl4jsirXri4jri6QuIFxcclxcblxcclxcbuunjOyVvSDsl6zrn6zrtoTsnbQg64uk66W4IOyCrOuejOuTpOyXkOqyjCDsmIHtlqXroKXsnYQg64G87LmY6rOgIO2aqOqzvOyggeycvOuhnCDsnbztlZjqs6Ag7Iu264uk66m0LCDrqLzsoIAg6re465Ok7J2EIOydtO2VtO2VoCDtlYTsmpTqsIAg7J6I7Iq164uI64ukLiDsl6zrn6zrtoQg7J6Q7Iug7J2YIOyDneqwgeydhCDslYzrpqzquLAg7KCE7JeQIOq3uOuTpOydmCDqsJDsoJUsIOyDneqwgSwg6rSA7KCQ7J2EIOydtO2VtO2VoCDsiJgg7J6I64+E66GdIOq3uOuTpOydmCDrp5DsnYQg66i87KCAIOyggeq3ueyggeycvOuhnCDrk6TslrTrs7TshLjsmpQuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgNS4gKkJld2FyZSBvZiBMb2NrLUluKlxcclxcblxcclxcbj4gKkxvY2staW4g7J2EIOyjvOydmO2VmOudvCpcXHJcXG5cXHJcXG7rr7jrnpjsl5DripQg7IaM7ZSE7Yq47Juo7Ja066W8IOq1rOy2le2VmOuKlCDrsKnsi53sl5Ag7ZiB66qF7J2EIOydvOycvO2CrCBIb3TtlZwg7IOd7IKw7ISxIOuPhOq1rOuTpOydtCDrsJjrk5zsi5wg66eO7J20IOyeiOydhCDqsoHri4jri6QuIFxcclxcblxcclxcbuyYiOulvCDrk6TslrQsIENBU0UgKENvbXB1dGVyIEFzc2lzdGVkIFNvZnR3YXJlIEVuZ2luZWVyaW5nKSDrj4TqtawsIENPVFMsIFBlb3BsZXNvZnQg67CPIFNBUOyZgCDqsJnsnYAgRW50ZXJwcmlzZSBSZXNvdXJjZSBQbGFubmluZyDsoJztkogsIOyLrOyngOyWtCBSdWJ564+EIO2PrO2VqOuQqeuLiOuLpC4g6re465Ok7J2AIO2VmOuCmCDqsJnsnbQg7J6Q7Iug65Ok7J2YIOyghOyytOyggeyduCDqsJzrsJwg67Cp67KV66Gg7J2EIOyxhO2Dne2VmOuptCDruYTsmqnqs7wg7Iuc6rCE7J20IO2BrOqyjCDsoIjqsJDrkJzri6Tqs6Ag7KO87J6l7ZWp64uI64ukLiDtlZjsp4Drp4wg7IOB64u57ZWcIOyEoO2WiSDruYTsmqkodXAtZnJvbnQgY29zdCnqs7wg7KCc7JW9KENvbnN0cmFpbnRzKeydtCDsl4bri6Tqs6Ag7ZWgIOyImOuKlCDsl4bsirXri4jri6QuIGBMb2NrLWluYOydgCDso7zroZwg6rO16riJ7ZWY64qUIO2ajOyCrOuhnOu2gO2EsCDso7zroZwg67Cc7IOd7ZaI7KeA66eMIOydtOygnOuKlCBg7ZSE66CI7J6EIOybjO2BrGDsl5DshJzrj4Qg67Cc7IOd7ZWgIOyImCDsnojsirXri4jri6QuIFxcclxcblxcclxcbuyWtOuKkCDsqr3snbTrk6AsIOqzoOygle2VmOuKlCDqsoPsnYAg67OA6rK97JeQIOyDgeuLue2VnCDruYTsmqnsnYQg7J2Y66+47ZWp64uI64ukLiDtmITrqoXtlZjqsowg7ISg7YOd7ZWY7IS47JqULiDsg4jroZzsmrQg6rKD7J20IO2VreyDgSDsoovsnYAg6rKD66eM7J2AIOyVhOuLmeuLiOuLpCFcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA2LiAqQmUgSG9uZXN0IGFuZCBBY2tub3dsZWRnZSBXaGVuIFlvdSBEb27igJl0IEZpdCB0aGUgUm9sZSAqXFxyXFxuXFxyXFxuPiAq7KCV7KeB7ZW06528IOq3uOumrOqzoCDsiqTsiqTroZwg66eh7J2AIOyXre2VoOyXkCDrp57sp4Ag7JWK64uk6rOgIOyDneqwge2VmOuptCDqt7jqsoPsnYQg7J247KCV7ZWY6rOgIOuwm+yVhOuTpOyXrOudvCpcXHJcXG5cXHJcXG7su6TrpqzslrTsnZgg7Ja064qQIOyLnOygkOyXkOyEnCDsnpDsi6Dsl5Dqsowg7KCB7ZWp7ZWY7KeAIOyViuydgCDsl63tlaDsnYQg66eh6rKMIOuQoCDsiJjrj4Qg7J6I7Iq164uI64ukLiDsnpjrqrvrkJwgRml07J2AIOyWtOuWpCDsnpjrqrvrkJwg7ZaJ64+Z7J2EIOyVvOq4sO2VoCDrp4ztgbwg7KSR64yA7ZWcIOyemOuqu+q5jOyngOuKlChDaGFyYWN0ZXIgZmxhd3MpIOyVhOuLiOyngOunjCDrrLTsi5ztlaAg7IiYIOyeiOuKlCDsoJXrj4TroZwg6rCA67K87Jq0IOusuOygnOuPhCDslYTri5nri4jri6QuIOydtOufrO2VnCDrlJzroIjrp4jrpbwg7ZW06rKw7ZWY6riwIOychO2VtOyEnOuKlCDtlZwg6rCA7KeAIOydtOyDgeydmCDrsKnrspXsnbQg7J6I7J2EIOyImCDsnojsirXri4jri6Q6IOyKpOyKpOuhnCDsp4TtmZTtlZjqsbDrgpgg7JWE64uI66m0IOyXre2VoOydtCDsp4TtmZQg7ZWgIOyImCDsnojsirXri4jri6QuIOyjvOyalCBwb2ludOuKlCDrrLTsiqgg7J287J20IOydvOyWtOuCmOqzoCDsnojripTsp4Ag7KCV7ZmV7Z6IIOyduOyLne2VmOqzoCDqsbTqsJXsl5Ag7ZW066Gc7Jq0IOqzs+ycvOuhnOu2gO2EsCDrspfslrTrgpjquLAg7JyE7ZW0IOyekOq4sOyekOyLoOydhCDslYTripQg6rKDKFNlbGYtS25vd2xlZGdlKeyeheuLiOuLpC4g67aI7ZaJ7ZWcIOqyg+ydgCDriITqtazsl5Dqsozrj4Qg7LWc7ISg7J2YIOydtOydteydtOuQmOyngCDslYrsnLzrqbAsIEJUSTM2MOydgCDsnbTrn6ztlZwg7IKs7Iuk7J2EIOyduOyngO2VmOqzoCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu7KCc6rCAIEdN7JeQIOyeiOyXiOydhCDrlYwg64uk7J2MIOuLqOqzhOqwgCDsp4TtlonrkJjsp4Ag7JWK7JWY64uk66m0IOyLpO2MqO2WiOuLpOqzoCDsl6zqsqjsoYzsirXri4jri6QuICfqtIDrpqzsnpDroZwg7Iq57KeE7ZWY7JesIOuNlCDrp47snYAg7IKs656M7J2EIOq0gOumrO2VmOqxsOuCmCDrjZQg7YGs6rOgIOuzteyeoe2VnCDtlITroZzsoJ3tirjrpbwg7IiY7ZaJ7ZWY64qUIOqygyfsnoXri4jri6QuIOunjuydgCDsgqzrnozrk6Tsl5Dqsowg7J206rKD7J2AIDx1Puu5hOywuO2VnCDsu6TrpqzslrQg7Yyo7IqkPC91PuulvCDrp4zrk6Tsl4jsirXri4jri6QuXFxyXFxuXFxyXFxu7ZWY7KeA66eMIEVEU+ydmCDrrLjtmZTripQgR03snZgg6re46rKD6rO864qUIOuLrOuekOyKteuLiOuLpC4g7IKs656M65Ok7J2AIOq0gOumrCDsl63tlaDsl5Ag65Ok7Ja06rCU64uk6rCAIOyiheyihSDri6Tsi5wg64KY6rCA6rOkIO2WiOyKteuLiOuLpC4g7KCE65617KCBIO2UjOuemOuEiOyZgCDqsJnsnbQg67KU7JyE6rCAIOuNlCDtgbAg7Jet7ZWg7JeQ7IScIFBNIOuYkOuKlCDtlITroZzsoJ3tirgg7IiY7KSAIOqwnOuwnOyekOyZgCDqsJnsnbQg67KU7JyE6rCAIOuNlCDsooHsnYAg7Jet7ZWg66GcIOydtOuPme2VmOuKlCDqsoPsnYQg7KKM7LKcIOuYkOuKlCDsmKTrqoXsnLzroZwg7Jes6riw64qUIOusuO2ZlOqwgCDsl4bsl4jsirXri4jri6QuIOyggOuKlCDsnbTrn6ztlZwg7Jyg7Jew7ISx7J2EIOydtOyaqe2VmOyXrCDquLDsiKAg7ZS8652866+465Oc7J2YIOy1nOyDgeychCDsl63tlaDsl5DshJwg7ZSE66Gc7KCd7Yq4IOyImOykgOydmCDqsJzrsJzsnpDroZwg64uk7IucIOydtOuPmSDtlZwg7IKs656MIOykkSDtlZwg66qF7J207JeI7Iq164uI64ukLiDqt7jrpqzqs6Ag7KCA64qUIOqysOy9lCDrkqTrj4zslYQg7ZuE7ZqM7ZWY7KeAIOyViuyVmOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyAqRmluYWwgVGhvdWdodHMqXFxyXFxuXFxyXFxu7KCA64qUIEJUSTM2MOyXkCDsnoXsgqztlZjquLAg7KCE7JeQ64+EIOychOyXkOyEnCDshKTrqoXtlZwg7JuQ7LmZ7J2EIOyGjOykke2eiCDsl6zquLDripQg6rOz7J20652864qUIOqyg+ydhCDslYwg7KCV64+E66GcIEJUSTM2MOydmCDrrLjtmZTsl5Ag64yA7ZW0IOy2qeu2hO2eiCDslYzqs6Ag7J6I7JeI7Iq164uI64ukLiBcXHJcXG5cXHJcXG7soJzqsIAg67CU652864qUIOqyg+ydgCDsl6zrn6zrtoQg6rCB7J6Q6rCAIEJUSTM2MOydtOuegCDtmozsgqzrpbwg7KeA7IaN7KCB7Jy866GcIOyGjO2UhO2KuOybqOyWtCDqtazstpXsnYQg7JyE7ZWcIO2bjOulre2VnCDsnqXshozroZwg66eM65Ok64+E66GdIO2VmOuKlCDqsJXroKXtlZwg7JeU7KeA64uI7Ja066eBIOusuO2ZlOulvCDsnKDsp4DtlaAg67+Q66eMIOyVhOuLiOudvCDqt7jrn6ztlZwg66y47ZmU66W8IOyngOy8nOuCmOqwgOqzoCDsnbTsl5Ag64yA7ZWcIOyjvOyduOydmOyLneydhCDqsIDsp4DripQg6rKD7J6F64uI64ukLlwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxyXFxudGl0bGU6IFxcXCLsspjsnYzrtoDthLAg64Gd6rmM7KeAIOyDgeyEuO2eiCDslYzslYTrs7TsnpAgLSBIVFRQM+yXkCDrjIDtlZwgQSBUTyBaIDHtjrhcXFwiXFxyXFxuZGF0ZTogXFxcIjIwMjEuMDguMTRcXFwiXFxyXFxudGFnczogXFxyXFxuICAtIEhUVFAzXFxyXFxuICAtIO2UhOuhnO2GoOy9nFxcclxcbi0tLVxcclxcblxcclxcbiMgKOuyiOyXrSkgSFRUUC8zIEZST00gQSBUbyBaOiBDb3JlIENvbmNlcHRzIChQYXJ0IDEpIGJ5IFJvYmluIE1hcnhcXHJcXG5cXHJcXG7sm5DrrLjrp4Htgaw6IFtodHRwczovL3d3dy5zbWFzaGluZ21hZ2F6aW5lLmNvbS8yMDIxLzA4L2h0dHAzLWNvcmUtY29uY2VwdHMtcGFydDEvXShodHRwczovL3d3dy5zbWFzaGluZ21hZ2F6aW5lLmNvbS8yMDIxLzA4L2h0dHAzLWNvcmUtY29uY2VwdHMtcGFydDEvKVxcclxcblxcclxcbuydtCDquIDsnYAgKlJvYmluIE1hcngq7J2YIFsqKkhUVFAvMyBGUk9NIEEgVG8gWjogQ29yZSBDb25jZXB0cyAoUGFydDEpKipdKGh0dHBzOi8vd3d3LnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMjEvMDgvaHR0cDMtY29yZS1jb25jZXB0cy1wYXJ0MS8p7J2EIOuyiOyXre2VmOyYgOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBUTDtEUlxcclxcblxcclxcbi0gKipIVFRQM+qwgCDsmZwg7ZWE7JqU7ZWc6rCAPyoqIC0g7JeE67CA7Z6IIOunkO2VmOuptCDsmrDrpqzsl5Dqsowg7ZWE7JqU7ZWcIOqyg+ydgCDsi6TsoJzroZwgSFRUUC8z6rCAIOyVhOuLiOudvCBcXFwiVENQLzJcXFwi7JiA7Jy866mwIOq3uCDqs7zsoJXsl5DshJwgVENQ7J6Q7LK066W8IOyXheq3uOugiOydtOuTnCDtlZjripQg6rKD67O064uk64qUIEhUVFAg67KE7KCE7JeF7J20IOuNlCDshpDsiazsmrQg67Cp67KV7J207JeI7Iq164uI64ukLiAo64Sk7Yq47JuM7YGsIOqzhOy4tSDqtazsobDsl5Ag65Sw66W066m0IEhUVFDripQgVENQ7ZSE66Gc7Yag7L2cIOychOyXkOyEnCDrj5nsnpHtlZjripTrjbAgSFRUUC8z6rCAIEhUVFAg7ZSE66Gc7Yag7L2c7J2YIOuwnOyghOuztOuLpOuKlCDquLDsoIDsl5Ag6rmU66awIFRDUOydmCDrsJzsoITsnbQg642UIO2VhOyalO2WiOqzoCBIVFRQLzPripQg7KKAIOuNlCDroZzsmrAg66CI67Ko7J2YIO2UhOuhnO2GoOy9nOyXkOyEnCDrsJzsoITsnbQg7J6I7JeI7J2M7J2EIOydmOuvuO2VqeuLiOuLpC4pIOyasOumrOqwgCBIVFRQLzPsl5Ag64yA7ZW0IOq4sOuMgO2VmOuKlCDso7zsmpQg6riw64qlKOuNlCDruaDrpbgg7Jew6rKwIOyEpOyglSwg642UIOyggeydgCBIb0wg7LCo64uoLCDsl7DqsrAg66eI7J206re466CI7J207IWYIOuTsSnsnYAg7Iuk7KCc66GcIOuqqOuRkCBRVUlDKFRDUOydmCDri6jsoJDsnYQg67O07JmE7ZWcIOyDiOuhnOyatCDtlITroZzthqDsvZwp7JeQ7IScIOygnOqzteuQqeuLiOuLpC5cXHJcXG4tICoqUVVJQ+qzvCBVRFAqKiAtICBIVFRQLzPripQgVENQ66W8IFVEUOuhnCDrsJTqv6jri6Tqs6Ag7ZW07IScIEhUVFAvMuuztOuLpCDsl4Tssq3rgpjqsowg67mg66W07KeAIOyViuyKteuLiOuLpC4o7KCV67O07LKY66as6riw7IKs7JeQ7IScIOunjuydtCDrgpjsmKTripQg7ZSE66Gc7Yag7L2cIOqwhOydmCDssKjsnbTsnbjrjbAgVURQ64qUIOyGjeuPhOqwgCDruaDrpbgg7ZSE66Gc7Yag7L2c7J6F64uI64ukLikg64yA7IugIFFVSUPsnbTrnbzripQg7Zuo7JSsIOuNlCDrsJzsoITrkJwgVENQIOuyhOyghOydhCDsnqzqtazsg4HtlZjqs6Ag6rWs7ZiE7ZaI7Iq164uI64ukLiDqt7jrpqzqs6Ag7J20IFFVSUPsnYAg642UIOyJveqyjCDrsLDtj6ztlaAg7IiYIOyeiOuPhOuhnSDsnbjthLDrhLfsl5DshJwg6rSR67KU7JyE7ZWY6rKMIOyngOybkOuQmOuKlCDri6Trpbgg7ZWY64KY7J2YIOyghOyGoSDqs4TsuLUg7ZSE66Gc7Yag7L2c7J24IFVEUCDsnITsl5DshJwg7Iuk7ZaJ7ZWp64uI64ukLiAoVENQ66W8IOyXheq3uOugiOydtOuTnCDtlZjripQg6rKD7J2AIOyCrOyLpOyDgSDrp6TsmrAg7Ja066C16riwIOuVjOusuOyeheuLiOuLpC4pXFxyXFxuLSAqKkJJRyBDSEFOR0VTKiogLSDsnbTsoIQg67KE7KCE7J2YIEhUVFDsl5DshJzripQg642w7J207YSwIO2GteyLoOqzvCBUU0wg7JWU7Zi47ZmU6rO87KCV7J20IOu2hOumrOuQmOyWtCDsnojsl4jsirXri4jri6QuIOuUsOudvOyEnCBUU0zslZTtmLjtmZTrpbwg7KeE7ZaJ7ZWY64uk67O066m0IOyEseuKpeydtCDrlqjslrTsp4DripQg6rKD7J20IOuLueyXsO2WiOyKteuLiOuLpC4g7ZWY7KeA66eMIFFVSUPsnYAgYWx3YXlzLW9uLVRTTCDsm5DsuZnsl5Ag66ee7LawIOq4sOuzuOyggeycvOuhnCBUU0zrpbwg7YOR7J6s7ZWY7JiA7Iq164uI64ukLiDrlLDrnbzshJwg7Jew6rKw7J20IOuNlCDruajrnbzsp4Dqs6Ag67O07JWIIOyEseuKpeydtCDrm7DslrTrgpjri6TripQg7J6l7KCQ7J20IOyeiOycvOuCmCDslZTtmLjtmZQg7Jik67KE7Zek65Oc6rCAIOuNlCDtgbAg66y47KCc6rCAIOyDneq4sOuKlCDqsoMsIOyduO2EsOuEtyDtmZjqsr3snbQg642UIOykkeyVmeynkeykke2ZlCDrkJjripQg6rKDIOuTseydmCDri6jsoJDsnbQg7JiI7IOB65CY6rOgIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4q67O466y4IFNUQVJUISpcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBRdWljayBTdW1tYXJ5XFxyXFxuXFxyXFxu7JW9IDXrhYTsl6zqsITsnZgg6rCc67CcIOuBneyXkCwg7IOI66Gc7Jq0IEhUVFAvMyDtlITroZzthqDsvZzsnbQg6rGw7J2YIOunieuwlOyngCDri6jqs4Tsl5Ag7J2066W066CA64ukLiDsnbTrr7gg7Iuk7ZeY7KCBIOq4sOuKpeycvOuhnCDrqofrqofsnZgg6riw64ql7J2AIOygnOqzteuQmOyXiOydjOyXkOuPhCDrtojqtaztlZjqs6AgSFRUUC8z7J2YIOqwgOyaqeyEseqzvCDsgqzsmqnsnYAgMjAyMeuFhOyXkCDspp3qsIDtlaAg6rKD7Jy866GcIOq4sOuMgOuQmOqzoCDsnojsirXri4jri6QuIFxcclxcblxcclxcbj4g6re4656Y7IScIEhUVFAvM+qwgCDsoJXtmZXtnogg662U642wPyBcXHJcXG4+IOyZnCBIVFRQLzIg6rCAIOuCmOyYqOyngCDslrzrp4gg7JWI65CY7IScIOqzp+uwlOuhnCDrmJAg64KY7Jio6rG46rmMPyBcXHJcXG4+IOyasOumrOqwgCDslrTrlrvqsowg7JO4IOyImCDsnojqs6Ag7Ja065a76rKMIOyNqOyVvCDtlZjripTqsbDsp4A/IFxcclxcbj4g6re466as6rOgIO2Kue2eiCDsm7kg7Y287Y+s66i87Iqk66W8IOyWtOuWu+qyjCDtlqXsg4Hsi5ztgqTripTqsbDsp4A/XFxyXFxuXFxyXFxu7J6QIOydtOygnCDslYzslYTrtIXsi5zri6QhXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMg8J+SgCBIVFRQLzPsl5Ag64yA7ZWcIOyemOuqu+uQnCDquLDrjIDqsIAg7Y287KeA6rOgIOyeiOuLpCFcXHJcXG5cXHJcXG7snbQg7KO87KCc7JeQIOuMgO2VnCDrqocg6rCA7KeAIOu4lOuhnOq3uCDqsozsi5zrrLzsnYQg7J296rGw64KYIOy7qO2NvOufsOyKpCDrk7HsnYQg65Oj6rOgIOyWtOuKkCDsoJXrj4Qg64u17J2EIOyVjOqzoCDsnojri6Tqs6Ag7IOd6rCB7ZWgIOyImOuPhCDsnojsirXri4jri6QuIFxcXCJIVFRQLzPripQg7Yyo7YK3IOyGkOyLpOydtCDsnojsnYQg65WMIEhUVFAvMuuztOuLpCDtm6jslKwg67mg66W064ukLlxcXCIg65iQ64qUIFxcXCJIVFRQLzMg7Jew6rKw7J2AIOuMgOq4sCDsi5zqsITsnbQg7Ken6rOgIOyEpOygle2VmOuKlCDrjbAg7Iuc6rCE7J20IOuNnCDqsbjrprDri6QuXFxcIiwg7JWE66eI64+EIFxcXCJIVFRQLzMg642w7J207YSw66W8IOuNlCDruajrpqwg67O064K8IOyImCDsnojqs6Ag642UIOunjuydgCDrpqzshozsiqTrpbwg67OR66Cs66GcIOuztOuCvCDsiJgg7J6I7Iq164uI64ukLlxcXCJcXHJcXG5cXHJcXG7snITsmYAg6rCZ7J2AIOusuOyepeqzvCDslYTti7DtgbTrk6TsnYAg7KKF7KKFIOykkeuMgO2VnCDquLDsiKDsoIEg65SU7YWM7J2865Ok7J2EIOqxtOuEiCDrm7DqsbDrgpgg7Zi57J2AIOygle2Zle2VnCDrrLjrp6Ug7YyM7JWF7J2EIOychO2VnCDriZjslZnsiqTrpbwg67mg65yo66as6rGw64KYIOu2gOu2hOyggeycvOuhnCDrp57ripQg7JaY6riw65Ok7J2064ukLiDsooXsooUg6re465Ok7J2AIEhUVFAvM+qwgCDshLHriqXrqbTsl5DshJwg7JeE7LKt64KcIO2YgeuqheyduCDqsoPsspjrn7wg67O07J206rKMIOunkO2VmOyngOuptCDsi6TsoJzroZzripQg6re466CH6rKM6rmM7KeAIOq4ieqyrO2VnCDsp4TtmZTripQg7JWE64uMKOq3uOufrOuCmCDsl6zsoITtnogg7Jyg7Jqp7ZWcISkg7KeE7ZmU7J6F64uI64ukLiDsnbTqsoPsnYAg7J6Q7LmrIOychO2XmO2VqeuLiOuLpC4g7Jmc64OQ7ZWY66m0IOyDiOuhnOyatCDtlITroZzthqDsvZzsnbQg7Iuk7KeI7KCB7Jy866GcIOydtOugh+qyjOq5jOyngCDrhpLsnYAg6riw64yA7LmY66W8IOy2qeyhseyLnO2CpOq4sOyngCDrqrvtlbTshJwg7IK07JWE64Ko7KeAIOuqu+2VoCDsiJjrj4Qg7J6I6riwIOuWhOusuOyeheuLiOuLpC4g65Sw65287IScIOuCmOuKlCDsnbTqsoPrk6TsnbQg66eO7J2AIOyCrOuejOuTpOydhCDqsrDqta0g7Iuk66ed7Iuc7Lyc7IScIOyDiOuhnOyYqCDsgqzrnozrk6Tsl5Dqsowg66e566qp7KCB7J24IOyYpO2VtOulvCDslYTso7wg7Jik656Y64+E66GdIOqwgeyduOyLnO2CpOqyjCDrkKDquYwg65GQ66C17Iq164uI64ukLlxcclxcblxcclxcbuuCmOuKlCBIVFRQLzLsl5DshJwg65iR6rCZ7J2AIOydvOydtCDsnbzslrTrgpjripQg6rKD7J2EIOuztOyVmOyKteuLiOuLpC4g64u57IucIOyEnOuyhCDtkbjsi5wsIOuzkeugrCDsiqTtirjrprwg67CPIOyasOyEoCDsiJzsnIQg7KeA7KCV6rO8IOqwmeydgCDtnaXrr7jroZzsmrQg7IOIIOq4sOuKpeycvOuhnCDrhoDrnbzsmrQg7ISx64qlIO2YgeuqheycvOuhnCDsmIjqs6DrkJjsl4jsirXri4jri6QuIO2Kue2eiCAn66as7IaM7IqkIOuyiOuTpOungeydhCDspJHsp4DtlZjqs6Ag7Jes65+sIOyEnOuyhOyXkOyEnCDrpqzshozsiqQg67aE7ZWg7J2EIOykkeyngO2VmOqzoCDtjpjsnbTsp4Ag66Gc65OcIO2UhOuhnOyEuOyKpOulvCDtgazqsowg6rCE7IaM7ZmU7ZWgIOyImCDsnojsl4jsirXri4jri6QuIOyKpOychOy5mOunjCDriITrpbTrqbQg7Ju57IKs7J207Yq46rCAIOuniOuyleyymOufvCA1MCUg67mo65287KeR64uI64ukISfsmYAg6rCZ7J20IOuEiOustCDtgbAg6riw64yA66W8IOu2iOufrOuqqOyVmOyjoC5cXHJcXG5cXHJcXG4164WE7J20IOyngOuCmOqzoCDrgpjshJwsIOyasOumrOuKlCDshJzrsoTtkbjsi5zqsIAg7Iuk7KeI7KCB7Jy866GcIOq3uOugh+qyjCDsnpHrj5ntlZjsp4Ag7JWK64qU64uk64qUIOqyg+qzvCDsiqTtirjrprwg67CPIOyasOyEoCDsiJzsnIQg7KeA7KCV7J2AIOyiheyihSDsnpjrqrsg6rWs7ZiE65Cc64uk64qUIOqyg+ydhCDslZXri4jri6QuIOq3uOumrOqzoCDqsrDqs7zsoIHsnLzroZwg7Ja065akIOyDge2ZqeyXkOyEnOuKlCAo6rCQ7IaM65CcKSDrpqzshozsiqQg67KI65Ok66eBIOuwjyDsg6TrlKnsobDssKjrj4Qg7J2867aAIOyDge2ZqeyXkOyEnCDsl6zsoITtnogg7KKL7J2AIOuwqeuyleyeheuLiOuLpC4g66eI7LCs6rCA7KeA66GcIFByZWxvYWRIaW50IO2ejO2KuOyZgCDqsJnsnbQg7ZSE66Gc7Yag7L2cIOuPmeyekeydhCDsobDsoJXtlZjripQg64uk66W4IOuplOy7pOuLiOymmOyXkOuKlCDsooXsooUg7Iio6rKo7KeEIOq5iuydtOyZgCDrsoTqt7jqsIAg7Y+s7ZWo65CY7Ja0IOyeiOyWtCDsmKzrsJTrpbTqsowg7IKs7Jqp7ZWY6riwIOyWtOugteyKteuLiOuLpC4gPHU+65WM66y47JeQIOuCmOuKlCDsnbTrn7Ag7J6Y66q765CcIOyYpOuztOulvCDrp4nslYQgSFRUUC8z7JeQIOuMgO2VnCDruYTtmITsi6TsoIHsnbgg6riw64yA6rCQ7J20IOuEkOumrCDtjbzsp4DquLAg7KCE7JeQIOunieuKlCDqsoPsnbQg7KSR7JqU7ZWY64uk6rOgIO2MkOuLqDwvdT7tlojsirXri4jri6QuXFxyXFxuXFxyXFxu7J20IOq4gOyXkOyEnCDrgpjripQgKio8dT7sg4jroZzsmrQg7ZSE66Gc7Yag7L2c6rO8IO2Kue2eiCDqt7gg7Y287Y+s66i87Iqk7KCBIO2KueynlTwvdT4qKuyXkCDrjIDtlbQg7J207JW86riw7ZWgIOqyg+yeheuLiOuLpC4g6re466as6rOgIEhUVFAz7J2YIOycoOunne2VnCDsg4jroZzsmrQg7Luo7IWJ6rO8IOq3uOugh+yngOunjCDrj5nsi5zsl5Ag7Iqs7ZSE6rKM64+EIOuMgOu2gOu2hOydmCDsm7kg7Y6Y7J207KeA7JeQ7JmAIOycoOyggOyXkOqyjOuKlCDsoJztlZzrkJwg7J6E7Yyp7Yq466eM7J2EIOykhCDqsoPsl5Ag64yA7ZW0IOydtOyVvOq4sO2VmOqyoOyKteuLiOuLpC4gSFRUUDPripQg65iQ7ZWcIOykgOu5hO2VmOqzoCDsgqzsmqntlZjquLAg6rmM7KeAIOq9pCDslrTroLXsirXri4jri6QuIOuVjOusuOyXkCDsg4jroZzsmrQg7ZSE66Gc7Yag7L2c7J2EIOydtO2VtO2VmOq4sCDsnITtlbQg64uo64uo7Z6IIOykgOu5hO2VmOyEuOyalCFcXHJcXG5cXHJcXG7snbQg7Iuc66as7KaI64qUICoqPHU+7YGs6rKMIDPqsIDsp4Ag7YyM7Yq4PC91Pioq66GcIOuCmOuJqeuLiOuLpDpcXHJcXG5cXHJcXG4jIyMgMDEuIEhUVFAvMyBoaXN0b3J5IGFuZCBjb3JlIGNvbmNlcHRzIEhUVFAvM+yXkCDqtIDtlZwg7Jet7IKs7JmAIO2VteyLrCDsu6jshYlcXHJcXG5cXHJcXG46IOydvOuwmOyggeycvOuhnCBIVFRQLzMg67CPIO2UhOuhnO2GoOy9nOydhCDsspjsnYwg7KCR7ZWY64qUIOyCrOuejOuTpOydhCDrjIDsg4HsnLzroZwg7ZWY66mwIOq4sOuzuCDsgqztla3rk6Tsl5Ag64yA7ZW0IOyEpOuqhe2VqeuLiOuLpC5cXHJcXG5cXHJcXG4jIyMgMDIuIEhUVFAvMyBQZXJmb21hbmNlIGZlYXR1cmVzOiDtjbztj6zrqLzsiqTsoIEg7Yq57KeVXFxyXFxuXFxyXFxuOiDrjZQg6rmK7J20IOyeiOqzoCDquLDsiKDsoIHsnbgg7YyM7Yq47J6F64uI64ukLiDquLDrs7gg7IKs7ZWt7J2EIOydtOuvuCDslYzqs6Ag7J6I64qUIOyCrOuejOuTpOydgCAx67KI7J2EIOyKpO2Cte2VmOqzoCDsl6zquLDrtoDthLAg7Iuc7J6R7ZW064+EIOyii+yKteuLiOuLpC5cXHJcXG5cXHJcXG4jIyMgMDMuIFByYWN0aWNhbCBIVFRQLzMgZGVwbG95bWVudCBvcHRpb25zOiDsi6Tsp4jsoIEg67Cw7Y+sIOyYteyFmFxcclxcblxcclxcbjogSFRUUC8z66W8IOyngeygkSDrsLDtj6ztlZjqs6Ag7YWM7Iqk7Yq47ZWY64qUIOqyg+qzvCDqtIDroKjrkJwg66y47KCc66W8IOyEpOuqhe2VqeuLiOuLpC4g7Ju5IO2OmOydtOyngOyZgCDrpqzshozsiqTrj4Qg67OA6rK97ZW07JW8IO2VoCDsiJjrj4Qg7J6I64qU642wLCDqt7jroIfqsowg7ZWY64qUIOuwqeuyleqzvCDqt7jroIfqsowg7ZW07JW8IO2VmOuKlCDsnbTsnKDsl5Ag64yA7ZW0IOyekOyEuO2eiCDshKTrqoXtlanri4jri6QuXFxyXFxuXFxyXFxu7J20IOyLnOumrOymiOuKlCDtlITroZzthqDsvZzsl5Ag64yA7ZWcIOq5iuydgCDsnbTtlbTqsIAg7ZWE7JqU7JeG64qUIOybuSDqsJzrsJzsnpDrk6TsnYQg7YOA6rKf7Jy866GcIOyTsOyYgOyKteuLiOuLpC4g6re465+s64KYLCDstqnrtoTtlZwg7JaR7J2YIOq4sOyIoOyggSDrlJTthYzsnbzqs7wg66eO7J2AIOyZuOu2gOunge2BrOuTpOydhCDtj6ztlajtlZjqs6Ag7J6I7Jy866+A66GcIGFkdmFuY2VkIHJlYWRlcnPrk6Qg7Jet7IucIOy2qeu2hO2eiCDrsLDsmrgg6rKD7J20IOyeiOydhCDqsoHri4jri6QuXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMg4p2TIEhUVFAvMyDrj4TrjIDssrQg7JmcIO2VhOyalO2VnOqxtOuNsD9cXHJcXG5cXHJcXG7sooXsooUg65Oc64qUIOyDneqwgeyduOuNsCwgXFxcIkhUVFAy6rCAIOuCmOyYqCAyMDE1IOydtO2bhOyXkCDsmZzsnbTroIfqsowg67mo66asIEhUVFAz6rCAIO2VhOyalO2VtOynhOqxsOyngD9cXFwiIOydtCDsp4jrrLjsl5Ag64yA7ZW07IScIOyCrOyLpCDri7nsi6DsnbQg7IOI66Gc7Jq0IEhUVFDrsoTsoITsnbQg6rWz7J20IO2VhOyalO2VmOyngOuKlCDslYrsp4Drp4wgVENQ7J2YIOyXheq3uOugiOydtOuTnOqwgCDtlYTsmpTtlZjri6TripQg6rKD7J2EIOq5qOuLq+q4sCDsoITquYzsp4DripQg7J207IOB7ZWY64uk6rOgIOuKkOuChOqyg+ydtOuLpC4gXFxyXFxuXFxyXFxuKOyDiOuhnOyatCBIVFRQ66GcIOuztOq4sOuztOuLqCBUQ1DsnZgg7JeF6re466CI7J2065OcIOuyhOyghOydtOudvOuKlCDqtIDsoJDsl5DshJwg67O066m0IEhUVFAz6rCAIDLrsoTsoIQg7J207ZuEIOu5oOultOqyjCDri6Tsi5wg64KY7Jik64qUIOqyg+ydhCDsnbTtlbTtlaAg7IiYIOyeiOuLpOuKlCDsnZjrr7jroZwg7ZW07ISd65Cp64uI64ukLilcXHJcXG5cXHJcXG5UQ1DripQgSFRUUOyZgCDqsJnsnbQg64uk66W4IO2UhOuhnO2GoOy9nOyXkCDrjIDtlZwg7JWI7KCV7ISxKHJlbGlhYmlsaXR5KSDrsI8g7Iic7IScIOyghOuLrChpbi1vcmRlciBkZWxpdmVyeSnqs7wg6rCZ7J2AIOykkeyalO2VnCDshJzruYTsiqTrpbwg7KCc6rO17ZWY64qUIOyjvOyalCDtlITroZzthqDsvZzsnoXri4jri6QuIOydtCDtlITroZzthqDsvZzsnbQg7IKs7Jqp7J6QIOuMgOyXre2PrSDsgqzsmqnrn4nsnYQg7Iqk66eI7Yq47ZWY6rOgIOqzteygle2VmOqyjCDsoJztlZztlZjripTrjZXrtoTsl5Ag7IiY66eO7J2AIOyCrOuejOydtCDsnbjthLDrhLfsl5Ag64+Z7IucIOygkeyGjeydhO2VtOuPhCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG7tlITroZzthqDsvZzsnZgg7J2065+s7ZWcIFxcXCLqs4TsuLXtmZQoTGF5ZXJpbmcpXFxcIuuKlCDtlbTri7kg6riw64ql7J2EIOyJveqyjCDsnqzsgqzsmqntlaAg7IiYIOyeiOuPhOuhnSDtlZjquLAg7JyE7ZW0IOyImO2WieuQqeuLiOuLpC4g7IOB7JyEIOqzhOy4tSDtlITroZzthqDsvZwo7JiIOiBIVFRQKeydgCDtlZjsnIQg6rOE7Li1IO2UhOuhnO2GoOy9nCjsmIg6IFRMUynsnbQg7J2066+4IOydtOulvCDsiJjtlontlZjquLAg65WM66y47JeQIOuzteyeoe2VnCDquLDriqUo7JiIOiDslZTtmLjtmZQp7J2EIOuLpOyLnCDqtaztmITtlaAg7ZWE7JqU6rCAIOyXhuyKteuLiOuLpC4g65iQIOuLpOuluCDsmIjroZwg7J247YSw64S37J2YIOuMgOu2gOu2hOydmCDsnZHsmqkg7ZSE66Gc6re4656o7J2AIOuCtOu2gOyggeycvOuhnCBUQ1Drpbwg7IKs7Jqp7ZWY7JesIOuqqOuToCDrjbDsnbTthLDqsIAg7JmE7KCE7Z6IIOyghOyGoeuQmOuPhOuhnSDtlanri4jri6QuIOydtOufrO2VnCDsnbTsnKDroZwgVENQ64qUIOyduO2EsOuEt+yXkOyEnCDqsIDsnqUg64SQ66asIOyCrOyaqeuQmOqzoCDrsLDtj6zrkJwg7ZSE66Gc7Yag7L2cIOykkSDtlZjrgpjsnoXri4jri6QuXFxyXFxuXFxyXFxuIVvtlITroZzthqDsvZzroIjsnbTslrRdKGh0dHBzOi8vY2xvdWQubmV0bGlmeXVzZXJjb250ZW50LmNvbS9hc3NldHMvMzQ0ZGJmODgtZmRmOS00MmJiLWFkYjQtNDZmMDFlZWRkNjI5LzZlZjM2ZDFlLWQ5MWUtNDNlMC04NzMyLWYzZTY2YmE5ZWE2NC9wcm90b2NvbC1zdGFjay1oMi1oMy5wbmcpXFxyXFxuXFxyXFxuVENQ64qUIOyImOyLrSDrhYQg64+Z7JWIIOybueydmCDstIjshJ3snbTsl4jsp4Drp4wgMjAwMOuFhOuMgCDtm4TrsJjsl5Ag6re4IOuLqOygkCjsm5DrrLggYWdl66W8IOydmOyXre2VqC4p7J2EIOuztOyXrOyjvOq4sCDsi5zsnpHtlojsirXri4jri6QuIFFVSUPrnbzripQg7J2066aE7J2YIOyDiOuhnOyatCDsoITshqEg7ZSE66Gc7Yag7L2c7J2AIFRDUOyZgCDrqocg6rCA7KeAIOyjvOyalCDrqbTsl5DshJwg7Lap67aE7Z6IIOuLpOultOq4sCDrlYzrrLjsl5Ag6re4IOychOyXkOyEnCDsp4HsoJEgSFRUUC8y66W8IOyLpO2Wie2VmOuKlCDqsoPsnbQg66ek7JqwIOyWtOugpOyauCDsiJgg7J6I7Iq164uI64ukLiDrlLDrnbzshJwgKipIVFRQLzMg7J6Q7LK064qUIOyCrOuejOuTpOydtCDsl7TqtJHtlZjripQg64yA67aA67aE7J2YIOyDiOuhnOyatCDquLDriqXsnYQg7Y+s7ZWo7ZWY64qUIOyDiOuhnOyatCBRVUlDIO2UhOuhnO2GoOy9nOqzvCDtmLjtmZjrkJjrj4TroZ0gSFRUUC8y66W8IOu5hOq1kOyggSDsnpHqsowg6rCc7KGw7ZWcIOqygyoq7J6F64uI64ukLlxcclxcblxcclxcblFVSUPsnYAg7J247YSw64S3IOy0iOywveq4sOu2gO2EsCDsobTsnqztlojrjZggVENQ6rCAIOyLpOygnOuhnCDstZzrjIAg7Zqo7Jyo7ISx7J2EIOyXvOuRkOyXkCDrkZDqs6Ag6rWs7LaV65CY7KeAIOyViuyVmOq4sCDrlYzrrLjsl5Ag67Cc7IOd7ZWY64qUIO2aqOycqOyEsSDrlYzrrLjsl5Ag6re4IOqwgOy5mOqwgCDsnojsirXri4jri6QuIOyYiOulvCDrk6TslrQgVENQ64qUIOyDiCDsl7DqsrDsnYQg7ISk7KCV7ZWY6riwIOychO2VtCAqKmDtlbjrk5zshbDsnbTtgaxgKirqsIAg7ZWE7JqU7ZWp64uI64ukLiDsnbTripQg7YG065287J207Ja47Yq47JmAIOyEnOuyhOqwgCDrqqjrkZAg7KG07J6s7ZWY6rOgIOuNsOydtO2EsOulvCDqtZDtmZjtlaAg7J2Y7IKs7JmAIOuKpeugpeydtCDsnojripTsp4Ag7ZmV7J247ZWY6riwIOychO2VtCDsiJjtlonrkKnri4jri6QuIOq3uOufrOuCmCDsl7DqsrDsl5DshJwg64uk66W4IOyekeyXheydhCDsiJjtlontlZjquLAg7KCEKHByZWZsaWdodCnsl5Ag7JmE66OM7ZWY66Ck66m0IOyghOyytCDrhKTtirjsm4ztgawg7JmV67O17J20IO2VhOyalO2VqeuLiOuLpC4g7YG065287J207Ja47Yq47JmAIOyEnOuyhOqwgCDsp4DrpqzsoIHsnLzroZwg66mA66asIOuWqOyWtOyguCDsnojripQg6rK97JqwIOqwgSBSVFQo7JmV67O1IOyLnOqwhCnsl5AgMTAw67CA66as7LSIIOydtOyDgeydtCDshozsmpTrkJjslrQg64iI7JeQIOudhOuKlCDsp4Dsl7DsnbQg67Cc7IOd7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu65GQIOuyiOynuCDsmIjroZwsIFRDUOuKlCDsi6TsoJzroZwg64+Z7Iuc7JeQIOyXrOufrCDtjIzsnbzsnYQg7KCE7Iah7ZWY64qUIOuNsCDsgqzsmqntlZjrjZTrnbzrj4Qg7KCE7Iah7ZWY64qUIOuqqOuToCDrjbDsnbTthLDrpbwg64uo7J28IFxcXCLtjIzsnbxcXFwiIOuYkOuKlCDrsJTsnbTtirgg7Iqk7Yq466a87Jy866GcIOu0heuLiOuLpCjsmIg6IOyduO2EsOuEtyDsm7ntjpjsnbTsp4Dsl5DshJwg66eO7J2AIOumrOyGjOyKpOulvCDri6TsmrTroZzrk5wg67Cb64qUIOqygykuIOyLpOygnOuhnCDsnbTqsoPsnYAg64uo7J28IO2MjOydvOydmCDrjbDsnbTthLDrpbwg7Y+s7ZWo7ZWY64qUIFRDUCDtjKjtgrfsnbQg7IaQ7Iuk65CY66m0IO2VtOuLuSDtjKjtgrfsnbQg67O16rWs65CgIOuVjOq5jOyngCDri6Trpbgg66qo65OgIO2MjOydvOuPhCDsp4Dsl7DrkKjsnYQg7J2Y66+47ZWp64uI64ukLiDsnbTrpbwgKio8dT7tl6Trk5wg7Jik67iMIOudvOyduChIb0wpIOywqOuLqDwvdT4qKuydtOudvOqzoCDtlanri4jri6QuIOydtOufrO2VnCDruYTtmqjsnKjshLHsnYAg7Iuk7KCc66GcIOq0gOumrO2VoCDsiJgg7J6I7KeA66eMKOq3uOugh+yngCDslYrsnLzrqbQgVENQ66W8IDMw64WEIOydtOyDgSDsgqzsmqntlZjsp4Ag7JWK7JWY7J2EIOqyg+yeheuLiOuLpCkgSFRUUOyZgCDqsJnsnYAg7IOB7JyEIOyImOykgCDtlITroZzthqDsvZzsl5Ag64iI7JeQIOudhOuKlCDrsKnsi53snLzroZwg7JiB7Zal7J2EIOuvuOy5qeuLiOuLpC4o7JWe7JeQ7IScIO2VmOuCmOunjCDshpDsg4HrkJjrjZTrnbzrj4Qg65Kk7JeQIOuqqOuRkOqwgCDsp4Dsl7DrkJjripQg7IOB7YOcLiDsoJXrs7TsspjrpqzquLDsgqzsl5Ag7J6Q7KO8IOy2nOygnOuQmOuKlCDrgrTsmqnsnbQg64KY7Jik64Sk7JqUIDs7KVxcclxcblxcclxcbuyLnOqwhOydtCDsp4Drgqjsl5Ag65Sw6528IOydtOufrO2VnCDrrLjsoJwg7KSRIOydvOu2gOulvCDqsJzshKDtlZjqs6Ag7IOI66Gc7Jq0IOyEseuKpSDquLDriqXsnYQg64+E7J6F7ZWY6riwIOychO2VtCBUQ1Drpbwg67Cc7KCEIOuwjyDsl4Xqt7jroIjsnbTrk5ztlZjroKTqs6Ag7ZaI7Iq164uI64ukLiDsmIjrpbwg65Ok7Ja0IFRDUCBGYXN0IE9wZW7snYAg7IOB7JyEIOqzhOy4tSDtlITroZzthqDsvZzsnbQg7LKY7J2M67aA7YSwIOuNsOydtO2EsOulvCDrs7Trgrwg7IiYIOyeiOuPhOuhnSDtlZjsl6wg7ZW465Oc7IWw7J207YGsIOyYpOuyhO2XpOuTnOulvCDsoJzqsbDtlanri4jri6QuIOuYkCDri6Trpbgg64W466Cl7J2AIE11bHRpUGF0aCBUQ1Drnbzqs6Ag7ZWp64uI64ukLiDsl6zquLDshJwg7JWE7J2065SU7Ja064qUIO2ctOuMgCDsoITtmZTsl5Ag7J2867CY7KCB7Jy866GcIFdpLUZp7JmAICg0Rykg7IWA66Ow65+sIOyXsOqysOydtCDrqqjrkZAg7J6I64uk64qUIOqyg+yeheuLiOuLpC4g6re465+s66+A66GcIOy2lOqwgCDsspjrpqzrn4nqs7wg6rKs6rOg7ISx7J2EIOychO2VtCDrkZAg6rCA7KeA66W8IOuPmeyLnOyXkCDsgqzsmqntlZjsp4Ag7JWK7J2EIOydtOycoOqwgCDsl4bqsqDri6TripQg7IOd6rCB7J20IOuLueyXsO2eiCDrk6TqsqDso6A/XFxyXFxuXFxyXFxu7J2065+s7ZWcIFRDUCDtmZXsnqXsnYQg6rWs7ZiE7ZWY64qUIOqyg+ydgCDqt7jrpqwg7Ja066C17KeAIOyViuyKteuLiOuLpC4g6re465+s64KYIDx1PuyLpOygnOuhnCDsnbjthLDrhLcg6rec66qo66GcIOuwsO2PrO2VmOuKlCDqsoPsnYAg66ek7JqwIOyWtOugteyKteuLiOuLpDwvdT4uIFRDUOuKlCDrhJDrpqwg7IKs7Jqp65CY6riwIOuVjOusuOyXkCDsl7DqsrDrkJwg6rGw7J2YIOuqqOuToCDsnqXsuZjsl5DripQg7J6Q7LK0IO2UhOuhnO2GoOy9nCDqtaztmITsnbQg7YOR7J6s65CY7Ja0IOyeiOyKteuLiOuLpC4g7J2065+s7ZWcIOq1rO2YhOydtCDrhIjrrLQg7Jik656Y65CY7JeI6rGw64KYIOyXheuNsOydtO2KuOqwgCDrtoDsobHtlZjqsbDrgpgg67KE6re46rCAIOyeiOuKlCDqsr3smrAg7ZmV7J6l7J2EIOyLpOygnOuhnCDsgqzsmqntlaAg7IiYIOyXhuyKteuLiOuLpC4g64us66asIOunkO2VmOuptCwg66qo65OgIOq1rO2YhOydgCDtmZXsnqXsnbQg7Jyg7Jqp7ZWY66Ck66m0IO2ZleyepeyXkCDrjIDtlbQg7JWM7JWE7JW8IO2VqeuLiOuLpC4g7LWc7KKFIOyCrOyaqeyekCDsnqXsuZgo7JiIOiDsu7Ttk6jthLAg65iQ64qUIOybuSDshJzrsoQp7JeQIOuMgO2VtOyEnOunjCDsnbTslbzquLDtlZjripQg6rK97JqwIOyImOuPmeycvOuhnCDruYTqtZDsoIEg7Im96rKMIOyXheuNsOydtO2KuO2VoCDsiJgg7J6I6riwIOuVjOusuOyXkCDsnbTripQg7YGwIOusuOygnOqwgCDrkJjsp4Ag7JWK7Iq164uI64ukLiDqt7jrn6zrgpgg7J6Q7LK0IFRDUCDsvZTrk5zrj4Qg7YOR7J6s65CcIO2BtOudvOydtOyWuO2KuOyZgCDshJzrsoQg7IKs7J207JeQIOuLpOuluCDrp47snYAg7J6l7LmY6rCAIOyeiOyKteuLiOuLpCjsmIg6IOuwqe2ZlOuyvSwg66Gc65OcIOuwuOufsOyEnCwg65287Jqw7YSwLCDsupDsi7Eg7ISc67KELCDtlITroZ3si5wg65OxKS4gPHU+7J2065+s7ZWcIOuvuOuTpOuwleyKpOuKlCDsl4XrjbDsnbTtirjtlZjquLDqsIAg642UIOyWtOugteqzoCDrlYzroZzripQg642UIOyXhOqyqe2VqeuLiOuLpDwvdT4uIOyYiOulvCDrk6TslrQg7J6l7LmY6rCAIOuwqe2ZlOuyveyduCDqsr3smrAgKOyVjCDsiJgg7JeG64qUKSDtmZXsnqXsnYQg7Y+s7ZWo7ZWY64qUIOuqqOuToCDtirjrnpjtlL3snYQg7LCo64uo7ZWY64+E66GdIOq1rOyEseuQoCDsiJgg7J6I7Iq164uI64ukLiDsi6TsoJzroZwsIOyXhOyyreuCnCDsiJjsnZgg7Zmc7ISxIOuvuOuTpOuwleyKpOqwgCDsg4jroZzsmrQg7ZmV7J6l7JeQIOuMgO2VtCDrjZQg7J207IOBIOycoOyngOuQmOyngCDslYrripQgVENQ7JeQIOuMgO2VnCDtirnsoJUg6rCA7KCV7J2EIO2VmOuKlCDqsoPsnLzroZwg64KY7YOA64Ks7Iq164uI64ukLiA8dT7qsrDqs7zsoIHsnLzroZwg7Lap67aE7ZWcICjrr7jrk6TrsJXsiqQpIFRDUCDqtaztmITsnbQg7Iuk7KCc66GcIOuMgOq3nOuqqOuhnCDtmZXsnqXsnYQg7IKs7Jqp7ZWY64+E66GdIOyXheuNsOydtO2KuOuQmOq4sOq5jOyngOuKlCDrqocg64WE7JeQ7IScIDEw64WEIOydtOyDgeydtCDqsbjrprQg7IiYIOyeiOyKteuLiOuLpC4gVENQ66W8IOynhO2ZlOyLnO2CpOuKlCDqsoPsnYAg7IKs7Iuk7IOBIOu2iOqwgOuKpe2VtOyhjOuLpOqzoCDrp5DtlaAg7IiYIOyeiOyKteuLiOuLpC48L3U+XFxyXFxuXFxyXFxu6rKw6rO87KCB7Jy866GcIOydtOufrO2VnCDrrLjsoJzrpbwg7ZW06rKw7ZWY66Ck66m0IOyngeygkeyggeyduCDsl4Xqt7jroIjsnbTrk5zqsIAg7JWE64uI6528IFRDUOyXkCDrjIDtlZwg64yA7LK0IO2UhOuhnO2GoOy9nOydtCDtlYTsmpTtlZjri6TripQg6rKD7J20IOu2hOuqhe2VtOyhjOyKteuLiOuLpC4g6re465+s64KYIFRDUCDquLDriqXqs7wg64uk7JaR7ZWcIOq1rO2YhOydmCDrs7XsnqHshLHsnLzroZwg7J247ZW0IOyymOydjOu2gO2EsCDsg4jroa3qs6Ag642UIOuCmOydgCDqsoPsnYQg66eM65Oc64qUIOqyg+ydgCDquLDrhZDruYTsoIHsnbgg7J287J20IOuQoCDqsoPsnoXri4jri6QuIOq3uOuemOyEnCAyMDEw64WE64yAIOy0iOuwmOyXkCDsnbQg7J6R7JeF7J2EIOyXsOq4sO2VmOq4sOuhnCDqsrDsoJXtlojsirXri4jri6QuIOqysOq1rSBUQ1Drv5Drp4wg7JWE64uI6528IEhUVFAvMS4x7JeQ64+EIOusuOygnOqwgCDsnojsl4jsirXri4jri6QuIOyasOumrOuKlCDsnpHsl4XsnYQg67aE7ZWg7ZWY6rOgIOuovOyggCBIVFRQLzEuMeydhCBcXFwi7IiY7KCVXFxcIu2VmOyXrCDtmITsnqwgSFRUUC8y6rCAIOuQmOuPhOuhnSDshKDtg53tlojsirXri4jri6QuIOydtCDsnpHsl4XsnbQg7JmE66OM65CY66m0IO2YhOyerCBRVUlD7J24IFRDUOulvCDrjIDssrTtlZjripQg7J6R7JeF7J2EIOyLnOyeke2VoCDsiJgg7J6I7Iq164uI64ukLiDsm5DrnpggUVVJQyDsnITsl5DshJwgSFRUUC8y66W8IOyngeygkSDsi6TtlontlaAg7IiYIOyeiOq4sOulvCDtnazrp53tlojsp4Drp4wg7KO866GcIOq4sOuKpSDspJHrs7XsnLzroZwg7J247ZW0IOyLpOygnOuhnOuKlCDqtaztmITsnbQg64SI66y0IOu5hO2aqOycqOyggeydtOyXiOyKteuLiOuLpC4g64yA7IugIDx1PkhUVFAvMuuKlCBRVUlD7JmAIO2YuO2ZmOuQmOuPhOuhnSDrqocg6rCA7KeAIOyjvOyalCDsmIHsl63sl5DshJwg7KGw7KCVPC91PuuQmOyXiOyKteuLiOuLpC4g7J20IOyhsOygleuQnCDrsoTsoITsnYAg7KO866GcIOuniOy8gO2MhSDsnbTsnKDsmYAg66qF7ZmV7ISx7J2EIOychO2VtCBIVFRQLzMoUVVJQyDrjIDsi6AgSFRUUC8yKeycvOuhnCDrqoXrqoXrkJjsl4jsirXri4jri6QuIOuUsOudvOyEnCA8dT5IVFRQLzEuMeqzvCBIVFRQLzLsnZgg7LCo7J207KCQ7J2AIEhUVFAvMuyZgCBIVFRQLzPsnZgg7LCo7J207KCQ67O064ukIO2bqOyUrCDrjZQg7KSR7JqU7ZWp64uI64ukLjwvdT5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyA6YnVsYjogV2hhdCBJcyBRVUlDP1xcclxcblxcclxcbuuLueyLoOydgCDslYTrp4gg7J206rKMIOyZnCDspJHsmpTtlZzsp4Ag6raB6riI7ZWgIOqyg+yeheuLiOuLpC4g7J2065+s7ZWcIOq4sOuKpeydtCBIVFRQLzMg7JeQIOyeiOuKlOyngCBRVUlD7JeQIOyeiOuKlOyngCDqt7jrn7Dqsbgg64iE6rCAIOyLoOqyvSDsk7DrgpjsmpQ/IFFVSUPsnYAgVENQ7JmAIOuniOywrOqwgOyngOuhnCBIVFRQIOuwjyDsm7kg7Y6Y7J207KeAIOuhnOuUqSDsmbjsl5Drj4Qg66eO7J2AIOyCrOyaqSDsgqzroYDsl5Ag7IKs7Jqp65CgIOyImCDsnojqs6Ag7JWe7Jy866Gc64+EIOyCrOyaqeuQoCDsnbzrsJgg7KCE7IahIO2UhOuhnO2GoOy9nOydtOq4sCDrlYzrrLjsl5Ag7J206rKD7J20IOykkeyalO2VmOuLpOqzoCDsg53qsIHtlanri4jri6QuIOyYiOulvCDrk6TslrQgRE5TLCBTU0gsIFNNQiwgUlRQIOuTseydgCDrqqjrkZAgUVVJQ+ulvCDthrXtlbQg7Iuk7ZaJ7ZWgIOyImCDsnojsirXri4jri6QuIOuUsOudvOyEnCDrgrTqsIAg7J297J2AIEhUVFAvM+yXkCDrjIDtlZwg64yA67aA67aE7J2YIOyYpO2VtOqwgCDsl6zquLDsl5Ag7J6I6riwIOuVjOusuOyXkCBRVUlD7JeQIOuMgO2VtCDsooAg642UIOyekOyEuO2eiCDsgrTtjrTrs7TqsqDsirXri4jri6QuXFxyXFxuXFxyXFxu7JWE66eIIFFVSUPqsIAgKlVEUChVc2VyIERhdGFncmFtIFByb3RvY29sKSrrnbzripQg65iQIOuLpOuluCDtlITroZzthqDsvZwg7JyE7JeQ7IScIOyLpO2WieuQnOuLpOuKlCDqsoPsnYQg65Ok7Ja067O07IWo7J2EIOqyg+yeheuLiOuLpC4g7J206rKD7J2AIOyCrOyLpOydtOyngOunjCDrp47snYAg7IKs656M65Ok7J20IOyjvOyepe2VmOuKlCDshLHriqUg7J207Jyg64qUIOyVhOuLmeuLiOuLpC4g7J207IOB7KCB7Jy866GcIFFVSUPripQg7JyE7JeQ7IScIOqzteycoO2VnCDsnbTrr7jsp4Dsl5Ag7ZGc7Iuc65CcIO2UhOuhnO2GoOy9nCDsiqTtg53snZggSVAg7JyE7JeQ7IScIOyngeygkSDsi6TtlonrkJjripQg7JmE7KCE7Z6IIOuPheumveyggeyduCDsg4jroZzsmrQg7KCE7IahIO2UhOuhnO2GoOy9nOydtOyXiOydhCDqsoPsnoXri4jri6QuIOq3uOufrOuCmCDqt7jroIfqsowg7ZWY66m0IDx1PlRDUOulvCDrsJzsoITsi5ztgqTroKTqs6Ag7ZWgIOuVjCDsp4HrqbTtlojrjZgg6rKD6rO8IOuPmeydvO2VnCDrrLjsoJzqsIAg67Cc7IOd7ZaI7J2EIOqygzwvdT4o66+465Ok7Juo7Ja0IHByb2JsZW1zKeyeheuLiOuLpC4gUVVJQ+ulvCDsnbjsi53tlZjqs6Ag7ZeI7Jqp7ZWY66Ck66m0IOyduO2EsOuEt+ydmCDrqqjrk6Ag7J6l7LmY66W8IOuovOyggCDsl4XrjbDsnbTtirjtlbTslbwg7ZWp64uI64ukLiDsmrTsnbQg7KKL6rKM64+EICoqPHU+7J247YSw64S37JeQ7IScIOq0keuylOychO2VmOqyjCDsp4Dsm5DrkJjripQg64uk66W4IO2VmOuCmOydmCDsoITshqEg6rOE7Li1IO2UhOuhnO2GoOy9nOyduCBVRFAg7JyE7JeQIFFVSUPrpbwg6rWs7LaVPC91Pioq7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu66eO7J2AIOy2nOyymOyXkOyEnCBIVFRQLzPqsIAg7ISx64qlIOuVjOusuOyXkCBVRFAg7JyE7JeQIOq1rOy2leuQmOyXiOuLpOqzoCDso7zsnqXtlanri4jri6QuIEhUVFAvM+uKlCBVRFDsmYAg66eI7LCs6rCA7KeA66GcIOyXsOqysOydhCDshKTsoJXtlZjsp4Ag7JWK6rOgIO2MqO2CtyDsnqzsoITshqHsnYQg6riw64uk66as7KeAIOyViuq4sCDrlYzrrLjsl5Ag642UIOu5oOultOuLpOqzoCDtlanri4jri6QuIO2VmOyngOunjCDsnbTrn6ztlZwg7KO87J6l7J2AIOyemOuqu+uQnCDqsoPsnoXri4jri6QuIOychOyXkOyEnCDrp5Dtlojrk6/snbQgKio8dT5VRFDripQgUVVJQ+yXkOyEnCDsgqzsmqk8L3U+KirrkJjrqbAsIEhUVFAvM+ydgCDso7zroZwg7J247YSw64S37J2YICjqsbDsnZgpIOuqqOuToCDsnqXsuZjsl5Ag7J2066+4IOyVjOugpOyguCDsnojqs6Ag6rWs7ZiE65CY6riwIOuVjOusuOyXkCDrsLDtj6zqsIAg642UIOyJrOybjOyngOq4sOulvCDtnazrp53tlZjquLAg65WM66y47J6F64uI64ukLiBVRFAg7JyE7JeQIOyWueyWtOynhCBRVUlD7J2AIOq4sOuzuOyggeycvOuhnCBUQ1DsnZgg6rCV66Cl7ZWY6rOgIOuMgOykkeyggeyduCjqt7jrn6zrgpgg64uk7IaMIOuKkOumsCkg6rGw7J2YIOuqqOuToCDquLDriqXsnYQg64uk7IucIOq1rO2YhO2VqeuLiOuLpC4gKipRVUlD64qUIOyImOyLoOuQnCDtjKjtgrfqs7wg7J6s7KCE7Iah7JeQIOuMgO2VnCDsirnsnbjsnYQg7IKs7Jqp7ZWY7JesIOyGkOyLpOuQnCDtjKjtgrfsnbQg7Jes7KCE7Z6IIOuPhOywqe2VmOuPhOuhnSDtlZjripQg7KCI64yA7KCB7Jy866GcIOyLoOuisCoq7ZWgIOyImCDsnojsirXri4jri6QuIFFVSUPripQg7Jes7KCE7Z6IIOyXsOqysOydhCDshKTsoJXtlZjqs6AgKio8dT7rp6TsmrAg67O17J6h7ZWcIO2VuOuTnOyFsOydtO2BrOulvCDsgqzsmqk8L3U+Kirtlanri4jri6QuIFxcclxcblxcclxcbuuniOyngOunieycvOuhnCBRVUlD64qUIOuwnOyLoOyekOqwgCDrhKTtirjsm4ztgazrgpgg7IiY7Iug7J6Q7JeQIOqzvOu2gO2VmOulvCDso7zsp4Ag7JWK64+E66GdIO2VmOuKlCwg7IaM7JyEIO2dkOumhCDsoJzslrQg67CPIO2YvOyeoSDsoJzslrQg66mU7Luk64uI7KaY7J2EIOyCrOyaqe2VmOyngOunjCwg7J2066GcIOyduO2VtCDsm5Dsi5wgVURQ66GcIO2VoCDsiJgg7J6I64qUIOqyg+uztOuLpCBUQ1Drpbwg64qQ66as6rKMIO2VqeuLiOuLpC4g7ZW17Ius7J2AIFFVSUPsnbQg7J2065+s7ZWcIOq4sOuKpeydhCBUQ1Drs7Tri6Qg642UIOuYkeuYke2VmOqzoCDrjZQg7ISx64ql7J20IOyii+ydgCDrsKnsi53snLzroZwg6rWs7ZiE7ZWc64uk64qUIOqyg+yeheuLiOuLpC4g7IiY7IutIOuFhOydmCDrsLDtj6wg6rK97ZeY6rO8IFRDUOydmCDrqqjrspQg7IKs66GA66W8IOuqhyDqsIDsp4Ag7ZW17IusIOyDiCDquLDriqXqs7wg6rKw7ZWp7ZWp64uI64ukLiDsnbQg6riw7IKs7J2YIOuSt+u2gOu2hOyXkOyEnCDsnbTrn6ztlZwg6riw64ql7JeQIOuMgO2VtCDrjZQg7J6Q7IS47Z6IIOyEpOuqhe2VqeuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4jIyBUaGUgQmlnIENoYW5nZXNcXHJcXG5cXHJcXG7qt7jroIfri6TrqbQgUVVJQ+ydgCBUQ1Drs7Tri6Qg7KCV7ZmV7Z6IIOyWtOuWpCDsoJDsnbQg7Ja866eI64KYIO2WpeyDgeuQnOuLpOuKlCDqsoHri4jquYw/IOutkOqwgCDqt7jroIfqsowg64uk66W46rG06rCA7JqUPyDsi5zrpqzspojsnZgg64uk7J2MIOu2gOu2hOyXkOyEnCDsnpDshLjtnogg64W87J2Y7ZWgIFFVSUMoMC1SVFQg642w7J207YSwLCDsl7DqsrAg66eI7J206re466CI7J207IWYLCDtjKjtgrcg7IaQ7IukIOuwjyDripDrprAg64Sk7Yq47JuM7YGs7JeQIOuMgO2VnCDrs7Xsm5DroKUg7Zal7IOBKeyXkOuKlCDrqocg6rCA7KeAIOyDiOuhnOyatCDqtazssrTsoIHsnbgg6riw64ql6rO8IOq4sO2ajOqwgCDsnojsirXri4jri6QuIOq3uOufrOuCmCDsnbTrn6ztlZwg66qo65OgIOyDiOuhnOyatCDsgqztla3snYAg6riw67O47KCB7Jy866GcIDTqsIDsp4Ag7KO87JqUIOuzgOqyvSDsgqztla3snLzroZwg7JqU7JW965Cp64uI64ukLlxcclxcblxcclxcbjEuIFFVSUMgZGVlcGx5IGludGVncmF0ZXMgd2l0aCBUTFMuIFFVSUPripQgVExT7JmAIOq4tOuwgO2VmOqyjCDthrXtlanrkKnri4jri6QuXFxyXFxuMi4gUVVJQyBzdXBwb3J0cyBtdWx0aXBsZSAqaW5kZXBlbmRlbnQqIGJ5dGUgc3RyZWFtcy4gUVVJQ+uKlCDsl6zrn6wg6rCc7J2YIOuPheumveyggeyduCDrsJTsnbTtirgg7Iqk7Yq466a87J2EIOyngOybkO2VqeuLiOuLpC5cXHJcXG4zLiBRVUlDIHVzZXMgY29ubmVjdGlvbiBJRHMuIFFVSUPripQg7Jew6rKwIElE66W8IOyCrOyaqe2VqeuLiOuLpC5cXHJcXG40LiBRVUlDIHVzZXMgZnJhbWVzLiBRVUlD64qUIO2UhOugiOyehOydhCDsgqzsmqntlanri4jri6QuXFxyXFxuXFxyXFxu7KKAIOuNlCDsnpDshLjtnogg7JWM7JWE67O07J6QLlxcclxcblxcclxcbiMjIyBUTFMg7JeG7J20IFFVSUPrj4Qg7JeG64ukXFxyXFxuXFxyXFxu7Ja46riJ7ZaI65Ov7J20IFRMU+uKlCDsnbjthLDrhLfsnYQg7Ya17ZW0IOyghOyGoeuQmOuKlCDrjbDsnbTthLDsnZgg67O07JWIIOuwjyDslZTtmLjtmZTrpbwg64u064u57ZWp64uI64ukLiBIVFRQU+ulvCDsgqzsmqntlZjripQg6rK97JqwIOydvOuwmCDthY3siqTtirggSFRUUCDrjbDsnbTthLDripQgVENQ66GcIOyghOyGoeuQmOq4sCDsoITsl5Ag66i87KCAIFRMU+uhnCDslZTtmLjtmZTrkKnri4jri6QuXFxyXFxuXFxyXFxuIVtUU0wsIFRDUCBhbmQgUVVJQ10oaHR0cHM6Ly9jbG91ZC5uZXRsaWZ5dXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8zNDRkYmY4OC1mZGY5LTQyYmItYWRiNC00NmYwMWVlZGQ2MjkvZjIyNDBjYjQtZWI2Mi00MDU0LWFkMTktMGU3MjE5MGUwYTRmL2Nvbm5lY3Rpb24tc2V0dXAucG5nKVxcclxcblxcclxcbuyduO2EsOuEtyDstIjssL3quLAg7Iuc7KCI7JeQ64qUIO2KuOuemO2UveydhCDslZTtmLjtmZTsspjrpqwg67mE7Jqp7J20IOunjuydtCDrk6Tsl4jsirXri4jri6QuIOuYkO2VnCDrqqjrk6Ag7Jyg7IqkIOy8gOydtOyKpOyXkCDrsJjrk5zsi5wg7ZWE7JqU7ZWcIOqyg+ycvOuhnCDsl6zqsqjsp4Dsp4Ag7JWK7JWY7Iq164uI64ukLiDsl63sgqzsoIHsnLzroZwgVExT64qUIFRDUCDsnITsl5DshJwg7ISg7YOd7KCB7Jy866GcIOyCrOyaqe2VoCDsiJgg7J6I64qUIOyZhOyghO2eiCDrs4Trj4TsnZgg7ZSE66Gc7Yag7L2c7J207JeI7Iq164uI64ukLiDsnbTqsoPsnbQgSFRUUChUTFMg7JeG7J2MKeyZgCBIVFRQUyhUTFMg7Y+s7ZWoKeulvCDqtazrtoTtlZjripQg7J207Jyg7J6F64uI64ukLiDsi5zqsITsnbQg7KeA64KY66m07IScIOyduO2EsOuEtyDrs7TslYjsl5Ag64yA7ZWcIOyasOumrOydmCDtg5zrj4TripQg67OA7ZmU7ZaI7Iq164uI64ukLiBcXFwi67O07JWI7J20IOuQnCDqsoMoSFRUUFMp6rCAIOq4sOuzuOydtOuLpFxcXCLrnbzqs6Ag66eQ7J207KOgLiDrlLDrnbzshJwgSFRUUC8y64qUIOydtOuhoOyggeycvOuhnCBUU0zsl4bsnbQgVENQ66W8IO2Gte2VtCDsp4HsoJEg7Iuk7ZaJ7ZWgIOyImCDsnojsp4Drp4wg7Iuk7KCc66GcIOydtCDrqqjrk5zrpbwg7KeA7JuQ7ZWY64qUIOybuSDruIzrnbzsmrDsoIDripQg7JeG7Iq164uI64ukLiDslrTrlqQg66m07JeQ7IScIOu4jOudvOyasOyggCDsoJzsobDsl4XssrTripQg7ISx64ql7J2EIO2drOyDne2VmOuptOyEnOq5jOyngCDrs7TslYjsg4HsnZgg7JWI7KCE7J2EIOychO2VtCDsnbzrtoDrn6wg7KCI7Lap7JWI7J2EIO2Dne2WiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5hbHdheXMtb24gVFNM66Gc7J2YIOu2hOuqhe2VnCDsp4Trs7Qg642V67aE7JeQIFFVSUPsnZgg7ISk6rOE7J6QKGRlc2lnbmVyKeqwgCDsnbQg7Yq466CM65Oc66W8IO2VnCDri6jqs4Qg642UIOuwnOyghOyLnO2CpOq4sOuhnCDqsrDsoJXtlZwg6rKD7J2AIOyWtOywjOuztOuptCDri7nsl7DtlZwg6rKD7J287KeA64+EIOuqqOumheuLiOuLpC4g64uo7Iic7Z6IIEhUVFAvM+yXkCDrjIDtlZwg7J2867CYIO2FjeyKpO2KuCDrqqjrk5zrpbwg7KCV7J2Y7ZWY7KeAIOyViuuKlCDrjIDsi6AgUVVJQyDsnpDssrTsl5Ag7JWU7Zi47ZmU66W8IOq5iuyImeydtCDrv4zrpqzquLDroZwg7ISg7YOd7ZaI7Iq164uI64ukLiBRVUlD7J2YIOyyqyDrsojsp7ggR29vZ2xlIOyghOyaqSDrsoTsoITsnYAg7J2066W8IOychO2VtCDrp57stqQg7ISk7KCV7J2EIOyCrOyaqe2WiOyngOunjCDtkZzspIDtmZTrkJwgUVVJQ+uKlCDquLDsobQgVExTIDEuMyDsnpDssrTrpbwg7KeB7KCRIOyCrOyaqe2VqeuLiOuLpC4g7J2066W8IOychO2VtCDsnbTsoIQg7J2066+47KeA7JeQ7IScIOuzvCDsiJgg7J6I65Ov7J20IDx1Pu2UhOuhnO2GoOy9nCDsiqTtg53snZgg7ZSE66Gc7Yag7L2cIOqwhOydmCDsnbzrsJjsoIHsnbgg66qF7ZmV7ZWcIOu2hOumrOulvCDquajrnKjrpr3ri4jri6Q8L3U+LiBUTFMgMS4z7J2AIOyXrOyghO2eiCBUQ1Ag7JyE7JeQ7IScIOuPheumveyggeycvOuhnCDsi6TtlontlaAg7IiYIOyeiOyngOunjCBRVUlD64qUIOuMgOyLoCBUTFMgMS4z7J2EIOy6oeyKkO2ZlO2VqeuLiOuLpC4gPHU+64us66asIOunkO2VmOuptCBUTFMg7JeG7J20IFFVSUPrpbwg7IKs7Jqp7ZWgIOuwqeuyleydtCDsl4bsirXri4jri6QuIFFVSUMo67CPIO2Zleyepe2VmOyXrCBIVFRQLzMp64qUIO2VreyDgSDsmYTsoITtnogg7JWU7Zi47ZmU65Cp64uI64ukPC91Pi4g65iQ7ZWcIFFVSUPripQg6rGw7J2YIOuqqOuToCDtjKjtgrcg7Zek642UIO2VhOuTnOuPhCDslZTtmLjtmZTtlanri4jri6QuIOyghOyGoSDqs4TsuLUg7KCV67O0KOyYiDogVENQ7JeQIOuMgO2VtCDslZTtmLjtmZTrkJjsp4Ag7JWK7J2AIO2MqO2CtyDrsojtmLgp64qUIOuNlCDsnbTsg4EgUVVJQ+ydmCDspJHqsJzsnpDqsIAg7J297J2EIOyImCDsl4bsirXri4jri6Qo7J2867aAIO2MqO2CtyDtl6TrjZQg7ZSM656Y6re464+EIOyVlO2YuO2ZlOuQqCkuXFxyXFxuXFxyXFxuIVsqVW5saWtlIFRDUCArIFRMUywgUVVJQyBhbHNvIGVuY3J5cHRzIGl0cyB0cmFuc3BvcnQtbGF5ZXIgbWV0YSBkYXRhIGluIHRoZSBwYWNrZXQgaGVhZGVyIGFuZCBwYXlsb2FkLipdKGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2luZHlzaWduZXIvaW1hZ2UvZmV0Y2gvZl9hdXRvLHFfODAvd18xMjAwL2h0dHBzOi8vY2xvdWQubmV0bGlmeXVzZXJjb250ZW50LmNvbS9hc3NldHMvMzQ0ZGJmODgtZmRmOS00MmJiLWFkYjQtNDZmMDFlZWRkNjI5L2ZiZjg2YjQyLThmMjAtNGIyNy1hZWE1LWYxZmMxNjRiMjY4My90Y3AtdnMtcXVpYy1wYWNrZXRpemF0aW9uLnBuZylcXHJcXG5cXHJcXG7snbQg66qo65OgIOqyg+ydhCDsnITtlbQgUVVJQ+uKlCDrqLzsoIAg7IiY7ZWZ7KCBIOyVlO2YuO2ZlCDrp6TqsJzrs4DsiJjrpbwg7ISk7KCV7ZWY6riwIOychO2VtCA8dT5UQ1Drpbwg7IKs7Jqp7ZWY64qUIOqyg+yymOufvCBUTFMgMS4zIO2VuOuTnOyFsOydtO2BrOulvCDsgqzsmqk8L3U+7ZWp64uI64ukLiDqt7jrn6zrgpgg7J207ZuE7JeQ64qUIFFVSUPqsIAg7Yyo7YK3IOyekOyytOulvCDsnbjsiJjtlZjsl6wg7JWU7Zi47ZmU7ZWY64qUIOuwmOuptCBUTFMtb3Zlci1UQ1Dsl5DshJzripQgVExT6rCAIOyekOyytCDslZTtmLjtmZTrpbwg7IiY7ZaJ7ZWp64uI64ukLiDsnbQg6rKJ67O06riw7JeQIOyekeydgCDssKjsnbTripQg642UIOuCruydgCDtlITroZzthqDsvZwg6rOE7Li17JeQ7IScIOyLnO2WieuQmOuKlCDsg4Hsi5wg7J6R64+ZIOyVlO2YuO2ZlOyXkCDrjIDtlZwg6re867O47KCB7J24IOqwnOuFkOyggSDrs4DtmZTrpbwg64KY7YOA64OF64uI64ukLlxcclxcblxcclxcbuydtCDrsKnrspXsnYAgUVVJQ+yXkCAqKjx1PuuqhyDqsIDsp4Ag7J2065Od7J2EIOygnOqztTwvdT4qKu2VqeuLiOuLpC5cXHJcXG5cXHJcXG4jIyMgIOydtOygkDEuIFFVSUMgaXMgbW9yZSBzZWN1cmUgZm9yIGl0cyB1c2Vycy4g7Jyg7KCA64qUIGF0dGFja2Vy7JmAIOuPhOyyreyekOuhnOu2gO2EsCDrjZTsmrEg7JWI7KCE7ZWp64uI64ukLlxcclxcblxcclxcbuydvOuwmCDthY3siqTtirggUVVJQ+ulvCDsi6TtlontlaAg7IiYIOyeiOuKlCDrsKnrspXsnbQg7JeG7Jy866+A66GcIOqzteqyqeyekOyZgCDrj4Tssq3snpDqsIAg65Ok7J2EIOyImCDsnojripQg7Ji17IWY64+EIOyggeyKteuLiOuLpC5cXHJcXG5cXHJcXG4jIyMg7J207KCQMi4gUVVJQ+KAmXMgY29ubmVjdGlvbiBzZXQtdXAgaXMgZmFzdGVyLiDsl7DqsrDsnbQg642UIOu5oOumheuLiOuLpC5cXHJcXG5cXHJcXG5UTFMtb3Zlci1UQ1Ag67Cp7Iud7JeQ7ISc64qUIOuRkCDtlITroZzthqDsvZwg66qo65GQ7JeQ7IScIOu2hOumrOuQnCDtlbjrk5zshbDsnbTtgazqsIAg7ZWE7JqU7ZaI64uk66m0IFFVSUPsnYAg7KCE7Iah6rO8IOyVlO2YuO2ZlCDtlbjrk5zshbDsnbTtgazrpbwg7ZWY64KY66GcIOqysO2Vqe2VmOyXrCDsmZXrs7Ug7IucIOy9lOyKpO2KuOulvCDsoIjslb3tlaAg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4jIyMg7J207KCQMy4gUVVJQyBjYW4gZXZvbHZlIG1vcmUgZWFzaWx5LiDsg4jroa3qsowg7KeE7ZmU7ZWY6riwIOyJveuLpC5cXHJcXG5cXHJcXG7smYTsoITtnogg7JWU7Zi47ZmUIOuQmOyWtOyeiOq4sCDrlYzrrLjsl5Ag64Sk7Yq47JuM7YGs7J2YIOuvuOuTpOuwleyKpOuKlCDrjZQg7J207IOBIFRDUOyXkOyEnOyZgCDqsJnsnbQg64K067aAIOyekeuPmeydhCDqtIDssLDtlZjqs6Ag7ZW07ISd7ZWgIOyImCDsl4bsirXri4jri6QuIOqysOqzvOyggeycvOuhnCDsl4XrjbDsnbTtirjsl5Ag7Iuk7Yyo7ZaI6riwIOuVjOusuOyXkCDstZzsi6Ag67KE7KCE7J2YIFFVSUPsl5DshJwg642UIOydtOyDgSDspJHri6jrkKAg7IiYIOyXhuyKteuLiOuLpC4g7Zal7ZuEIFFVSUPsl5Ag7IOI66Gc7Jq0IOq4sOuKpeydhCDstpTqsIDtlZjroKTrqbQg66qo65OgIOuvuOuTpOuwleyKpCDrjIDsi6Ag7LWc7KKFIOyepey5mOunjCDsl4XrjbDsnbTtirjtlZjrqbQg65Cp64uI64ukLlxcclxcblxcclxcbu2VmOyngOunjCDrj5nsi5zsl5AgKio8dT7snqDsnqzsoIEgRE9XTlNJREXrj4Qg7JiI7IOBPC91Pioq65Cp64uI64ukLlxcclxcblxcclxcbiMjIyDri6jsoJAxLiBNYW55IG5ldHdvcmtzIHdpbGwgaGVzaXRhdGUgdG8gYWxsb3cgUVVJQy4g64uk7IiY7J2YIOuEpO2KuOybjO2BrOyXkOyEnCBRVUlD64+E7J6F7J2EIOq6vOumtCDqsoPsnbTri6QuXFxyXFxuXFxyXFxu7JuQ7LmYIOyViuuKlCDtirjrnpjtlL3snYQg6rCQ7KeA7ZWY64qUIOqyg+ydtCDrjZQg7Ja066Ck7JuM7KeA6riwIOuVjOusuOyXkCA8dT7tmozsgqzripQg67Cp7ZmU67K97JeQ7IScIOydtOulvCDssKjri6jtlZjroKTqs6Ag7ZWgIOyImCDsnojsirXri4jri6Q8L3U+LiDtj4nqt6Ag7KeA7JewIOuwjyDtjKjtgrcg7IaQ7IukIOu5hOycqOqzvCDqsJnsnYAg66mU7Yq466at7J2EIOuNlCDsnbTsg4Eg7Im96rKMIOyCrOyaqe2VoCDsiJgg7JeG7Ja0IDx1PuusuOygnOulvCDqsJDsp4DtlZjqs6Ag7KeE64uo7ZWY6riw6rCAIOuNlCDslrTroKTsm4zsp4DquLAg65WM66y47JeQIElTUCDrsI8g7KSR6rCEIOuEpO2KuOybjO2BrOqwgCDsnbTrpbwg7LCo64uo7ZWgIOyImCDsnojsirXri4jri6QuPC91PlxcclxcblxcclxcbiMjIyDri6jsoJAyLiBRVUlDIGhhcyBhIGhpZ2hlciBlbmNyeXB0aW9uIG92ZXJoZWFkLiDslZTtmLjtmZQg7Jik67KE7Zek65Oc6rCAIOuNlCDtgazri6QuXFxyXFxuXFxyXFxuUVVJQ+uKlCBUTFProZwg6rCBIOqwnOuzhCDtjKjtgrfsnYQg7JWU7Zi47ZmU7ZWY64qUIOuwmOuptCBUTFMtb3Zlci1UQ1DripQg64+Z7Iuc7JeQIOyXrOufrCDtjKjtgrfsnYQg7JWU7Zi47ZmU7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuIyMjIOuLqOygkCAzLiBRVUlDIG1ha2VzIHRoZSB3ZWIgbW9yZSBjZW50cmFsaXplZC4gUVVJQ+ydtCDsm7nsnYQg642UIOykkeyVmeynkeykke2ZlCDsi5ztgqwg6rKD7J2064ukLlxcclxcblxcclxcbuyyq+ynuOuhnCDrgrTqsIAg7J6Q7KO8IOygke2VnCDrtojrp4zsnYAgXFxcIlFVSUPsnYAg64uk66W4IOyCrOuejOqzvCDrjbDsnbTthLDrpbwg6rO17Jyg7ZWY7KeAIOyViuqzoCA8dT7rjbDsnbTthLDsl5Ag64yA7ZWcIOyghOyytCDslaHshLjsiqQg6raM7ZWc7J2EIOu2gOyXrDwvdT7tlZjquLAg65WM66y47JeQIEdvb2dsZeyXkOyEnCDtkbjsi5ztlZjqs6Ag7J6I7Iq164uI64ukLlxcXCLsmYAg6rCZ7J2AIOqyg+yeheuLiOuLpC4gUVVJQ+uKlCBUTFMtb3Zlci1UQ1AoUVVJQ+uKlCDtmITsg4HsnYQg7Jyg7KeA7ZWc64ukKeuztOuLpCDsmbjrtoAg6rSA7LCw7J6Q66Gc67aA7YSwIOuNlCDrp47snYAo65iQ64qUIOyggeqyjCEpIOyCrOyaqeyekCDsiJjspIAg7KCV67O0KOyYiDog67Cp66y4IOykkeyduCBVUkwp66W8IOyIqOq4sOyngCDslYrsirXri4jri6QuXFxyXFxuXFxyXFxu65GY7Ke466GcLCBHb29nbGXsnbQgUVVJQyDtlITroZzsoJ3tirjrpbwg7Iuc7J6R7ZaI7KeA66eMIOyYpOuKmCDsmrDrpqzqsIAg7J207JW86riw7ZWY64qUIOy1nOyihSDtlITroZzthqDsvZzsnYAgSUVURihJbnRlcm5ldCBFbmdpbmVlcmluZyBUYXNrIEZvcmNlKeydmCDtm6jslKwg642UIOq0keuylOychO2VnCDtjIDsl5DshJwg7ISk6rOE7ZaI7Iq164uI64ukLiBJRVRG7J2YIFFVSUPripQg6riw7Iig7KCB7Jy866GcIEdvb2dsZeydmCBRVUlD7JmAIOunpOyasCDri6TrpoXri4jri6QuIOq3uOufrOuCmCBJRVRG7J2YIOyCrOuejOuTpOydgCDrjIDrtoDrtoQgR29vZ2xlIOuwjyBGYWNlYm9va+qzvCDqsJnsnYAg64yA6riw7JeF6rO8IENsb3VkZmxhcmUg67CPIEZhc3RseeyZgCDqsJnsnYAgQ0RO7JeQ7IScIOyYqCDsgqzrnozrk6TsnoXri4jri6QuIFFVSUPsnZgg67O17J6h7ISx7Jy866GcIOyduO2VtCwg7JiI66W8IOuTpOyWtCDsi6TsoJzroZwgSFRUUC8z7J2EIOyYrOuwlOultOqzoCDshLHriqXsoIHsnLzroZwg67Cw7Y+s7ZWY64qUIOuNsCDtlYTsmpTtlZwg64W47ZWY7Jqw66W8IOqwgOynhCDtmozsgqzripQg7KO866GcIOyVnuyEnCDslrjquIntlZwg7ZqM7IKs65Ok7J28IOqyg+yeheuLiOuLpC4g7J206rKD7J2AIOyVhOuniOuPhCDsnbTrn6ztlZwg7ZqM7IKs65Ok66Gc7J2YIOuNlCDrp47snYAgPHU+7KSR7JWZIOynkeykke2ZlDwvdT7roZwg7J207Ja07KeIIOqyg+ydtCDsmrDroKTrkJjripQg7IKs7ZWt7J6F64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbi0tLVxcclxcblxcclxcbuyXrOq4sOq5jOyngOuPhCDrgrTsmqnsnbQg66eO7J2A642wIOydtOqyjCDsoIjrsJgg7KCV64+E7J6F64uI64ukLi4uIFxcclxcblxcclxcbuuCmOuouOyngCDrgrTsmqnrj4Qg6rOnIOuyiOyXre2VtOyEnCDsl4XroZzrk5ztlZjqsqDsirXri4jri6QuLiFcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cIjsiLCJleHBvcnQgZGVmYXVsdCBcIi0tLVxcclxcbnRpdGxlOiBcXFwi7LKY7J2M67aA7YSwIOuBneq5jOyngCDsg4HshLjtnogg7JWM7JWE67O07J6QIEhUVFAz7JeQIOuMgO2VnCBBIFRPIFogMu2OuFxcXCJcXHJcXG5kYXRlOiBcXFwiMjAyMS4wOC4yMlxcXCJcXHJcXG50YWdzOiBcXHJcXG4gIC0gSFRUUDNcXHJcXG4gIC0g7ZSE66Gc7Yag7L2cXFxyXFxuLS0tXFxyXFxuXFxyXFxuIyAo67KI7JetKSBIVFRQLzMgRlJPTSBBIFRvIFo6IENvcmUgQ29uY2VwdHMgKFBhcnQgMSkgYnkgUm9iaW4gTWFyeFxcclxcblxcclxcbuybkOusuOunge2BrDogW2h0dHBzOi8vd3d3LnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMjEvMDgvaHR0cDMtY29yZS1jb25jZXB0cy1wYXJ0MS9dKGh0dHBzOi8vd3d3LnNtYXNoaW5nbWFnYXppbmUuY29tLzIwMjEvMDgvaHR0cDMtY29yZS1jb25jZXB0cy1wYXJ0MS8pXFxyXFxuXFxyXFxu7J20IOq4gOydgCAqUm9iaW4gTWFyeCrsnZggWyoqSFRUUC8zIEZST00gQSBUbyBaOiBDb3JlIENvbmNlcHRzIChQYXJ0MSkqKl0oaHR0cHM6Ly93d3cuc21hc2hpbmdtYWdhemluZS5jb20vMjAyMS8wOC9odHRwMy1jb3JlLWNvbmNlcHRzLXBhcnQxLynsnYQg65GQIO2PrOyKpO2KuOuhnCDrgpjriKAg67KI7Jet7ZWY7JiA7Iq164uI64ukLlxcclxcblxcclxcbuyVnuu2gOu2hCDssqsg67KI7Ke4IO2PrOyKpO2KuOuKlCBb7LKY7J2M67aA7YSwIOuBneq5jOyngCDsg4HshLjtnogg7JWM7JWE67O07J6QISAtIEhUVFAvM+yXkCDrjIDtlZwgQSBUTyBaICgxKV0oKeyXkOyEnCDrs7Tsi6Qg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4qMuu2gCBTVEFSVCEqXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMgOmJ1bGI6IFFVSUPsnYAg64uk7KSRIOuwlOydtO2KuCDsiqTtirjrprzsnYQg6rWs67aE7ZWgIOyImCDsnojsirXri4jri6RcXHJcXG5cXHJcXG5IVFRQLzEuMeydmCDrpqzshozsiqQg66Gc65OcIO2UhOuhnOyEuOyKpOuKlCDrp6TsmrAg6rCE64uo7ZWp64uI64ukLiDqsIEg7YyM7J287J2AIOyekOyytCBUQ1DqsIAg7Jew6rKw65CY6rOgIO2MjOydvCDsoITssrTqsIAg64uk7Jq066Gc65OcIOuQqeuLiOuLpC4g7JiI66W8IOuTpOyWtCwgQSwgQiwgQyDtjIzsnbzsnbQg7J6I64uk66m0IOyasOumrOuKlCAz6rCc7J2YIFRDUOyXsOqysOydtCDsnojsirXri4jri6QgKEhUVFAvMS4x7JeQ7IScKS4g7Iuk7KCc66GcIOu4jOudvOyasOyggOuKlCDsgqzsmqntlaAg7IiYIOyeiOuKlCDrj5nsi5wg7Jew6rKwIOyImCjrs5HroKzroZwg64uk7Jq066Gc65Oc7ZWgIOyImCDsnojripQg7YyM7J28IOyImCnsl5Ag64yA7ZWcIOygnO2VnOydhCDrtoDqs7ztlanri4jri6QgKOydvOuwmOyggeycvOuhnCDtjpjsnbTsp4Ag66Gc65Oc64u5IOyVvSA2fjMw6rCcKS4g6re465+wIOuLpOydjCDsnbTsoIQg7YyM7J287J20IOyZhOyghO2eiCDsoITshqHrkJjrqbQg7Jew6rKw7J2EIOuLpOyLnCDsgqzsmqntlZjsl6wg7IOIIO2MjOydvOydhCDri6TsmrTroZzrk5ztlanri4jri6QuIOydtOufrO2VnCDsoJztlZzsnYAg6rKw6rWtIDMw6rCcIOydtOyDgeydmCDrpqzshozsiqTrpbwg66Gc65Oc7ZWY64qUIOy1nOyLoCDtjpjsnbTsp4DsnZgg7Ju5IOyEseuKpeydhCDrsKntlbTtlZjquLAg7Iuc7J6R7ZaI7Iq164uI64ukLlxcclxcblxcclxcbuydtOufrO2VnCDsg4HtmansnYQg6rCc7ISg7ZWY64qUIOqyg+ydtCBIVFRQLzLsnZgg7KO87JqUIOuqqe2RnCDspJEg7ZWY64KY7JiA7Iq164uI64ukLiDtlITroZzthqDsvZzsnYAg642UIOydtOyDgSDqsIHqsIHsnZgg66qo65OgIO2MjOydvOyXkCDrjIDtlbQg7IOIIFRDUCDsl7DqsrDsnYQg7Je07KeAIOyViuqzoCDri6jsnbwgVENQIOyXsOqysOydhCDthrXtlbQg64uk66W4IOumrOyGjOyKpOulvCDri6TsmrTroZzrk5ztlZjsl6wg7J2066W8IOyImO2Wie2VqeuLiOuLpC4g7J206rKD7J2AIFxcXCLrqYDti7DtlIzroInsi7FcXFwi7J20652864qUIOyXrOufrOqwnCDrsJTsnbTtirgg7Iqk7Yq466a87JeQIOydmO2VtCDsiJjtlonrkKnri4jri6QuIOq3uOqyg+ydgCDsmrDrpqzqsIAg6re46rKD7J2EIOyghOyGoe2VoCDrlYwg64uk66W4IO2MjOydvOydmCDrjbDsnbTthLDrpbwg7Zi87ZWp7ZWY64qUIOupi+ynhCDrsKnrspXsnYQg65y77ZWp64uI64ukLiDshLgg6rCA7KeAIOyYiOygnCDtjIzsnbzsnZgg6rK97JqwIOuLqOydvCBUQ1Ag7Jew6rKw7J2EIO2Gte2VtCDrk6TslrTsmKTripQg642w7J207YSw64qUIEFBQkJDQ0FBQkJDQ+yymOufvCDrs7Tsnbwg7IiYIOyeiOyKteuLiOuLpCjri6Trpbgg66eO7J2AIOyInOyEnCDssrTqs4TqsIAg6rCA64ql7ZWY7KeA66eMKS4g7J206rKD7J2AIOy2qeu2hO2eiCDqsITri6jtlbQg67O07J206rOgIOyLpOygnOuhnCDslYTso7wg7J6YIOyekeuPme2VmOyXrCBIVFRQLzLrpbwg7J2867CY7KCB7Jy866GcIEhUVFAvMS4x66eM7YG8IOu5oOultOqxsOuCmCDslb3qsIQg67mg66W07KeA66eMIOyYpOuyhO2XpOuTnOuKlCDtm6jslKwg7KCB7Iq164uI64ukLlxcclxcblxcclxcbuydtOuvuOyngOulvCDthrXtlbQg7LCo7J207KCQ7J2EIO2ZleyduO2VtOu0heyLnOuLpC5cXHJcXG5cXHJcXG4hW2h0dHAxLjHqs7wgaHR0cDLsnZgg7LCo7J207KCQXShodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9pbmR5c2lnbmVyL2ltYWdlL2ZldGNoL2ZfYXV0byxxXzgwL3dfMjAwMC9odHRwczovL2Nsb3VkLm5ldGxpZnl1c2VyY29udGVudC5jb20vYXNzZXRzLzM0NGRiZjg4LWZkZjktNDJiYi1hZGI0LTQ2ZjAxZWVkZDYyOS85MDBlYThmMC0zNzgyLTQ1MDUtYjFiNi05OWNhMjk1NGJiY2UvbXVsdGlwbGV4aW5nLWJhc2ljLnBuZylcXHJcXG5cXHJcXG48dT7qt7jrn6zrgpgsIFRDUCDsqr3sl5Ag66y47KCc6rCAIOyeiOyKteuLiOuLpC48L3U+IOyVjOuLpOyLnO2UvCBUQ1DripQg7Jik656Y65CcIO2UhOuhnO2GoOy9nOydtOqzoCDsm7kg7Y6Y7J207KeA66W8IOuhnOuUqe2VmOq4sCDsnITtlbQg66eM65Ok7Ja07KeEIOqyg+ydtCDslYTri4jquLAg65WM66y47JeQIEEsIEIsIEPqsIAg66y07JeH7J247KeAIOyVjOyngCDrqrvtlanri4jri6QuIFRDUOuKlCDrgrTrtoDsoIHsnLzroZwg6re464OlIOuLqOyInO2VnCDtlZjrgpjsnZgg7YyM7J28IFjrpbwg7KCE7Iah7ZWY6rOgIOyeiOuLpOqzoCDsg53qsIHtlZjqs6Ag7J6I7Ja0IOyLpOygnOuhnCBIVFRQIOyImOykgOyXkOyEnCBBQUJCQ0NBQUJCQ0ProZwg7KCE64us65CY64qUIOqyg+yduOyngCBYWFhYWFhYWFhYWFjroZwg67O07J2064qUIOqyg+yduOyngOyXkCDrjIDtlbQg7Iug6rK9IOyTsOyngCDslYrsirXri4jri6QuIOuMgOu2gOu2hOydmCDqsr3smrDsl5DshJzripQg7J206rKMIO2BsCDrrLjsoJzqsIAg65CY7KeA64qUIOyViuyKteuLiOuLpC4gPHU+7ZWY7KeA66eMIOuEpO2KuOybjO2BrCDsg4Hsl5DshJwg7Yyo7YK366Gc7Iqk6rCAIOyeiOydhCDqsr3smrDsl5DripQg66y47KCc6rCAIOuQqeuLiOuLpC48L3U+XFxyXFxuXFxyXFxu66qo65OgIOuNsOydtO2EsCDsoITshqHsnYAg66y47KCc7JeG7JeI7KeA66eMIDPrsojsp7gg7Yyo7YK3KGZpbGUgQuydmCDssqsg642w7J207YSw66W8IOuLtOqzoCDsnojripQp7J20IOyGkOyLpOuQmOyXiOuLpOqzoCDsg53qsIHtlbTrtIXsi5zri6QuIFRDUOuKlCDsnbQg7IaQ7Iuk7J2EIOuplOq+uOq4sCDsnITtlbQg7IaQ7IukIOuNsOydtO2EsOydmCDsg4jroZzsmrQg67O17IKs67O47J2EIOyerOyghOyGoe2VqeuLiOuLpC4g6re465+s64KYIOydtCDsnqzsoITshqHsnYAg64+E7LCp6rmM7KeAIOyLnOqwhOydtCDqvaQg6rG466a964uI64ukLiDslYTrp4gg7J206riA7J2EIOydveuKlCDrj4XsnpDrtoTqu5jshJzripQgQeuekSBD7YyM7J28IExPU1Prp4wg7JeG7JeI64uk66m0ICfqt7jqsowg662QIOuMgOyImOudvOqzoCcsICfqt7jrg6Ug64uk7IucIEIg7YyM7J287J2EIOyerOyghOyGoe2VmOuptCDrkJjripTqsbAg7JWE64uI64OQJyDsg53qsIHtlaAg7IiY64+EIOyeiOyKteuLiOuLpC4gXFxyXFxuXFxyXFxu7ZWY7KeA66eMIOyViO2DgOq5neqyjOuPhCDsnqzsoITshqEg66Gc7KeB7J2AIFRDUCDqs4TsuLXsl5DshJwg67Cc7IOd7ZWY6rOgIOyVnuyEnCDslrjquIntlojrk6/snbQgPHU+VENQ64qUIEEsIEIsIEPsl5Ag64yA7ZW0IOyVjOyngCDrqrvtlZjquLAg65WM66y47JeQPC91PiDqt7jroIfsp4Ag7JWK7Iq164uI64ukISgtPiDrrLjsoJzqsIAg65Cp64uI64ukISkgPHU+64yA7IugIFRDUOuKlCDri6jsnbwgWCDtjIzsnbzsnZgg7J2867aA6rCAIOyGkOyLpOuQmOyXiOuLpOqzoCDsg53qsIE8L3U+7ZWY66+A66GcIOq1rOupjeydtCDssYTsm4zsp4gg65WM6rmM7KeAIFjsnZgg64KY66i47KeAIOuNsOydtO2EsOqwgCDsspjrpqzrkJjsp4Ag7JWK64+E66GdIO2VtOyVvCDtlZzri6Tqs6Ag7IOd6rCB7ZWp64uI64ukLiDri6zrpqwg66eQ7ZWY66m0LCBIVFRQLzIg7IiY7KSA7JeQ7IScIOyasOumrOuKlCDsnbTrr7ggQeyZgCBD66W8IOyymOumrO2VoCDsiJgg7J6I64uk64qUIOqyg+ydhCDslYzqs6Ag7J6I7KeA66eMIFRDUOuKlCDsnbTqsoPsnYQg7JWM7KeAIOuqu+2VmOuvgOuhnCDsnqDsnqzsoIHsnbgg6rKD67O064ukIOydvCDsspjrpqzqsIAg642UIOuKkOumveuLiOuLpC4g7J2065+s7ZWcIOusuOygnOulvCAqKkhPTChIZWFkIG9mIExpbmUpIEJsb2NraW5nKirsnbTrnbzqs6Ag7ZWp64uI64ukLiBIT0zsl5Ag64yA7ZW0IOuNlCDsnpDshLjtnogg7JWM6rOgIOyLtuycvOuptCBbSGVhZC1vZi1saW5lIGV4YW1wbGVdKGh0dHBzOi8vY2FsZW5kYXIucGVyZnBsYW5ldC5jb20vMjAyMC9oZWFkLW9mLWxpbmUtYmxvY2tpbmctaW4tcXVpYy1hbmQtaHR0cC0zLXRoZS1kZXRhaWxzLykg7JeQ7IScIOyVjOyVhOuztOyEuOyalC5cXHJcXG5cXHJcXG48dT7soITshqEg6rOE7Li17JeQ7IScIEhvTCDssKjri6jsnYQg7ZW06rKw7ZWY64qUIOqyg+ydgCBRVUlD7J2YIOyjvOyalCDrqqntkZwg7KSRIO2VmOuCmOyYgOyKteuLiOuLpC48L3U+IFRDUOyZgCDri6zrpqwgUVVJQ+uKlCDsl6zrn6wg6rCc7J2YIOuPheumveyggeyduCDrsJTsnbTtirgg7Iqk7Yq466a87J2EIOuLpOykke2ZlO2VmOqzoCDsnojsnYzsnYQg7J6YIOyVjOqzoCDsnojsirXri4jri6QuIOusvOuhoCBDU1MsIEphdmFTY3JpcHQg67CPIOydtOuvuOyngOulvCDsoITshqHtlZjqs6Ag7J6I64uk64qUIOyCrOyLpOq5jOyngOuKlCDslYzsp4Ag66q77ZWp64uI64uk66eMIOyKpO2KuOumvOydtCDrtoTrpqzrkJjslrQg7J6I64uk64qUIOqyg+ydhCDslYzqs6Ag7J6I7Iq164uI64ukLiDsnbTsmYAg6rCZ7J20IFFVSUPripQg7Iqk7Yq466a867OE66GcIO2MqO2CtyDshpDsi6Qg6rCQ7KeA7JmAIOuzteq1rCDrhbzrpqzrpbwg7IiY7ZaJ7ZWgIOyImCDsnojsirXri4jri6QuIOychOydmCDsi5zrgpjrpqzsmKTsl5DshJzripQg7Iqk7Yq466a8IELsl5Ag64yA7ZWcIOuNsOydtO2EsOunjCDrs7TrpZjtlZjqs6AgVENQ7JmAIOuLrOumrCBBIOuwjyBD7JeQIOuMgO2VnCDrqqjrk6Ag642w7J207YSw66W8IOqwgOuKpe2VnCDtlZwg67mo66asIEhUVFAvMyDqs4TsuLXsl5Ag7KCE64us7ZWp64uI64ukLiDsnbTroIfqsowg65CY66m0IOydtOuhoOyggeycvOuhnCDtjbztj6zrqLzsiqQg7Zal7IOB7J2EIOq4sOuMgO2VoCDsiJgg7J6I7Iq164uI64ukLiBcXHJcXG5cXHJcXG4hW0hPTF0oaHR0cHM6Ly9yZXMuY2xvdWRpbmFyeS5jb20vaW5keXNpZ25lci9pbWFnZS9mZXRjaC9mX2F1dG8scV84MC93XzEyMDAvaHR0cHM6Ly9jbG91ZC5uZXRsaWZ5dXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8zNDRkYmY4OC1mZGY5LTQyYmItYWRiNC00NmYwMWVlZGQ2MjkvNzk4MWNiODItMzk1Yy00NDg0LTg4NzMtNDZmZDkyODA0YjRkL2hvbC1ibG9ja2luZy1iYXNpYy5wbmcpXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuIyMg4p2TIFFVSUPsnYAgQ09OTkVDVElPTiBNSUdSQVRJT07snYQg7KeA7JuQ7ZWp64uI64ukLlxcclxcblxcclxcblFVSUPsnZgg7IS4IOuyiOynuCDso7zsmpQg6rCc7ISgIOyCrO2VreydgCDsl7DqsrDsnbQg642UIOyYpOuemCDsnKDsp4DrkKAg7IiYIOyeiOuLpOuKlCDsgqzsi6TsnoXri4jri6QuIOuUsOudvOyEnCDrrLjsoJzripQg7J2065+s7ZWcIO2MqO2Ct+ydtCDsmKzrsJTrpbgg66qp7KCB7KeA7JeQIOyWtOuWu+qyjCDrj4TssKntlZjripTqsIAg7ZWY64qUIOqyg+yeheuLiOuLpC4gXFxyXFxuXFxyXFxu7J247YSw64S37JeQ7IScIElQIOyjvOyGjOuKlCDrkZAg6rCc7J2YIOqzoOycoO2VnCDsi5zsiqTthZwg6rCE7JeQIO2MqO2Ct+ydhCDrnbzsmrDtjIXtlZjripQg642wIOyCrOyaqeuQqeuLiOuLpC4g6re465+s64KYIOuLueyLoOydmCDsoITtmZTquLDsmYAg7ISc67KE7JeQIOuMgO2VnCBJUCDrkZAg6rCA7KeA66eM66Gc64qUIOy2qeu2hO2VmOyngCDslYrsirXri4jri6QuICDsmZzrg5DtlZjrqbQg64u57Iug6rO8IOyEnOuyhCDrqqjrkZAg7JaR7Kq9IOuBneyXkOyEnCDrj5nsi5zsl5Ag7Jes65+sIOuEpO2KuOybjO2BrCDtlITroZzqt7jrnqjsnYQg7Iuk7ZaJ7ZWgIOyImCDsnojquLDrpbwg7Z2s66ed7ZWY6riwIOuVjOusuOyeheuLiOuLpC4g7J206rKD7J20IOqwgeqwgeydmCDqsJzrs4Qg7Jew6rKw66eI64ukIOyWkeyqvSDrgZ3soJDsl5DshJwgPHU+7Y+s7Yq4IOuyiO2YuOqwgCDtlaDri7nrkJjslrQg7Jew6rKwKENvbm5lY3Rpb24p6rO8IO2VtOuLuSDsl7DqsrDsnbQg7IaN7ZWcIOydkeyaqSDtlITroZzqt7jrnqgoQXBwbGljYXRpb24p7J2EIOq1rOuzhO2VmOuKlCDsnbTsnKA8L3U+7J6F64uI64ukLiDshJzrsoQg7J2R7JqpIO2UhOuhnOq3uOueqOydgCDsnbzrsJjsoIHsnLzroZwg6riw64ql7JeQIOuUsOudvCDqs6DsoJUg7Y+s7Yq4IOuyiO2YuCjsmIg6IEhUVFAoUynsnZgg6rK97JqwIO2PrO2KuCA4MCDrsI8gNDQzLCBETlPsnZgg6rK97JqwIO2PrO2KuCA1Mynrpbwg6rCW64qUIOuwmOuptCDtgbTrnbzsnbTslrjtirjripQg7J2867CY7KCB7Jy866GcIOqwgSDsl7DqsrDsl5Ag64yA7ZW0IO2PrO2KuCDrsojtmLjrpbwgKOuwmCnsnoTsnZjroZwg7ISg7YOd7ZWp64uI64ukLlxcclxcblxcclxcbuuUsOudvOyEnCDrqLjsi6Dqs7wg7JWg7ZSM66as7LyA7J207IWYIOqwhOyXkCDqs6DsnKDtlZwg7Jew6rKw7J2EIOygleydmO2VmOugpOuptCAqKigxKe2BtOudvOydtOyWuO2KuCBJUCDso7zshowqKiArICoqKDIp7YG065287J207Ja47Yq4IO2PrO2KuCoqICsgKiooMynshJzrsoQgSVAg7KO87IaMKiogKyAqKig0KeyEnOuyhCDtj6ztirgqKuydmCA8dT406rCA7KeA6rCAIO2VhOyalDwvdT7tlanri4jri6QuXFxyXFxuXFxyXFxuVENQ7JeQ7IScIOyXsOqysOydgCA0Le2KnO2UjOuhnOunjCDsi53rs4TrkKnri4jri6QuIOuUsOudvOyEnCDsnbQg64SkIOqwgOyngCDrp6TqsJzrs4DsiJgg7KSRIO2VmOuCmOunjCDrs4Dqsr3rkJjrqbQg7Jew6rKw7J20IOustO2aqO2ZlOuQmOqzoCDri6Tsi5wg7ISk7KCV7ZW07JW8IO2VqeuLiOuLpCjsg4gg7ZW465Oc7IWw7J207YGsIO2PrO2VqCkuIOydtOulvCDsnbTtlbTtlZjroKTrqbQgYOyjvOywqOyepSDrrLjsoJwg7JiI7IucYOulvCDtmZzsmqntlZjrqbQg7KKL7Iq164uI64ukLiDtlZwg67KIIOyDgeyDge2VtCDrs7TshLjsmpQuIO2YhOyerCDqsbTrrLwg7JWI7JeQ7IScIFdpLUZp66GcIOyKpOuniO2KuO2PsOydhCDsgqzsmqntlZjqs6Ag7J6I7Iq164uI64ukLiDrlLDrnbzshJwg7J20IFdpLUZpIOuEpO2KuOybjO2BrOyXkCBJUCDso7zshozqsIAg7J6I7Iq164uI64ukLiDsnbTsoJwg7Jm467aA66GcIOydtOuPme2VmOuptCDtnLTrjIDsoITtmZTqsIAg7IWA66Ow65+sIDRHIOuEpO2KuOybjO2BrOuhnCDsoITtmZjrkKAg6rKD7J6F64uI64ukLiDsnbTqsoPsnYAg7IOI66Gc7Jq0IOuEpO2KuOybjO2BrOydtOq4sCDrlYzrrLjsl5Ag7JmE7KCE7Z6IIOyDiOuhnOyatCBJUCDso7zshozrpbwg6rCW6rKMIOuQqeuLiOuLpC4g7J207KCcIOyEnOuyhOuKlCDsnbTsoITsl5Ag67O4IOyggeydtCDsl4bripQg7YG065287J207Ja47Yq4IElQ7JeQ7IScIOuTpOyWtOyYpOuKlCBUQ1Ag7Yyo7YK37J2EIOuztOqyjCDrkKnri4jri6Qo66y866GgIOuRkCDtj6ztirjsmYAg7ISc67KEIElQ64qUIOuPmeydvO2VmOqyjCDsnKDsp4DrkKAg7IiYIOyeiOyngOunjCkuXFxyXFxuXFxyXFxuIVt3aWZp7JeQ7IScIOyFgOujsOufrOuhnOydmCDthrXsi6DsoITtmZhdKGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2luZHlzaWduZXIvaW1hZ2UvZmV0Y2gvZl9hdXRvLHFfODAvd18xMjAwL2h0dHBzOi8vY2xvdWQubmV0bGlmeXVzZXJjb250ZW50LmNvbS9hc3NldHMvMzQ0ZGJmODgtZmRmOS00MmJiLWFkYjQtNDZmMDFlZWRkNjI5Lzk0MTNiMjIxLTQ3ZTktNDI3Yi1iOTU4LWIwZTYyZmU3ZjY4MS8xLW1pZ3JhdGlvbi10Y3AucG5nKVxcclxcblxcclxcbuq3uOugh+uLpOuptCDshJzrsoTripQg7IOI66Gc7Jq0IElQ7Yyo7YK37J20IOydtCDquLDsobTsnZggXFxcIuyXsOqysFxcXCLsl5Ag7IaN7ZWc64uk64qUIOqyg+ydhCDslrTrlrvqsowg7JWMIOyImCDsnojsnYTquYzsmpQ/IOydtOufrO2VnCDtjKjtgrfsnbQg64+Z7J287ZWcKOyehOydmCkg7YG065287J207Ja47Yq4IO2PrO2KuCjsib3qsowg67Cc7IOd7ZWgIOyImCDsnojsnYwp66W8IOyEoO2Dne2VnCDshYDro7Drn6wg64Sk7Yq47JuM7YGs7J2YIOuLpOuluCDtgbTrnbzsnbTslrjtirjroZzrtoDthLDsnZgg7IOIIOyXsOqysOyXkCDsho3tlZjsp4Ag7JWK64qU64uk64qUIOqyg+ydhCDslrTrlrvqsowg7JWMIOyImCDsnojsnYTquYzsmpQ/IOyViO2DgOq5neqyjOuPhCwgVENQ66Gc64qUIOydtOqyg+ydhCDslYwg7IiYIOyXhuyKteuLiOuLpC4gVENQ64qUIOyasOumrOqwgCDshYDro7Drn6wg64Sk7Yq47JuM7YGs7JmAIOyKpOuniO2KuO2PsOydhCDqv4jqvrjquLDrj4Qg7KCE7JeQIOuwnOuqheuQmOyXiOq4sCDrlYzrrLjsl5Ag7YG0PHU+65287J207Ja47Yq46rCAIElQ6rCAIOuzgOqyveuQmOyXiOydjOydhCDshJzrsoTsl5Ag7JWM66a0IOyImCDsnojripQg66mU7Luk64uI7KaY7J20IOyXhuyKteuLiOuLpC48L3U+IOq4sOyhtCA0Le2KnO2UjOyXkCDsoITshqHrkJwgVENQIOyerOyEpOyglSDrmJDripQgZmluIOuqheugueydtCDrjZQg7J207IOBIO2BtOudvOydtOyWuO2KuOyXkCDrj4Tri6ztlZjsp4Drj4Qg7JWK6riwIOuVjOusuOyXkCDsl7DqsrDsnYQgXFxcIuuLq+ydhFxcXCIg67Cp67KV7KGw7LCoIOyXhuyKteuLiOuLpC4g65Sw65287IScIOyLpOygnOuhnCDrqqjrk6Ag64Sk7Yq47JuM7YGsIOuzgOqyveydgCDquLDsobQgVENQIOyXsOqysOydhCDrjZQg7J207IOBIOyCrOyaqe2VoCDsiJgg7JeG7J2M7J2EIOydmOuvuO2VqeuLiOuLpC4g7IOIIOyXsOqysOydhCDshKTsoJXtlZjroKTrqbQg7IOIIFRDUCjrsI8gVExTKSDtlbjrk5zshbDsnbTtgazrpbwg7Iuk7ZaJ7ZW07JW8IO2VmOupsCDsnZHsmqkg7ZSE66Gc6re4656oIOyImOykgCDtlITroZzthqDsvZzsl5Ag65Sw6528IOynhO2WiSDspJHsnbgg7J6R7JeF7J2EIOuLpOyLnCDsi5zsnpHtlbTslbwg7ZWp64uI64ukLiDsmIjrpbwg65Ok7Ja0IEhUVFDrpbwg7Ya17ZW0IOuMgOyaqeufiSDtjIzsnbzsnYQg64uk7Jq066Gc65Oc7ZWY64qUIOqyveyasCDtlbTri7kg7YyM7J287J2EIOyymOydjOu2gO2EsCDri6Tsi5wg7JqU7LKt7ZW07JW8IO2VoCDsiJgg7J6I7Iq164uI64ukLiDrmJAg64uk66W4IOyYiOuhnOuKlCDrhKTtirjsm4ztgazrpbwg7KCE7ZmY7ZWgIOuVjCDsp6fsnYAg7KCV7KCE7J20IOuwnOyDne2VoCDsiJgg7J6I64qUIOudvOydtOu4jCDtmZTsg4Eg7ZqM7J2Y6rCAIOyeiOyKteuLiOuLpC4g7ZWY7KeA66eMIOychOyZgCDqsJnsnYAg7IOB7Zmp7JeQ7IScIFRDUCDsl7DqsrDsnYQg64uk7IucIOyLnOyeke2VmOuptCDsi6zqsIHtlZwg7JiB7Zal7J2EIOuvuOy5oCDsiJgg7J6I7Iq164uI64ukLiAqKjx1PuydtCDrrLjsoJzrpbwg7ZW06rKw7ZWY6riwIOychO2VtCBRVUlD7JeQ7ISc64qUIOyXsOqysCDsi53rs4TsnpAoQ0lEKeudvOuKlCDsg4jroZzsmrQg6rCc64WQ7J2EIOuPhOyehTwvdT4qKu2WiOyKteuLiOuLpC4g6rCBIOyXsOqysOyXkOuKlCDrkZAg64Gd7KCQIOyCrOydtOyXkOyEnCDqs6DsnKDtlZjqsowg7Iud67OE7ZWY64qUIDQt7Yqc7ZSMIOychOyXkCDri6Trpbgg67KI7Zi46rCAIO2VoOuLueuQqeuLiOuLpC4g6rKw7KCV7KCB7Jy866GcIDx1PuydtCBDSUTripQgUVVJQyDsnpDssrTsnZgg7KCE7IahIOqzhOy4teyXkOyEnCDsoJXsnZjrkJjquLAg65WM66y47JeQIOuEpO2KuOybjO2BrCDqsITsl5Ag7J2064+Z7ZWgIOuVjCDrs4Dqsr3rkJjsp4Ag7JWK7Iq164uI64ukPC91PiEgIOyVhOuemCDsnbTrr7jsp4Drpbwg7Ya17ZW0IOuEpO2KuOybjO2BrCDsm5Drpqzrpbwg7ZmV7J247ZW067O07IS47JqULiDsnbTrpbwg6rCA64ql7ZWY6rKMIO2VmOq4sCDsnITtlbQgQ0lE64qUIOuqqOuToCBRVUlDIO2MqO2Ct+ydmCDsoITrqbTsl5Ag7Y+s7ZWo65Cp64uI64ukLlxcclxcblxcclxcbiFbUVVJQ+qzvCBDSURdKGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2luZHlzaWduZXIvaW1hZ2UvZmV0Y2gvZl9hdXRvLHFfODAvd18xMjAwL2h0dHBzOi8vY2xvdWQubmV0bGlmeXVzZXJjb250ZW50LmNvbS9hc3NldHMvMzQ0ZGJmODgtZmRmOS00MmJiLWFkYjQtNDZmMDFlZWRkNjI5L2U2YWUwZWMxLTNiODUtNDlhOS05NzA3LWVlMjFjZTViMDJiMy8yLW1pZ3JhdGlvbi1zaW5nbGUtY2lkLnBuZylcXHJcXG5cXHJcXG48dT5RVUlD7J2YIOydtCDshKTsoJXsnYQg7IKs7Jqp7ZWY66m0IDQt7Yqc7ZSM7J2YIO2VreuqqSDspJEg7ZWY64KY6rCAIOuzgOqyveuQmOuNlOudvOuPhCBRVUlDIOyEnOuyhOyZgCDtgbTrnbzsnbTslrjtirjripQgQ0lE66eMIOuztOqzoCDrj5nsnbztlZwg7J207KCEIOyXsOqysOyehOydhCDslYzqs6Ag6rOE7IaNIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLjwvdT4g7IOI66Gc7Jq0IO2VuOuTnOyFsOydtO2BrOqwgCDtlYTsmpTtlZjsp4Ag7JWK7Jy866mwIOuLpOyatOuhnOuTnCDsg4Htg5zrpbwg6re464yA66GcIOycoOyngO2VoCDsiJgg7J6I7Iq164uI64ukLiDsnbQg6riw64ql7J2EIOydvOuwmOyggeycvOuhnCDsl7DqsrAg66eI7J206re466CI7J207IWY7J2065286rOgIO2VqeuLiOuLpC4gXFxyXFxuXFxyXFxu66y866GgIENJROuPhCDqt7nrs7XtlbTslbwg7ZWgIOuLpOuluCDqs7zsoJzqsIAg7J6I7Iq164uI64ukLiDsmIjrpbwg65Ok7Ja0LCDsi6TsoJzroZwg7ZWY64KY7J2YIENJROunjCDsgqzsmqntlZzri6TrqbQg7ZW07Luk7JmAIOuPhOyyreyekOqwgCDrhKTtirjsm4ztgazrpbwg7Ya17ZW0IOyCrOyaqeyekOulvCDstpTsoIHtlZjqs6Ag7ZmV7J6l7ZWY7JesIOq3uOuTpOydmCAo64yA65617KCB7J24KSDrrLzrpqzsoIEg7JyE7LmY66W8IOy2lOuhoO2VmOuKlCDqsoPsnbQg66ek7JqwIOyJrOybjOyniCDqsoPsnoXri4jri6QuIOydtOufrO2VnCDtlITrnbzsnbTrsoTsi5wg7JWF7Jqp7J2EIOuwqeyngO2VmOq4sCDsnITtlbQgUVVJQ+ydgCDsg4gg64Sk7Yq47JuM7YGs6rCAIOyCrOyaqeuQoCDrlYzrp4jri6QgQ0lE66W8IOuzgOqyve2VqeuLiOuLpC5cXHJcXG5cXHJcXG4/Pz8g7J20IOyWmOq4sOuKlCDslYTrp4jrj4Qg7J20IOq4gOydhCDsnb3ripQg64+F7J6Q67aE65Ok7J2EIO2YvOuegOyKpOufveqyjCDtlaAg7IiYIOyeiOyKteuLiOuLpC4g67Cp6riI6rmM7KeAIENJROqwgCDrhKTtirjsm4ztgazsl5DshJwg64+Z7J287ZW07JW8IO2VnOuLpOqzoCDrp5DtlZjsp4Ag7JWK7JWY7JeI64KY7JqUPyDtnaAuLi4g6riA7I6E7JqULCDqt7jqsoPsnYAg7KeA64KY7LmcIOuLqOyInO2ZlOyYgOyKteuLiOuLpC4g7Iuk7KCc66GcIOuCtOu2gOyggeycvOuhnCDrsJzsg53tlZjripQg6rKD7J2AIO2BtOudvOydtOyWuO2KuOyZgCDshJzrsoTqsIAg66qo65GQIOuPmeydvO2VnCDqsJzrhZDsoIEgXFxcIuyXsOqysFxcXCLsl5Ag66ek7ZWR65CY64qUICjsnoTsnZjroZwg7IOd7ISx65CcKSBDSUTsnZgg6rO17Ya1IOuqqeuhneyXkCDrj5nsnZjtlZzri6TripQg6rKD7J6F64uI64ukLiDsmIjrpbwg65Ok7Ja0IOuRmCDri6Qg7Iuk7KCc66GcIENJRCBLLCBDIOuwjyBE6rCAIOuqqOuRkCDsl7DqsrAgWOyXkCDrp6TtlZHrkJzri6TripQg6rKD7J2EIOyVjOqzoCDsnojsirXri4jri6QuIOuUsOudvOyEnCDtgbTrnbzsnbTslrjtirjripQgV2ktRmnsl5DshJwg7Yyo7YK37JeQIEvroZwg7YOc6re466W8IOyngOygle2VoCDsiJgg7J6I7KeA66eMIDRH7JeQ7ISc64qUIEPrpbwg7IKs7Jqp7ZWY64+E66GdIOyghO2ZmO2VoCDsiJgg7J6I7Iq164uI64ukLiDsnbTrn6ztlZwg6rO17Ya1IOuqqeuhneydgCBRVUlD7JeQ7IScIOyZhOyghO2eiCDslZTtmLjtmZTrkJjslrQg7ZiR7IOB65CY66+A66GcIOyeoOyerOyggeyduCDqs7XqsqnsnpDripQgS+yZgCBD6rCAIOyLpOygnOuhnCBY7J247KeAIOyVjOyngCDrqrvtlZjsp4Drp4wg7YG065287J207Ja47Yq47JmAIOyEnOuyhOuKlCDsnbTrpbwg7JWM6rOgIOyXsOqysOydhCDqs4Tsho0g7Jyg7KeA7ZWgIOyImCDsnojsirXri4jri6QuICh3aWZp7JeQ7IScIOyFgOujsOufrOuhnCDsoITtmZjrkKAg65WMIOuYkeqwmeydgCBDSUQg7JWI7JeQIOyXrOufrOqwnOydmCDrp4jsu6Trpbwg65GQ6rOgIO2VtOuLuSDrp4jsu6Trpbwg7Y+s7ZWo7ZWY6riw66eMIO2VmOuptCDqsJnsnYAg7IKs7Jqp7J6Q65286rOgIOyLneuzhC4g64uk66eMIOyZuOu2gOyXkOyEnOuKlCDsnbTqsoPsnYQg7KCV7KCV7ZmV7Z6IIOq1rOu2hO2VoCDsiJgg7JeG7Ja0IO2VtOy7pOuhnOu2gO2EsCDsooAg642UIOyViOyghC4pXFxyXFxuXFxyXFxuIVtRVUlD6rO8IENJRDJdKGh0dHBzOi8vcmVzLmNsb3VkaW5hcnkuY29tL2luZHlzaWduZXIvaW1hZ2UvZmV0Y2gvZl9hdXRvLHFfODAvd18xMjAwL2h0dHBzOi8vY2xvdWQubmV0bGlmeXVzZXJjb250ZW50LmNvbS9hc3NldHMvMzQ0ZGJmODgtZmRmOS00MmJiLWFkYjQtNDZmMDFlZWRkNjI5LzcxNWYxODllLTRhZTYtNGM0Yy04ZGI4LTlmZDgxNzAwNDlkOC8zLW1pZ3JhdGlvbi1tdWx0aS1jaWQucG5nKVxcclxcblxcclxcbuudvOydtOyWuO2KuOyZgCDshJzrsoTqsIAg7Iqk7Iqk66GcIOyEoO2Dne2VnCBDSUQg66qp66Gd7J20IOuLpOultOq4sCDrlYzrrLjsl5Ao7Y+s7Yq4IOuyiO2YuOqwgCDri6Trpbgg6rKD6rO8IOycoOyCrCkg7Zuo7JSsIOuNlCDrs7XsnqHtlbTsp5Hri4jri6QuIOydtOuKlCDso7zroZwg64yA6rec66qoIOyEnOuyhCDshKTsoJXsl5DshJwg65287Jqw7YyFIOuwjyDroZzrk5wg67C465+w7Iux7J2EIOyngOybkO2VmOq4sCDsnITtlZwg6rKD7J6F64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIDpidWxiOiBRVUlD7J2AIOycoOyXsO2VmOqzoCDsp4TtmZTtlaAg7IiYIOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG5RVUlD7J2YIOuniOyngOuniSDsuKHrqbTsnYAg7KeE7ZmU7ZWY6riwIOyJveuPhOuhnSDtirnrs4Ttnogg7KCc7J6R65CY7JeI64uk64qUIOqyg+yeheuLiOuLpC4g7J206rKD7J2AIOyXrOufrCDqsIDsp4Ag67Cp67KV7Jy866GcIOyImO2WieuQqeuLiOuLpC4g66i87KCAIOuFvOydmO2VnCDrsJTsmYAg6rCZ7J20IFFVSUPqsIAg6rGw7J2YIOyZhOyghO2eiCDslZTtmLjtmZTrkJjslrQg7J6I64uk64qUIOyCrOyLpOydgCDstZzsi6Ag67KE7KCE7J2YIFFVSUPrpbwg67Cw7Y+s7ZWY66Ck64qUIOqyveyasCDrqqjrk6Ag66+465Ok67CV7Iqk6rCAIOyVhOuLiOudvCDrgZ3soJAo7YG065287J207Ja47Yq4IOuwjyDshJzrsoQp66eMIOyXheuNsOydtO2KuO2VmOuptCDrkJzri6TripQg6rKD7J2EIOydmOuvuO2VqeuLiOuLpC4g6re46rKD7J2AIOyXrOyghO2eiCDsi5zqsITsnbQg6rG466as7KeAIOunjCDsnbzrsJjsoIHsnLzroZwg66qHIOuFhOydtCDslYTri4wg66qHIOqwnOyblCDsoJXrj4TsnoXri4jri6QuIFxcclxcblxcclxcbuuRmOynuCwgVENQ7JmAIOuLrOumrCBRVUlD64qUIOuLqOydvCDqs6DsoJUg7Yyo7YK3IO2XpOuNlOulvCDsgqzsmqntlZjsl6wg66qo65OgIO2UhOuhnO2GoOy9nCDrqZTtg4Ag642w7J207YSw66W8IOyghOyGoe2VmOyngCDslYrsirXri4jri6QuIOuMgOyLoCBRVUlD64qUIO2MqO2CtyDtl6TrjZTqsIAg7Ken6rOgIO2MqO2CtyDtjpjsnbTroZzrk5wg64K067aA7JeQIOuLpOyWke2VnCBcXFwi7ZSE66CI7J6EXFxcIijsmIg6IOyGjO2YlSDtirnsiJgg7Yyo7YK3KeydhCDsgqzsmqntlZjsl6wg7LaU6rCAIOygleuztOulvCDsoITri6ztlanri4jri6QuIOyYiOulvCDrk6TslrQsIOyVhOuemCDsnbTrr7jsp4DsmYAg6rCZ7J20IEFDSyDtlITroIjsnoQo7Iq57J247JqpKSwgTkVXX0NPTk5FQ1RJT05fSUQg7ZSE66CI7J6EKOyXsOqysCDrp4jsnbTqt7jroIjsnbTshZgg7ISk7KCV7J2EIOuPleq4sCDsnITtlbQpIOuwjyBTVFJFQU0g7ZSE66CI7J6EKOuNsOydtO2EsCDsoITri6zsmqkp7J20IOyeiOyKteuLiOuLpC5cXHJcXG5cXHJcXG7snbTqsoPsnYAg66qo65OgIO2MqO2Ct+ydtCDqsIDriqXtlZwg66qo65OgIOuplO2DgCDrjbDsnbTthLDrpbwg7KCE64us7ZWY64qUIOqyg+ydgCDslYTri4jquLAg65WM66y47JeQIOyjvOuhnCDstZzsoIHtmZTroZwg7IiY7ZaJ65Cp64uI64ukLiDqt7jrn6zrgpgg7ZSE66CI7J6EIOyCrOyaqeydmCDrp6TsmrAg7Jyg7Jqp7ZWcIOu2gOyekeyaqeydgCDsg4jroZzsmrQg7ZSE66CI7J6EIOycoO2YleydhCBRVUlD7JeQIOuMgO2VnCDtmZXsnqXsnLzroZwg7KCV7J2Y7ZWY64qUIOqyg+ydtCDrr7jrnpjsl5Ag66ek7JqwIOyJrOyauCDqsoPsnbTrnbzripQg7KCQ7J6F64uI64ukLiDsmIjrpbwg65Ok7Ja0IOunpOyasCDspJHsmpTtlZwg7ZSE66CI7J6E7J2AIERBVEFHUkFNIO2UhOugiOyehOycvOuhnCwg7JWU7Zi47ZmU65CcIFFVSUMg7Jew6rKw7J2EIO2Gte2VtCDsi6DrorDtlaAg7IiYIOyXhuuKlCDrjbDsnbTthLDrpbwg7KCE7Iah7ZWgIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxuIVtRVUlDIGV2bG9sdmUxXShodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9pbmR5c2lnbmVyL2ltYWdlL2ZldGNoL2ZfYXV0byxxXzgwL3dfMTIwMC9odHRwczovL2Nsb3VkLm5ldGxpZnl1c2VyY29udGVudC5jb20vYXNzZXRzLzM0NGRiZjg4LWZkZjktNDJiYi1hZGI0LTQ2ZjAxZWVkZDYyOS84OGM3NmE3YS0yNzUyLTRlNWItYTgyOS0yOTBjZDQ5NTFhZjMvcXVpYy1mcmFtaW5nLnBuZylcXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG7shYvsp7gsIFFVSUPripQg7IKs7Jqp7J6QIOyngOyglSBUTFMg7ZmV7J6l7J2EIOyCrOyaqe2VmOyXrCDshozsnIQg7KCE7IahIOunpOqwnOuzgOyImOudvCDrtojrpqzripQg6rKD7J2EIOyghOuLrO2VqeuLiOuLpC4g7J2066W8IO2Gte2VtCDtgbTrnbzsnbTslrjtirjsmYAg7ISc67KE64qUIFFVSUMg7Jew6rKw7J2EIOychO2VnCDqtazshLHsnYQg7ISg7YOd7ZWgIOyImCDsnojsirXri4jri6QuIOydtOqyg+ydgCDslrTrlqQg6riw64ql7J20IO2ZnOyEse2ZlOuQmOyXiOuKlOyngCjsmIg6IOyXsOqysCDrp4jsnbTqt7jroIjsnbTshZgg7ZeI7JqpIOyXrOu2gCwg7KeA7JuQ65CY64qUIO2ZleyepSDrk7EpIO2YkeyDge2VmOqzoCDsnbzrtoAg66mU7Luk64uI7KaYKOyYiDog7KeA7JuQ65CY64qUIOy1nOuMgCDtjKjtgrcg7YGs6riwLCDtnZDrpoQg7KCc7Ja0IOygnO2VnCnsl5Ag64yA7ZW0IOqwgOyepSDtlanrpqzsoIHsnbgg6riw67O46rCS7J2EIOyghOuLrO2VoCDsiJgg7J6I64uk64qUIOqyg+ydhCDsnZjrr7jtlanri4jri6QuIFFVSUMg7ZGc7KSA7J2AIOydtOuTpOydmCDquLQg66qp66Gd7J2EIOygleydmO2VmOyngOunjCDtmZXsnqXsnYQg7Ya17ZW0IOyDiCDtla3rqqnsnYQg7KCV7J2Y7ZWgIOyImOuPhCDsnojsnLzrr4DroZwg7ZSE66Gc7Yag7L2c7J2EIOuNlOyasSDsnKDsl7DtlZjqsowg66eM65OkIOyImCDsnojsirXri4jri6QuXFxyXFxuXFxyXFxu66eI7KeA66eJ7Jy866GcLCBRVUlDIOyekOyytOydmCDsi6TsoJwg7JqU6rWsIOyCrO2VreydgCDslYTri4jsp4Drp4wg64yA67aA67aE7J2YIOq1rO2YhOydgCDtmITsnqwgXFxcIuyCrOyaqeyekCDqs7XqsIRcXFwi7JeQ7IScIOyImO2WieuQqeuLiOuLpCjsnbzrsJjsoIHsnLzroZwgXFxcIuy7pOuEkCDqs7XqsIRcXFwi7JeQ7IScIOyImO2WieuQmOuKlCBUQ1DsmYAg67CY64yAKS4g7J2064qUIOyjvOuhnCBUQ1Drs7Tri6QgUVVJQyDqtaztmIQg67OA7ZiVIOuwjyDtmZXsnqXsnYQg7Iuk7ZeY7ZWY6rOgIOuwsO2PrO2VmOuKlCDqsoPsnbQg7Zuo7JSsIOyJveuLpOuKlCDqsoPsnYQg7J2Y66+47ZWp64uI64ukLlxcclxcblxcclxcblxcclxcblxcclxcbiMjIENvbmNsdXNpb25cXHJcXG7snbQg67aA67aE7JeQ7IScIOuwsOyatCDrgrTsmqnsnYQg7JqU7JW97ZW0IOuztOqyoOyKteuLiOuLpC4g7Jqw66as64qUIOyjvOuhnCDslrTrlJTsl5Drgpgg7KG07J6s7ZWY64qUIFRDUCDtlITroZzthqDsvZzqs7wg7Jik64qY64Kg7J2YIOunjuydgCDrrLjsoJzqsIAg7JWM66Ck7KeA7KeAIOyViuydgCDsi5zquLDsl5AgSFRUUO2UhOuhnO2GoOy9nOydtCDslrTrlrvqsowg7ISk6rOE65CY7JeI64qU7KeA7JeQIOuMgO2VtCDsnbTslbzquLDtlojsirXri4jri6QuIO2VmOyngOunjCBUQ1Drpbwg67Cc7KCE7Iuc7YKk66Ck6rOgIOyLnOuPhO2VmOuptOyEnCDqsbDsnZgg66qo65OgIOyepey5mOyXkCDsl4XrjbDsnbTtirjtlbTslbwg7ZWY64qUIOyekOyytCBUQ1Ag6rWs7ZiE7J20IO2DkeyerOuQmOyWtCDsnojquLAg65WM66y47JeQIFRDUOyekOyytOulvCDrsJzsoITsi5ztgqTripQg6rKD7J20IOyLpOygnOuhnCDslrTroLXri6TripQg6rKD7J20IOu2hOuqhe2VtOyhjOyKteuLiOuLpC5cXHJcXG5cXHJcXG5UQ1Drpbwg6rOE7IaNIOqwnOyEoO2VmOuptOyEnCDsnbQg66y47KCc66W8IOyasO2ajO2VmOq4sCDsnITtlbQgPHU+7IOI66Gc7Jq0IFFVSUMg7ZSE66Gc7Yag7L2cPC91Pijsi6TsoJzroZzripQgVENQIDIuMCnsnYQg66eM65Ok7JeI7Iq164uI64ukLiA8dT5RVUlD66W8IOuNlCDsib3qsowg67Cw7Y+s7ZWgIOyImCDsnojrj4TroZ0gVURQIO2UhOuhnO2GoOy9nCjrjIDrtoDrtoTsnZgg64Sk7Yq47JuM7YGsIOyepey5mOuPhCDsp4Dsm5DtlagpIOychOyXkOyEnCDsi6TtlonrkJjrqbAg7Zal7ZuEIOuwnOyghO2VoCDsiJgg7J6I64+E66GdIOq4sOuzuOyggeycvOuhnCDqsbDsnZgg7JmE7KCE7Z6IIOyVlO2YuO2ZlOuQmOupsCDsnKDsl7DtlZwg7ZSE66CI7J2067CN7J2EIOyCrOyaqTwvdT7tlanri4jri6QuXFxyXFxuXFxyXFxu7J20IOyZuOyXkOuPhCA8dT5RVUlD64qUIO2VuOuTnOyFsOydtO2BrCwg7JWI7KCV7ISxIOuwjyDtmLzsnqEg7KCc7Ja07JmAIOqwmeydgCDslYzroKTsp4QgVENQIOq4sOuKpeydhCDrjIDrtoDrtoQg65Sw6528PC91Pu2VqeuLiOuLpC4g7JWU7Zi47ZmUIOuwjyDtlITroIjsnbTrsI0g7Jm47JeQIOuRkCDqsIDsp4Ag7KO87JqUIOuzgOqyvSDsgqztla3snYAg64uk7KSRIOuwlOydtO2KuCDsiqTtirjrprwg7J247Iud6rO8IOyXsOqysCBJRCDrj4TsnoXsnoXri4jri6QuIOq3uOufrOuCmCDsnbTrn6ztlZwg67OA6rK9IOyCrO2VreydgCBRVUlDIOychOyXkOyEnCBIVFRQLzLrpbwg7KeB7KCRIOyLpO2Wie2VmOuKlCDqsoPsnYQg67Cp7KeA7ZWY6riw7JeQIOy2qeu2hO2VmOyXrCBIVFRQLzMo7Iuk7KCc66Gc64qUIFFVSUPsnYQg7Ya17ZWcIEhUVFAvMuyehCnsnYQg66eM65Ok7Ja07JW8IO2WiOyKteuLiOuLpC5cXHJcXG5cXHJcXG4qKlFVSUPsnZgg7IOI66Gc7Jq0IOygkeq3vCDrsKnsi53snYAg7Jes65+sIOqwgOyngCDshLHriqUg7Zal7IOB7J2EIOygnOqztSoq7ZWY7KeA66eMIOyeoOyerOyggeyduCDsnbTsoJDsnYAgUVVJQyDrsI8gSFRUUC8z7JeQIOuMgO2VnCDquLDsgqzsl5DshJwg7J2867CY7KCB7Jy866GcIOyghOuLrOuQmOuKlCDqsoPrs7Tri6Qg642UIOuvuOusmO2VnCDssKjsnbTqsIAg7J6I7Iq164uI64ukLiDsnbTsoJwg6riw67O4IOyCrO2VreydhCDslYzslZjsnLzrr4DroZwg7J20IOyLnOumrOymiOydmCDri6TsnYwg67aA67aE7JeQ7IScIOydtOufrO2VnCDriZjslZnsiqTrpbwg642UIOq5iuydtCDrhbzsnZjtlaAg7IiYIOyeiOyKteuLiOuLpC4g6rOE7IaNIOyngOy8nOu0kCDso7zshLjsmpQhXFxyXFxuXFxyXFxuXFxyXFxuXFxyXFxuLS0tXFxyXFxuXFxyXFxu6ri0IOq4gCDsnb3slrTso7zshZTshJwg6rCQ7IKs7ZWp64uI64ukLlxcclxcblxcclxcblwiOyIsImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxudGl0bGU6IFxcXCLsoovsnYAg6rCc67Cc7J6Q656AIOustOyXh+ydvOq5jFxcXCJcXG5kYXRlOiBcXFwiMjAyMi4wOC4xNVxcXCJcXG50YWdzOlxcbi0g7ZqM6rOgXFxuLS0tXFxuXFxuXFxuXFxuXFxuXFxu7Jes7YOc6rmM7KeA64qUIOutlOqwgCBcXFwiKioq6riw7IigKioqXFxcIiDruJTroZzqt7jrnbzripQg6rKD7JeQIOqwh+2YgOyEnCDtmITsnqwg67iU66Gc6re47JeQ64qUIOuCtCDsg53qsIHrs7Tri6TripQg64uk66W4IOyCrOuejOuTpOydtCDrk6TslrTsmYDshJwg7LC46rOg7ZWgIOunjO2VnCBcXFwi6riw7IigXFxcIuyXkCDqtIDtlZwg6rKD66eMIO2PrOyKpO2MheydhCDtlbTsmZTsirXri4jri6QuXFxuXFxu7ZWY7KeA66eMIO2WpeuhnOuLmOydmCBbMjAyMeuFhCDtmozqs6BdKGh0dHBzOi8vam9qb2xkdS50aXN0b3J5LmNvbS82MjY/dXRtX3NvdXJjZT1wb2NrZXRfbXlsaXN0KSDsmYAg6rCZ7J20IOyii+ydgCDquIDsnYQg7J297Jy866m07IScIOuCtOqwgCDtmITsnqwg64qQ64G86rOgIOyeiOuKlCDsg53qsIHsnbTrgpgg6rCQ7KCV7J2EIOuCqOqyqOuztOuKlCDqsoPrj4Qg7KKL6rKg64uk6rOgIOyDneqwge2VtOyEnCDsspjsnYzsnLzroZwg6re465+s7ZWcIOuCtOyaqeydhCDri7TslYTrs7TroKQg7ZWp64uI64ukLlxcblxcblxcblxcbiMg7KKL7J2AIOqwnOuwnOyekOuegCDrrLTsl4fsnbzquYxcXG5cXG7rp4nsl7Dtnogg7KKL7J2AIOqwnOuwnOyekOqwgCDrkJjqs6Ag7Iu27JeI7Iq164uI64ukLiDqt7jrn6zri6Qg66y465OdICoqKifsoovsnYAg6rCc67Cc7J6Q656AIOustOyXh+yduOqwgD8nKioqIOyXkCDrjIDtlZwg7KCV7J2Y66W8IOyKpOyKpOuhnCDtlZwg67KIIOuCtOugpOu0kOyVvCDqsqDri6Tqs6Ag7IOd6rCB7ZWY7JiA6rOgIOqwmeydgCDtmozsgqwg7YyA7JuQ67aE6rO8IOydtOufsCDsoIDrn7Ag7J207JW86riw66W8IOuCmOuItOyKteuLiOuLpC4g7J6K6riwIOyghOyXkCDqt7gg64K07Jqp7J2EIO2VnCDrsogg7KCV66as7ZW067Sk7Iq164uI64ukLlxcblxcbuuCtOyaqeydgCDtgazqsowg65GQIOqwgOyngOuhnCDrtoTrpZjtlbTrtKTsirXri4jri6QuIFxcblxcbuyyqyDrsojsp7jripQgKirqsJzrsJwg64ql66ClLCoqIFxcbuuRkCDrsojsp7jripQgKirtmJHsl4Ug64ql66ClKipcXG5cXG7snbjrjbAg6re464OlIGDqsJzrsJwg64ql66ClYOqzvCBg6rCc67CcIOyZuCDriqXroKVgIOycvOuhnCDrs7wg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG5cXG5cXG4jIyBBLiDqsJzrsJzriqXroKVcXG5cXG4jIyMgMS4g6rmK7J20IO2DkOq1rO2VmOuKlCDriqXroKUoYS5rLmEgREZTKVxcblxcbuygnCDsiqTsiqTroZzsl5Ag64yA7ZWcIOuwmOyEseydtOq4sOuPhCDtlZjsp4Drp4wg7KCAIOu/kOunjCDslYTri4jrnbwg6r2k64KYIOunjuydgCDqsJzrsJzsnpDrk6Qg7Jet7IucIOyWtOuWpCDqsoPsnYQg6rO167aA7ZW0IOuCmOqwiCDrlYwsIO2UvOyDgeyggeyduCDroIjrsqjsl5DshJwg6re47LmY64qUIOqyveyasOqwgCDsooXsooUg7J6I7Iq164uI64ukLiBcXG5cXG7smIjrpbwg65Ok7Ja0IO2UhOuhoO2KuOyXlOuTnCDqsJzrsJzsnpDsnZgg66m07KCRIOuLqOqzqCDsp4jrrLjsnbggJ+u4jOudvOyasOyggOuKlCDslrTrlrvqsowg64+Z7J6R7ZWY64qU6rCAPyfsl5Ag64yA7ZW07IScIOyVjOqzoCDsi7bri6TrqbQg7ZW064u5IOuCtOyaqeydhCDqtazquIDrp4HtlbTshJwg7KCV66as65CcIOuCtOyaqeydhCDrs7Tqs6Ag6riw6rOE7KCB7Jy866GcIOyZuOyasOqxsOuCmCDsnbTtlbTtlZjripQg6rGw7KOgLlxcblxcbi0gRE5T66GcIOu2gO2EsCDshJzrsoQgSVAg67Cb7JWE7Jik6rOgLCBIVE1MIO2MjOyLse2VmOqzoCwgQ1NTT00sIOugjOuNlO2KuOumrCwgUmVmbG93LCBSZXBhaW50IC4uLlxcblxcbuu2gOuBhOufveyngOunjCDsoIDripQg7ZWt7IOBIOydtCDsiJjspIDsl5Ag66i466y866CA7JeI642YIOqygyDqsJnsirXri4jri6QuXFxuXFxuJ+q3uOufrOuLpOqwgCDsmrDrpqzqsIAg7J6Q7KO8IOyTsOuKlCDrpqzslaHtirjripQg7J20IOqzvOyglSDspJHsl5Ag7Ja47KCcIOu2meuKlOqxuOq5jD8nIOudvOuKlCDsp4jrrLjsnYQg67Cb6rKMIOuQmOyXiOqzoCDqt7jsmYAg6rSA66Co7ZW07IScIOumrOyEnOy5mOulvCDri6Tsi5wg7Iuc7J6R7ZW067O064qUIOykkSDslYTrnpjsmYAg6rCZ7J2AIOq4gOydhCDrp4zrgpjqsowg65CY7JeI7Iq164uI64ukLlxcblxcblvsmZwgdmlydHVhbCBkb23snbQg642UIOyii+ydgOqwgD9dKGh0dHBzOi8vdmVsb2cuaW8vQHllc2JiL3ZpcnR1YWwtZG9tJUVDJTlEJTk4LSVFQyU4NCVCMSVFQiU4QSVBNSVFQyU5RCVCNC0lRUIlOEQlOTQtJUVDJUEyJThCJUVDJTlEJTgwJUVDJTlEJUI0JUVDJTlDJUEwKSAoOmJ1bGI6IOqwley2lCEpXFxuXFxu7JyEIOyVhO2LsO2BtOydhCDsnb3slrTrs7TrqbQg7KCV66eQIOumrOyVoe2KuOydmCDqsIDsg4Hrj5Tsl5Ag64yA7ZWcIOyVhOyjvCDquYrsnYAg66CI67Ko6rmM7KeA7J2YIOumrOyEnOy5mCwg6re466as6rOgIOq3uOqyg+ydhCDsoJXrpqztlbTrgrgg64K07Jqp7J2EIOuzvCDsiJgg7J6I7Iq164uI64ukLiDsspjsnYwg7J20IOq4gOydhCDsnb3qs6Ag7KKL7J2AIOydmOuvuOyXkOyEnOydmCDstqnqsqnsnYQg7KKAIOuwm+yVmOyKteuLiOuLpC4gKion7Jes7YOc6rmM7KeAIOuCtOqwgCDtlZwg6rKD7J2AIOqzteu2gOqwgCDslYTri4jsl4jqtazrgpgnKirrpbwg7J286rmo7JuMIOykgCDqt7jrn7Ag64qQ64KM6rmM7KeAIOuwm+yVmOyKteuLiOuLpC5cXG5cXG7snbTtm4Qg7J2066CH6rKMIO2VmOuCmOydmCDso7zsoJzsl5Ag64yA7ZW07IScIOq5iuydgCDroIjrsqjquYzsp4Ag7YyM6rOg65Ok7Ja07IScIO2VmeyKteydhCDtlbTrgrTripQg64ql66Cl7J20IOqwnOuwnOyekOydmCDshLHsnqXsl5Ag7KCV66eQIOykkeyalO2VmOuLpOuKlCDqsoPsnYQg6rmo64ur6rKMIOuQmOyXiOyKteuLiOuLpC4g6re466as6rOgIOydtCDriqXroKXsnbQg662U6rCAIOq5iuydtOyasOyEoO2DkOyDiShERlMp6rO8IOuPmeyekeybkOumrOqwgCDsnKDsgqztlZwg6rKDIOqwmeuLpOqzoCDripDqu7Qg7KCcIOunmOuMgOuhnCBg6rmK7J207Jqw7ISg7YOQ7IOJKERGUynriqXroKXsnbQg7J6I64qUIOqwnOuwnOyekGAg65286rOgIOuqheuqhe2VtOu0pOyKteuLiOuLpC5cXG5cXG5cXG5cXG4jIyMgMi4g64ST6rKMIO2VmeyKte2VmOuKlCDriqXroKVcXG5cXG7qsJzrsJwg7JiB7Jet7JeQ7ISc7J2YIOq4sOyIoCDrsJzsoIQg7IaN64+E64qUIOygleunkCDruaDrpoXri4jri6QuIOyKpOyKpOuhnCAn7ZWcIOqwgOyngOulvCDsnbTtlbTtlojri6QhJyDsi7bsnLzrqbQg7Je0IOqwgOyngOydmCDsg4jroZzsmrQg6rKD7J20IOyDneqyqOuCmOuKlCDquLDrtoTsnoXri4jri6QuIOuVjOusuOyXkCDtlZwg6rCA7KeA66W8IOq5iuydtCDtjIzqs6Drk5zripQg64ql66Cl7Jm47JeQ64+EIOuLpOyWke2VnCDquLDsiKDsnYQg67mo66asIOyKteuTne2VmOuKlCDriqXroKXrj4Qg66ek7JqwIOykkeyalO2VmOuLpOqzoCDsg53qsIHtlanri4jri6QuIFxcblxcbi0g7ZW064u5IOq4sOyIoOydhCDslrTrlrvqsowg7IKs7Jqp7ZW07JW8IO2VmOuKlOyngCxcXG4tIO2VtOuLuSDquLDsiKDsnbQg6riw7KG0IOq4sOyIoOydmCDslrTrlqQg7KCQ7J2EIOuztOyZhO2VmOuKlOyngFxcbi0g6riw7KG0IOq4sOyIoOydtCDtlbTri7kg6riw7Iig67O064ukIOuNlCDrgpjsnYAg7KCQ7J2AIOyXhuuKlOyngFxcblxcbuulvCDruYTqtZAg67aE7ISd7ZWY7JesIOq4sOyhtOyXkCDsgqzsmqntlZjripQg6rKD67O064ukIOuNlCDrgpjsnYAg6riw7Iig7J20652864qUIO2MkOuLqOydtCDrk6TrqbQg7ZSE66Gc7KCd7Yq47JeQIOuPhOyehe2VoCDsiJgg7J6I64qUIOuKpeugpeuPhCDspJHsmpTtlZjri6Tqs6Ag7Jes6rKo7KeR64uI64ukLiBcXG5cXG7snbTroIfqsowg64uk7JaR7ZWcIOqyg+ydhCDrhJPqsowg7Iq165Od7ZWY64qUIOuKpeugpeydtCDspJHsmpTtlZwg7J207Jyg66GcIO2BrOqyjCDrkZAg6rCA7KeA6rCAIOuNlCDsg53qsIHrgqnri4jri6QuXFxuXFxuIyMjIyAyLTEuICoq7Jqw66as6rCAIO2YhOyerCDri60g7J6h64qUIOy5vOuhnCDshozrpbwg7J6h6rOgIOyeiOuKlCDqsoPsnYAg7JWE64uM6rCAPyoqXFxuXFxu6riw7Iig7J2AIO2Kueygle2VnCDrrLjsoJzrpbwg7ZW06rKw7ZWY6riwIOychO2VtCDrp4zrk6TslrTsp4DripQg6rK97Zal7J20IOyeiOyKteuLiOuLpC4g66as7JWh7Yq4IOy0iOq4sOyXkCDtlITroa3rk5zrprTrp4Eg6rCZ7J2AIOyDge2DnOq0gOumrCDrrLjsoJzrpbwg7ZW06rKw7ZWY6riwIOychO2VnCDrpqzrjZXsiqTqsIAg7J6I7JeI6rOgIOq3uCDrjZXrtoTsl5AgRkxVWO2MqO2EtOqzvCDsoITsl60g7IOB7YOc6rSA66asIOqwnOuFkOydtCDsg53qsqjrgqzsirXri4jri6QuIOydtO2bhCDtlITroaDtirjsl5Trk5zsl5DshJwg66as642V7Iqk66W8IOyCrOyaqe2VmOuKlCDruYTsnKjsnbQg7IOB64u57Z6IIOuGkuyVhOyhjOyKteuLiOuLpC4g7ZWY7KeA66eMIOumrOuNleyKpOydmCDtgbAg642p7LmY7JmAIOuNlOu2iOyWtCDsg4Htg5wg7ZWY64KY66W8IOy2lOqwgO2VmOq4sCDsnITtlbQg7Jes65+sIOykhOydmCDrs7Tsnbzrn6ztlIzroIjsnbTtirgg7L2U65Oc66W8IOunjOuTpOyWtOyVvCDtlZjripQg66y47KCc6rCAIOyeiOyjoC4g65iQ7ZWcIOumrOyVoe2KuOyXkOyEnCDsoJzqs7XtlZjripQgY29udGV4dCBBUEnsmYAgUmVjb2lsIOuTsSDsl6zrn6wg64yA7LK07KCc6rCAIOyDneqyqOuCmOuptOyEnCDrjIDqt5zrqqgg7ZSE66Gc7KCd7Yq46rCAIOyVhOuLjCDqsr3smrDsl5DripQg6rWz7J20IOyDiCDtlITroZzsoJ3tirjsl5Ag66as642V7Iqk66W8IOyCrOyaqe2VmOyngCDslYrslYTrj4Qg65CY7Ja06rCA6rOgIOyeiOyKteuLiOuLpC4g7J207LKY65+8IO2UhOuhnOygne2KuOyXkCDrlLEg7JWM66ee64qUIOq4sOyIoOydhCDst6jsgqwg7ISg7YOd7ZW07IScIOyTuCDsiJgg7J6I64qUIOuKpeugpeydhCDsnITtlbTshJzripQg7Jet7IucIOyXrOufrCDquLDsiKDrk6TsnYQg7J217ZiA64aT64qUIOqyg+ydtCDspJHsmpTtlanri4jri6QuXFxuXFxuXFxuXFxuIyMjIyAyLTIuICoq7IKs7Jqp7ZWY64qUIO2YueydgCDsgqzsmqntlZjroKTripQg6riw7Iig7J20IOyLnOyepeyXkOyEnCDslrTrlqQg7Y+s7KeA7IWY7JeQIOyeiOqzoCwg6re47JmAIOq0gOugqO2VmOyXrCDsnbjroKXsnYQg67O07Lap7ZWY6rGw64KYIOq4sOyhtCDtjIDsm5Drk6TsnZgg65+s64ud7Luk67iM66W8IOunjOuTpOyngOuKlCDslYrripTqsIA/KipcXG5cXG7rjIDquLDsl4Xqs7wg64us66asIOyKpO2DgO2KuOyXheyXkOyEnOuKlCDqsJzrsJzsnpAg7ZWcIOuqheydhCDqs6DsmqntlZjripQg6rKD7J20IOywuCDslrTroKTsmrQg7J287J6F64uI64ukLiDrlYzrrLjsl5Ag7Ja065akIOq4sOyIoOyKpO2DneydhCDsk7gg6rKD7J247KeA66W8IO2MkOuLqO2VoCDrlYwg7JyE7JeQ7IScIOunkO2VnCDtlITroZzsoJ3tirgg66CI67Ko7JeQ7ISc66eMIOyDneqwge2VtOyEnOuKlCDri6Tshowg67aA7KGx7ZWp64uI64ukLiDtlITroZzsoJ3tirjsl5DripQg65SxIOunnuuKlCDsiqTtgqzsnbwg7IiYIOyeiOyngOunjCDqsJzrsJzsnpAg7Iuc7J6l7JeQ7ISc64qUIO2VtOuLuSDquLDsiKAg7Iqk7YOd7J2EIOqwgOynhCDsnbjroKXsnYQg6rWs7ZWY64qUIOqyg+ydtCDrp6TsmrAg7Ja066Ck7Jq4IOyImOuPhCDsnojquLAg65WM66y47J6F64uI64ukLiDrlLDrnbzshJwg7ZSE66Gc7KCd7Yq47J2YIO2YhOyerCDrv5Drp4wg7JWE64uI6528IOuvuOuemOyXkOuPhCDtlITroZzsoJ3tirjrpbwg7J207Ja064KY6rCA6riwIOychO2VtOyEnCDsnbjroKUg67O07Lap7JeQIOyaqeydtO2VnCDquLDsiKAsIO2YueydgCDslZ7snLzroZwg642UIOyduOq4sOqwgCDrp47slYTsp4gg7ZmV66Wg7J20IOuGkuydgCDquLDsiKDsnYQg7ISg7YOd7ZWY64qUIOqyg+uPhCAo7Iqk7YOA7Yq47JeFIO2VnOyglT8g7J28IOyImOuPhCDsnojqsqDsirXri4jri6QuLi4p6rCc67Cc7J6Q7J2YIOuKpeugpeydtCDrkKAg7IiYIOyeiOyKteuLiOuLpC5cXG5cXG5cXG5cXG4jIyAzLiDri6Tsi5wg64+M7JWE67O064qUIOuKpeugpVxcblxcbuyymOydjOyXkOuKlCDsnbQg64ql66Cl7JeQIOuMgO2VnCDsoJzrqqnsnYQgJ+uhnOq3uOulvCDrgqjquLDripQg64ql66ClJ+ycvOuhnCDtlZjroKTtlojsirXri4jri6QuIOyWtOuWpCDqsoPsnYQg7ZaI7Jy866m0IO2VtOuLuSDrgrTsmqnsl5Ag64yA7ZW0IOq3uCDsnbzsnYQg7ZWcIOyCrOuejCDrv5Drp4wg7JWE64uI6528IOuLpOuluCDsgqzrnozsnbQg67SQ64+EIOyVjOyVhOuzvCDsiJgg7J6I6rKMIOq4sOuhneydhCDrgqjquLDripQg64ql66Cl7J2EIOunkO2VmOqzoCDsi7bsl4jquLAg65WM66y47J207JeI7Iq164uI64ukLiDtlZjsp4Drp4wg7KCc66qp7J2EICfri6Tsi5wg64+M7JWE67O064qUIOuKpeugpSfsnbTrnbzqs6Ag67OA6rK97ZWcIOuNsOuKlCDquLDroZ3snYQg64Ko6riw6riw66eMIO2VmOuKlCDqsoPsl5DshJwg6re47LmY64qUIOqyg+ydtCDslYTri4jrnbwg6rO86rGw66W8IOuSpOuPjOyVhOuztOqzoCDri7nsi5wg7IOB7Zmp7JeQ7ISc7J2YIOyemO2VnCDqsoPqs7wg66q77ZWcIOqyg+ydhCDqtazrtoTtlZjqs6Ag6re46rKD7J2EIOyekOyLoCDtmLnsnYAg7YyA7J2YIOyEseyepeyXkCDri6Tsi5wg7Zmc7Jqp7ZWgIOyImCDsnojslrTslbwg7ZWc64uk64qUIOyDneqwgeydtCDrk6Tsl4jquLAg65WM66y47J6F64uI64ukLlxcblxcbuyCrOyaqeyekOydmCDroZzqt7gg6riw66Gd7J2EIOyVhOustOumrCDrgqjqsqjrtJDslbwg6re4IOuhnOq3uOulvCDqsIDsp4Dqs6Ag7IKs7Jqp7J6QIO2MqO2EtOydhCDrtoTshJ3tlZjqsbDrgpgg7ZWY64qU642wIOyTsOyngCDslYrripTri6TrqbQg7J2Y66+4IOyXhuuKlCDroZzqt7jqsIAg65CY6rKg7KOgLlxcblxcbuqwnOuwnOyekOuhnOyEnCDsl4XrrLTrpbwg7ZWY64qUIOqyg+uPhCDsnbzrp6Xsg4HthrXtlZjripTsoJDsnbQg7J6I7Iq164uI64ukLiDsi5zqsITsl5Ag7KuT6rKoIOyWtOuWpCBmZWF0dXJl66W8IOqwnOuwnO2WiOuNlOudvOuPhCDstpTtm4Tsl5Ag7Iuc6rCE7J20IOuCqOycvOuptCDsiqTsiqTroZwg642UIOyii+qyjCDrpqztjKnthqDrp4Eg7ZWgIOyImCDsl4bripTsp4Ag64uk7IucIOuztOqzoCwg7Zi87J6Q7IScIO2VmOq4sCDslrTroLXri6TrqbQg7YyA7JuQ7JeQ6rKMIOusu+qzoCDqt7jqsoPrj4Qg7JWI65Cc64uk66m0IOyKpO2DnSDsmKTrsoQg7ZSM66Gc7Jqw64KYIOy5tOy5tOyYpO2GoSDsmKTtlIgg7LGE7YyF67Cp7JeQ7IScIOusvOyWtOuzvCDsgqzrnozsnYQg7LC+7JWE7ISc652864+EIOyKpOyKpOuhnOulvCDrkJjrj4zslYQg67O066Ck64qUIOuKpeugpeydtCDsoovsnYAg6rCc67Cc7J6Q6rCAIOuQmOuKlCDtlZjrgpjsnZgg64ql66Cl7J206528IOyDneqwge2VqeuLiOuLpC5cXG5cXG5cXG5cXG7snpHshLHtlbQg64aT6rOgIOuztOuLiCDsnIQg64K07Jqp65Ok7J20IOq8rSDqsJzrsJzsl5Drp4wg7ZWc7KCV65CY64qUIOqyg+ydgCDslYTri4jrnbzripQg7IOd6rCB7J20IOuTreuLiOuLpC5cXG5cXG7qsJzrsJzsnYQg65ag64KYIO2VnCDrqoXsnZgg6rCc7J247Jy866Gc7ISc64+EIOyWtOuWpCDqsoPsnYQg6rmK7J20IO2MjOqzoOuTpOqzoCwg65iQIOuLpOuwqeuptOycvOuhnCDtlZnsirXtlZjripQg6rKDLCDqt7jrpqzqs6Ag7Iqk7Iqk66Gc66W8IOuPjOyVhOuztOuKlCDriqXroKXsnYAg6re4IOyCrOuejOydtCDslrzrp4jrgpgg7ISx7J6l7ZWgIOyImCDsnojripQg7IKs656M7J247KeA66W8IOuztOyXrOykgOuLpOuKlCDsg53qsIHsnbQg65Oc64Sk7JqULiBcXG5cXG4tLS1cXG5cXG5cXG5cXG4jIyBCLiDqsJzrsJwg7Jm4IOuKpeugpVxcblxcbiMjIDEuIOy7pOuupOuLiOy8gOydtOyFmCDriqXroKVcXG5cXG7qsJzrsJzsnpDsl5Dqsowg7YOA7KeB6rWw6rO87J2YIOyGjO2GteuKpeugpeydhCDsmpTqtaztlZjripQg64K07Jqp7J2EIOydtOqzsyDsoIDqs7Psl5DshJwg6r2kIOunjuydtCDrtKTrjZgg6rKDIOqwmeyKteuLiOuLpC4g6re465WM64qUIOydtCDrgrTsmqnsnYQg7IOB7IS47Z6IIOyVjOyngCDrqrvtlbTshJwgJ+utkCDqt7jqsbAg6re464OlIOyemCDslpjquLDtlbTshJwg7J287ZWY66m0IOuQmOuKlOqxsCDslYTri4zqsIA/J+2VmOqzoCDqsIDrs43qsowg7IOd6rCB7ZaI7JeI7Iq164uI64ukLiDtlZjsp4Drp4wg7Iuk7KCE7J2AIOuLpOultOuNlOq1sOyalC4g7KO866GcIOqyquuKlCDsgqzroYDripQg64uk7J2M6rO8IOqwmeyVmOyKteuLiOuLpC5cXG5cXG7rsoTsoIQgMS4g65SU7J6Q7J2064SIXFxuXFxuLSDrlJTsnpDsnbTrhIg6IOydtOqxsCDsnbTroIfqsowg64+87JqUP1xcbi0g6rCc67Cc7J6QOiAoJ+yWtC4uLiDrkJjquLQg7ZWY64qU642wLCDqt7jrn7TroKTrqbQg6riw7KG07JeQIOynnOuRlOqxsOulvCDsnbTroIfqsowg7KCA66CH6rKMIOuwlOq/lOyVvCDrkJjqs6Ag7KKAIOydtOyDge2VnOuNsC4uLiDqvK0g7J206rG4IOq3uOugh+qyjCDtlbTslbzrkJjrgpg/J+udvOqzoCDsg53qsIHtlZjrqbApIFxcXCLsmIgsIOuQmOq4tCDrkJjripTrjbAuLi5cXFwiXFxuLSDrlJTsnpDsnbTrhIg6IOuQmOuptCDqt7jroIfqsowg7ZW07KO87IS47JqULlxcbi0g6rCc67Cc7J6QOiDsnYwuLi4g6re8642wIOq3uOuftOqxsOuptCDquLDsobTsl5Ag7J20IOy7tO2PrOuEjO2KuOulvCDsk7DripQg64uk66W4IOqzs+yXkOyEnCDroIjsnbTslYTsm4PsnbQg66y064SI7KeIIOyImCDsnojslrTshJwg67OE66GcIOyduOqxsCDqsJnslYTsmpQuXFxuLSDrlJTsnpDsnbTrhIg6IOuQmOqyjCDtlbTso7zsi5zrqbQg7JWI64+87JqUPyDtmLnsnYAgXFxcIuq3uOuDpSDtlbTso7zshLjsmpRcXFwiXFxuLSDqsJzrsJzsnpA6IC4uLlxcblxcblxcblxcbuyXrOq4sOyEnCDqsJzrsJzsnpDripQg7Ja065akIOy7pOuupOuLiOy8gOydtOyFmOydhCDsnpjrqrvtlZwg6rKD7J286rmM7JqUP1xcblxcbuyCrOyLpCDsl4TrsIDtnogg65Sw7KGM7J2EIOuVjCDqsJzrsJzsnpDsnZgg66eQIOykkeyXkOyEnCDrlLHtnogg7YuA66aw66eQ7J2AIOyXhuyKteuLiOuLpC4g67OE66GcIOyii+yngCDslYrsnYAg7JqU6rWs7IKs7ZWt7J207Ja07IScIOq3uOugh+yngCDslYjrkJjripTqsbQg7JWE64uI64uI6rmMIOuQmOq4tCDtlZzri6Tqs6Ag7ZaI6rGw65Og7JqULlxcblxcbuuLpOyGjCDslrXsmrjtlZjsp4Drp4wg7J2065+0IOuVjCDsnpgg7KGw7Jyo7ZW0IOuCmOqwgOuKlCDqsoPsnbQg67CU66GcIOqwnOuwnOyekOydmCDsu6TrrqTri4jsvIDsnbTshZgg64ql66Cl7J206528IOuzvCDsiJgg7J6I7Iq164uI64ukLlxcblxcblxcblxcbuqwnOuwnOyekOydmCDssqsg67KIIOynuCDrjIDri7XsnYQg64uk7J2M6rO8IOqwmeydtCDsiJjsoJXtlbQg67SF7Iuc64ukLlxcblxcbi0g65SU7J6Q7J2064SIOiDsnbTqsbAg7J2066CH6rKMIOuPvOyalD9cXG4tIOqwnOuwnOyekDog7J2MLi4uIOydtOqyjCDquLDsobTsl5Ag64+Z7J287ZWY6rKMIOyCrOyaqe2VmOqzoCDsnojripQg7Lu07Y+s64SM7Yq47JeQIOyghOyytOyggeycvOuhnCDsmIHtlqXsnYQg7KSEIOyImCDsnojripQg7IiY7KCV7IKs7ZWt7J2065287IScIOydtOugh+qyjCDsoIHsmqntlZjripQg6rKD7J2AIOyii+yngCDslYrsnYQg6rKDIOqwmeyKteuLiOuLpC4g64yA7IugIELrsKnsi53snYAg7Ja065ao6rmM7JqUP1xcblxcbuudvOqzoCDsm5Ag7KCc7JWI7JeQIOuMgO2VtOyEnCDsmZwg7JWI7KKL7J2AIOyngOulvCDshKTrqoXtlZjqs6DrgpjshJwg67CU66GcIOuLpOuluCDrjIDslYjsnYQg67CU66GcIOygnOyLnO2VmOuKlCDqsoPsnbTso6AuXFxuXFxu66y866GgIOyLpOyghOydgCDsnbTroIfqsowg6rCE64uo7ZWY6rKMIOuBneuCmOyngOulvCDslYrsp4Drp4wg6re4656Y64+EIOydtOufsCDsu6TrrqTri4jsvIDsnbTshZjsnbQg64iE7KCB65CY7Ja07JW8IOuLpOuluCDtjIDsm5Drk6Trj4Qg7ZW064u5IOyCrO2VreyXkCDrjIDtlbQg7KeA7IaN7KCB7Jy866GcIOuTo+qzoCDsg53qsIHtlZjrqbTshJwg7KCQ7LCoIOuwnOyghO2VtOuCmOqwiCDsiJgg7J6I7Ja07IScIOq8rSDtlYTsmpTtlZwg64ql66Cl7J206528IOyXrOqyqOynkeuLiOuLpC5cXG5cXG5cXG5cXG4jIyAyLiDruYTspojri4jsiqQg7J6E7Yyp7Yq466W8IOqzoOugpO2VmOuKlCDriqXroKVcXG5cXG7qsJzrsJzsnpDqsIAg7Iug6recIOq4sOuKpeydhCDrp4zrk6TqsbDrgpgsIOy9lOuTnCDsnqXslaAg7IOB7Zmp7J2EIOuMgOyymO2VoCDrlYwg7J6Q7Iug7J20IO2VmOuKlCDsnbzsnbQg67mE7KaI64uI7IqkIOyggeycvOuhnCDslrzrp4ztgbzsnZgg6rCA7LmY66W8IOqwgOynhCDsnbzsnbjsp4Drpbwg7IOd6rCB7ZWgIOyImCDsnojripQg64ql66Cl7J20IOyeiOycvOuptCDsoovsnYAg6rCc67Cc7J6Q65286rOgIOyDneqwge2VqeuLiOuLpC5cXG5cXG7smIjrpbwg65Ok7Ja0LCDslrTrlqQg7J6l7JWgIOyDge2ZqeydtCDrsJzsg53tlZjsl6wgMeyLnOqwhCDrj5nslYgg7Iug6rec7Jyg7KCA6rCAIOqwgOyeheydhCDtlaAg7IiYIOyXhuuKlCDsg4HtmansnbTrnbwg6rCA7KCV7ZW0IOu0heyLnOuLpC4g7Y+J7IOB7Iuc7JeQIO2VtOuLuSDsi5zqsITrjIDsl5Ag7Y+J6reg7KCB7Jy866GcIOyVvSAxMDDrqoXsnbQg65Ok7Ja07Jik6rOgIDHrqoXsnZgg7ZqM7JuQ64u5IDXrp4zsm5DsnZgg67C466WY66W8IOqwluuKlCDqsoPsnYQg7JWM6rOgIOyeiOuLpOuptCDsnbQg7ZWcIOyLnOqwhOuPmeyViOydmCDsnqXslaDqsIAgNTAw66eM7JuQ7Kec66asIOyepeyVoOudvOuKlCDqsoPsnYQg7LaU7IKw7ZW067O8IOyImCDsnojsirXri4jri6QuIFxcblxcbuuYkCwg67CY64yA66GcIOydtOyZgCDqsJnsnbQg7Iug6recIO2ajOybkOydhCDrqqjsp5HtlZjripQg7J2067Kk7Yq466W8IO2VoCDrlYwg7ZWcIOyLnOqwhOydmCDqsIDsuZjqsIAgNTAw66eM7JuQ7J24IOqyveyasCDsnbQg7J2067Kk7Yq466W8IO2VnCDsi5zqsIQg67mo66asIOufsOy5re2VoCDsiJgg7J6I64+E66GdIOunjOuTpOyWtCDrgrjri6TrqbQg7J20IOqwnOuwnOyekOuKlCDtmozsgqzsl5DshJwg7ZWcIOyLnOqwhOydtOudvOuKlCDstpTqsIDsoIHsnbgg66as7IaM7IqkIOu5hOyaqeydhCDqsJDstpXsi5ztgqTqs6Ag64+Z7Iuc7JeQIDUwMOunjOybkOydmCDqsIDsuZjrpbwg7ZWcIOyLnOqwhCDrjZQg7J287LCNIOuyjOyWtOuTpOydvCDsiJgg7J6I64+E66GdIOunjOuTpOyXiOycvOuvgOuhnCA1MDDrp4wgK+ydmCDqsIDsuZjrpbwg7IOd7IKw7ZW064OI64uk6rOgIOyXrOq4uCDsiJgg7J6I7Iq164uI64ukLlxcblxcbuydtOyymOufvCDqsJzrsJzsnpDqsIAg7J6Q7Iug7J20IOyKpOyKpOuhnCDslrzrp4jrp4ztgbzsnZgg6rCA7LmY66W8IOunjOuTpOyWtOuCtOqzoCDsnojripTsp4Drpbwg7JWM6rOgIOq3uCDqsIDsuZjrpbwg7JWI64uk66m0LCDqt7gg6rCA7LmY66W8IOuNlOyasSDtgazqsowg66eM65OkIOyImOuPhCDsnojqs6Ag67CY64yA66GcIOyGkOyLpOuPhCDspITsnbwg7IiYIOyeiOyKteuLiOuLpC4g65iQ7ZWcIOyWtOuWpCDsnbzsnZgg7Jqw7ISg7Iic7JyE66W8IOygle2VoCDrlYzrj4Qg7J20IFxcXCLruYTspojri4jsiqQg7J6E7Yyp7Yq4XFxcIuulvCDquLDspIDsnLzroZwg7ZWY66m0IOuNlCDspJHsmpTtlZwg7J287JeQIOynkeykke2VmOqzoCDrjZwg7KSR7JqU7ZWcIOydvOydhCDrgpjspJHsl5Ag7ZWgIOyImOuPhCDsnojsirXri4jri6QuIOuVjOusuOyXkCDqsJzrsJzsnpDsl5Dqsowg67mE7KaI64uI7IqkIOyehO2Mqe2KuOulvCDqs6DroKTtlZjripQg64ql66Cl7J20IOykkeyalO2VnCDsl63rn4nsnbTrnbwg7IOd6rCB7ZWp64uI64ukLlxcblxcblxcblxcbuyXrOq4sOq5jOyngOqwgCDsoJzqsIAg7IOd6rCB7ZWY64qUIGDsoovsnYAg6rCc67Cc7J6QYCDsl5Ag64yA7ZWcIOuCtOyaqeydtOyXiOyKteuLiOuLpC4gXFxuXFxu64KY7KSR7JeQIOuNlCDsoovsnYAg64K07Jqp7J20IOyDneqwgeuCmOuptCDstpTqsIDtlbTrs7Trj4TroZ0g7ZWY6rKg7Iq164uI64ukLlxcblxcbuyXrOufrOu2hOydtCDsg53qsIHtlZjripQg7KKL7J2AIOqwnOuwnOyekOyXkCDrjIDtlZwg7J2Y6rKs7J20IOyeiOycvOyLnOuLpOuptCDrjJPquIAg64Ko6rKo7KO87IS47JqULiDqsJDsgqztlanri4jri6QuXFxuXFxuXCI7IiwiZXhwb3J0IGRlZmF1bHQgXCItLS1cXG50aXRsZTogXFxcIuyalOymmOuTpOyWtCDqsJzrsJzsnpDrj4Qg7Luk666k64uI7LyA7J207IWYIOuKpeugpeydtCDspJHsmpTtlZjri6Tqs6Ag64qQ64G864qUIOydtOycoFxcXCJcXG5kYXRlOiBcXFwiMjAyMi4wOC4yOFxcXCJcXG50YWdzOlxcbiAgLSDtmozqs6BcXG4gIC0g7Luk666k64uI7LyA7J207IWYXFxuLS0tXFxuXFxuXFxuXFxuIyMgSW50cm86IOy7pOuupOuLiOy8gOydtOyFmCDriqXroKU/IOutkCDqt7jqsbAg6rGNIOy1nOuMgO2VnCDsnpgg7JaY6riw7ZWY66m0IOuQmOuKlOqxsCDslYTri4jslbw/XFxuXFxu7JiI7KCE7JeQ64qUIGDsu6TrrqTri4jsvIDsnbTshZgg64ql66ClYOydhCDrs7TrqbQgJ+utkCDqt7jqsbAg6re464OlIOy1nOuMgO2VnCDsnpgg7JaY6riw7ZWY66m0IOuQmOuKlOqxsCDslYTri4jslbw/J+udvOqzoCDqsIDrs43qsowg7IOd6rCB7ZaI642YIOyLnOygiOydtCDsnojsl4jsirXri4jri6QuXFxuXFxu7ZWY7KeA66eMIOyLnOqwhOydtCDsp4DrgqDsiJjroZ0gYOy7pOuupOuLiOy8gOydtOyFmGAg7J20IOywuCDslrTroLXri6TripQg6rKD7J2EIOygkOygkCDripDqu7TqsIDqs6Ag7J6I7Iq164uI64ukLiDsmKTripjsnYAg6re466CH6rKMIOuKkOuBvOuKlCDsnbTsnKDsl5Ag64yA7ZW0IO2VnCDrsogg7J6R7ISx7ZW067O06rKg7Iq164uI64ukLlxcblxcbiFb7J6Y7JWI65CRXSgvYXNzZXRzL2ltZy/si6TtjKguanBnKVxcblxcblxcblxcbiMjIDpvbmU66rCc67Cc7J6QIOy7pOuupOuLiOy8gOydtOyFmCDsi6TtjKgg7IKs66GAIFxcblxcbuydtOuyiOyXkCDtmozsgqwg7ISc67mE7Iqk7JeQIOyduCDslbEg6rKw7KCc6riw64ql7J2EIOy2lOqwgO2VmOuKlCDqvaQg6rec66qo6rCAIO2BsCDtg5zsiqTtgazqsIAg7J6I7JeI7Iq164uI64ukLiDthqDsiqQg7Y6Y7J2066i87Lig66W8IOyXsOuPmeyLnOy8nOyEnCDtlZwg67KIIOyLoOyaqey5tOuTnOulvCDrk7HroZ3tlbTrkZDrqbQg64S37ZSM66at7Iqk7JmAIOqwmeydtCDrp6Tsm5Trp4jri6Qg7J6Q64+ZIOqysOygnOqwgCDrkJjripQg7Iuc7Iqk7YWc7J6F64uI64ukLlxcblxcbu2VmOyngOunjCDquLDsobTsl5DripQg6rKw7KCc66W8IOyWtO2UjOumrOy8gOydtOyFmCDrgrTrtoDsl5DshJwg6rWs7ZiE7ZWY7KeAIOyViuyVmOqzoCDsoITthrXsoIHsnbgg6rOE7KKM7J207LK0IOuwqeyLneydhCDthrXtlbQg6rOE7KKM7J207LK06rCAIO2ZleyduOuQnCDqsr3smrDsl5Drp4wg7JWE7J2065SU66W8IOuwnOq4ie2VmOyXrCDsnKDsoIDsnZgg7KCR6re87J2EIO2XiOyaqe2VtOyZlOyKteuLiOuLpC4g64uk7IucIOunkO2VtOyEnCDqsrDsoJzsmYAg6rSA66Co65CcIOuCtOyaqeydtCDtlZjrgpjrj4Qg7KSA67mE65CY7Ja07J6I7KeAIOyViuydgCDsg4Htg5zsmIDso6AuIOuUsOudvOyEnCDqsJzrsJzsnpAg7J6F7J6l7JeQ7ISc64qUIOydtOqyg+yggOqygyDrlLDsoLjrtJDslbztlaAg6rKMIOunjuydgCDsnpHsl4XsnbTsl4jsirXri4jri6QuXFxuXFxu6riw7KG07JeQIOydvO2VmOuKlCDrsKnsi53snYAg6riw7ZqN7YyA7JeQ7IScIOq4sO2ajeyViOydhCDrhbjshZgg7Lm065Oc66GcIOyekeyEse2VmOuptCDqt7gg64K07Jqp7J2EIO2ZleyduO2VmOqzoCDsnb3snYAg65KkIOqwnOuwnOyekOqwgCDtlLzrk5zrsLHsnYQg7KO86rOgIOq3uCDrkqTsl5Ag7ZW064u5IOuCtOyaqeydhCDrs7TsmYTtlbTshJwg64uk7IucIOq4sO2ajeyViOydhCDsiJjsoJXtlZwg65KkIOqwnOuwnOydhCDsp4TtlontlZjripQg67Cp7Iud7J207JeI7Iq164uI64ukLiDri6Tshowg7KCE7Ya17KCB7J24IOuwqeyLneydtOyXiOyjoC5cXG5cXG4qKlvqtawg67Cp7IudXSoqXFxuXFxuLSAxKSDquLDtmo3tjIAg6riw7ZqN7JWIIOyekeyEsSBcXG4tIDIpIOqwnOuwnO2MgCDrs7TsmYQg7IKs7ZWtIO2UvOuTnOuwsVxcbi0gMykg6riw7ZqN7YyAIOq4sO2ajeyViCDsiJjsoJUg67O07JmEXFxuLSA0KSDqsJzrsJwg7KeE7ZaJXFxuXFxu6re8642wIOydtOugh+qyjCDtlZjri6Trs7TrqbQgMi0z67KIIOqzvOygleydtCDqvaQg7Jes65+s67KIIOuwmOuzteuQoCDrlYzrj4Qg7J6I7Iq164uI64ukLiDsnbQg6rK97JqwIOqwnOuwnO2MgOyXkOyEnCDrs7TsmYTsnYQg7JqU7LKt7ZWcIOuCtOyaqeydhCDquLDtmo3tjIDsl5DshJwg7KCV7ZmV7Z6IIOuwm+yVhOuTpOydtOyngCDrqrvtlojri6TripQg7J207JW86riw7J206rGw64KYIOuwmOuMgCDtmLnsnYAg66qo65GQ7J2YIOydtO2VtOuPhOqwgCDrlqjslrTsp4DripQg6rK97Jqw7J28IOyImOuPhCDsnojsirXri4jri6QuXFxuXFxu7J2065+wIOusuOygnOulvCDtlbTqsrDtlZjquLAg7JyE7ZW0IOyggO2drO2MgOydgCDslZ7snLzroZwg7KCV7Iud7KCB7Jy866GcIOq4sO2ajeyViOydhCDsnpHshLHtlZjquLAg7KCE7JeQIOq4sO2ajSDstIjslYjsnYQg6rCA7KeA6rOgIOq4sO2ajS/qsJzrsJwg66qo65GQ6rCAIO2VqOq7mCDrqqjsnbTripQgYO2CpeyYpO2UhCDrr7jtjIVg7J2EIOynhO2Wie2VoCDqsoPsnYQg7KCc7JWI7ZaI7Iq164uI64ukLiDslZ7shJwg7Ja46riJ7ZWcIOqysOygnOyLnOyKpO2FnOydhCDstpTqsIDtlZjripQg6riw7ZqNIOuCtOyaqeydtCDssqsg67KI7Ke4IOy8gOydtOyKpOqwgCDrkJjsl4jsirXri4jri6QuXFxuXFxuKipb7YKl7Jik7ZSEIOuvuO2MhSDsp4TtloldKipcXG5cXG4tIOq4sO2aje2MgCBEcmFmdCDshKTrqoVcXG4tIOqwnOuwnO2MgCDtlLzrk5zrsLFcXG4tIO2ajOydmCDrp4jrrLTrpqxcXG5cXG7tgqXsmKTtlIQg66+47YyF7J2AIOuLqOqzhOuhnCDrlLDsp4DrqbQg6rCE64uo7ZWY7KeA66eMIOyLpOyDgeydgCDsoIAg6rO87KCV7JeQ7IScIOunjuydgCDrgrTsmqnsnbQg7Jik6rCU7Iq164uI64ukLiDsoIDtnazqsIAg7YyQ66ek7ZWY64qUIOyDge2SiOydgCAqKuyblOuzhCBvciDsl7Drs4Qg6rWs64+FIFxcXCLtlIzrnpxcXFwiKirsnbTsl4jqs6Ag6re4IO2UjOuenOydmCDsooXrpZjripQg7YGs6rKMIOuLpOyEr+qwgOyngOqwgCDsnojsirXri4jri6QuIOydtCDspJHsl5DshJwgRWR1Y2F0aW9uIO2UjOuenOydtCDsnojsl4jripTrjbAg64yA7ZWZ7IOdL+uMgO2VmeybkOyDneydhCDsnITtlZwg7ZWg7J24IOqwnOuFkOydmCDtlIzrnpzsnoXri4jri6QuIOydtCDqs7zsoJXsl5DshJwg6rCc67Cc7YyA7JeQ7IScIOyYiOy4oSDqsIDriqXtlZwg66y47KCc65Ok7J2EIOyDneqwgeuCmOuKlOuMgOuhnCDtlLzrk5zrsLHsnYQg65Oc66C47Iq164uI64ukLlxcblxcbi0gJ0VkdWNhdGlvbiDtlIzrnpzsnYAg7Ja065a76rKMIOq1rOuzhO2VoCDsiJjqsIAg7J6I7J2E6rmM7JqUPyDqsIDsnoXtlaAg65WM7J2YIOuplOydvCDrkqQg64+E66mU7J247J2EIOyCtO2OtOyVvCDtlaDquYzsmpQ/IOyVhOuLiOuptCDtlZnqtZAg7J2066mU7J2866GcIHZlcmlmaWNhdGlvbuuplOydvOydhCDsoITshqHtlaDquYzsmpQ/J1xcbi0gJ+yhuOyXheydhCDtlbTrj4Qg7ZWZ7IOdIOydtOuplOydvOydtCDsgrTslYTsnojripQg6rK97Jqw64qUIOyWtOuWu+qyjCDqtazrs4TtlaAg7IiYIOyeiOydhOq5jOyalD8nXFxuLSAn7KeA6riIIOyEpOuqhe2VtOyjvOyLoCBVc2VyIEZsb3fsl5DshJzripQg7JWE66y0IO2UjOuenOuPhCDshKDtg53tlZjsp4Ag7JWK7J2AIOycoOyggOuTpOydmCDtlIzroZzsmrDqsIAg67mg7KC47J6I7Iq164uI64ukLiDsnbQgTk9ORSDtg4DsnoUg7ZSM656c7J28IOqyveyasOydmCBVc2VyIEZsb3frpbwg7LaU6rCA7ZW07KO87IS47JqULidcXG4tICfsg4gg7ZSM656c7J2EIO2VoOyduO2VmOqzoCDsnojripTrjbAsIOydtOufsCDtlaDsnbjsnYQg7Ja47KCc6rmM7KeAIO2VoCDqsoPsnbjsp4DqsIAg64iE652965CY7Ja07J6I7Iq164uI64ukLiDsnKDsoIAg7J6F7J6l7JeQ7ISc64qUIO2VoOyduOydtCDslrjsoJzquYzsp4Ag6rOE7IaN65Cg7KeA66W8IOyVhOuKlCDqsoPsnbQg6rWs66ek7JeQIOykkeyalO2VnCDsmpTshozqsIAg65Cg7YWQ642wLCDsnbTrpbwg6rWs66ek7KCE7JeQIOuvuOumrCDslYwg7IiYIOyeiOuPhOuhnSDqs7Xsp4DtlZjripQg6rKD7J20IOyii+ydhCDqsoMg6rCZ7Iq164uI64ukLiDtlaDsnbjsnbTrsqTtirjripQg7Ja47KCc6rmM7KeAIO2VoCDsg53qsIHsnbTsi6DqsIDsmpQ/J1xcblxcblxcblxcblxcblxcbiMjIyDri6TrpbjqsbQg66qw652864+EIOycoOyggOydmCDrj4jsnbQg6rG466awIOydvOydgCDstZzrjIDtlZwg6ry86ry87ZWY6rKMIOyymOumrO2VtOyVvO2VnOuLpCFcXG5cXG4hW+ycoOyggOuKlCDrj4jsl5Ag7JiI66+8XShodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xODA0NTk1OC8xODgyNTg0ODUtNTEyM2Y3OTMtZWZjMC00OTFiLWE3NjYtZmEyMmU2Y2QxYmQ2LmdpZilcXG5cXG7snKDsoIDripQg64+I7JeQIOyYiOuvvO2VmOuLpFxcblxcblxcblxcbuyggOyZgCDsoIDtnaztjIDsnYAg7J2067KIIOydvOydgCBcXFwi7Jyg7KCA7J2YIOuPiFxcXCLsnYQg6rKw7KCcL+2ZmOu2iO2VmOuKlCDsi5zsiqTthZzsnbTrr4DroZwg7J207KCE6rmM7KeA7J2YIEZlYXR1cmUg6rCc67Cc67O064ukIOuNlOyasSDqsqzqs6DtlZwg7JWE7YKk7YWN7LOQ7JmAIO2DgOyeheydhCDsgqzsmqntlbTshJwg7KeE7ZaJ7ZW07JW8IO2VnOuLpOuKlCDrp4jsnYzsnbQg7KeA67Cw7KCB7J207JeI7Iq164uI64ukLiDrlLDrnbzshJwg7JyE7JmAIOqwmeydtCDrsJzsg53tlaAg7IiYIOyeiOuKlCDsmKTrpZgg7IKs7ZWt6rO8IOuIhOudveyCrO2VreuTpOydhCDri6Qg6rCZ7J20IOuqqOyduCDsnpDrpqzsl5DshJwg7LWc64yA7ZWcIOunjuydtCDsoITri6ztlbTshJwg642UIOyii+ydgCDquLDtmo3slYjsnYQg66eM65OkIOyImCDsnojrj4TroZ0g6riw7Jes66W8IO2VtOyVvOqyoOuLpOuKlCDsg53qsIHsnLzroZwg7ZqM7J2Y7Iuk7JeQ7IScIOy1nOuMgO2VnCDrqLjrpqzrpbwg7KWQ7Ja0IOynnOuDiOqzoCDqs7XsnKDtlojsirXri4jri6QuXFxuXFxu7ZqM7J2Y66W8IOuBneuCtOqzoOyEnOuPhCDtmLnsi5zrgpgg642UIOu5oOucqOumsCDqsoPsnYAg7JeG7J2E6rmMIOyDneqwge2VmOupsCDsl6zrn6zrsogg6rKA7Yag7ZWY6rOgIOyDneqwgeuCmOuKlCDsgqztla3rk6TsnYAg6re465WMIOq3uOuVjCDquLDtmo3tjIDsnLzroZwg7KCE64us7ZaI7Iq164uI64ukLlxcblxcbiFb7I6E7ZWc64qQ64KMXSgvYXNzZXRzL2ltZy/sjoTtlZzripDrgowuanBnKVxcblxcblxcblxcbu2VmOyngOunjCDrrZTqsIAg7I6E7ZWcIOuKkOuCjOydtOyXiOyKteuLiOuLpC4g7Jqw66asIOyqveyXkOyEnCDsnbTroIfqsowg7Je07Ius7Z6IIO2UvOuTnOuwseydhCDtlbTrj4Qg6riw7ZqN7YyA7JeQ7ISc64qUIOqwnOuwnO2MgOydmCDtlLzrk5zrsLHsl5Ag64yA7ZWcIO2UvOuTnOuwseydhCDrlLDroZwg7ZWY6rGw64KYLCDrs4TroZwg64us6rCA7JuMIO2VmOyngCDslYrripQg65Ov7ZWcIOq4sOu2hOydtCDrk6Tsl4jquLAg65WM66y47J6F64uI64ukLlxcblxcbuyVhOustO2KvCDquLDtlZzsnYAg7KCV7ZW07KC47J6I6rOgLCDthqDsiqTtjpjsnbTrqLzsuKDsmYAg7Lm065Oc7IKs7J2YIOyLrOyCrCDrmJDtlZwg7ZWE7JqU7ZaI7Jy866+A66GcIOq4sO2ajeydhCDrhIjrrLQg6ri46rKMIOuBjCDsiJjripQg7JeG64qUIOyDge2ZqeydtOyXiOyKteuLiOuLpC4g7ZqM7IKs64qUIOq4sO2ajeydtCDsmYTrsr3tlZjsp4Ag7JWK642U652864+EIOydvOuLqCDstZzrjIDtlZwg67mo66asIOynhO2Wie2VmOq4sOulvCDtnazrp53tlojqs6Ag7J2864uoIO2UhOuhoO2KuCDsnpHsl4Xqs7wg6rytIO2VhOyalO2VtOuztOydtOuKlCBhcGkg7J6R7JeF67aA7YSwIOuovOyggCDsp4TtlontlZjquLAg7Iuc7J6R7ZaI7Iq164uI64ukLlxcblxcblxcblxcbiMjIyAo6riw7ZqNKSDqt7jqsbAg67OE66GcIOydvOyWtOuCmOyngOuPhCDslYrsnYQg7IOB7Zmp7J246rGwIOqwmeydgOuNsCDrhIjrrLQg6rmQ6rmQ7ZWY6rKMIOq1rOuKlOqxsCDslYTrg5A/IOqwnOuwnO2MgCDsnbztlZjquLAg7Iur7Ja07IScIOq8rOyepeu2gOumrOuKlOqxsCDqsJnsnYDrjbA/XFxuXFxu7J6R7JeF7J20IOyLnOyekeuQmOqzoCDqvaQg7Iuc6rCE7J20IOyngOuCnCDtm4TsnZgg7J287J6F64uI64ukLiDtlZzssL0g7J287JeQIOyXtOykke2VtOyeiOuNmCDqt7gg7KaI7J2MIOqxtOuEiCDqsbTrhIgg6rG064SI7IScIOq4sO2aje2MgOydtCDsoIDtnawg6rCc67Cc7YyA7JeQIOu2iOunjOydhCDqsJbqs6Ag7J6I64uk64qUIOuCtOyaqeydhCDslYzqsowg65CY7JeI64qU642wIOq3uCDrgrTsmqnsnbQg7KCA7JeQ6rKM64qUIOqwgO2eiCDstqnqsqnsoIHsnbTsl4jsirXri4jri6QuXFxuXFxuPiDqt7jqsbAg67OE66GcIOydvOyWtOuCmOyngOuPhCDslYrsnYQg7IOB7Zmp7J246rGwIOqwmeydgOuNsCDrhIjrrLQg6rmQ6rmQ7ZWY6rKMIOq1rOuKlOqxsCDslYTrg5A/IOqwnOuwnO2MgCDsnbztlZjquLAg7Iur7Ja07IScIOq8rOyepeu2gOumrOuKlOqxsCDqsJnsnYDrjbA/XFxuXFxu6re466CH6rKMIOykkeyalO2VnCDqsoMg6rCZ7KeAIOyViuydgOuNsCDtgqXsmKTtlIQg66+47YyF7JeQ7IScIOuEiOustCDrlJTthYzsnbztlZwg66m06rmM7KeAIO2UvOuTnOuwseydhCDtlZwg6re4IOyDge2ZqeydtCDrp5jsl5Ag65Ok7KeAIOyViuyVmOuLpOuKlCDqsoPsnbTsl4jsirXri4jri6QuIO2doC4uLi4g67Cx67KIIOyWkeuztO2VtOyEnCAn7YKl7Jik7ZSEIOuvuO2MheyXkOyEnCDrhIjrrLQg65SU7YWM7J287ZWcIOuptOq5jOyngCDsnbTslbzquLDtlZjripQg6rKD7J20IOutlOqwgCDsnpDsi6DsnZgg6riw7ZqN7JWI7J2EIOq5jOuKlCDqsoPsspjrn7wg64qQ6ru07KC47IScIOq4sOu2hOuCmOyBoCDsiJjrj4Qg7J6I6rKg64ukLifqs6Ag7Iqk7Iqk66Gc66W8IOuwmOyEse2VtOuztOq4sOuPhCDtlojsirXri4jri6QuIO2VmOyngOunjCDslYTrrLTrpqwg7IOd6rCB7ZW064+EICoqXFxcIuydvCDtlZjquLAg7Iur7Ja07IScIOydvOu2gOufrCDqt7jrn7Dri6RcXFwiKiog64qUIOuPhOyggO2eiCDrsJvslYTrk6Tsnbwg7IiY6rCAIOyXhuqzoCDsho3snbQg67aA6riA67aA6riAIOuBk+uNlOudvOq1rOyalC4g6re465+87JeQ64+EIOu2iOq1rO2VmOqzoCDri6Tsi5wg7ZWcIOuyiCDqsIDsirTsl5Ag7IaQ7J2EIOyWueqzoCDsiqTsiqTroZzsl5Dqsowg66y87Ja067Sk7Iq164uI64ukLiAqKifsoJXrp5Ag64uoIDFn7J2YIOuniOydjOydtOudvOuPhCDsnbzsnYQg7ZWY6riwIOyLq+yWtO2WiOuNmCDrp4jsnYzsnbQg7J6I7JeI64qU6rCAPycqKuulvCDsnpDsi6Dsl5Dqsowg7Jes65+s67KIIOuLpOyLnCDrsJjrrLjtlbTrs7TslZjsirXri4jri6QuIO2VmOyngOunjCDsl6zrn6zrsogg7IOd6rCB7ZW067SQ64+EIOydtCDsgqzslYjsl5Ag64yA7ZW07ISc64qUIOyKpOyKpOuhnCBcXFwi7KCE7ZiAIOq3uOufsCDrp4jsnYzsnbQgMWfrj4Qg7JeG7JeI64ukXFxcIuqzoCDtmZXsi6DtlaAg7IiYIOyeiOyXiOyKteuLiOuLpC5cXG5cXG5cXG5cXG7rj4TrjIDssrQg7Ja065akIOydtOycoOuhnCAg7Jqw66as7YyA7J20IOydtOugh+qyjOq5jOyngCDsi6DrorDrpbwg7J6D7JeI7J2E6rmMLi4uIOywuCDssKnsnqHtlojsirXri4jri6QuXFxuXFxu66qo66W064qU6rKMIOyVveydtOudvOqzoCDssKjrnbzrpqwg7J20IOuCtOyaqeydhCDrqrDrnpDrjZTrnbzrqbQg6rSc7LCu7JWY7J2E7YWQ642wIOyVjOqzoCDrgpjri4jquYwg66eI7J2465OcIOy7qO2KuOuhpOydtCDsib3sp4Ag7JWK7JWY7Iq164uI64ukLlxcblxcbuyWtOywjOyggOywjCDrp4jsnYzsnYQg7LaU7Iqk66as6rOgIOydtCDsg4HtmansnYQg6rCd6rSA7KCB7Jy866GcIOuLpOyLnCDtjIzslYXtlbTrs7TroKQg64W466Cl7ZaI7Iq164uI64ukLiDrj4TrjIDssrQg7Ja065akIOqzvOygleyXkOyEnCDsmKTrpZjqsIAg7J6I7JeI6rOgLCDqt7gg6rO87KCV7J2EIOydtOyghOqzvCDri6Trpbgg7Ja065akIOyDiOuhnOyatCDrsKnsi53snLzroZwg64yA7J2R7ZWc64uk66m0IOyngOq4iOqzvOuKlCDri6Trpbgg6rKw6rO866W8IOydtOuBjOyWtCDrgrwg7IiYIOyeiOydhOyngCDqs6Drr7ztlbTrtKTsirXri4jri6QuXFxuXFxuXFxuXFxuIyMjIyAxLiDtg5zrj4TqsIAg66y47KCc7JiA64qU6rCAP1xcblxcbi0g6riw7ZqNIOuCtOyaqSDtlLzrk5zrsLHsnYQg7KeE7ZaJ7ZWY64qUIOqzvOygleyGjeyXkOyEnCDrhIjrrLQgJ+yVhOuKlCDsspknIO2WiOyXiOuNmCDqsoPsnbzquYw/XFxuLSDsg4jroZzsmrQg67Cp7JWI7J2064KYIOuMgOyViOydhCDsg53qsIHtlZjquLAg67O064uk64qUIOu5hO2MkOyXkOunjCDstIjsoJDsnYQg66ee7LeE642YIOqyg+ydvOq5jD9cXG5cXG5cXG5cXG4jIyMjIDIuIO2UvOuTnOuwseydmCDslpHsnbQg66y47KCc7JiA64qU6rCAPyDspoksIO2UhOuhnOyEuOyKpOydmCDri6jqs4Trs4Qg7JeF66y0IOugiOuyqOydtCDsnojripTrjbAg64SI66y0IOyVnuyEnOqwhCDqsoMg7JWE64uQ6rmMP1xcblxcbi0g6re466CH64uk66m0IO2CpeyYpO2UhCDrr7jtjIXsl5DshJwg7KCE7LK0IDEwMCUg7KSR7JeQ7IScIE4l66eMIO2UvOuTnOuwseydhCDsp4TtlontlZjqs6Ag7ZW064u5IOqzvOygleydhCDsl6zrn6zrsogg67CY67O17ZWY66mwIOyZhOyEseuPhOulvCDrhpLsl6wg64KY6rCU7Ja07JW8IO2WiOuKlOqwgD9cXG5cXG5cXG5cXG4jIyA6dHdvOiDqsJzrsJzsnpDsnZgg65Sc66CI66eIIDFcXG5cXG4hW+uUnOugiOuniF0oL2Fzc2V0cy9pbWcv6rCA67aI6riwLmpwZylcXG5cXG4+IOyii+ydgCDquLDtmo3slYjsnYQg66eM65Ok6riwIOychO2VtOyEnOuKlCDqsJzrsJzsnpDqsIAg7KSEIOyImCDsnojripQg7LWc64yA7ZWcIOunjuydgCDslpHsp4jsnZgg7ZS865Oc67Cx7J2EIOykgOuLpC4g7ZWY7KeA66eMIOydtCDqs7zsoJUg7KSR7JeQIO2MgOqwhCBjb25mbGljdCDrsJzsg50g6rCA64ql7ISx7J20IOuGkuuLpC5cXG4+IFZTXFxuPiDquLDtmo3slYjsnZgg7YCE66as7Yuw66W8IOyhsOq4iCDtj6zquLDtlZjrjZTrnbzrj4Qg7LWc64yA7ZWcIOu2gOuTnOufrOyatCDtg5zrj4TsmYAg7Ja07Yis66GcIO2VhOyImOyggeyduCDtlLzrk5zrsLHrp4zsnYQg7KSA64ukLiDtlZjsp4Drp4wg7J20IOqzvOyglSDsho3sl5DshJwg64aT7LmgIOyImCDsnojripQg7IOB7Zmp7J2AIOyKpOyKpOuhnCDsspjrpqztlbTslbwg7ZWc64ukLlxcblxcbu2YhOyerCDsoJzqsIAg7LKY7ZW07J6I64qUIOyDge2ZqeydhCDrsJTrnbzrtKTsnYQg65WMIOyggOuKlCDslrTripDsqr3snLzroZwg6rCA642U652864+EIOyepeuLqOygkOydtCDsnojripQg66qF7ZmV7ZWY6rKMIOyeiOyWtOyEnCDtlZwg7Kq97Jy866GcIOyJveqyjCDshKDtg53tlZjsp4Ag66q77ZWY64qUIOuUnOugiOuniCDsg4Htmansl5Ag67mg7KC47J6I64uk64qUIOqyg+ydhCDslYzqsowg65CY7JeI7Iq164uI64ukLiDsnbQg7IOB7Zmp7JeQ7ISc64qUIFxcXCLtlLzrk5zrsLHsnYQg7ZWY66m0IO2VoOyImOuhnSDqsIjrk7Hsg4HtmansnbQg67Cc7IOd7ZWc64ukXFxcIuuKlCDqsoPsnbQg7KCE7KCc66GcIOq5lOugpOyeiOyKteuLiOuLpC5cXG5cXG4qKlxcXCLqsJzrsJzsnpBcXFwiKiog7KaJLCDsl5Tsp4Dri4jslrTroZzshJwg6rCA7J6lIOuGkuydgCDtgITrpqzti7DsnZgg7ZSE66Gc642V7Yq466W8IOunjOuTnOuKlCDqsoPsnbQg7KeB7JeF7KCBIOyGjOuqheydtOudvCDrs7wg7IiYIOyeiOyKteuLiOuLpC4g7J2066W8IOychO2VtOyEnCDstZzrjIDtlZwg7JmE67K97ZWcIOq4sO2ajeyViOydhCDsnpHshLHtlaAg7IiYIOyeiOuPhOuhnSDqsIDriqXtlZwg66qo65OgIO2UvOuTnOuwseydhCDsoITri6ztlbTslbwg7ZWY7KeAIOyViuydhOq5jD8g7ZWY64qUIOyDneqwgeydtCDtlZjrgpgg7J6I6rOgLFxcblxcbuuLpOuluCDtlZjrgpjripQgJ+qwnOuwnOyekOydtOq4sCDsnbTsoITsl5Ag7ZWcIOuqheydmCDsobDsp4HqtazshLHsm5DsnLzroZzshJwg6rWs7ISx7JuQ6rCE7J2YIOqwiOuTsSDsg4HtmansnYQg7KSE7J206rOgIOy1nOuMgOydtOydteydhCDsnITtlbQg7Ja064qQIOygleuPhCDtg4DtmJHsnYQg7ZW07JW8IO2VmOuKlCDqsoPsnbzquYw/J+2VmOuKlCDqsoPsnbQg65GQIOuyiOynuCDsg53qsIHsnoXri4jri6QuXFxuXFxu7J207IOB7KCB7Jy866Gc64qUIDHrsojqs7wg6rCZ7J20IOqzteumrOyjvOydmOyggeycvOuhnCDqsIHsnpDsnZgg7KeB6rWw7JeQ7IScIOy1nOyEoOydmCDshKDsnYQg7LaU6rWs7ZWY66m0ICDsoITssrQg7KGw7KeB7J2YIOydtOydteydtCDstZzrjIDqsIAg65CgIOyImCDsnojsp4Ag7JWK7J2E6rmMIOyDneqwge2VqeuLiOuLpC4g7ZWY7KeA66eMIOygnOqwgCDsho3tlZwg7ZiE7Iuk7J2AIOuMgOu2gOu2hCAy67KI7LKY65+8IO2DgO2YkeydhCDtlZjqsowg65CY642U6rWw7JqULlxcblxcbuq3uOugh+yngOunjCAy67KI7LKY65+8IO2VnOuLpOqzoCDtlbTrj4Qg66y47KCc6rCAIO2VtOqysOuQmOyngOuPhCDslYrsirXri4jri6QuIOqwnOuwnOyekOyXkOqyjOuKlCDri6TsnYzqs7wg6rCZ7J2AIOyCrO2VreydtCDso7zslrTsp4Dqsowg65CY64qU6rGw7KOgLlxcblxcblxcblxcbiMjIDp0aHJlZTog6rCc67Cc7J6Q7J2YIOuUnOugiOuniCAyXFxuXFxuPiDsmKTsvIDsnbQuIOq4sO2ajeydmCDruYjti4gg7KCV64+E64qUIOyWtOuKkCDsoJXrj4Qg7J247KCV7ZWY6rOgIOuEmOyWtOqwhOuLpC4g7ZWY7KeA66eMIOqwnOuwnOyekOydmCDsl63rn4nsnLzroZwg6re4IOuCmOuouOyngCDruYjti4jsnYQg7LGE7JuM64Sj7Ja07IScIOy1nOuMgO2VnCDsmKTrpZjrpbwg7JeG7JWg64+E66GdIO2VmOyekFxcbj4gVlNcXG4+IOq4sO2ajeydmCDruYjti4gg7J247KCV7ZWc64ukLiDtlZjsp4Drp4wg6riw7ZWc7J20IOuNlCDspJHsmpTtlZjrr4DroZwg67mI7YuI7J2EIOyxhOybjOuEo+uLpOqwgCDquLDtlZzsnYQg64aT7Lmg67CU7JeQ64qUIOq4sO2VnOyXkCDrp57strAg7JqU6rWs7IKs7ZWt66eM7J2EIOyngOy8nCDqsJzrsJztlZzri6QuXFxuXFxu7ZuM66Wt7ZWcIOqwnOuwnOyekOudvOuptCDquLDtlZwg7JWI7JeQIOuqqOuToCDsmpTqtazsgqztla3snYQg66eM7KGx7ZWY6rOg7IScIOu2gOyhse2VnCDrtoDrtoTquYzsp4Ag7LGE7Jqw6rKg7KeA66eMLCDqt7jrn7Qg7IiYIOyXhuuKlCDsg4Htmansl5Ag7LKY7ZW0IOychCAy6rCcIOykkeyXkCDtlZjrgpjrp4zsnYQg6rOo65287JW8IO2VmOuKlCDsg4HtmansnbQg64yA67aA67aE7J6F64uI64ukLlxcblxcbuusvOuhoCAx67KI7LKY65+8IO2VmOuKlCDqsoPsnbQg6rCc67Cc7J6Q7J2YIOyxheyehOydtOudvCDrs7wg7IiYIOyeiOyKteuLiOuLpC4g7KCAIOyXreyLnCDqt7jroIfqsowg7ZWY6rOgIOyLtuyKteuLiOuLpC4g7ZWY7KeA66eMIOuMgOu2gOu2hCDsi5zqsITsnbQg67aA7KGx7ZWp64uI64ukLiAx67KI7J2EIOyEoO2Dne2WiOydhCDrlYzsnZgg64uo7KCQ7J2ALCDruYjti4jsnYQg7LGE7JuM64Sj642U652864+EIOyVhOustOuPhCDrqrDrnbzspIDri6TripQg6rKD7J207KOgLiDslYzslYTso7zripQg6rKD6rmM7KeAIOuwlOudvOyngOuKlCDslYrsp4Drp4wgXFxcIuyGjeuPhOqwgCDripDrprAg6rCc67Cc7J6QXFxcIiwgXFxcIuydvOuqu+2VmOuKlCDqsJzrsJzsnpBcXFwi7IaM66as66W8IOuTpOydhCDsiJgg7J6I64uk64qUIOqyg+ydtOyjoC5cXG5cXG7rmJAg64uk66W4IOusuOygnOuhnOuKlCDsnbTroIfqsowg65CY66m0IOydtOqyjCDquLDspIDsnbQg65CY7Ja07IScIOyVnuycvOuhnOuPhCDqs4Tsho0g6riw7ZqN7JWI7J2AIOydtOygleuPhCDsiJjspIDsl5Ag66i466y86rKMIOuQoCDsiJjrj4Qg7J6I7Iq164uI64ukLlxcblxcblxcblxcbjLrsojsspjrn7wg7ZWY66m0IOyngOq4iCDri7nsnqXsnYAg66y47KCc6rCAIOyDneq4sOyngCDslYrqs6Ag7KGw7KeBIOuCtCDqsIjrk7Eg7IOB7Zmp64+EIOykhOyXrOykhCDsiJgg7J6I6rOgIOyemO2VmOuptCDsnbjsoJXquYzsp4Ag67Cb7J2EIOyImCDsnojsirXri4jri6QuIO2VmOyngOunjCDslrjsoJwg7Ja065SU7IScIOq3uCDrhJjslrTqsJTrjZgg7J207IqI6rCAIOuwnOyDne2VoCDsiJjrj4Qg7J6I64uk64qUIOu2iOyViOqwkCwg6re466as6rOgIOyLpOygnOuhnCDsmIjsg4HtlojrjZgg6re4IOuyhOq3uOqwgCDrsJzsg53tlZjsl6wg7ISc67mE7IqkIOyepeyVoOulvCDsnbzsnLztgqTripQg7IOB7Zmp7J20IOydvOyWtOuCoCDsiJgg7J6I64uk64qUIOuLqOygkOydtCDsnojsirXri4jri6QuXFxuXFxuXFxuXFxu7LWc6re8IOydtOufsCDsg4HtmansnYQg7Iuk7KCE7JeQ7IScIOunnuuLpeucqOumrOuptOyEnCDsl6zrn6wg7ZqM7IKs7JeQ7IScIOunkO2VmOuKlCBg6rCc67Cc7J6Q7J2YIOy7pOuupOuLiOy8gOydtOyFmCDriqXroKVg7J20IOyWvOuniOuCmCDspJHsmpTtlZzsp4Drpbwg7IOI7IK8IOyytOqwkO2VmOqzoCDsnojsirXri4jri6QuXFxuXFxuJ+y7pOuupOuLiOy8gOydtOyFmCDqt7jquYzsnbTqurwg64yA7LapJ+2VmOuptCDrkJjripTqsowg7JWE64uI64Sk7JqULiDsoJXri7XsnbQg7JeG64qUIOydtOufsCDrrLjsoJzrpbwg7ZW06rKw7ZWY64qUIOqyg+ydtCDqsIDsnqUg7Ja066Ck7Jq0IOqygyDqsJnsirXri4jri6QuXFxuXFxu7JWI7YOA6rmd6rKM64+EIOyngOq4iOydgCDslrTrlrvqsowg7ZW07JW8IOyYs+ydgCDqsoPsnbjsp4Ag7J6YIOuqqOultOqyoOyKteuLiOuLpC4g7LC+7JWE64KY6rCA64qUIOykkeydtOudvCDsg53qsIHtlZjqs6Ag7J2066asIOy5mOydtOqzoCDsoIDrpqwg7LmY7J2066m07IScIOyijOy2qeyasOuPjO2VmOqzoCDsnojsirXri4jri6QuIFxcblxcbuydtOufsCDsg4Htmakg7IaN7JeQ7ISc64+EIOq3uOuVjCDqt7jrlYzsnZgg7LWc7ISg7J2YIOyEoO2DneydhCDqs6DrpbTquLAg7JyE7ZW0IOqzoOuvvO2VtCDrgpjqsIDripQg6rK97ZeY7J2EIOunjuydtCDqsJbsnLzrqbTshJwg6rOg66+87ZWY64qUIOyLnOqwhOydhCDrp47snbQg6rCA7KC46rCA64uk67O066m0IOq3uOuemOuPhCDqvaQg7KKL7J2AIOqwnOuwnOyekOqwgCDrkKAg7IiYIOyeiOyngCDslYrsnYTquYwg6riw64yA66W8IO2VtOuztOupsCDquIDsnYQg66eI7Lmp64uI64ukLlxcblwiOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufSIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheUxpbWl0IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gIGlmICghcmF3KSB7XG4gICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHtcbiAgICByYXc6IHtcbiAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICB9XG4gIH0pKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRob3V0SG9sZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWRcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICdAZW1vdGlvbi9tZW1vaXplJztcblxudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuZXhwb3J0IGRlZmF1bHQgaXNQcm9wVmFsaWQ7XG4iLCJmdW5jdGlvbiBtZW1vaXplKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJmdW5jdGlvbiBzdHlsaXNfbWluIChXKSB7XG4gIGZ1bmN0aW9uIE0oZCwgYywgZSwgaCwgYSkge1xuICAgIGZvciAodmFyIG0gPSAwLCBiID0gMCwgdiA9IDAsIG4gPSAwLCBxLCBnLCB4ID0gMCwgSyA9IDAsIGssIHUgPSBrID0gcSA9IDAsIGwgPSAwLCByID0gMCwgSSA9IDAsIHQgPSAwLCBCID0gZS5sZW5ndGgsIEogPSBCIC0gMSwgeSwgZiA9ICcnLCBwID0gJycsIEYgPSAnJywgRyA9ICcnLCBDOyBsIDwgQjspIHtcbiAgICAgIGcgPSBlLmNoYXJDb2RlQXQobCk7XG4gICAgICBsID09PSBKICYmIDAgIT09IGIgKyBuICsgdiArIG0gJiYgKDAgIT09IGIgJiYgKGcgPSA0NyA9PT0gYiA/IDEwIDogNDcpLCBuID0gdiA9IG0gPSAwLCBCKyssIEorKyk7XG5cbiAgICAgIGlmICgwID09PSBiICsgbiArIHYgKyBtKSB7XG4gICAgICAgIGlmIChsID09PSBKICYmICgwIDwgciAmJiAoZiA9IGYucmVwbGFjZShOLCAnJykpLCAwIDwgZi50cmltKCkubGVuZ3RoKSkge1xuICAgICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGYgKz0gZS5jaGFyQXQobCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZyA9IDU5O1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChnKSB7XG4gICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICBmID0gZi50cmltKCk7XG4gICAgICAgICAgICBxID0gZi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgayA9IDE7XG5cbiAgICAgICAgICAgIGZvciAodCA9ICsrbDsgbCA8IEI7KSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZyA9IGUuY2hhckNvZGVBdChsKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZyA9IGUuY2hhckNvZGVBdChsICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHUgPSBsICsgMTsgdSA8IEo7ICsrdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGUuY2hhckNvZGVBdCh1KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoNDIgPT09IGcgJiYgNDIgPT09IGUuY2hhckNvZGVBdCh1IC0gMSkgJiYgbCArIDIgIT09IHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoNDcgPT09IGcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHUgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgIGcrKztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICBnKys7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgbCsrIDwgSiAmJiBlLmNoYXJDb2RlQXQobCkgIT09IGc7KSB7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgwID09PSBrKSBicmVhaztcbiAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrID0gZS5zdWJzdHJpbmcodCwgbCk7XG4gICAgICAgICAgICAwID09PSBxICYmIChxID0gKGYgPSBmLnJlcGxhY2UoY2EsICcnKS50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHEpIHtcbiAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICAwIDwgciAmJiAoZiA9IGYucmVwbGFjZShOLCAnJykpO1xuICAgICAgICAgICAgICAgIGcgPSBmLmNoYXJDb2RlQXQoMSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgIHIgPSBjO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgciA9IE87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgayA9IE0oYywgciwgaywgZywgYSArIDEpO1xuICAgICAgICAgICAgICAgIHQgPSBrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAwIDwgQSAmJiAociA9IFgoTywgZiwgSSksIEMgPSBIKDMsIGssIHIsIGMsIEQsIHosIHQsIGcsIGEsIGgpLCBmID0gci5qb2luKCcnKSwgdm9pZCAwICE9PSBDICYmIDAgPT09ICh0ID0gKGsgPSBDLnRyaW0oKSkubGVuZ3RoKSAmJiAoZyA9IDAsIGsgPSAnJykpO1xuICAgICAgICAgICAgICAgIGlmICgwIDwgdCkgc3dpdGNoIChnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYucmVwbGFjZShkYSwgZWEpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICAgICAgayA9IGYgKyAneycgKyBrICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLnJlcGxhY2UoZmEsICckMSAkMicpO1xuICAgICAgICAgICAgICAgICAgICBrID0gZiArICd7JyArIGsgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAxID09PSB3IHx8IDIgPT09IHcgJiYgTCgnQCcgKyBrLCAzKSA/ICdALXdlYmtpdC0nICsgayArICdAJyArIGsgOiAnQCcgKyBrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgayA9IGYgKyBrLCAxMTIgPT09IGggJiYgKGsgPSAocCArPSBrLCAnJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBrID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBrID0gTShjLCBYKGMsIGYsIEkpLCBrLCBoLCBhICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEYgKz0gaztcbiAgICAgICAgICAgIGsgPSBJID0gciA9IHUgPSBxID0gMDtcbiAgICAgICAgICAgIGYgPSAnJztcbiAgICAgICAgICAgIGcgPSBlLmNoYXJDb2RlQXQoKytsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGYgPSAoMCA8IHIgPyBmLnJlcGxhY2UoTiwgJycpIDogZikudHJpbSgpO1xuICAgICAgICAgICAgaWYgKDEgPCAodCA9IGYubGVuZ3RoKSkgc3dpdGNoICgwID09PSB1ICYmIChxID0gZi5jaGFyQ29kZUF0KDApLCA0NSA9PT0gcSB8fCA5NiA8IHEgJiYgMTIzID4gcSkgJiYgKHQgPSAoZiA9IGYucmVwbGFjZSgnICcsICc6JykpLmxlbmd0aCksIDAgPCBBICYmIHZvaWQgMCAhPT0gKEMgPSBIKDEsIGYsIGMsIGQsIEQsIHosIHAubGVuZ3RoLCBoLCBhLCBoKSkgJiYgMCA9PT0gKHQgPSAoZiA9IEMudHJpbSgpKS5sZW5ndGgpICYmIChmID0gJ1xceDAwXFx4MDAnKSwgcSA9IGYuY2hhckNvZGVBdCgwKSwgZyA9IGYuY2hhckNvZGVBdCgxKSwgcSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgICAgICBpZiAoMTA1ID09PSBnIHx8IDk5ID09PSBnKSB7XG4gICAgICAgICAgICAgICAgICBHICs9IGYgKyBlLmNoYXJBdChsKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIDU4ICE9PSBmLmNoYXJDb2RlQXQodCAtIDEpICYmIChwICs9IFAoZiwgcSwgZywgZi5jaGFyQ29kZUF0KDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJID0gciA9IHUgPSBxID0gMDtcbiAgICAgICAgICAgIGYgPSAnJztcbiAgICAgICAgICAgIGcgPSBlLmNoYXJDb2RlQXQoKytsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICA0NyA9PT0gYiA/IGIgPSAwIDogMCA9PT0gMSArIHEgJiYgMTA3ICE9PSBoICYmIDAgPCBmLmxlbmd0aCAmJiAociA9IDEsIGYgKz0gJ1xceDAwJyk7XG4gICAgICAgICAgMCA8IEEgKiBZICYmIEgoMCwgZiwgYywgZCwgRCwgeiwgcC5sZW5ndGgsIGgsIGEsIGgpO1xuICAgICAgICAgIHogPSAxO1xuICAgICAgICAgIEQrKztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU5OlxuICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICBpZiAoMCA9PT0gYiArIG4gKyB2ICsgbSkge1xuICAgICAgICAgICAgeisrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeisrO1xuICAgICAgICAgIHkgPSBlLmNoYXJBdChsKTtcblxuICAgICAgICAgIHN3aXRjaCAoZykge1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IG4gKyBtICsgYikgc3dpdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgICAgeSA9ICcnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgMzIgIT09IGcgJiYgKHkgPSAnICcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHkgPSAnXFxcXDAnO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgeSA9ICdcXFxcZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICB5ID0gJ1xcXFx2JztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgbSAmJiAociA9IEkgPSAxLCB5ID0gJ1xcZicgKyB5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTA4OlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gbiArIGIgKyBtICsgRSAmJiAwIDwgdSkgc3dpdGNoIChsIC0gdSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIDExMiA9PT0geCAmJiA1OCA9PT0gZS5jaGFyQ29kZUF0KGwgLSAzKSAmJiAoRSA9IHgpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgMTExID09PSBLICYmIChFID0gSyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgbSAmJiAodSA9IGwpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgMCA9PT0gYiArIHYgKyBuICsgbSAmJiAociA9IDEsIHkgKz0gJ1xccicpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIDAgPT09IGIgJiYgKG4gPSBuID09PSBnID8gMCA6IDAgPT09IG4gPyBnIDogbik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAwID09PSBuICsgYiArIHYgJiYgbSsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgICAgICAgMCA9PT0gbiArIGIgKyB2ICYmIG0tLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgIDAgPT09IG4gKyBiICsgbSAmJiB2LS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gbiArIGIgKyBtKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHEpIHN3aXRjaCAoMiAqIHggKyAzICogSykge1xuICAgICAgICAgICAgICAgICAgY2FzZSA1MzM6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBxID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdisrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICAgIDAgPT09IGIgKyB2ICsgbiArIG0gKyB1ICsgayAmJiAoayA9IDEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIGlmICghKDAgPCBuICsgbSArIHYpKSBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKDIgKiBnICsgMyAqIGUuY2hhckNvZGVBdChsICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzU6XG4gICAgICAgICAgICAgICAgICAgICAgYiA9IDQ3O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjIwOlxuICAgICAgICAgICAgICAgICAgICAgIHQgPSBsLCBiID0gNDI7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICAgIDQ3ID09PSBnICYmIDQyID09PSB4ICYmIHQgKyAyICE9PSBsICYmICgzMyA9PT0gZS5jaGFyQ29kZUF0KHQgKyAyKSAmJiAocCArPSBlLnN1YnN0cmluZyh0LCBsICsgMSkpLCB5ID0gJycsIGIgPSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIDAgPT09IGIgJiYgKGYgKz0geSk7XG4gICAgICB9XG5cbiAgICAgIEsgPSB4O1xuICAgICAgeCA9IGc7XG4gICAgICBsKys7XG4gICAgfVxuXG4gICAgdCA9IHAubGVuZ3RoO1xuXG4gICAgaWYgKDAgPCB0KSB7XG4gICAgICByID0gYztcbiAgICAgIGlmICgwIDwgQSAmJiAoQyA9IEgoMiwgcCwgciwgZCwgRCwgeiwgdCwgaCwgYSwgaCksIHZvaWQgMCAhPT0gQyAmJiAwID09PSAocCA9IEMpLmxlbmd0aCkpIHJldHVybiBHICsgcCArIEY7XG4gICAgICBwID0gci5qb2luKCcsJykgKyAneycgKyBwICsgJ30nO1xuXG4gICAgICBpZiAoMCAhPT0gdyAqIEUpIHtcbiAgICAgICAgMiAhPT0gdyB8fCBMKHAsIDIpIHx8IChFID0gMCk7XG5cbiAgICAgICAgc3dpdGNoIChFKSB7XG4gICAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgICBwID0gcC5yZXBsYWNlKGhhLCAnOi1tb3otJDEnKSArIHA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgcCA9IHAucmVwbGFjZShRLCAnOjotd2Via2l0LWlucHV0LSQxJykgKyBwLnJlcGxhY2UoUSwgJzo6LW1vei0kMScpICsgcC5yZXBsYWNlKFEsICc6LW1zLWlucHV0LSQxJykgKyBwO1xuICAgICAgICB9XG5cbiAgICAgICAgRSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEcgKyBwICsgRjtcbiAgfVxuXG4gIGZ1bmN0aW9uIFgoZCwgYywgZSkge1xuICAgIHZhciBoID0gYy50cmltKCkuc3BsaXQoaWEpO1xuICAgIGMgPSBoO1xuICAgIHZhciBhID0gaC5sZW5ndGgsXG4gICAgICAgIG0gPSBkLmxlbmd0aDtcblxuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxOlxuICAgICAgICB2YXIgYiA9IDA7XG5cbiAgICAgICAgZm9yIChkID0gMCA9PT0gbSA/ICcnIDogZFswXSArICcgJzsgYiA8IGE7ICsrYikge1xuICAgICAgICAgIGNbYl0gPSBaKGQsIGNbYl0sIGUpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdiA9IGIgPSAwO1xuXG4gICAgICAgIGZvciAoYyA9IFtdOyBiIDwgYTsgKytiKSB7XG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBtOyArK24pIHtcbiAgICAgICAgICAgIGNbdisrXSA9IFooZFtuXSArICcgJywgaFtiXSwgZSkudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBaKGQsIGMsIGUpIHtcbiAgICB2YXIgaCA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAzMyA+IGggJiYgKGggPSAoYyA9IGMudHJpbSgpKS5jaGFyQ29kZUF0KDApKTtcblxuICAgIHN3aXRjaCAoaCkge1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgcmV0dXJuIGMucmVwbGFjZShGLCAnJDEnICsgZC50cmltKCkpO1xuXG4gICAgICBjYXNlIDU4OlxuICAgICAgICByZXR1cm4gZC50cmltKCkgKyBjLnJlcGxhY2UoRiwgJyQxJyArIGQudHJpbSgpKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKDAgPCAxICogZSAmJiAwIDwgYy5pbmRleE9mKCdcXGYnKSkgcmV0dXJuIGMucmVwbGFjZShGLCAoNTggPT09IGQuY2hhckNvZGVBdCgwKSA/ICcnIDogJyQxJykgKyBkLnRyaW0oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQgKyBjO1xuICB9XG5cbiAgZnVuY3Rpb24gUChkLCBjLCBlLCBoKSB7XG4gICAgdmFyIGEgPSBkICsgJzsnLFxuICAgICAgICBtID0gMiAqIGMgKyAzICogZSArIDQgKiBoO1xuXG4gICAgaWYgKDk0NCA9PT0gbSkge1xuICAgICAgZCA9IGEuaW5kZXhPZignOicsIDkpICsgMTtcbiAgICAgIHZhciBiID0gYS5zdWJzdHJpbmcoZCwgYS5sZW5ndGggLSAxKS50cmltKCk7XG4gICAgICBiID0gYS5zdWJzdHJpbmcoMCwgZCkudHJpbSgpICsgYiArICc7JztcbiAgICAgIHJldHVybiAxID09PSB3IHx8IDIgPT09IHcgJiYgTChiLCAxKSA/ICctd2Via2l0LScgKyBiICsgYiA6IGI7XG4gICAgfVxuXG4gICAgaWYgKDAgPT09IHcgfHwgMiA9PT0gdyAmJiAhTChhLCAxKSkgcmV0dXJuIGE7XG5cbiAgICBzd2l0Y2ggKG0pIHtcbiAgICAgIGNhc2UgMTAxNTpcbiAgICAgICAgcmV0dXJuIDk3ID09PSBhLmNoYXJDb2RlQXQoMTApID8gJy13ZWJraXQtJyArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSA5NTE6XG4gICAgICAgIHJldHVybiAxMTYgPT09IGEuY2hhckNvZGVBdCgzKSA/ICctd2Via2l0LScgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTYzOlxuICAgICAgICByZXR1cm4gMTEwID09PSBhLmNoYXJDb2RlQXQoNSkgPyAnLXdlYmtpdC0nICsgYSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDEwMDk6XG4gICAgICAgIGlmICgxMDAgIT09IGEuY2hhckNvZGVBdCg0KSkgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTY5OlxuICAgICAgY2FzZSA5NDI6XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgOTc4OlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1vei0nICsgYSArIGE7XG5cbiAgICAgIGNhc2UgMTAxOTpcbiAgICAgIGNhc2UgOTgzOlxuICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1vei0nICsgYSArICctbXMtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDg4MzpcbiAgICAgICAgaWYgKDQ1ID09PSBhLmNoYXJDb2RlQXQoOCkpIHJldHVybiAnLXdlYmtpdC0nICsgYSArIGE7XG4gICAgICAgIGlmICgwIDwgYS5pbmRleE9mKCdpbWFnZS1zZXQoJywgMTEpKSByZXR1cm4gYS5yZXBsYWNlKGphLCAnJDEtd2Via2l0LSQyJykgKyBhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5MzI6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDQpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg1KSkge1xuICAgICAgICAgIGNhc2UgMTAzOlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LWJveC0nICsgYS5yZXBsYWNlKCctZ3JvdycsICcnKSArICctd2Via2l0LScgKyBhICsgJy1tcy0nICsgYS5yZXBsYWNlKCdncm93JywgJ3Bvc2l0aXZlJykgKyBhO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhLnJlcGxhY2UoJ3NocmluaycsICduZWdhdGl2ZScpICsgYTtcblxuICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgICByZXR1cm4gJy13ZWJraXQtJyArIGEgKyAnLW1zLScgKyBhLnJlcGxhY2UoJ2Jhc2lzJywgJ3ByZWZlcnJlZC1zaXplJykgKyBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGEgKyBhO1xuXG4gICAgICBjYXNlIDk2NDpcbiAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LScgKyBhICsgYTtcblxuICAgICAgY2FzZSAxMDIzOlxuICAgICAgICBpZiAoOTkgIT09IGEuY2hhckNvZGVBdCg4KSkgYnJlYWs7XG4gICAgICAgIGIgPSBhLnN1YnN0cmluZyhhLmluZGV4T2YoJzonLCAxNSkpLnJlcGxhY2UoJ2ZsZXgtJywgJycpLnJlcGxhY2UoJ3NwYWNlLWJldHdlZW4nLCAnanVzdGlmeScpO1xuICAgICAgICByZXR1cm4gJy13ZWJraXQtYm94LXBhY2snICsgYiArICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LXBhY2snICsgYiArIGE7XG5cbiAgICAgIGNhc2UgMTAwNTpcbiAgICAgICAgcmV0dXJuIGthLnRlc3QoYSkgPyBhLnJlcGxhY2UoYWEsICc6LXdlYmtpdC0nKSArIGEucmVwbGFjZShhYSwgJzotbW96LScpICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgMWUzOlxuICAgICAgICBiID0gYS5zdWJzdHJpbmcoMTMpLnRyaW0oKTtcbiAgICAgICAgYyA9IGIuaW5kZXhPZignLScpICsgMTtcblxuICAgICAgICBzd2l0Y2ggKGIuY2hhckNvZGVBdCgwKSArIGIuY2hhckNvZGVBdChjKSkge1xuICAgICAgICAgIGNhc2UgMjI2OlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShHLCAndGInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMzI6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKEcsICd0Yi1ybCcpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoRywgJ2xyJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtJyArIGIgKyBhO1xuXG4gICAgICBjYXNlIDEwMTc6XG4gICAgICAgIGlmICgtMSA9PT0gYS5pbmRleE9mKCdzdGlja3knLCA5KSkgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTc1OlxuICAgICAgICBjID0gKGEgPSBkKS5sZW5ndGggLSAxMDtcbiAgICAgICAgYiA9ICgzMyA9PT0gYS5jaGFyQ29kZUF0KGMpID8gYS5zdWJzdHJpbmcoMCwgYykgOiBhKS5zdWJzdHJpbmcoZC5pbmRleE9mKCc6JywgNykgKyAxKS50cmltKCk7XG5cbiAgICAgICAgc3dpdGNoIChtID0gYi5jaGFyQ29kZUF0KDApICsgKGIuY2hhckNvZGVBdCg3KSB8IDApKSB7XG4gICAgICAgICAgY2FzZSAyMDM6XG4gICAgICAgICAgICBpZiAoMTExID4gYi5jaGFyQ29kZUF0KDgpKSBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgYSA9IGEucmVwbGFjZShiLCAnLXdlYmtpdC0nICsgYikgKyAnOycgKyBhO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwNzpcbiAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgJy13ZWJraXQtJyArICgxMDIgPCBtID8gJ2lubGluZS0nIDogJycpICsgJ2JveCcpICsgJzsnICsgYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyBiKSArICc7JyArIGEucmVwbGFjZShiLCAnLW1zLScgKyBiICsgJ2JveCcpICsgJzsnICsgYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhICsgJzsnO1xuXG4gICAgICBjYXNlIDkzODpcbiAgICAgICAgaWYgKDQ1ID09PSBhLmNoYXJDb2RlQXQoNSkpIHN3aXRjaCAoYS5jaGFyQ29kZUF0KDYpKSB7XG4gICAgICAgICAgY2FzZSAxMDU6XG4gICAgICAgICAgICByZXR1cm4gYiA9IGEucmVwbGFjZSgnLWl0ZW1zJywgJycpLCAnLXdlYmtpdC0nICsgYSArICctd2Via2l0LWJveC0nICsgYiArICctbXMtZmxleC0nICsgYiArIGE7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIHJldHVybiAnLXdlYmtpdC0nICsgYSArICctbXMtZmxleC1pdGVtLScgKyBhLnJlcGxhY2UoYmEsICcnKSArIGE7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICctd2Via2l0LScgKyBhICsgJy1tcy1mbGV4LWxpbmUtcGFjaycgKyBhLnJlcGxhY2UoJ2FsaWduLWNvbnRlbnQnLCAnJykucmVwbGFjZShiYSwgJycpICsgYTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5NzM6XG4gICAgICBjYXNlIDk4OTpcbiAgICAgICAgaWYgKDQ1ICE9PSBhLmNoYXJDb2RlQXQoMykgfHwgMTIyID09PSBhLmNoYXJDb2RlQXQoNCkpIGJyZWFrO1xuXG4gICAgICBjYXNlIDkzMTpcbiAgICAgIGNhc2UgOTUzOlxuICAgICAgICBpZiAoITAgPT09IGxhLnRlc3QoZCkpIHJldHVybiAxMTUgPT09IChiID0gZC5zdWJzdHJpbmcoZC5pbmRleE9mKCc6JykgKyAxKSkuY2hhckNvZGVBdCgwKSA/IFAoZC5yZXBsYWNlKCdzdHJldGNoJywgJ2ZpbGwtYXZhaWxhYmxlJyksIGMsIGUsIGgpLnJlcGxhY2UoJzpmaWxsLWF2YWlsYWJsZScsICc6c3RyZXRjaCcpIDogYS5yZXBsYWNlKGIsICctd2Via2l0LScgKyBiKSArIGEucmVwbGFjZShiLCAnLW1vei0nICsgYi5yZXBsYWNlKCdmaWxsLScsICcnKSkgKyBhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5NjI6XG4gICAgICAgIGlmIChhID0gJy13ZWJraXQtJyArIGEgKyAoMTAyID09PSBhLmNoYXJDb2RlQXQoNSkgPyAnLW1zLScgKyBhIDogJycpICsgYSwgMjExID09PSBlICsgaCAmJiAxMDUgPT09IGEuY2hhckNvZGVBdCgxMykgJiYgMCA8IGEuaW5kZXhPZigndHJhbnNmb3JtJywgMTApKSByZXR1cm4gYS5zdWJzdHJpbmcoMCwgYS5pbmRleE9mKCc7JywgMjcpICsgMSkucmVwbGFjZShtYSwgJyQxLXdlYmtpdC0kMicpICsgYTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEwoZCwgYykge1xuICAgIHZhciBlID0gZC5pbmRleE9mKDEgPT09IGMgPyAnOicgOiAneycpLFxuICAgICAgICBoID0gZC5zdWJzdHJpbmcoMCwgMyAhPT0gYyA/IGUgOiAxMCk7XG4gICAgZSA9IGQuc3Vic3RyaW5nKGUgKyAxLCBkLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBSKDIgIT09IGMgPyBoIDogaC5yZXBsYWNlKG5hLCAnJDEnKSwgZSwgYyk7XG4gIH1cblxuICBmdW5jdGlvbiBlYShkLCBjKSB7XG4gICAgdmFyIGUgPSBQKGMsIGMuY2hhckNvZGVBdCgwKSwgYy5jaGFyQ29kZUF0KDEpLCBjLmNoYXJDb2RlQXQoMikpO1xuICAgIHJldHVybiBlICE9PSBjICsgJzsnID8gZS5yZXBsYWNlKG9hLCAnIG9yICgkMSknKS5zdWJzdHJpbmcoNCkgOiAnKCcgKyBjICsgJyknO1xuICB9XG5cbiAgZnVuY3Rpb24gSChkLCBjLCBlLCBoLCBhLCBtLCBiLCB2LCBuLCBxKSB7XG4gICAgZm9yICh2YXIgZyA9IDAsIHggPSBjLCB3OyBnIDwgQTsgKytnKSB7XG4gICAgICBzd2l0Y2ggKHcgPSBTW2ddLmNhbGwoQiwgZCwgeCwgZSwgaCwgYSwgbSwgYiwgdiwgbiwgcSkpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgITE6XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHggPSB3O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4ICE9PSBjKSByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFQoZCkge1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICBjYXNlIG51bGw6XG4gICAgICAgIEEgPSBTLmxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGQpIFNbQSsrXSA9IGQ7ZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBkKSBmb3IgKHZhciBjID0gMCwgZSA9IGQubGVuZ3RoOyBjIDwgZTsgKytjKSB7XG4gICAgICAgICAgVChkW2NdKTtcbiAgICAgICAgfSBlbHNlIFkgPSAhIWQgfCAwO1xuICAgIH1cblxuICAgIHJldHVybiBUO1xuICB9XG5cbiAgZnVuY3Rpb24gVShkKSB7XG4gICAgZCA9IGQucHJlZml4O1xuICAgIHZvaWQgMCAhPT0gZCAmJiAoUiA9IG51bGwsIGQgPyAnZnVuY3Rpb24nICE9PSB0eXBlb2YgZCA/IHcgPSAxIDogKHcgPSAyLCBSID0gZCkgOiB3ID0gMCk7XG4gICAgcmV0dXJuIFU7XG4gIH1cblxuICBmdW5jdGlvbiBCKGQsIGMpIHtcbiAgICB2YXIgZSA9IGQ7XG4gICAgMzMgPiBlLmNoYXJDb2RlQXQoMCkgJiYgKGUgPSBlLnRyaW0oKSk7XG4gICAgViA9IGU7XG4gICAgZSA9IFtWXTtcblxuICAgIGlmICgwIDwgQSkge1xuICAgICAgdmFyIGggPSBIKC0xLCBjLCBlLCBlLCBELCB6LCAwLCAwLCAwLCAwKTtcbiAgICAgIHZvaWQgMCAhPT0gaCAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIGggJiYgKGMgPSBoKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IE0oTywgZSwgYywgMCwgMCk7XG4gICAgMCA8IEEgJiYgKGggPSBIKC0yLCBhLCBlLCBlLCBELCB6LCBhLmxlbmd0aCwgMCwgMCwgMCksIHZvaWQgMCAhPT0gaCAmJiAoYSA9IGgpKTtcbiAgICBWID0gJyc7XG4gICAgRSA9IDA7XG4gICAgeiA9IEQgPSAxO1xuICAgIHJldHVybiBhO1xuICB9XG5cbiAgdmFyIGNhID0gL15cXDArL2csXG4gICAgICBOID0gL1tcXDBcXHJcXGZdL2csXG4gICAgICBhYSA9IC86ICovZyxcbiAgICAgIGthID0gL3pvb3xncmEvLFxuICAgICAgbWEgPSAvKFssOiBdKSh0cmFuc2Zvcm0pL2csXG4gICAgICBpYSA9IC8sXFxyKz8vZyxcbiAgICAgIEYgPSAvKFtcXHRcXHJcXG4gXSkqXFxmPyYvZyxcbiAgICAgIGZhID0gL0Aoa1xcdyspXFxzKihcXFMqKVxccyovLFxuICAgICAgUSA9IC86OihwbGFjZSkvZyxcbiAgICAgIGhhID0gLzoocmVhZC1vbmx5KS9nLFxuICAgICAgRyA9IC9bc3ZoXVxcdystW3RibHJdezJ9LyxcbiAgICAgIGRhID0gL1xcKFxccyooLiopXFxzKlxcKS9nLFxuICAgICAgb2EgPSAvKFtcXHNcXFNdKj8pOy9nLFxuICAgICAgYmEgPSAvLXNlbGZ8ZmxleC0vZyxcbiAgICAgIG5hID0gL1teXSo/KDpbcnBdW2VsXWFbXFx3LV0rKVteXSovLFxuICAgICAgbGEgPSAvc3RyZXRjaHw6XFxzKlxcdytcXC0oPzpjb250ZXxhdmFpbCkvLFxuICAgICAgamEgPSAvKFteLV0pKGltYWdlLXNldFxcKCkvLFxuICAgICAgeiA9IDEsXG4gICAgICBEID0gMSxcbiAgICAgIEUgPSAwLFxuICAgICAgdyA9IDEsXG4gICAgICBPID0gW10sXG4gICAgICBTID0gW10sXG4gICAgICBBID0gMCxcbiAgICAgIFIgPSBudWxsLFxuICAgICAgWSA9IDAsXG4gICAgICBWID0gJyc7XG4gIEIudXNlID0gVDtcbiAgQi5zZXQgPSBVO1xuICB2b2lkIDAgIT09IFcgJiYgVShXKTtcbiAgcmV0dXJuIEI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxpc19taW47XG4iLCJ2YXIgdW5pdGxlc3NLZXlzID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgdGFiU2l6ZTogMSxcbiAgd2lkb3dzOiAxLFxuICB6SW5kZXg6IDEsXG4gIHpvb206IDEsXG4gIFdlYmtpdExpbmVDbGFtcDogMSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogMSxcbiAgZmxvb2RPcGFjaXR5OiAxLFxuICBzdG9wT3BhY2l0eTogMSxcbiAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuICBzdHJva2VEYXNob2Zmc2V0OiAxLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VPcGFjaXR5OiAxLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdW5pdGxlc3NLZXlzO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKVxuICAgID8gU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKVxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgdmFyIHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgdmFyIGkxNiA9IGkgKiAxNlxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJlc3ByaW1hXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImVzcHJpbWFcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0Lypcblx0ICBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLCBodHRwczovL2pzLmZvdW5kYXRpb24vXG5cblx0ICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcblx0ICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuXHQgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuXHQgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cdCAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG5cdCAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcblx0ICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuXHQgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG5cdCAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuXHQgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG5cdCAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuXHQgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG5cdCAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuXHQgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuXHQgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG5cdCAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG5cdCAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblx0Ki9cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgY29tbWVudF9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIganN4X3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0dmFyIHBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0dmFyIHRva2VuaXplcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XG5cdCAgICB2YXIgY29tbWVudEhhbmRsZXIgPSBudWxsO1xuXHQgICAgdmFyIHByb3h5RGVsZWdhdGUgPSBmdW5jdGlvbiAobm9kZSwgbWV0YWRhdGEpIHtcblx0ICAgICAgICBpZiAoZGVsZWdhdGUpIHtcblx0ICAgICAgICAgICAgZGVsZWdhdGUobm9kZSwgbWV0YWRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29tbWVudEhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgY29tbWVudEhhbmRsZXIudmlzaXQobm9kZSwgbWV0YWRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICB2YXIgcGFyc2VyRGVsZWdhdGUgPSAodHlwZW9mIGRlbGVnYXRlID09PSAnZnVuY3Rpb24nKSA/IHByb3h5RGVsZWdhdGUgOiBudWxsO1xuXHQgICAgdmFyIGNvbGxlY3RDb21tZW50ID0gZmFsc2U7XG5cdCAgICBpZiAob3B0aW9ucykge1xuXHQgICAgICAgIGNvbGxlY3RDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmNvbW1lbnQpO1xuXHQgICAgICAgIHZhciBhdHRhY2hDb21tZW50ID0gKHR5cGVvZiBvcHRpb25zLmF0dGFjaENvbW1lbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmF0dGFjaENvbW1lbnQpO1xuXHQgICAgICAgIGlmIChjb2xsZWN0Q29tbWVudCB8fCBhdHRhY2hDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyID0gbmV3IGNvbW1lbnRfaGFuZGxlcl8xLkNvbW1lbnRIYW5kbGVyKCk7XG5cdCAgICAgICAgICAgIGNvbW1lbnRIYW5kbGVyLmF0dGFjaCA9IGF0dGFjaENvbW1lbnQ7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudCA9IHRydWU7XG5cdCAgICAgICAgICAgIHBhcnNlckRlbGVnYXRlID0gcHJveHlEZWxlZ2F0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgaXNNb2R1bGUgPSBmYWxzZTtcblx0ICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZVR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgaXNNb2R1bGUgPSAob3B0aW9ucy5zb3VyY2VUeXBlID09PSAnbW9kdWxlJyk7XG5cdCAgICB9XG5cdCAgICB2YXIgcGFyc2VyO1xuXHQgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuanN4ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5qc3gpIHtcblx0ICAgICAgICBwYXJzZXIgPSBuZXcganN4X3BhcnNlcl8xLkpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBwYXJzZXJEZWxlZ2F0ZSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBwYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKGNvZGUsIG9wdGlvbnMsIHBhcnNlckRlbGVnYXRlKTtcblx0ICAgIH1cblx0ICAgIHZhciBwcm9ncmFtID0gaXNNb2R1bGUgPyBwYXJzZXIucGFyc2VNb2R1bGUoKSA6IHBhcnNlci5wYXJzZVNjcmlwdCgpO1xuXHQgICAgdmFyIGFzdCA9IHByb2dyYW07XG5cdCAgICBpZiAoY29sbGVjdENvbW1lbnQgJiYgY29tbWVudEhhbmRsZXIpIHtcblx0ICAgICAgICBhc3QuY29tbWVudHMgPSBjb21tZW50SGFuZGxlci5jb21tZW50cztcblx0ICAgIH1cblx0ICAgIGlmIChwYXJzZXIuY29uZmlnLnRva2Vucykge1xuXHQgICAgICAgIGFzdC50b2tlbnMgPSBwYXJzZXIudG9rZW5zO1xuXHQgICAgfVxuXHQgICAgaWYgKHBhcnNlci5jb25maWcudG9sZXJhbnQpIHtcblx0ICAgICAgICBhc3QuZXJyb3JzID0gcGFyc2VyLmVycm9ySGFuZGxlci5lcnJvcnM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYXN0O1xuXHR9XG5cdGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblx0ZnVuY3Rpb24gcGFyc2VNb2R1bGUoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcblx0ICAgIHZhciBwYXJzaW5nT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBwYXJzaW5nT3B0aW9ucy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XG5cdCAgICByZXR1cm4gcGFyc2UoY29kZSwgcGFyc2luZ09wdGlvbnMsIGRlbGVnYXRlKTtcblx0fVxuXHRleHBvcnRzLnBhcnNlTW9kdWxlID0gcGFyc2VNb2R1bGU7XG5cdGZ1bmN0aW9uIHBhcnNlU2NyaXB0KGNvZGUsIG9wdGlvbnMsIGRlbGVnYXRlKSB7XG5cdCAgICB2YXIgcGFyc2luZ09wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgcGFyc2luZ09wdGlvbnMuc291cmNlVHlwZSA9ICdzY3JpcHQnO1xuXHQgICAgcmV0dXJuIHBhcnNlKGNvZGUsIHBhcnNpbmdPcHRpb25zLCBkZWxlZ2F0ZSk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZVNjcmlwdCA9IHBhcnNlU2NyaXB0O1xuXHRmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xuXHQgICAgdmFyIHRva2VuaXplciA9IG5ldyB0b2tlbml6ZXJfMS5Ub2tlbml6ZXIoY29kZSwgb3B0aW9ucyk7XG5cdCAgICB2YXIgdG9rZW5zO1xuXHQgICAgdG9rZW5zID0gW107XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2VuaXplci5nZXROZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGRlbGVnYXRlKHRva2VuKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGUpIHtcblx0ICAgICAgICB0b2tlbml6ZXIuZXJyb3JIYW5kbGVyLnRvbGVyYXRlKGUpO1xuXHQgICAgfVxuXHQgICAgaWYgKHRva2VuaXplci5lcnJvckhhbmRsZXIudG9sZXJhbnQpIHtcblx0ICAgICAgICB0b2tlbnMuZXJyb3JzID0gdG9rZW5pemVyLmVycm9ycygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRva2Vucztcblx0fVxuXHRleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG5cdHZhciBzeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdGV4cG9ydHMuU3ludGF4ID0gc3ludGF4XzEuU3ludGF4O1xuXHQvLyBTeW5jIHdpdGggKi5qc29uIG1hbmlmZXN0cy5cblx0ZXhwb3J0cy52ZXJzaW9uID0gJzQuMC4xJztcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIHN5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0dmFyIENvbW1lbnRIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvbW1lbnRIYW5kbGVyKCkge1xuXHQgICAgICAgIHRoaXMuYXR0YWNoID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5jb21tZW50cyA9IFtdO1xuXHQgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcblx0ICAgICAgICB0aGlzLmxlYWRpbmcgPSBbXTtcblx0ICAgICAgICB0aGlzLnRyYWlsaW5nID0gW107XG5cdCAgICB9XG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUuaW5zZXJ0SW5uZXJDb21tZW50cyA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xuXHQgICAgICAgIC8vICBpbm5uZXJDb21tZW50cyBmb3IgcHJvcGVydGllcyBlbXB0eSBibG9ja1xuXHQgICAgICAgIC8vICBgZnVuY3Rpb24gYSgpIHsvKiogY29tbWVudHMgKipcXC99YFxuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHZhciBpbm5lckNvbW1lbnRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMubGVhZGluZ1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YS5lbmQub2Zmc2V0ID49IGVudHJ5LnN0YXJ0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5uZXJDb21tZW50cy51bnNoaWZ0KGVudHJ5LmNvbW1lbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFpbGluZy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLmlubmVyQ29tbWVudHMgPSBpbm5lckNvbW1lbnRzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kVHJhaWxpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gW107XG5cdCAgICAgICAgaWYgKHRoaXMudHJhaWxpbmcubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cmFpbGluZy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGVudHJ5XzEgPSB0aGlzLnRyYWlsaW5nW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVudHJ5XzEuc3RhcnQgPj0gbWV0YWRhdGEuZW5kLm9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeV8xLmNvbW1lbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcubGVuZ3RoID0gMDtcblx0ICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nQ29tbWVudHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG5cdCAgICAgICAgICAgIHZhciBmaXJzdENvbW1lbnQgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHNbMF07XG5cdCAgICAgICAgICAgIGlmIChmaXJzdENvbW1lbnQgJiYgZmlyc3RDb21tZW50LnJhbmdlWzBdID49IG1ldGFkYXRhLmVuZC5vZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMgPSBlbnRyeS5ub2RlLnRyYWlsaW5nQ29tbWVudHM7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZW50cnkubm9kZS50cmFpbGluZ0NvbW1lbnRzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cmFpbGluZ0NvbW1lbnRzO1xuXHQgICAgfTtcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS5maW5kTGVhZGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IFtdO1xuXHQgICAgICAgIHZhciB0YXJnZXQ7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5zdGFydCA+PSBtZXRhZGF0YS5zdGFydC5vZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldCA9IGVudHJ5Lm5vZGU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgICAgICB2YXIgY291bnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID8gdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggOiAwO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gY291bnQgLSAxOyBpID49IDA7IC0taSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQucmFuZ2VbMV0gPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoY29tbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRhcmdldC5sZWFkaW5nQ29tbWVudHMgJiYgdGFyZ2V0LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQubGVhZGluZ0NvbW1lbnRzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBsZWFkaW5nQ29tbWVudHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlYWRpbmcubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0ICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5sZWFkaW5nW2ldO1xuXHQgICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQgPD0gbWV0YWRhdGEuc3RhcnQub2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMudW5zaGlmdChlbnRyeS5jb21tZW50KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMubGVhZGluZy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxlYWRpbmdDb21tZW50cztcblx0ICAgIH07XG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XG5cdCAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlByb2dyYW0gJiYgbm9kZS5ib2R5Lmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmluc2VydElubmVyQ29tbWVudHMobm9kZSwgbWV0YWRhdGEpO1xuXHQgICAgICAgIHZhciB0cmFpbGluZ0NvbW1lbnRzID0gdGhpcy5maW5kVHJhaWxpbmdDb21tZW50cyhtZXRhZGF0YSk7XG5cdCAgICAgICAgdmFyIGxlYWRpbmdDb21tZW50cyA9IHRoaXMuZmluZExlYWRpbmdDb21tZW50cyhtZXRhZGF0YSk7XG5cdCAgICAgICAgaWYgKGxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHJhaWxpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRyYWlsaW5nQ29tbWVudHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG5cdCAgICAgICAgICAgIG5vZGU6IG5vZGUsXG5cdCAgICAgICAgICAgIHN0YXJ0OiBtZXRhZGF0YS5zdGFydC5vZmZzZXRcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBDb21tZW50SGFuZGxlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUsIG1ldGFkYXRhKSB7XG5cdCAgICAgICAgdmFyIHR5cGUgPSAobm9kZS50eXBlWzBdID09PSAnTCcpID8gJ0xpbmUnIDogJ0Jsb2NrJztcblx0ICAgICAgICB2YXIgY29tbWVudCA9IHtcblx0ICAgICAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICAgICAgdmFsdWU6IG5vZGUudmFsdWVcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChub2RlLnJhbmdlKSB7XG5cdCAgICAgICAgICAgIGNvbW1lbnQucmFuZ2UgPSBub2RlLnJhbmdlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobm9kZS5sb2MpIHtcblx0ICAgICAgICAgICAgY29tbWVudC5sb2MgPSBub2RlLmxvYztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuXHQgICAgICAgIGlmICh0aGlzLmF0dGFjaCkge1xuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XG5cdCAgICAgICAgICAgICAgICBjb21tZW50OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZTogW21ldGFkYXRhLnN0YXJ0Lm9mZnNldCwgbWV0YWRhdGEuZW5kLm9mZnNldF1cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzdGFydDogbWV0YWRhdGEuc3RhcnQub2Zmc2V0XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGlmIChub2RlLmxvYykge1xuXHQgICAgICAgICAgICAgICAgZW50cnkuY29tbWVudC5sb2MgPSBub2RlLmxvYztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBub2RlLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLmxlYWRpbmcucHVzaChlbnRyeSk7XG5cdCAgICAgICAgICAgIHRoaXMudHJhaWxpbmcucHVzaChlbnRyeSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIENvbW1lbnRIYW5kbGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uIChub2RlLCBtZXRhZGF0YSkge1xuXHQgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdMaW5lQ29tbWVudCcpIHtcblx0ICAgICAgICAgICAgdGhpcy52aXNpdENvbW1lbnQobm9kZSwgbWV0YWRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja0NvbW1lbnQnKSB7XG5cdCAgICAgICAgICAgIHRoaXMudmlzaXRDb21tZW50KG5vZGUsIG1ldGFkYXRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5hdHRhY2gpIHtcblx0ICAgICAgICAgICAgdGhpcy52aXNpdE5vZGUobm9kZSwgbWV0YWRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29tbWVudEhhbmRsZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ29tbWVudEhhbmRsZXIgPSBDb21tZW50SGFuZGxlcjtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy5TeW50YXggPSB7XG5cdCAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcblx0ICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxuXHQgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcblx0ICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXG5cdCAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcblx0ICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsXG5cdCAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50Jyxcblx0ICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcblx0ICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuXHQgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG5cdCAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcblx0ICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG5cdCAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG5cdCAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxuXHQgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcblx0ICAgIENvbnRpbnVlU3RhdGVtZW50OiAnQ29udGludWVTdGF0ZW1lbnQnLFxuXHQgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuXHQgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG5cdCAgICBFbXB0eVN0YXRlbWVudDogJ0VtcHR5U3RhdGVtZW50Jyxcblx0ICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxuXHQgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcblx0ICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJyxcblx0ICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG5cdCAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG5cdCAgICBGb3JTdGF0ZW1lbnQ6ICdGb3JTdGF0ZW1lbnQnLFxuXHQgICAgRm9yT2ZTdGF0ZW1lbnQ6ICdGb3JPZlN0YXRlbWVudCcsXG5cdCAgICBGb3JJblN0YXRlbWVudDogJ0ZvckluU3RhdGVtZW50Jyxcblx0ICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcblx0ICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG5cdCAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG5cdCAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50Jyxcblx0ICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuXHQgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuXHQgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyxcblx0ICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXG5cdCAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG5cdCAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG5cdCAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcblx0ICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcblx0ICAgIE1ldGFQcm9wZXJ0eTogJ01ldGFQcm9wZXJ0eScsXG5cdCAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG5cdCAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG5cdCAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG5cdCAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG5cdCAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG5cdCAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5Jyxcblx0ICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxuXHQgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50Jyxcblx0ICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXG5cdCAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG5cdCAgICBTdXBlcjogJ1N1cGVyJyxcblx0ICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcblx0ICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG5cdCAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuXHQgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50Jyxcblx0ICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXG5cdCAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcblx0ICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuXHQgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50Jyxcblx0ICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG5cdCAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG5cdCAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuXHQgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG5cdCAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG5cdCAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGNoYXJhY3Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIEpTWE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIganN4X3N5bnRheF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHR2YXIgcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHR2YXIgeGh0bWxfZW50aXRpZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR0b2tlbl8xLlRva2VuTmFtZVsxMDAgLyogSWRlbnRpZmllciAqL10gPSAnSlNYSWRlbnRpZmllcic7XG5cdHRva2VuXzEuVG9rZW5OYW1lWzEwMSAvKiBUZXh0ICovXSA9ICdKU1hUZXh0Jztcblx0Ly8gRnVsbHkgcXVhbGlmaWVkIGVsZW1lbnQgbmFtZSwgZS5nLiA8c3ZnOnBhdGg+IHJldHVybnMgXCJzdmc6cGF0aFwiXG5cdGZ1bmN0aW9uIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGVsZW1lbnROYW1lKSB7XG5cdCAgICB2YXIgcXVhbGlmaWVkTmFtZTtcblx0ICAgIHN3aXRjaCAoZWxlbWVudE5hbWUudHlwZSkge1xuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hJZGVudGlmaWVyOlxuXHQgICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50TmFtZTtcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGlkLm5hbWU7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGNhc2UganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hOYW1lc3BhY2VkTmFtZTpcblx0ICAgICAgICAgICAgdmFyIG5zID0gZWxlbWVudE5hbWU7XG5cdCAgICAgICAgICAgIHF1YWxpZmllZE5hbWUgPSBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShucy5uYW1lc3BhY2UpICsgJzonICtcblx0ICAgICAgICAgICAgICAgIGdldFF1YWxpZmllZEVsZW1lbnROYW1lKG5zLm5hbWUpO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlIGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTWVtYmVyRXhwcmVzc2lvbjpcblx0ICAgICAgICAgICAgdmFyIGV4cHIgPSBlbGVtZW50TmFtZTtcblx0ICAgICAgICAgICAgcXVhbGlmaWVkTmFtZSA9IGdldFF1YWxpZmllZEVsZW1lbnROYW1lKGV4cHIub2JqZWN0KSArICcuJyArXG5cdCAgICAgICAgICAgICAgICBnZXRRdWFsaWZpZWRFbGVtZW50TmFtZShleHByLnByb3BlcnR5KTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiBxdWFsaWZpZWROYW1lO1xuXHR9XG5cdHZhciBKU1hQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEpTWFBhcnNlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEpTWFBhcnNlcihjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBvcHRpb25zLCBkZWxlZ2F0ZSkgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgnPCcpID8gdGhpcy5wYXJzZUpTWFJvb3QoKSA6IF9zdXBlci5wcm90b3R5cGUucGFyc2VQcmltYXJ5RXhwcmVzc2lvbi5jYWxsKHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUuc3RhcnRKU1ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gVW53aW5kIHRoZSBzY2FubmVyIGJlZm9yZSB0aGUgbG9va2FoZWFkIHRva2VuLlxuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXg7XG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XG5cdCAgICAgICAgdGhpcy5zY2FubmVyLmxpbmVTdGFydCA9IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXggLSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmZpbmlzaEpTWCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnJlZW50ZXJKU1ggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5zdGFydEpTWCgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd9Jyk7XG5cdCAgICAgICAgLy8gUG9wIHRoZSBjbG9zaW5nICd9JyBhZGRlZCBmcm9tIHRoZSBsb29rYWhlYWQuXG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRva2Vucykge1xuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hOb2RlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVKU1hDaGlsZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc2Nhbm5lci5pbmRleCxcblx0ICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5zY2FuWEhUTUxFbnRpdHkgPSBmdW5jdGlvbiAocXVvdGUpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gJyYnO1xuXHQgICAgICAgIHZhciB2YWxpZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHRlcm1pbmF0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgbnVtZXJpYyA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBoZXggPSBmYWxzZTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSAmJiB2YWxpZCAmJiAhdGVybWluYXRlZCkge1xuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF07XG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSAoY2ggPT09ICc7Jyk7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgICAgIGlmICghdGVybWluYXRlZCkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChyZXN1bHQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuICcmIzEyMzsnXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSAoY2ggPT09ICcjJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyaWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gJyYjeDQxOydcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IChjaCA9PT0gJ3gnKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gaGV4IHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyaWMgPSBudW1lcmljICYmICFoZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiAhKG51bWVyaWMgJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdmFsaWQgJiYgIShoZXggJiYgIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHZhbGlkICYmIHRlcm1pbmF0ZWQgJiYgcmVzdWx0Lmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgLy8gZS5nLiAnJiN4NDE7JyBiZWNvbWVzIGp1c3QgJyN4NDEnXG5cdCAgICAgICAgICAgIHZhciBzdHIgPSByZXN1bHQuc3Vic3RyKDEsIHJlc3VsdC5sZW5ndGggLSAyKTtcblx0ICAgICAgICAgICAgaWYgKG51bWVyaWMgJiYgc3RyLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTApKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChoZXggJiYgc3RyLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzAnICsgc3RyLnN1YnN0cigxKSwgMTYpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghbnVtZXJpYyAmJiAhaGV4ICYmIHhodG1sX2VudGl0aWVzXzEuWEhUTUxFbnRpdGllc1tzdHJdKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB4aHRtbF9lbnRpdGllc18xLlhIVE1MRW50aXRpZXNbc3RyXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIFNjYW4gdGhlIG5leHQgSlNYIHRva2VuLiBUaGlzIHJlcGxhY2VzIFNjYW5uZXIjbGV4IHdoZW4gaW4gSlNYIG1vZGUuXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmxleEpTWCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcblx0ICAgICAgICAvLyA8ID4gLyA6ID0geyB9XG5cdCAgICAgICAgaWYgKGNwID09PSA2MCB8fCBjcCA9PT0gNjIgfHwgY3AgPT09IDQ3IHx8IGNwID09PSA1OCB8fCBjcCA9PT0gNjEgfHwgY3AgPT09IDEyMyB8fCBjcCA9PT0gMTI1KSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBQdW5jdHVhdG9yICovLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXG5cdCAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zY2FubmVyLmluZGV4IC0gMSxcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFwiICdcblx0ICAgICAgICBpZiAoY3AgPT09IDM0IHx8IGNwID09PSAzOSkge1xuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4KytdO1xuXHQgICAgICAgICAgICB2YXIgc3RyID0gJyc7XG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdGhpcy5zY2FuWEhUTUxFbnRpdHkocXVvdGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIFN0cmluZ0xpdGVyYWwgKi8sXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyAuLi4gb3IgLlxuXHQgICAgICAgIGlmIChjcCA9PT0gNDYpIHtcblx0ICAgICAgICAgICAgdmFyIG4xID0gdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci5pbmRleCArIDEpO1xuXHQgICAgICAgICAgICB2YXIgbjIgPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4ICsgMik7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IChuMSA9PT0gNDYgJiYgbjIgPT09IDQ2KSA/ICcuLi4nIDogJy4nO1xuXHQgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5pbmRleCArPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcblx0ICAgICAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5zY2FubmVyLmxpbmVTdGFydCxcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGBcblx0ICAgICAgICBpZiAoY3AgPT09IDk2KSB7XG5cdCAgICAgICAgICAgIC8vIE9ubHkgcGxhY2Vob2xkZXIsIHNpbmNlIGl0IHdpbGwgYmUgcmVzY2FubmVkIGFzIGEgcmVhbCBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiAxMCAvKiBUZW1wbGF0ZSAqLyxcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcblx0ICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc2Nhbm5lci5pbmRleCxcblx0ICAgICAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIElkZW50aWZlciBjYW4gbm90IGNvbnRhaW4gYmFja3NsYXNoIChjaGFyIGNvZGUgOTIpLlxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY3ApICYmIChjcCAhPT0gOTIpKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZigpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLmluZGV4KTtcblx0ICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaCkgJiYgKGNoICE9PSA5MikpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSA0NSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEh5cGhlbiAoY2hhciBjb2RlIDQ1KSBjYW4gYmUgcGFydCBvZiBhbiBpZGVudGlmaWVyLlxuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5zY2FubmVyLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZShzdGFydCwgdGhpcy5zY2FubmVyLmluZGV4KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDEwMCAvKiBJZGVudGlmaWVyICovLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMuc2Nhbm5lci5saW5lU3RhcnQsXG5cdCAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHRoaXMuc2Nhbm5lci5pbmRleFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLmxleCgpO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRva2VuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sZXhKU1goKTtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubmV4dEpTWFRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbiA9IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnQ7XG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xuXHQgICAgICAgIHZhciB0ZXh0ID0gJyc7XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAoY2ggPT09ICd7JyB8fCBjaCA9PT0gJzwnKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICAgICAgdGV4dCArPSBjaDtcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG5cdCAgICAgICAgICAgICAgICArK3RoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNjYW5uZXIuc291cmNlW3RoaXMuc2Nhbm5lci5pbmRleF0gPT09ICdcXG4nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubGluZVN0YXJ0ID0gdGhpcy5zY2FubmVyLmluZGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHtcblx0ICAgICAgICAgICAgdHlwZTogMTAxIC8qIFRleHQgKi8sXG5cdCAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLnNjYW5uZXIubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5zY2FubmVyLmluZGV4XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAoKHRleHQubGVuZ3RoID4gMCkgJiYgdGhpcy5jb25maWcudG9rZW5zKSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godGhpcy5jb252ZXJ0VG9rZW4odG9rZW4pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRva2VuO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGVla0pTWFRva2VuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcblx0ICAgICAgICB0aGlzLnNjYW5uZXIuc2NhbkNvbW1lbnRzKCk7XG5cdCAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxleEpTWCgpO1xuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xuXHQgICAgICAgIHJldHVybiBuZXh0O1xuXHQgICAgfTtcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCBKU1ggdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXHQgICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmV4cGVjdEpTWCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRva2VuKCk7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IEpTWCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUubWF0Y2hKU1ggPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMucGVla0pTWFRva2VuKCk7XG5cdCAgICAgICAgcmV0dXJuIG5leHQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIG5leHQudmFsdWUgPT09IHZhbHVlO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0SlNYVG9rZW4oKTtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gMTAwIC8qIElkZW50aWZpZXIgKi8pIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWElkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRWxlbWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB2YXIgZWxlbWVudE5hbWUgPSB0aGlzLnBhcnNlSlNYSWRlbnRpZmllcigpO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCc6JykpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGVsZW1lbnROYW1lO1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnOicpO1xuXHQgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgZWxlbWVudE5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8xKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hKU1goJy4nKSkge1xuXHQgICAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaEpTWCgnLicpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gZWxlbWVudE5hbWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLicpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZUpTWElkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB2YXIgYXR0cmlidXRlTmFtZTtcblx0ICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJzonKSkge1xuXHQgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gaWRlbnRpZmllcjtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJzonKTtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IHRoaXMucGFyc2VKU1hJZGVudGlmaWVyKCk7XG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZV8yKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gaWRlbnRpZmllcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWU7XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRKU1hUb2tlbigpO1xuXHQgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByYXcgPSB0aGlzLmdldFRva2VuUmF3KHRva2VuKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKHRva2VuLnZhbHVlLCByYXcpKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYRXhwcmVzc2lvbkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0SlNYKCd7Jyk7XG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcignSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hFeHByZXNzaW9uQXR0cmlidXRlKCkgOlxuXHQgICAgICAgICAgICB0aGlzLm1hdGNoSlNYKCc8JykgPyB0aGlzLnBhcnNlSlNYRWxlbWVudCgpIDogdGhpcy5wYXJzZUpTWFN0cmluZ0xpdGVyYWxBdHRyaWJ1dGUoKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlTmFtZSgpO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hKU1goJz0nKSkge1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPScpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVWYWx1ZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYU3ByZWFkQXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJ3snKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLi4uJyk7XG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICB0aGlzLnJlZW50ZXJKU1goKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpKTtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaEpTWCgnLycpICYmICF0aGlzLm1hdGNoSlNYKCc+JykpIHtcblx0ICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMubWF0Y2hKU1goJ3snKSA/IHRoaXMucGFyc2VKU1hTcHJlYWRBdHRyaWJ1dGUoKSA6XG5cdCAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSlNYTmFtZVZhbHVlQXR0cmlidXRlKCk7XG5cdCAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlSlNYT3BlbmluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xuXHQgICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUpTWEVsZW1lbnROYW1lKCk7XG5cdCAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSlNYQXR0cmlidXRlcygpO1xuXHQgICAgICAgIHZhciBzZWxmQ2xvc2luZyA9IHRoaXMubWF0Y2hKU1goJy8nKTtcblx0ICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3RKU1goJz4nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hPcGVuaW5nRWxlbWVudChuYW1lLCBzZWxmQ2xvc2luZywgYXR0cmlidXRlcykpO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hCb3VuZGFyeUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPCcpO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCcvJykpIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJy8nKTtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMyA9IHRoaXMucGFyc2VKU1hFbGVtZW50TmFtZSgpO1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hDbG9zaW5nRWxlbWVudChuYW1lXzMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlSlNYRWxlbWVudE5hbWUoKTtcblx0ICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFyc2VKU1hBdHRyaWJ1dGVzKCk7XG5cdCAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gdGhpcy5tYXRjaEpTWCgnLycpO1xuXHQgICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEpTWCgnLycpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgnPicpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWE9wZW5pbmdFbGVtZW50KG5hbWUsIHNlbGZDbG9zaW5nLCBhdHRyaWJ1dGVzKSk7XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVtcHR5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XG5cdCAgICAgICAgdGhpcy5jb2xsZWN0Q29tbWVudHMoKTtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuaW5kZXggPSB0aGlzLnNjYW5uZXIuaW5kZXg7XG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIuY29sdW1uID0gdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydDtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbXB0eUV4cHJlc3Npb24oKSk7XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEpTWCgneycpO1xuXHQgICAgICAgIHZhciBleHByZXNzaW9uO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoSlNYKCd9JykpIHtcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VKU1hFbXB0eUV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3RKU1goJ30nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZmluaXNoSlNYKCk7XG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgdGhpcy5yZWVudGVySlNYKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWEV4cHJlc3Npb25Db250YWluZXIoZXhwcmVzc2lvbikpO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlSlNYQ2hpbGROb2RlKCk7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dEpTWFRleHQoKTtcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnN0YXJ0IDwgdG9rZW4uZW5kKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBKU1hOb2RlLkpTWFRleHQodG9rZW4udmFsdWUsIHJhdykpO1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5zb3VyY2VbdGhpcy5zY2FubmVyLmluZGV4XSA9PT0gJ3snKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5wYXJzZUpTWEV4cHJlc3Npb25Db250YWluZXIoKTtcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjaGlsZHJlbjtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29tcGxleEpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcblx0ICAgICAgICB2YXIgc3RhY2sgPSBbXTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YoKSkge1xuXHQgICAgICAgICAgICBlbC5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmNvbmNhdCh0aGlzLnBhcnNlSlNYQ2hpbGRyZW4oKSk7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVKU1hDaGlsZE5vZGUoKTtcblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlSlNYQm91bmRhcnlFbGVtZW50KCk7XG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYT3BlbmluZ0VsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcGVuaW5nID0gZWxlbWVudDtcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nLnNlbGZDbG9zaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgSlNYTm9kZS5KU1hFbGVtZW50KG9wZW5pbmcsIFtdLCBudWxsKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgICAgICAgICBlbCA9IHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogbnVsbCwgY2hpbGRyZW46IFtdIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgZWwuY2xvc2luZyA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3Blbl8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwub3BlbmluZy5uYW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjbG9zZV8xID0gZ2V0UXVhbGlmaWVkRWxlbWVudE5hbWUoZWwuY2xvc2luZy5uYW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmIChvcGVuXzEgIT09IGNsb3NlXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IoJ0V4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciAlMCcsIG9wZW5fMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZmluYWxpemUoZWwubm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChlbC5vcGVuaW5nLCBlbC5jaGlsZHJlbiwgZWwuY2xvc2luZykpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVsID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZWw7XG5cdCAgICB9O1xuXHQgICAgSlNYUGFyc2VyLnByb3RvdHlwZS5wYXJzZUpTWEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUpTWE5vZGUoKTtcblx0ICAgICAgICB2YXIgb3BlbmluZyA9IHRoaXMucGFyc2VKU1hPcGVuaW5nRWxlbWVudCgpO1xuXHQgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXHQgICAgICAgIHZhciBjbG9zaW5nID0gbnVsbDtcblx0ICAgICAgICBpZiAoIW9wZW5pbmcuc2VsZkNsb3NpbmcpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5wYXJzZUNvbXBsZXhKU1hFbGVtZW50KHsgbm9kZTogbm9kZSwgb3BlbmluZzogb3BlbmluZywgY2xvc2luZzogY2xvc2luZywgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXHQgICAgICAgICAgICBjbG9zaW5nID0gZWwuY2xvc2luZztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IEpTWE5vZGUuSlNYRWxlbWVudChvcGVuaW5nLCBjaGlsZHJlbiwgY2xvc2luZykpO1xuXHQgICAgfTtcblx0ICAgIEpTWFBhcnNlci5wcm90b3R5cGUucGFyc2VKU1hSb290ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIFBvcCB0aGUgb3BlbmluZyAnPCcgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkLlxuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2tlbnMpIHtcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuc3RhcnRKU1goKTtcblx0ICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VKU1hFbGVtZW50KCk7XG5cdCAgICAgICAgdGhpcy5maW5pc2hKU1goKTtcblx0ICAgICAgICByZXR1cm4gZWxlbWVudDtcblx0ICAgIH07XG5cdCAgICBKU1hQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaXNTdGFydE9mRXhwcmVzc2lvbi5jYWxsKHRoaXMpIHx8IHRoaXMubWF0Y2goJzwnKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSlNYUGFyc2VyO1xuXHR9KHBhcnNlcl8xLlBhcnNlcikpO1xuXHRleHBvcnRzLkpTWFBhcnNlciA9IEpTWFBhcnNlcjtcblxuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5qcy5cblx0dmFyIFJlZ2V4ID0ge1xuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XG5cdCAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRFxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuXHQgICAgLy8gVW5pY29kZSB2OC4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcblx0ICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xuXHR9O1xuXHRleHBvcnRzLkNoYXJhY3RlciA9IHtcblx0ICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2UgKi9cblx0ICAgIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIChjcCkge1xuXHQgICAgICAgIHJldHVybiAoY3AgPCAweDEwMDAwKSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApIDpcblx0ICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoKGNwIC0gMHgxMDAwMCkgPj4gMTApKSArXG5cdCAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4REMwMCArICgoY3AgLSAweDEwMDAwKSAmIDEwMjMpKTtcblx0ICAgIH0sXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13aGl0ZS1zcGFjZVxuXHQgICAgaXNXaGl0ZVNwYWNlOiBmdW5jdGlvbiAoY3ApIHtcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDIwKSB8fCAoY3AgPT09IDB4MDkpIHx8IChjcCA9PT0gMHgwQikgfHwgKGNwID09PSAweDBDKSB8fCAoY3AgPT09IDB4QTApIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjcCkgPj0gMCk7XG5cdCAgICB9LFxuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGluZS10ZXJtaW5hdG9yc1xuXHQgICAgaXNMaW5lVGVybWluYXRvcjogZnVuY3Rpb24gKGNwKSB7XG5cdCAgICAgICAgcmV0dXJuIChjcCA9PT0gMHgwQSkgfHwgKGNwID09PSAweDBEKSB8fCAoY3AgPT09IDB4MjAyOCkgfHwgKGNwID09PSAweDIwMjkpO1xuXHQgICAgfSxcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xuXHQgICAgaXNJZGVudGlmaWVyU3RhcnQ6IGZ1bmN0aW9uIChjcCkge1xuXHQgICAgICAgIHJldHVybiAoY3AgPT09IDB4MjQpIHx8IChjcCA9PT0gMHg1RikgfHxcblx0ICAgICAgICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1QSkgfHxcblx0ICAgICAgICAgICAgKGNwID49IDB4NjEgJiYgY3AgPD0gMHg3QSkgfHxcblx0ICAgICAgICAgICAgKGNwID09PSAweDVDKSB8fFxuXHQgICAgICAgICAgICAoKGNwID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcblx0ICAgIH0sXG5cdCAgICBpc0lkZW50aWZpZXJQYXJ0OiBmdW5jdGlvbiAoY3ApIHtcblx0ICAgICAgICByZXR1cm4gKGNwID09PSAweDI0KSB8fCAoY3AgPT09IDB4NUYpIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NUEpIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N0EpIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XG5cdCAgICAgICAgICAgIChjcCA9PT0gMHg1QykgfHxcblx0ICAgICAgICAgICAgKChjcCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZXhwb3J0cy5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjcCkpKTtcblx0ICAgIH0sXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1saXRlcmFscy1udW1lcmljLWxpdGVyYWxzXG5cdCAgICBpc0RlY2ltYWxEaWdpdDogZnVuY3Rpb24gKGNwKSB7XG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpOyAvLyAwLi45XG5cdCAgICB9LFxuXHQgICAgaXNIZXhEaWdpdDogZnVuY3Rpb24gKGNwKSB7XG5cdCAgICAgICAgcmV0dXJuIChjcCA+PSAweDMwICYmIGNwIDw9IDB4MzkpIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDQxICYmIGNwIDw9IDB4NDYpIHx8XG5cdCAgICAgICAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4NjYpOyAvLyBhLi5mXG5cdCAgICB9LFxuXHQgICAgaXNPY3RhbERpZ2l0OiBmdW5jdGlvbiAoY3ApIHtcblx0ICAgICAgICByZXR1cm4gKGNwID49IDB4MzAgJiYgY3AgPD0gMHgzNyk7IC8vIDAuLjdcblx0ICAgIH1cblx0fTtcblxuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGpzeF9zeW50YXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdC8qIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlICovXG5cdHZhciBKU1hDbG9zaW5nRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudChuYW1lKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hDbG9zaW5nRWxlbWVudDtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEpTWENsb3NpbmdFbGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWENsb3NpbmdFbGVtZW50ID0gSlNYQ2xvc2luZ0VsZW1lbnQ7XG5cdHZhciBKU1hFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEpTWEVsZW1lbnQob3BlbmluZ0VsZW1lbnQsIGNoaWxkcmVuLCBjbG9zaW5nRWxlbWVudCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYRWxlbWVudDtcblx0ICAgICAgICB0aGlzLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG5cdCAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXHQgICAgICAgIHRoaXMuY2xvc2luZ0VsZW1lbnQgPSBjbG9zaW5nRWxlbWVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hFbGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWEVsZW1lbnQgPSBKU1hFbGVtZW50O1xuXHR2YXIgSlNYRW1wdHlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEVtcHR5RXhwcmVzc2lvbjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hFbXB0eUV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gSlNYRW1wdHlFeHByZXNzaW9uO1xuXHR2YXIgSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKGV4cHJlc3Npb24pIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWEV4cHJlc3Npb25Db250YWluZXI7XG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBKU1hFeHByZXNzaW9uQ29udGFpbmVyO1xuXHR2YXIgSlNYSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBKU1hJZGVudGlmaWVyKG5hbWUpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWElkZW50aWZpZXI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hJZGVudGlmaWVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWElkZW50aWZpZXIgPSBKU1hJZGVudGlmaWVyO1xuXHR2YXIgSlNYTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBKU1hNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE1lbWJlckV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEpTWE1lbWJlckV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IEpTWE1lbWJlckV4cHJlc3Npb247XG5cdHZhciBKU1hBdHRyaWJ1dGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gSlNYQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hBdHRyaWJ1dGU7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gSlNYQXR0cmlidXRlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IEpTWEF0dHJpYnV0ZTtcblx0dmFyIEpTWE5hbWVzcGFjZWROYW1lID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEpTWE5hbWVzcGFjZWROYW1lKG5hbWVzcGFjZSwgbmFtZSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IGpzeF9zeW50YXhfMS5KU1hTeW50YXguSlNYTmFtZXNwYWNlZE5hbWU7XG5cdCAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hOYW1lc3BhY2VkTmFtZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xuXHR2YXIgSlNYT3BlbmluZ0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQobmFtZSwgc2VsZkNsb3NpbmcsIGF0dHJpYnV0ZXMpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWE9wZW5pbmdFbGVtZW50O1xuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdGhpcy5zZWxmQ2xvc2luZyA9IHNlbGZDbG9zaW5nO1xuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gSlNYT3BlbmluZ0VsZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuSlNYT3BlbmluZ0VsZW1lbnQgPSBKU1hPcGVuaW5nRWxlbWVudDtcblx0dmFyIEpTWFNwcmVhZEF0dHJpYnV0ZSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBqc3hfc3ludGF4XzEuSlNYU3ludGF4LkpTWFNwcmVhZEF0dHJpYnV0ZTtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gSlNYU3ByZWFkQXR0cmlidXRlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IEpTWFNwcmVhZEF0dHJpYnV0ZTtcblx0dmFyIEpTWFRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gSlNYVGV4dCh2YWx1ZSwgcmF3KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0ganN4X3N5bnRheF8xLkpTWFN5bnRheC5KU1hUZXh0O1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLnJhdyA9IHJhdztcblx0ICAgIH1cblx0ICAgIHJldHVybiBKU1hUZXh0O1xuXHR9KCkpO1xuXHRleHBvcnRzLkpTWFRleHQgPSBKU1hUZXh0O1xuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLkpTWFN5bnRheCA9IHtcblx0ICAgIEpTWEF0dHJpYnV0ZTogJ0pTWEF0dHJpYnV0ZScsXG5cdCAgICBKU1hDbG9zaW5nRWxlbWVudDogJ0pTWENsb3NpbmdFbGVtZW50Jyxcblx0ICAgIEpTWEVsZW1lbnQ6ICdKU1hFbGVtZW50Jyxcblx0ICAgIEpTWEVtcHR5RXhwcmVzc2lvbjogJ0pTWEVtcHR5RXhwcmVzc2lvbicsXG5cdCAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiAnSlNYRXhwcmVzc2lvbkNvbnRhaW5lcicsXG5cdCAgICBKU1hJZGVudGlmaWVyOiAnSlNYSWRlbnRpZmllcicsXG5cdCAgICBKU1hNZW1iZXJFeHByZXNzaW9uOiAnSlNYTWVtYmVyRXhwcmVzc2lvbicsXG5cdCAgICBKU1hOYW1lc3BhY2VkTmFtZTogJ0pTWE5hbWVzcGFjZWROYW1lJyxcblx0ICAgIEpTWE9wZW5pbmdFbGVtZW50OiAnSlNYT3BlbmluZ0VsZW1lbnQnLFxuXHQgICAgSlNYU3ByZWFkQXR0cmlidXRlOiAnSlNYU3ByZWFkQXR0cmlidXRlJyxcblx0ICAgIEpTWFRleHQ6ICdKU1hUZXh0J1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuXHR2YXIgQXJyYXlFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFycmF5RXhwcmVzc2lvbihlbGVtZW50cykge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJheUV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEFycmF5RXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBBcnJheUV4cHJlc3Npb247XG5cdHZhciBBcnJheVBhdHRlcm4gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcblx0ICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQXJyYXlQYXR0ZXJuO1xuXHR9KCkpO1xuXHRleHBvcnRzLkFycmF5UGF0dGVybiA9IEFycmF5UGF0dGVybjtcblx0dmFyIEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcblx0dmFyIEFzc2lnbm1lbnRFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQXNzaWdubWVudEV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcblx0dmFyIEFzc2lnbm1lbnRQYXR0ZXJuID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuO1xuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEFzc2lnbm1lbnRQYXR0ZXJuO1xuXHR9KCkpO1xuXHRleHBvcnRzLkFzc2lnbm1lbnRQYXR0ZXJuID0gQXNzaWdubWVudFBhdHRlcm47XG5cdHZhciBBc3luY0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCBib2R5LCBleHByZXNzaW9uKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IEFzeW5jQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5cdHZhciBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQXN5bmNGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjtcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Bc3luY0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBBc3luY0Z1bmN0aW9uRGVjbGFyYXRpb247XG5cdHZhciBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuYXN5bmMgPSB0cnVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEFzeW5jRnVuY3Rpb25FeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkFzeW5jRnVuY3Rpb25FeHByZXNzaW9uID0gQXN5bmNGdW5jdGlvbkV4cHJlc3Npb247XG5cdHZhciBBd2FpdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkF3YWl0RXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQXdhaXRFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IEF3YWl0RXhwcmVzc2lvbjtcblx0dmFyIEJpbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcblx0ICAgICAgICB2YXIgbG9naWNhbCA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJyk7XG5cdCAgICAgICAgdGhpcy50eXBlID0gbG9naWNhbCA/IHN5bnRheF8xLlN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IHN5bnRheF8xLlN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblx0ICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBCaW5hcnlFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBCaW5hcnlFeHByZXNzaW9uO1xuXHR2YXIgQmxvY2tTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CbG9ja1N0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEJsb2NrU3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkJsb2NrU3RhdGVtZW50ID0gQmxvY2tTdGF0ZW1lbnQ7XG5cdHZhciBCcmVha1N0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCcmVha1N0YXRlbWVudChsYWJlbCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5CcmVha1N0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQnJlYWtTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgPSBCcmVha1N0YXRlbWVudDtcblx0dmFyIENhbGxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DYWxsRXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ2FsbEV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcblx0dmFyIENhdGNoQ2xhdXNlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENhdGNoQ2xhdXNlKHBhcmFtLCBib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkNhdGNoQ2xhdXNlO1xuXHQgICAgICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIENhdGNoQ2xhdXNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkNhdGNoQ2xhdXNlID0gQ2F0Y2hDbGF1c2U7XG5cdHZhciBDbGFzc0JvZHkgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ2xhc3NCb2R5KGJvZHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NCb2R5O1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ2xhc3NCb2R5O1xuXHR9KCkpO1xuXHRleHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcblx0dmFyIENsYXNzRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgYm9keSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5DbGFzc0RlY2xhcmF0aW9uO1xuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ2xhc3NEZWNsYXJhdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcblx0dmFyIENsYXNzRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBDbGFzc0V4cHJlc3Npb24oaWQsIHN1cGVyQ2xhc3MsIGJvZHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ2xhc3NFeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgICAgICB0aGlzLnN1cGVyQ2xhc3MgPSBzdXBlckNsYXNzO1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gQ2xhc3NFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IENsYXNzRXhwcmVzc2lvbjtcblx0dmFyIENvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMuY29tcHV0ZWQgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBDb21wdXRlZE1lbWJlckV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uID0gQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uO1xuXHR2YXIgQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcblx0ICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBDb25kaXRpb25hbEV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuXHR2YXIgQ29udGludWVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobGFiZWwpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQ29udGludWVTdGF0ZW1lbnQ7XG5cdCAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIENvbnRpbnVlU3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gQ29udGludWVTdGF0ZW1lbnQ7XG5cdHZhciBEZWJ1Z2dlclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBEZWJ1Z2dlclN0YXRlbWVudCgpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRGVidWdnZXJTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRGVidWdnZXJTdGF0ZW1lbnQgPSBEZWJ1Z2dlclN0YXRlbWVudDtcblx0dmFyIERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBEaXJlY3RpdmUoZXhwcmVzc2lvbiwgZGlyZWN0aXZlKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBEaXJlY3RpdmU7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xuXHR2YXIgRG9XaGlsZVN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBEb1doaWxlU3RhdGVtZW50KGJvZHksIHRlc3QpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRG9XaGlsZVN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRG9XaGlsZVN0YXRlbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcblx0dmFyIEVtcHR5U3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEVtcHR5U3RhdGVtZW50KCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FbXB0eVN0YXRlbWVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBFbXB0eVN0YXRlbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IEVtcHR5U3RhdGVtZW50O1xuXHR2YXIgRXhwb3J0QWxsRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXhwb3J0QWxsRGVjbGFyYXRpb24oc291cmNlKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydEFsbERlY2xhcmF0aW9uO1xuXHQgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEV4cG9ydEFsbERlY2xhcmF0aW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XG5cdHZhciBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcblx0dmFyIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgc3BlY2lmaWVycywgc291cmNlKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5cdCAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuXHQgICAgICAgIHRoaXMuc3BlY2lmaWVycyA9IHNwZWNpZmllcnM7XG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcblx0dmFyIEV4cG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBFeHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkV4cG9ydFNwZWNpZmllcjtcblx0ICAgICAgICB0aGlzLmV4cG9ydGVkID0gZXhwb3J0ZWQ7XG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEV4cG9ydFNwZWNpZmllcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBFeHBvcnRTcGVjaWZpZXI7XG5cdHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRXhwcmVzc2lvblN0YXRlbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gRXhwcmVzc2lvblN0YXRlbWVudDtcblx0dmFyIEZvckluU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZvckluU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvckluU3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICAgICAgdGhpcy5lYWNoID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRm9ySW5TdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRm9ySW5TdGF0ZW1lbnQgPSBGb3JJblN0YXRlbWVudDtcblx0dmFyIEZvck9mU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZvck9mU3RhdGVtZW50KGxlZnQsIHJpZ2h0LCBib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvck9mU3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRm9yT2ZTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBGb3JPZlN0YXRlbWVudDtcblx0dmFyIEZvclN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGb3JTdGF0ZW1lbnQoaW5pdCwgdGVzdCwgdXBkYXRlLCBib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkZvclN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICAgICAgdGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBGb3JTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuRm9yU3RhdGVtZW50ID0gRm9yU3RhdGVtZW50O1xuXHR2YXIgRnVuY3Rpb25EZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGdW5jdGlvbkRlY2xhcmF0aW9uKGlkLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvcikge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBGdW5jdGlvbkRlY2xhcmF0aW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBGdW5jdGlvbkRlY2xhcmF0aW9uO1xuXHR2YXIgRnVuY3Rpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcmVzc2lvbihpZCwgcGFyYW1zLCBib2R5LCBnZW5lcmF0b3IpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguRnVuY3Rpb25FeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMuaWQgPSBpZDtcblx0ICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuXHQgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuYXN5bmMgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBGdW5jdGlvbkV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuRnVuY3Rpb25FeHByZXNzaW9uID0gRnVuY3Rpb25FeHByZXNzaW9uO1xuXHR2YXIgSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJZGVudGlmaWVyKG5hbWUpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIElkZW50aWZpZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuSWRlbnRpZmllciA9IElkZW50aWZpZXI7XG5cdHZhciBJZlN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSWZTdGF0ZW1lbnQ7XG5cdCAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcblx0ICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuXHQgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIElmU3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG5cdHZhciBJbXBvcnREZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWNsYXJhdGlvbihzcGVjaWZpZXJzLCBzb3VyY2UpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguSW1wb3J0RGVjbGFyYXRpb247XG5cdCAgICAgICAgdGhpcy5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcblx0ICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBJbXBvcnREZWNsYXJhdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xuXHR2YXIgSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5cdCAgICAgICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5cdHZhciBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGxvY2FsKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcblx0dmFyIEltcG9ydFNwZWNpZmllciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbXBvcnRTcGVjaWZpZXIobG9jYWwsIGltcG9ydGVkKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkltcG9ydFNwZWNpZmllcjtcblx0ICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG5cdCAgICAgICAgdGhpcy5pbXBvcnRlZCA9IGltcG9ydGVkO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEltcG9ydFNwZWNpZmllcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5JbXBvcnRTcGVjaWZpZXIgPSBJbXBvcnRTcGVjaWZpZXI7XG5cdHZhciBMYWJlbGVkU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIExhYmVsZWRTdGF0ZW1lbnQobGFiZWwsIGJvZHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGFiZWxlZFN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBMYWJlbGVkU3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xuXHR2YXIgTGl0ZXJhbCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBMaXRlcmFsKHZhbHVlLCByYXcpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbDtcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy5yYXcgPSByYXc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTGl0ZXJhbDtcblx0fSgpKTtcblx0ZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcblx0dmFyIE1ldGFQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBNZXRhUHJvcGVydHkobWV0YSwgcHJvcGVydHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTWV0YVByb3BlcnR5O1xuXHQgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1ldGFQcm9wZXJ0eTtcblx0fSgpKTtcblx0ZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XG5cdHZhciBNZXRob2REZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIE1ldGhvZERlZmluaXRpb24oa2V5LCBjb21wdXRlZCwgdmFsdWUsIGtpbmQsIGlzU3RhdGljKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuXHQgICAgICAgIHRoaXMuc3RhdGljID0gaXNTdGF0aWM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWV0aG9kRGVmaW5pdGlvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5NZXRob2REZWZpbml0aW9uID0gTWV0aG9kRGVmaW5pdGlvbjtcblx0dmFyIE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBNb2R1bGUoYm9keSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Qcm9ncmFtO1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICAgICAgdGhpcy5zb3VyY2VUeXBlID0gJ21vZHVsZSc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTW9kdWxlO1xuXHR9KCkpO1xuXHRleHBvcnRzLk1vZHVsZSA9IE1vZHVsZTtcblx0dmFyIE5ld0V4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguTmV3RXhwcmVzc2lvbjtcblx0ICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTmV3RXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcblx0dmFyIE9iamVjdEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBPYmplY3RFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xuXHR2YXIgT2JqZWN0UGF0dGVybiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBPYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjtcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE9iamVjdFBhdHRlcm47XG5cdH0oKSk7XG5cdGV4cG9ydHMuT2JqZWN0UGF0dGVybiA9IE9iamVjdFBhdHRlcm47XG5cdHZhciBQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQcm9wZXJ0eShraW5kLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUHJvcGVydHk7XG5cdCAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuXHQgICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuXHQgICAgICAgIHRoaXMuc2hvcnRoYW5kID0gc2hvcnRoYW5kO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFByb3BlcnR5O1xuXHR9KCkpO1xuXHRleHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XG5cdHZhciBSZWdleExpdGVyYWwgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVnZXhMaXRlcmFsKHZhbHVlLCByYXcsIHBhdHRlcm4sIGZsYWdzKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LkxpdGVyYWw7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMucmF3ID0gcmF3O1xuXHQgICAgICAgIHRoaXMucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFJlZ2V4TGl0ZXJhbDtcblx0fSgpKTtcblx0ZXhwb3J0cy5SZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XG5cdHZhciBSZXN0RWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXN0RWxlbWVudChhcmd1bWVudCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5SZXN0RWxlbWVudDtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUmVzdEVsZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcblx0dmFyIFJldHVyblN0YXRlbWVudCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQoYXJndW1lbnQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguUmV0dXJuU3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gUmV0dXJuU3RhdGVtZW50O1xuXHR2YXIgU2NyaXB0ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFNjcmlwdChib2R5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlByb2dyYW07XG5cdCAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcblx0ICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnc2NyaXB0Jztcblx0ICAgIH1cblx0ICAgIHJldHVybiBTY3JpcHQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuU2NyaXB0ID0gU2NyaXB0O1xuXHR2YXIgU2VxdWVuY2VFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5TZXF1ZW5jZUV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFNlcXVlbmNlRXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBTZXF1ZW5jZUV4cHJlc3Npb247XG5cdHZhciBTcHJlYWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFNwcmVhZEVsZW1lbnQoYXJndW1lbnQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguU3ByZWFkRWxlbWVudDtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gU3ByZWFkRWxlbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gU3ByZWFkRWxlbWVudDtcblx0dmFyIFN0YXRpY01lbWJlckV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3RhdGljTWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5jb21wdXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXHQgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN0YXRpY01lbWJlckV4cHJlc3Npb24gPSBTdGF0aWNNZW1iZXJFeHByZXNzaW9uO1xuXHR2YXIgU3VwZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU3VwZXIoKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN1cGVyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFN1cGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN1cGVyID0gU3VwZXI7XG5cdHZhciBTd2l0Y2hDYXNlID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaENhc2UodGVzdCwgY29uc2VxdWVudCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5Td2l0Y2hDYXNlO1xuXHQgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG5cdCAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBTd2l0Y2hDYXNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xuXHR2YXIgU3dpdGNoU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlN3aXRjaFN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLmRpc2NyaW1pbmFudCA9IGRpc2NyaW1pbmFudDtcblx0ICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gU3dpdGNoU3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IFN3aXRjaFN0YXRlbWVudDtcblx0dmFyIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy50YWcgPSB0YWc7XG5cdCAgICAgICAgdGhpcy5xdWFzaSA9IHF1YXNpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5cdHZhciBUZW1wbGF0ZUVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KHZhbHVlLCB0YWlsKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlRWxlbWVudDtcblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBUZW1wbGF0ZUVsZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gVGVtcGxhdGVFbGVtZW50O1xuXHR2YXIgVGVtcGxhdGVMaXRlcmFsID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFRlbXBsYXRlTGl0ZXJhbChxdWFzaXMsIGV4cHJlc3Npb25zKSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlRlbXBsYXRlTGl0ZXJhbDtcblx0ICAgICAgICB0aGlzLnF1YXNpcyA9IHF1YXNpcztcblx0ICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsO1xuXHR9KCkpO1xuXHRleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcblx0dmFyIFRoaXNFeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFRoaXNFeHByZXNzaW9uKCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5UaGlzRXhwcmVzc2lvbjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBUaGlzRXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xuXHR2YXIgVGhyb3dTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVGhyb3dTdGF0ZW1lbnQ7XG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRocm93U3RhdGVtZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XG5cdHZhciBUcnlTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVHJ5U3RhdGVtZW50KGJsb2NrLCBoYW5kbGVyLCBmaW5hbGl6ZXIpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVHJ5U3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcblx0ICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHQgICAgICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRyeVN0YXRlbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5UcnlTdGF0ZW1lbnQgPSBUcnlTdGF0ZW1lbnQ7XG5cdHZhciBVbmFyeUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXHQgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcblx0ICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVW5hcnlFeHByZXNzaW9uO1xuXHR9KCkpO1xuXHRleHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcblx0dmFyIFVwZGF0ZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5VcGRhdGVFeHByZXNzaW9uO1xuXHQgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblx0ICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG5cdCAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVXBkYXRlRXhwcmVzc2lvbjtcblx0fSgpKTtcblx0ZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcblx0dmFyIFZhcmlhYmxlRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjtcblx0ICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucyA9IGRlY2xhcmF0aW9ucztcblx0ICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFZhcmlhYmxlRGVjbGFyYXRpb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XG5cdHZhciBWYXJpYWJsZURlY2xhcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSB7XG5cdCAgICAgICAgdGhpcy50eXBlID0gc3ludGF4XzEuU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjtcblx0ICAgICAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBWYXJpYWJsZURlY2xhcmF0b3I7XG5cdH0oKSk7XG5cdGV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gVmFyaWFibGVEZWNsYXJhdG9yO1xuXHR2YXIgV2hpbGVTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5XaGlsZVN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuXHQgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gV2hpbGVTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcblx0dmFyIFdpdGhTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gV2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBzeW50YXhfMS5TeW50YXguV2l0aFN0YXRlbWVudDtcblx0ICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0ICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFdpdGhTdGF0ZW1lbnQ7XG5cdH0oKSk7XG5cdGV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XG5cdHZhciBZaWVsZEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkge1xuXHQgICAgICAgIHRoaXMudHlwZSA9IHN5bnRheF8xLlN5bnRheC5ZaWVsZEV4cHJlc3Npb247XG5cdCAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBZaWVsZEV4cHJlc3Npb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gWWllbGRFeHByZXNzaW9uO1xuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgYXNzZXJ0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgZXJyb3JfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIHNjYW5uZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgc3ludGF4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgdG9rZW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHR2YXIgQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciA9ICdBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyJztcblx0dmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQYXJzZXIoY29kZSwgb3B0aW9ucywgZGVsZWdhdGUpIHtcblx0ICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuXHQgICAgICAgIHRoaXMuY29uZmlnID0ge1xuXHQgICAgICAgICAgICByYW5nZTogKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2UsXG5cdCAgICAgICAgICAgIGxvYzogKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYyxcblx0ICAgICAgICAgICAgc291cmNlOiBudWxsLFxuXHQgICAgICAgICAgICB0b2tlbnM6ICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy50b2tlbnMsXG5cdCAgICAgICAgICAgIGNvbW1lbnQ6ICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMuY29tbWVudCxcblx0ICAgICAgICAgICAgdG9sZXJhbnQ6ICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnRvbGVyYW50XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcubG9jICYmIG9wdGlvbnMuc291cmNlICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29uZmlnLnNvdXJjZSA9IFN0cmluZyhvcHRpb25zLnNvdXJjZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG5ldyBlcnJvcl9oYW5kbGVyXzEuRXJyb3JIYW5kbGVyKCk7XG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhbnQgPSB0aGlzLmNvbmZpZy50b2xlcmFudDtcblx0ICAgICAgICB0aGlzLnNjYW5uZXIgPSBuZXcgc2Nhbm5lcl8xLlNjYW5uZXIoY29kZSwgdGhpcy5lcnJvckhhbmRsZXIpO1xuXHQgICAgICAgIHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQgPSB0aGlzLmNvbmZpZy5jb21tZW50O1xuXHQgICAgICAgIHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlID0ge1xuXHQgICAgICAgICAgICAnKSc6IDAsXG5cdCAgICAgICAgICAgICc7JzogMCxcblx0ICAgICAgICAgICAgJywnOiAwLFxuXHQgICAgICAgICAgICAnPSc6IDAsXG5cdCAgICAgICAgICAgICddJzogMCxcblx0ICAgICAgICAgICAgJ3x8JzogMSxcblx0ICAgICAgICAgICAgJyYmJzogMixcblx0ICAgICAgICAgICAgJ3wnOiAzLFxuXHQgICAgICAgICAgICAnXic6IDQsXG5cdCAgICAgICAgICAgICcmJzogNSxcblx0ICAgICAgICAgICAgJz09JzogNixcblx0ICAgICAgICAgICAgJyE9JzogNixcblx0ICAgICAgICAgICAgJz09PSc6IDYsXG5cdCAgICAgICAgICAgICchPT0nOiA2LFxuXHQgICAgICAgICAgICAnPCc6IDcsXG5cdCAgICAgICAgICAgICc+JzogNyxcblx0ICAgICAgICAgICAgJzw9JzogNyxcblx0ICAgICAgICAgICAgJz49JzogNyxcblx0ICAgICAgICAgICAgJzw8JzogOCxcblx0ICAgICAgICAgICAgJz4+JzogOCxcblx0ICAgICAgICAgICAgJz4+Pic6IDgsXG5cdCAgICAgICAgICAgICcrJzogOSxcblx0ICAgICAgICAgICAgJy0nOiA5LFxuXHQgICAgICAgICAgICAnKic6IDExLFxuXHQgICAgICAgICAgICAnLyc6IDExLFxuXHQgICAgICAgICAgICAnJSc6IDExXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aGlzLmxvb2thaGVhZCA9IHtcblx0ICAgICAgICAgICAgdHlwZTogMiAvKiBFT0YgKi8sXG5cdCAgICAgICAgICAgIHZhbHVlOiAnJyxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogMCxcblx0ICAgICAgICAgICAgc3RhcnQ6IDAsXG5cdCAgICAgICAgICAgIGVuZDogMFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5oYXNMaW5lVGVybWluYXRvciA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dCA9IHtcblx0ICAgICAgICAgICAgaXNNb2R1bGU6IGZhbHNlLFxuXHQgICAgICAgICAgICBhd2FpdDogZmFsc2UsXG5cdCAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG5cdCAgICAgICAgICAgIGFsbG93U3RyaWN0RGlyZWN0aXZlOiB0cnVlLFxuXHQgICAgICAgICAgICBhbGxvd1lpZWxkOiB0cnVlLFxuXHQgICAgICAgICAgICBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I6IG51bGwsXG5cdCAgICAgICAgICAgIGlzQXNzaWdubWVudFRhcmdldDogZmFsc2UsXG5cdCAgICAgICAgICAgIGlzQmluZGluZ0VsZW1lbnQ6IGZhbHNlLFxuXHQgICAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG5cdCAgICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcblx0ICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuXHQgICAgICAgICAgICBsYWJlbFNldDoge30sXG5cdCAgICAgICAgICAgIHN0cmljdDogZmFsc2Vcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMudG9rZW5zID0gW107XG5cdCAgICAgICAgdGhpcy5zdGFydE1hcmtlciA9IHtcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBjb2x1bW46IDBcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlciA9IHtcblx0ICAgICAgICAgICAgaW5kZXg6IDAsXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBjb2x1bW46IDBcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgdGhpcy5sYXN0TWFya2VyID0ge1xuXHQgICAgICAgICAgICBpbmRleDogdGhpcy5zY2FubmVyLmluZGV4LFxuXHQgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIFBhcnNlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlRm9ybWF0KSB7XG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIHZhbHVlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHQgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoLyUoXFxkKS9nLCBmdW5jdGlvbiAod2hvbGUsIGlkeCkge1xuXHQgICAgICAgICAgICBhc3NlcnRfMS5hc3NlcnQoaWR4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzW2lkeF07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sYXN0TWFya2VyLmluZGV4O1xuXHQgICAgICAgIHZhciBsaW5lID0gdGhpcy5sYXN0TWFya2VyLmxpbmU7XG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xuXHQgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2x1bW4sIG1zZyk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50b2xlcmF0ZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VGb3JtYXQpIHtcblx0ICAgICAgICB2YXIgdmFsdWVzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdCAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csIGZ1bmN0aW9uICh3aG9sZSwgaWR4KSB7XG5cdCAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpZHggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaWR4XTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxhc3RNYXJrZXIuaW5kZXg7XG5cdCAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5sYXN0TWFya2VyLmNvbHVtbiArIDE7XG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcihpbmRleCwgbGluZSwgY29sdW1uLCBtc2cpO1xuXHQgICAgfTtcblx0ICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblx0ICAgIFBhcnNlci5wcm90b3R5cGUudW5leHBlY3RlZFRva2VuRXJyb3IgPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICB2YXIgbXNnID0gbWVzc2FnZSB8fCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcblx0ICAgICAgICB2YXIgdmFsdWU7XG5cdCAgICAgICAgaWYgKHRva2VuKSB7XG5cdCAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuXHQgICAgICAgICAgICAgICAgbXNnID0gKHRva2VuLnR5cGUgPT09IDIgLyogRU9GICovKSA/IG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5leHBlY3RlZEVPUyA6XG5cdCAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09IDYgLyogTnVtZXJpY0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4udHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8pID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVGVtcGxhdGUgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbjtcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gJ0lMTEVHQUwnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgnJTAnLCB2YWx1ZSk7XG5cdCAgICAgICAgaWYgKHRva2VuICYmIHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0b2tlbi5zdGFydDtcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0b2tlbi5saW5lTnVtYmVyO1xuXHQgICAgICAgICAgICB2YXIgbGFzdE1hcmtlckxpbmVTdGFydCA9IHRoaXMubGFzdE1hcmtlci5pbmRleCAtIHRoaXMubGFzdE1hcmtlci5jb2x1bW47XG5cdCAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxhc3RNYXJrZXJMaW5lU3RhcnQgKyAxO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGFzdE1hcmtlci5pbmRleDtcblx0ICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxhc3RNYXJrZXIubGluZTtcblx0ICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMubGFzdE1hcmtlci5jb2x1bW4gKyAxO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckhhbmRsZXIuY3JlYXRlRXJyb3IoaW5kZXgsIGxpbmUsIGNvbHVtbiwgbXNnKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbiwgbWVzc2FnZSkge1xuXHQgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZFRva2VuRXJyb3IodG9rZW4sIG1lc3NhZ2UpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIG1lc3NhZ2UpIHtcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmF0ZSh0aGlzLnVuZXhwZWN0ZWRUb2tlbkVycm9yKHRva2VuLCBtZXNzYWdlKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5jb2xsZWN0Q29tbWVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5jb21tZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcblx0ICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5kZWxlZ2F0ZSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tZW50cy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29tbWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5tdWx0aUxpbmUgPyAnQmxvY2tDb21tZW50JyA6ICdMaW5lQ29tbWVudCcsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc291cmNlLnNsaWNlKGUuc2xpY2VbMF0sIGUuc2xpY2VbMV0pXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IGUucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSBlLmxvYztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2Muc3RhcnQubGluZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZS5sb2Muc3RhcnQuY29sdW1uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlLnJhbmdlWzBdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogZS5sb2MuZW5kLmxpbmUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGUubG9jLmVuZC5jb2x1bW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGUucmFuZ2VbMV1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8gRnJvbSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0byBhbiBleHRlcm5hbCBzdHJ1Y3R1cmVcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5SYXcgPSBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnZlcnRUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgIHZhciB0ID0ge1xuXHQgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcblx0ICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pXG5cdCAgICAgICAgfTtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcucmFuZ2UpIHtcblx0ICAgICAgICAgICAgdC5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xuXHQgICAgICAgICAgICB0LmxvYyA9IHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zdGFydE1hcmtlci5saW5lLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zdGFydE1hcmtlci5jb2x1bW5cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnNjYW5uZXIubGluZU51bWJlcixcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuc2Nhbm5lci5pbmRleCAtIHRoaXMuc2Nhbm5lci5saW5lU3RhcnRcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcblx0ICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0b2tlbi5wYXR0ZXJuO1xuXHQgICAgICAgICAgICB2YXIgZmxhZ3MgPSB0b2tlbi5mbGFncztcblx0ICAgICAgICAgICAgdC5yZWdleCA9IHsgcGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0O1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5pbmRleCA9IHRoaXMuc2Nhbm5lci5pbmRleDtcblx0ICAgICAgICB0aGlzLmxhc3RNYXJrZXIubGluZSA9IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyO1xuXHQgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XG5cdCAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pbmRleCAhPT0gdGhpcy5zdGFydE1hcmtlci5pbmRleCkge1xuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmluZGV4ID0gdGhpcy5zY2FubmVyLmluZGV4O1xuXHQgICAgICAgICAgICB0aGlzLnN0YXJ0TWFya2VyLmxpbmUgPSB0aGlzLnNjYW5uZXIubGluZU51bWJlcjtcblx0ICAgICAgICAgICAgdGhpcy5zdGFydE1hcmtlci5jb2x1bW4gPSB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcblx0ICAgICAgICB0aGlzLmhhc0xpbmVUZXJtaW5hdG9yID0gKHRva2VuLmxpbmVOdW1iZXIgIT09IG5leHQubGluZU51bWJlcik7XG5cdCAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5jb250ZXh0LnN0cmljdCAmJiBuZXh0LnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChuZXh0LnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgbmV4dC50eXBlID0gNCAvKiBLZXl3b3JkICovO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMubG9va2FoZWFkID0gbmV4dDtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zICYmIG5leHQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbihuZXh0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm5leHRSZWdleFRva2VuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29sbGVjdENvbW1lbnRzKCk7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5zY2FubmVyLnNjYW5SZWdFeHAoKTtcblx0ICAgICAgICBpZiAodGhpcy5jb25maWcudG9rZW5zKSB7XG5cdCAgICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sICcvJyBvciAnLz0nXG5cdCAgICAgICAgICAgIC8vIFRoaXMgaXMgYWRkZWQgZnJvbSB0aGUgbG9va2FoZWFkIHRva2VuLlxuXHQgICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcblx0ICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0aGlzLmNvbnZlcnRUb2tlbih0b2tlbikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBQcmltZSB0aGUgbmV4dCBsb29rYWhlYWQuXG5cdCAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0b2tlbjtcblx0ICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIHJldHVybiB0b2tlbjtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgaW5kZXg6IHRoaXMuc3RhcnRNYXJrZXIuaW5kZXgsXG5cdCAgICAgICAgICAgIGxpbmU6IHRoaXMuc3RhcnRNYXJrZXIubGluZSxcblx0ICAgICAgICAgICAgY29sdW1uOiB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtblxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5zdGFydE5vZGUgPSBmdW5jdGlvbiAodG9rZW4sIGxhc3RMaW5lU3RhcnQpIHtcblx0ICAgICAgICBpZiAobGFzdExpbmVTdGFydCA9PT0gdm9pZCAwKSB7IGxhc3RMaW5lU3RhcnQgPSAwOyB9XG5cdCAgICAgICAgdmFyIGNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gdG9rZW4ubGluZVN0YXJ0O1xuXHQgICAgICAgIHZhciBsaW5lID0gdG9rZW4ubGluZU51bWJlcjtcblx0ICAgICAgICBpZiAoY29sdW1uIDwgMCkge1xuXHQgICAgICAgICAgICBjb2x1bW4gKz0gbGFzdExpbmVTdGFydDtcblx0ICAgICAgICAgICAgbGluZS0tO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBpbmRleDogdG9rZW4uc3RhcnQsXG5cdCAgICAgICAgICAgIGxpbmU6IGxpbmUsXG5cdCAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKG1hcmtlciwgbm9kZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy5yYW5nZSkge1xuXHQgICAgICAgICAgICBub2RlLnJhbmdlID0gW21hcmtlci5pbmRleCwgdGhpcy5sYXN0TWFya2VyLmluZGV4XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvYykge1xuXHQgICAgICAgICAgICBub2RlLmxvYyA9IHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogbWFya2VyLmxpbmUsXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBtYXJrZXIuY29sdW1uLFxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGVuZDoge1xuXHQgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGFzdE1hcmtlci5saW5lLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sYXN0TWFya2VyLmNvbHVtblxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuc291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLmxvYy5zb3VyY2UgPSB0aGlzLmNvbmZpZy5zb3VyY2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0ge1xuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiBtYXJrZXIubGluZSxcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IG1hcmtlci5jb2x1bW4sXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtYXJrZXIuaW5kZXhcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxhc3RNYXJrZXIubGluZSxcblx0ICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubGFzdE1hcmtlci5jb2x1bW4sXG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxhc3RNYXJrZXIuaW5kZXhcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShub2RlLCBtZXRhZGF0YSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgfTtcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8gUXVpZXRseSBleHBlY3QgYSBjb21tYSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXMgdG8gZXhwZWN0KCkuXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmV4cGVjdENvbW1hU2VwYXJhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbmZpZy50b2xlcmFudCkge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJywnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJzsnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG5cdCAgICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblx0ICAgIFBhcnNlci5wcm90b3R5cGUuZXhwZWN0S2V5d29yZCA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gNCAvKiBLZXl3b3JkICovIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblx0ICAgIFBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSA0IC8qIEtleXdvcmQgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnRleHR1YWwga2V5d29yZFxuXHQgICAgLy8gKHdoZXJlIGFuIGlkZW50aWZpZXIgaXMgc29tZXRpbWVzIGEga2V5d29yZCBkZXBlbmRpbmcgb24gdGhlIGNvbnRleHQpXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQ29udGV4dHVhbEtleXdvcmQgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdGhpcy5sb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFzc2lnbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gNyAvKiBQdW5jdHVhdG9yICovKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG9wID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XG5cdCAgICAgICAgcmV0dXJuIG9wID09PSAnPScgfHxcblx0ICAgICAgICAgICAgb3AgPT09ICcqPScgfHxcblx0ICAgICAgICAgICAgb3AgPT09ICcqKj0nIHx8XG5cdCAgICAgICAgICAgIG9wID09PSAnLz0nIHx8XG5cdCAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XG5cdCAgICAgICAgICAgIG9wID09PSAnKz0nIHx8XG5cdCAgICAgICAgICAgIG9wID09PSAnLT0nIHx8XG5cdCAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxuXHQgICAgICAgICAgICBvcCA9PT0gJz4+PScgfHxcblx0ICAgICAgICAgICAgb3AgPT09ICc+Pj49JyB8fFxuXHQgICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxuXHQgICAgICAgICAgICBvcCA9PT0gJ149JyB8fFxuXHQgICAgICAgICAgICBvcCA9PT0gJ3w9Jztcblx0ICAgIH07XG5cdCAgICAvLyBDb3ZlciBncmFtbWFyIHN1cHBvcnQuXG5cdCAgICAvL1xuXHQgICAgLy8gV2hlbiBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24gcG9zaXRpb24gc3RhcnRzIHdpdGggYW4gbGVmdCBwYXJlbnRoZXNpcywgdGhlIGRldGVybWluYXRpb24gb2YgdGhlIHR5cGVcblx0ICAgIC8vIG9mIHRoZSBzeW50YXggaXMgdG8gYmUgZGVmZXJyZWQgYXJiaXRyYXJpbHkgbG9uZyB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnRoZXNlcyBwYWlyIChwbHVzIGEgbG9va2FoZWFkKVxuXHQgICAgLy8gb3IgdGhlIGZpcnN0IGNvbW1hLiBUaGlzIHNpdHVhdGlvbiBhbHNvIGRlZmVycyB0aGUgZGV0ZXJtaW5hdGlvbiBvZiBhbGwgdGhlIGV4cHJlc3Npb25zIG5lc3RlZCBpbiB0aGUgcGFpci5cblx0ICAgIC8vXG5cdCAgICAvLyBUaGVyZSBhcmUgdGhyZWUgcHJvZHVjdGlvbnMgdGhhdCBjYW4gYmUgcGFyc2VkIGluIGEgcGFyZW50aGVzZXMgcGFpciB0aGF0IG5lZWRzIHRvIGJlIGRldGVybWluZWRcblx0ICAgIC8vIGFmdGVyIHRoZSBvdXRlcm1vc3QgcGFpciBpcyBjbG9zZWQuIFRoZXkgYXJlOlxuXHQgICAgLy9cblx0ICAgIC8vICAgMS4gQXNzaWdubWVudEV4cHJlc3Npb25cblx0ICAgIC8vICAgMi4gQmluZGluZ0VsZW1lbnRzXG5cdCAgICAvLyAgIDMuIEFzc2lnbm1lbnRUYXJnZXRzXG5cdCAgICAvL1xuXHQgICAgLy8gSW4gb3JkZXIgdG8gYXZvaWQgZXhwb25lbnRpYWwgYmFja3RyYWNraW5nLCB3ZSB1c2UgdHdvIGZsYWdzIHRvIGRlbm90ZSBpZiB0aGUgcHJvZHVjdGlvbiBjYW4gYmVcblx0ICAgIC8vIGJpbmRpbmcgZWxlbWVudCBvciBhc3NpZ25tZW50IHRhcmdldC5cblx0ICAgIC8vXG5cdCAgICAvLyBUaGUgdGhyZWUgcHJvZHVjdGlvbnMgaGF2ZSB0aGUgcmVsYXRpb25zaGlwOlxuXHQgICAgLy9cblx0ICAgIC8vICAgQmluZGluZ0VsZW1lbnRzIOKKhiBBc3NpZ25tZW50VGFyZ2V0cyDiioYgQXNzaWdubWVudEV4cHJlc3Npb25cblx0ICAgIC8vXG5cdCAgICAvLyB3aXRoIGEgc2luZ2xlIGV4Y2VwdGlvbiB0aGF0IENvdmVySW5pdGlhbGl6ZWROYW1lIHdoZW4gdXNlZCBkaXJlY3RseSBpbiBhbiBFeHByZXNzaW9uLCBnZW5lcmF0ZXNcblx0ICAgIC8vIGFuIGVhcmx5IGVycm9yLiBUaGVyZWZvcmUsIHdlIG5lZWQgdGhlIHRoaXJkIHN0YXRlLCBmaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IsIHRvIHRyYWNrIHRoZVxuXHQgICAgLy8gZmlyc3QgdXNhZ2Ugb2YgQ292ZXJJbml0aWFsaXplZE5hbWUgYW5kIHJlcG9ydCBpdCB3aGVuIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcGFyZW50aGVzZXMgcGFpci5cblx0ICAgIC8vXG5cdCAgICAvLyBpc29sYXRlQ292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlciBmdW5jdGlvbiB3aXRoIGEgbmV3IGNvdmVyIGdyYW1tYXIgY29udGV4dCwgYW5kIGl0IGRvZXMgbm90XG5cdCAgICAvLyBlZmZlY3QgdGhlIGN1cnJlbnQgZmxhZ3MuIFRoaXMgbWVhbnMgdGhlIHByb2R1Y3Rpb24gdGhlIHBhcnNlciBwYXJzZXMgaXMgb25seSB1c2VkIGFzIGFuIGV4cHJlc3Npb24uIFRoZXJlZm9yZVxuXHQgICAgLy8gdGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGNvbmR1Y3RlZC5cblx0ICAgIC8vXG5cdCAgICAvLyBpbmhlcml0Q292ZXJHcmFtbWFyIGZ1bmN0aW9uIHJ1bnMgdGhlIGdpdmVuIHBhcnNlIGZ1bmN0aW9uIHdpdGggYSBuZXcgY292ZXIgZ3JhbW1hciBjb250ZXh0LCBhbmQgaXQgcHJvcGFnYXRlc1xuXHQgICAgLy8gdGhlIGZsYWdzIG91dHNpZGUgb2YgdGhlIHBhcnNlci4gVGhpcyBtZWFucyB0aGUgcHJvZHVjdGlvbiB0aGUgcGFyc2VyIHBhcnNlcyBpcyB1c2VkIGFzIGEgcGFydCBvZiBhIHBvdGVudGlhbFxuXHQgICAgLy8gcGF0dGVybi4gVGhlIENvdmVySW5pdGlhbGl6ZWROYW1lIGNoZWNrIGlzIGRlZmVycmVkLlxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc29sYXRlQ292ZXJHcmFtbWFyID0gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50ID0gdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQ7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzSXNBc3NpZ25tZW50VGFyZ2V0ID0gdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldDtcblx0ICAgICAgICB2YXIgcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbi5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gcHJldmlvdXNJc0JpbmRpbmdFbGVtZW50O1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBwcmV2aW91c0lzQXNzaWdubWVudFRhcmdldDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gcHJldmlvdXNGaXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmluaGVyaXRDb3ZlckdyYW1tYXIgPSBmdW5jdGlvbiAocGFyc2VGdW5jdGlvbikge1xuXHQgICAgICAgIHZhciBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudDtcblx0ICAgICAgICB2YXIgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQgPSB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0O1xuXHQgICAgICAgIHZhciBwcmV2aW91c0ZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUZ1bmN0aW9uLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCAmJiBwcmV2aW91c0lzQmluZGluZ0VsZW1lbnQ7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgJiYgcHJldmlvdXNJc0Fzc2lnbm1lbnRUYXJnZXQ7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmZpcnN0Q292ZXJJbml0aWFsaXplZE5hbWVFcnJvciA9IHByZXZpb3VzRmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yIHx8IHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3I7XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmNvbnN1bWVTZW1pY29sb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8gJiYgIXRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmluZGV4ID0gdGhpcy5zdGFydE1hcmtlci5pbmRleDtcblx0ICAgICAgICAgICAgdGhpcy5sYXN0TWFya2VyLmxpbmUgPSB0aGlzLnN0YXJ0TWFya2VyLmxpbmU7XG5cdCAgICAgICAgICAgIHRoaXMubGFzdE1hcmtlci5jb2x1bW4gPSB0aGlzLnN0YXJ0TWFya2VyLmNvbHVtbjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJpbWFyeS1leHByZXNzaW9uXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgZXhwcjtcblx0ICAgICAgICB2YXIgdG9rZW4sIHJhdztcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XG5cdCAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnYXdhaXQnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSA/IHRoaXMucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKSA6IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0aGlzLm5leHRUb2tlbigpLnZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLm9jdGFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSwgcmF3KSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTGl0ZXJhbCh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnLCByYXcpKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5MaXRlcmFsKG51bGwsIHJhdykpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgNyAvKiBQdW5jdHVhdG9yICovOlxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VHcm91cEV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXJyYXlJbml0aWFsaXplcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VPYmplY3RJbml0aWFsaXplcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJy89Jzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuaW5kZXggPSB0aGlzLnN0YXJ0TWFya2VyLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFJlZ2V4VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlZ2V4TGl0ZXJhbCh0b2tlbi5yZWdleCwgcmF3LCB0b2tlbi5wYXR0ZXJuLCB0b2tlbi5mbGFncykpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodGhpcy5uZXh0VG9rZW4oKS52YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdmdW5jdGlvbicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd0aGlzJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhpc0V4cHJlc3Npb24oKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjbGFzcycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQ2xhc3NFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS1pbml0aWFsaXplclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNwcmVhZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnLi4uJyk7XG5cdCAgICAgICAgdmFyIGFyZyA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNwcmVhZEVsZW1lbnQoYXJnKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFycmF5SW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTcHJlYWRFbGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ10nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJheUV4cHJlc3Npb24oZWxlbWVudHMpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtaW5pdGlhbGl6ZXJcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQcm9wZXJ0eU1ldGhvZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgcHJldmlvdXNTdHJpY3QgPSB0aGlzLmNvbnRleHQuc3RyaWN0O1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlID0gdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSA9IHBhcmFtcy5zaW1wbGU7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMpO1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5maXJzdFJlc3RyaWN0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihwYXJhbXMuZmlyc3RSZXN0cmljdGVkLCBwYXJhbXMubWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHBhcmFtcy5zdHJpY3RlZCkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHBhcmFtcy5zdHJpY3RlZCwgcGFyYW1zLm1lc3NhZ2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcblx0ICAgICAgICByZXR1cm4gYm9keTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5TWV0aG9kQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcblx0ICAgICAgICB2YXIgcHJldmlvdXNBd2FpdCA9IHRoaXMuY29udGV4dC5hd2FpdDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgcGFyYW1zLnBhcmFtcywgbWV0aG9kKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdFByb3BlcnR5S2V5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB2YXIga2V5O1xuXHQgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIDggLyogU3RyaW5nTGl0ZXJhbCAqLzpcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5nZXRUb2tlblJhdyh0b2tlbik7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgMyAvKiBJZGVudGlmaWVyICovOlxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcblx0ICAgICAgICAgICAgY2FzZSA0IC8qIEtleXdvcmQgKi86XG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLklkZW50aWZpZXIodG9rZW4udmFsdWUpKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcblx0ICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGtleTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzUHJvcGVydHlLZXkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoa2V5LnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIGtleS5uYW1lID09PSB2YWx1ZSkgfHxcblx0ICAgICAgICAgICAgKGtleS50eXBlID09PSBzeW50YXhfMS5TeW50YXguTGl0ZXJhbCAmJiBrZXkudmFsdWUgPT09IHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UHJvcGVydHkgPSBmdW5jdGlvbiAoaGFzUHJvdG8pIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgIHZhciBraW5kO1xuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdG9rZW4udmFsdWU7XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xuXHQgICAgICAgICAgICBpc0FzeW5jID0gIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgKGlkID09PSAnYXN5bmMnKSAmJlxuXHQgICAgICAgICAgICAgICAgIXRoaXMubWF0Y2goJzonKSAmJiAhdGhpcy5tYXRjaCgnKCcpICYmICF0aGlzLm1hdGNoKCcqJykgJiYgIXRoaXMubWF0Y2goJywnKTtcblx0ICAgICAgICAgICAga2V5ID0gaXNBc3luYyA/IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIDogdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZGVudGlmaWVyKGlkKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAhaXNBc3luYyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2dldCcgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcblx0ICAgICAgICAgICAga2luZCA9ICdnZXQnO1xuXHQgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIWlzQXN5bmMgJiYgdG9rZW4udmFsdWUgPT09ICdzZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XG5cdCAgICAgICAgICAgIGtpbmQgPSAnc2V0Jztcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VTZXR0ZXJNZXRob2QoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gNyAvKiBQdW5jdHVhdG9yICovICYmIHRva2VuLnZhbHVlID09PSAnKicgJiYgbG9va2FoZWFkUHJvcGVydHlLZXkpIHtcblx0ICAgICAgICAgICAga2luZCA9ICdpbml0Jztcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VHZW5lcmF0b3JNZXRob2QoKTtcblx0ICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICgha2V5KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBraW5kID0gJ2luaXQnO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnOicpICYmICFpc0FzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbXB1dGVkICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdfX3Byb3RvX18nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm90by52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVQcm90b1Byb3BlcnR5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzUHJvdG8udmFsdWUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXN5bmMgPyB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RBc3luY0Z1bmN0aW9uKCkgOiB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2RGdW5jdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4oaWQsIGluaXQpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHNob3J0aGFuZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoa2luZCwga2V5LCBjb21wdXRlZCwgdmFsdWUsIG1ldGhvZCwgc2hvcnRoYW5kKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9iamVjdEluaXRpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcblx0ICAgICAgICB2YXIgcHJvcGVydGllcyA9IFtdO1xuXHQgICAgICAgIHZhciBoYXNQcm90byA9IHsgdmFsdWU6IGZhbHNlIH07XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKCd9JykpIHtcblx0ICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShoYXNQcm90bykpO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbHNcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KHRoaXMubG9va2FoZWFkLmhlYWQsICdUZW1wbGF0ZSBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHRlbXBsYXRlIGhlYWQnKTtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgdmFyIHJhdyA9IHRva2VuLnZhbHVlO1xuXHQgICAgICAgIHZhciBjb29rZWQgPSB0b2tlbi5jb29rZWQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVFbGVtZW50KHsgcmF3OiByYXcsIGNvb2tlZDogY29va2VkIH0sIHRva2VuLnRhaWwpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAxMCAvKiBUZW1wbGF0ZSAqLykge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB2YXIgcmF3ID0gdG9rZW4udmFsdWU7XG5cdCAgICAgICAgdmFyIGNvb2tlZCA9IHRva2VuLmNvb2tlZDtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5UZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHJhdywgY29va2VkOiBjb29rZWQgfSwgdG9rZW4udGFpbCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcblx0ICAgICAgICB2YXIgcXVhc2lzID0gW107XG5cdCAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlSGVhZCgpO1xuXHQgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcblx0ICAgICAgICB3aGlsZSAoIXF1YXNpLnRhaWwpIHtcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcblx0ICAgICAgICAgICAgcXVhc2kgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KCk7XG5cdCAgICAgICAgICAgIHF1YXNpcy5wdXNoKHF1YXNpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1ncm91cGluZy1vcGVyYXRvclxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4gPSBmdW5jdGlvbiAoZXhwcikge1xuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50OlxuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5TcHJlYWRFbGVtZW50OlxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LlJlc3RFbGVtZW50O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwci5hcmd1bWVudCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlFeHByZXNzaW9uOlxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4LkFycmF5UGF0dGVybjtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChleHByLmVsZW1lbnRzW2ldICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIuZWxlbWVudHNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxuXHQgICAgICAgICAgICAgICAgZXhwci50eXBlID0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIucHJvcGVydGllc1tpXS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG5cdCAgICAgICAgICAgICAgICBleHByLnR5cGUgPSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgZXhwci5vcGVyYXRvcjtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIubGVmdCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIG5vZGUgdHlwZSBmb3IgdG9sZXJhbnQgcGFyc2luZy5cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXBFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBleHByO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc9PicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGV4cHIgPSB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuXHQgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLi4uJykpIHtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcblx0ICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2Vcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXJyb3cgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcsJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VSZXN0RWxlbWVudChwYXJhbXMpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJz0+JykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnPT4nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oZXhwcmVzc2lvbnNbaV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyb3cgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZXhwcmVzc2lvbnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycm93KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIWFycm93KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPT4nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiBleHByLm5hbWUgPT09ICd5aWVsZCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtleHByXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcnJvdykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByLmV4cHJlc3Npb25zW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihleHByKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gKGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LlNlcXVlbmNlRXhwcmVzc2lvbiA/IGV4cHIuZXhwcmVzc2lvbnMgOiBbZXhwcl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1ldGVycyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1sZWZ0LWhhbmQtc2lkZS1leHByZXNzaW9uc1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q29tbWFTZXBhcmF0b3IoKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xuXHQgICAgICAgIHJldHVybiBhcmdzO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuaXNJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHxcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNCAvKiBLZXl3b3JkICovIHx8XG5cdCAgICAgICAgICAgIHRva2VuLnR5cGUgPT09IDEgLyogQm9vbGVhbkxpdGVyYWwgKi8gfHxcblx0ICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gNSAvKiBOdWxsTGl0ZXJhbCAqLztcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIGlmICghdGhpcy5pc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRva2VuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XG5cdCAgICAgICAgYXNzZXJ0XzEuYXNzZXJ0KGlkLm5hbWUgPT09ICduZXcnLCAnTmV3IGV4cHJlc3Npb24gbXVzdCBzdGFydCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgdmFyIGV4cHI7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmIHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSAmJiB0aGlzLmxvb2thaGVhZC52YWx1ZSA9PT0gJ3RhcmdldCcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IG5ldyBOb2RlLk1ldGFQcm9wZXJ0eShpZCwgcHJvcGVydHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBjYWxsZWUgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMubWF0Y2goJygnKSA/IHRoaXMucGFyc2VBcmd1bWVudHMoKSA6IFtdO1xuXHQgICAgICAgICAgICBleHByID0gbmV3IE5vZGUuTmV3RXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIGV4cHIpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZmlyc3RDb3ZlckluaXRpYWxpemVkTmFtZUVycm9yID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gYXJnO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBc3luY0FyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKCcpO1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlU3ByZWFkRWxlbWVudCgpIDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzeW5jQXJndW1lbnQpO1xuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDb21tYVNlcGFyYXRvcigpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJyknKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICB2YXIgbWF5YmVBc3luYyA9IHRoaXMubWF0Y2hDb250ZXh0dWFsS2V5d29yZCgnYXN5bmMnKTtcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSB0cnVlO1xuXHQgICAgICAgIHZhciBleHByO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpIHtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZShleHByLCBuZXcgTm9kZS5TdXBlcigpKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykgJiYgIXRoaXMubWF0Y2goJy4nKSAmJiAhdGhpcy5tYXRjaCgnWycpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLm1hdGNoS2V5d29yZCgnbmV3JykgPyB0aGlzLnBhcnNlTmV3RXhwcmVzc2lvbiA6IHRoaXMucGFyc2VQcmltYXJ5RXhwcmVzc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcuJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcuJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TdGF0aWNNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKCcpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IG1heWJlQXN5bmMgJiYgKHN0YXJ0VG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhc3luY0Fycm93ID8gdGhpcy5wYXJzZUFzeW5jQXJndW1lbnRzKCkgOiB0aGlzLnBhcnNlQXJndW1lbnRzKCk7XG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncykpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGFzeW5jQXJyb3cgJiYgdGhpcy5tYXRjaCgnPT4nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihhcmdzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBhcmdzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnWycpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XG5cdCAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKGV4cHIsIHByb3BlcnR5KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMTAgLyogVGVtcGxhdGUgKi8gJiYgdGhpcy5sb29rYWhlYWQuaGVhZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlTGl0ZXJhbCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN1cGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdzdXBlcicpO1xuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnWycpICYmICF0aGlzLm1hdGNoKCcuJykpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN1cGVyKCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydCh0aGlzLmNvbnRleHQuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICB2YXIgZXhwciA9ICh0aGlzLm1hdGNoS2V5d29yZCgnc3VwZXInKSAmJiB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkpID8gdGhpcy5wYXJzZVN1cGVyKCkgOlxuXHQgICAgICAgICAgICB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5tYXRjaEtleXdvcmQoJ25ldycpID8gdGhpcy5wYXJzZU5ld0V4cHJlc3Npb24gOiB0aGlzLnBhcnNlUHJpbWFyeUV4cHJlc3Npb24pO1xuXHQgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCdbJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCdbJyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJ10nKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJy4nKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJy4nKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3RhdGljTWVtYmVyRXhwcmVzc2lvbihleHByLCBwcm9wZXJ0eSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDEwIC8qIFRlbXBsYXRlICovICYmIHRoaXMubG9va2FoZWFkLmhlYWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBxdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZUxpdGVyYWwoKTtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihleHByLCBxdWFzaSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdXBkYXRlLWV4cHJlc3Npb25zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVXBkYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZXhwcjtcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCcrKycpIHx8IHRoaXMubWF0Y2goJy0tJykpIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKTtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZXhwci50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHByZWZpeCA9IHRydWU7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlVwZGF0ZUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIsIHByZWZpeCkpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJysrJykgfHwgdGhpcy5tYXRjaCgnLS0nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNQb3N0Zml4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuVXBkYXRlRXhwcmVzc2lvbihvcGVyYXRvciwgZXhwciwgcHJlZml4KSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdW5hcnktb3BlcmF0b3JzXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXdhaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSB0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXdhaXRFeHByZXNzaW9uKGFyZ3VtZW50KSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZXhwcjtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKycpIHx8IHRoaXMubWF0Y2goJy0nKSB8fCB0aGlzLm1hdGNoKCd+JykgfHwgdGhpcy5tYXRjaCgnIScpIHx8XG5cdCAgICAgICAgICAgIHRoaXMubWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCB0aGlzLm1hdGNoS2V5d29yZCgndm9pZCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlVW5hcnlFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNCaW5kaW5nRWxlbWVudCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRleHQuYXdhaXQgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhd2FpdCcpKSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXRFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVVwZGF0ZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9uZW50aWF0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pbmhlcml0Q292ZXJHcmFtbWFyKHRoaXMucGFyc2VVbmFyeUV4cHJlc3Npb24pO1xuXHQgICAgICAgIGlmIChleHByLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5VbmFyeUV4cHJlc3Npb24gJiYgdGhpcy5tYXRjaCgnKionKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBsZWZ0ID0gZXhwcjtcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbignKionLCBsZWZ0LCByaWdodCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1leHAtb3BlcmF0b3Jcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW11bHRpcGxpY2F0aXZlLW9wZXJhdG9yc1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWRkaXRpdmUtb3BlcmF0b3JzXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaXR3aXNlLXNoaWZ0LW9wZXJhdG9yc1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVsYXRpb25hbC1vcGVyYXRvcnNcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVxdWFsaXR5LW9wZXJhdG9yc1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmluYXJ5LWJpdHdpc2Utb3BlcmF0b3JzXG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1iaW5hcnktbG9naWNhbC1vcGVyYXRvcnNcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuYmluYXJ5UHJlY2VkZW5jZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuXHQgICAgICAgIHZhciBvcCA9IHRva2VuLnZhbHVlO1xuXHQgICAgICAgIHZhciBwcmVjZWRlbmNlO1xuXHQgICAgICAgIGlmICh0b2tlbi50eXBlID09PSA3IC8qIFB1bmN0dWF0b3IgKi8pIHtcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IHRoaXMub3BlcmF0b3JQcmVjZWRlbmNlW29wXSB8fCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcblx0ICAgICAgICAgICAgcHJlY2VkZW5jZSA9IChvcCA9PT0gJ2luc3RhbmNlb2YnIHx8ICh0aGlzLmNvbnRleHQuYWxsb3dJbiAmJiBvcCA9PT0gJ2luJykpID8gNyA6IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwcmVjZWRlbmNlID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHByZWNlZGVuY2U7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuaW5oZXJpdENvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcblx0ICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICB2YXIgcHJlYyA9IHRoaXMuYmluYXJ5UHJlY2VkZW5jZSh0b2tlbik7XG5cdCAgICAgICAgaWYgKHByZWMgPiAwKSB7XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIG1hcmtlcnMgPSBbc3RhcnRUb2tlbiwgdGhpcy5sb29rYWhlYWRdO1xuXHQgICAgICAgICAgICB2YXIgbGVmdCA9IGV4cHI7XG5cdCAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlRXhwb25lbnRpYXRpb25FeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgdmFyIHN0YWNrID0gW2xlZnQsIHRva2VuLnZhbHVlLCByaWdodF07XG5cdCAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlcyA9IFtwcmVjXTtcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIHByZWMgPSB0aGlzLmJpbmFyeVByZWNlZGVuY2UodGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHByZWMgPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBwcmVjZWRlbmNlc1twcmVjZWRlbmNlcy5sZW5ndGggLSAxXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHN0YWNrLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBTaGlmdC5cblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5uZXh0VG9rZW4oKS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlcy5wdXNoKHByZWMpO1xuXHQgICAgICAgICAgICAgICAgbWFya2Vycy5wdXNoKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VFeHBvbmVudGlhdGlvbkV4cHJlc3Npb24pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxuXHQgICAgICAgICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgIGV4cHIgPSBzdGFja1tpXTtcblx0ICAgICAgICAgICAgdmFyIGxhc3RNYXJrZXIgPSBtYXJrZXJzLnBvcCgpO1xuXHQgICAgICAgICAgICB3aGlsZSAoaSA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lU3RhcnQgPSBsYXN0TWFya2VyICYmIGxhc3RNYXJrZXIubGluZVN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZShtYXJrZXIsIGxhc3RMaW5lU3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gc3RhY2tbaSAtIDFdO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgc3RhY2tbaSAtIDJdLCBleHByKSk7XG5cdCAgICAgICAgICAgICAgICBpIC09IDI7XG5cdCAgICAgICAgICAgICAgICBsYXN0TWFya2VyID0gbWFya2VyO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbmRpdGlvbmFsLW9wZXJhdG9yXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBzdGFydFRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUJpbmFyeUV4cHJlc3Npb24pO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc/JykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHRydWU7XG5cdCAgICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xuXHQgICAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5Db25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXNzaWdubWVudC1vcGVyYXRvcnNcblx0ICAgIFBhcnNlci5wcm90b3R5cGUuY2hlY2tQYXR0ZXJuUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0pIHtcblx0ICAgICAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcjpcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQYXJhbShvcHRpb25zLCBwYXJhbSwgcGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguUmVzdEVsZW1lbnQ6XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmFyZ3VtZW50KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIHN5bnRheF8xLlN5bnRheC5Bc3NpZ25tZW50UGF0dGVybjpcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ubGVmdCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuOlxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS5lbGVtZW50c1tpXSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGF0dGVyblBhcmFtKG9wdGlvbnMsIHBhcmFtLmVsZW1lbnRzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBzeW50YXhfMS5TeW50YXguT2JqZWN0UGF0dGVybjpcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0ucHJvcGVydGllc1tpXS52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdCA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtleHByXTtcblx0ICAgICAgICB2YXIgb3B0aW9ucztcblx0ICAgICAgICB2YXIgYXN5bmNBcnJvdyA9IGZhbHNlO1xuXHQgICAgICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG5cdCAgICAgICAgICAgIGNhc2Ugc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zID0gZXhwci5wYXJhbXM7XG5cdCAgICAgICAgICAgICAgICBhc3luY0Fycm93ID0gZXhwci5hc3luYztcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgICAgIHNpbXBsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgcGFyYW1TZXQ6IHt9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudFBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yaWdodC50eXBlID09PSBzeW50YXhfMS5TeW50YXguWWllbGRFeHByZXNzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnJpZ2h0LmFyZ3VtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbS5yaWdodC50eXBlID0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmlnaHQubmFtZSA9ICd5aWVsZCc7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtLnJpZ2h0LmFyZ3VtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbS5yaWdodC5kZWxlZ2F0ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChhc3luY0Fycm93ICYmIHBhcmFtLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyICYmIHBhcmFtLm5hbWUgPT09ICdhd2FpdCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuUGFyYW0ob3B0aW9ucywgcGFyYW0pO1xuXHQgICAgICAgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgIXRoaXMuY29udGV4dC5hbGxvd1lpZWxkKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJhbXNbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LllpZWxkRXhwcmVzc2lvbikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UgPT09IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1EdXBlKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuY29udGV4dC5zdHJpY3QgPyBvcHRpb25zLnN0cmljdGVkIDogb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQ7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG9wdGlvbnMubWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHNpbXBsZTogb3B0aW9ucy5zaW1wbGUsXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGV4cHI7XG5cdCAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkge1xuXHQgICAgICAgICAgICBleHByID0gdGhpcy5wYXJzZVlpZWxkRXhwcmVzc2lvbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRUb2tlbjtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMucGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiAodG9rZW4ubGluZU51bWJlciA9PT0gdGhpcy5sb29rYWhlYWQubGluZU51bWJlcikgJiYgdG9rZW4udmFsdWUgPT09ICdhc3luYycpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gfHwgdGhpcy5tYXRjaEtleXdvcmQoJ3lpZWxkJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oYXJnKTtcblx0ICAgICAgICAgICAgICAgICAgICBleHByID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcnJvd1BhcmFtZXRlclBsYWNlSG9sZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFthcmddLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gQXJyb3dQYXJhbWV0ZXJQbGFjZUhvbGRlciB8fCB0aGlzLm1hdGNoKCc9PicpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJvdy1mdW5jdGlvbi1kZWZpbml0aW9uc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQXNzaWdubWVudFRhcmdldCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHZhciBpc0FzeW5jID0gZXhwci5hc3luYztcblx0ICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5yZWludGVycHJldEFzQ292ZXJGb3JtYWxzTGlzdChleHByKTtcblx0ICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gbGlzdC5zaW1wbGU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbik7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0+Jyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGJvZHkudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LkJsb2NrU3RhdGVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3QuZmlyc3RSZXN0cmljdGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obGlzdC5maXJzdFJlc3RyaWN0ZWQsIGxpc3QubWVzc2FnZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGxpc3Quc3RyaWN0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihsaXN0LnN0cmljdGVkLCBsaXN0Lm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBleHByID0gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpIDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihsaXN0LnBhcmFtcywgYm9keSwgZXhwcmVzc2lvbikpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQXdhaXQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEFzc2lnbigpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkFzc2lnbm1lbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGV4cHI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RMSFNBc3NpZ25tZW50KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZC5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnPScpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlzQmluZGluZ0VsZW1lbnQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVpbnRlcnByZXRFeHByZXNzaW9uQXNQYXR0ZXJuKGV4cHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdG9rZW4udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoc3RhcnRUb2tlbiksIG5ldyBOb2RlLkFzc2lnbm1lbnRFeHByZXNzaW9uKG9wZXJhdG9yLCBleHByLCByaWdodCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maXJzdENvdmVySW5pdGlhbGl6ZWROYW1lRXJyb3IgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1hLW9wZXJhdG9yXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xuXHQgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcblx0ICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByKTtcblx0ICAgICAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goJywnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2godGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmFsaXplKHRoaXMuc3RhcnROb2RlKHN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYmxvY2tcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhdGVtZW50O1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pc0JpbmRpbmdFbGVtZW50ID0gdHJ1ZTtcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsRXhwb3J0RGVjbGFyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNNb2R1bGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLmxvb2thaGVhZCwgbWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnN0Jzpcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdjbGFzcyc6XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5pc0xleGljYWxEZWNsYXJhdGlvbigpID8gdGhpcy5wYXJzZUxleGljYWxEZWNsYXJhdGlvbih7IGluRm9yOiBmYWxzZSB9KSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBbXTtcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBibG9jay5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5CbG9ja1N0YXRlbWVudChibG9jaykpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxldC1hbmQtY29uc3QtZGVjbGFyYXRpb25zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTGV4aWNhbEJpbmRpbmcgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuXHQgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKGlkLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdjb25zdCcpIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoS2V5d29yZCgnaW4nKSAmJiAhdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgJ2NvbnN0Jyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoKCFvcHRpb25zLmluRm9yICYmIGlkLnR5cGUgIT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSB8fCB0aGlzLm1hdGNoKCc9JykpIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcblx0ICAgICAgICAgICAgaW5pdCA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0b3IoaWQsIGluaXQpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ0xpc3QgPSBmdW5jdGlvbiAoa2luZCwgb3B0aW9ucykge1xuXHQgICAgICAgIHZhciBsaXN0ID0gW3RoaXMucGFyc2VMZXhpY2FsQmluZGluZyhraW5kLCBvcHRpb25zKV07XG5cdCAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5wYXJzZUxleGljYWxCaW5kaW5nKGtpbmQsIG9wdGlvbnMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpc3Q7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5pc0xleGljYWxEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnNjYW5uZXIuc2F2ZVN0YXRlKCk7XG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5zY2FubmVyLmxleCgpO1xuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5yZXN0b3JlU3RhdGUoc3RhdGUpO1xuXHQgICAgICAgIHJldHVybiAobmV4dC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pIHx8XG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAnWycpIHx8XG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiBuZXh0LnZhbHVlID09PSAneycpIHx8XG5cdCAgICAgICAgICAgIChuZXh0LnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiBuZXh0LnZhbHVlID09PSAnbGV0JykgfHxcblx0ICAgICAgICAgICAgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovICYmIG5leHQudmFsdWUgPT09ICd5aWVsZCcpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VMZXhpY2FsRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChraW5kID09PSAnbGV0JyB8fCBraW5kID09PSAnY29uc3QnLCAnTGV4aWNhbCBkZWNsYXJhdGlvbiBtdXN0IGJlIGVpdGhlciBsZXQgb3IgY29uc3QnKTtcblx0ICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIG9wdGlvbnMpO1xuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVzdHJ1Y3R1cmluZy1iaW5kaW5nLXBhdHRlcm5zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcywga2luZCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsIGtpbmQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJlc3RFbGVtZW50KGFyZykpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBcnJheVBhdHRlcm4gPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnWycpO1xuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnXScpKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcsJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJy4uLicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlQmluZGluZ1Jlc3RFbGVtZW50KHBhcmFtcywga2luZCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzLnBhcnNlUGF0dGVybldpdGhEZWZhdWx0KHBhcmFtcywga2luZCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCddJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCddJyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBjb21wdXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBzaG9ydGhhbmQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgbWV0aG9kID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIGtleTtcblx0ICAgICAgICB2YXIgdmFsdWU7XG5cdCAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xuXHQgICAgICAgICAgICB2YXIga2V5VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXHQgICAgICAgICAgICB2YXIgaW5pdCA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcihrZXlUb2tlbi52YWx1ZSkpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChrZXlUb2tlbik7XG5cdCAgICAgICAgICAgICAgICBzaG9ydGhhbmQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoa2V5VG9rZW4pLCBuZXcgTm9kZS5Bc3NpZ25tZW50UGF0dGVybihpbml0LCBleHByKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMubWF0Y2goJzonKSkge1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goa2V5VG9rZW4pO1xuXHQgICAgICAgICAgICAgICAgc2hvcnRoYW5kID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOicpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zLCBraW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuUHJvcGVydHkoJ2luaXQnLCBrZXksIGNvbXB1dGVkLCB2YWx1ZSwgbWV0aG9kLCBzaG9ydGhhbmQpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlT2JqZWN0UGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ3snKTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2godGhpcy5wYXJzZVByb3BlcnR5UGF0dGVybihwYXJhbXMsIGtpbmQpKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5PYmplY3RQYXR0ZXJuKHByb3BlcnRpZXMpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlUGF0dGVybiA9IGZ1bmN0aW9uIChwYXJhbXMsIGtpbmQpIHtcblx0ICAgICAgICB2YXIgcGF0dGVybjtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnWycpKSB7XG5cdCAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLnBhcnNlQXJyYXlQYXR0ZXJuKHBhcmFtcywga2luZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJ3snKSkge1xuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5wYXJzZU9iamVjdFBhdHRlcm4ocGFyYW1zLCBraW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnbGV0JykgJiYgKGtpbmQgPT09ICdjb25zdCcgfHwga2luZCA9PT0gJ2xldCcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkxldEluTGV4aWNhbEJpbmRpbmcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoa2luZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQgPSBmdW5jdGlvbiAocGFyYW1zLCBraW5kKSB7XG5cdCAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLmxvb2thaGVhZDtcblx0ICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucGFyc2VQYXR0ZXJuKHBhcmFtcywga2luZCk7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJz0nKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbik7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXHQgICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5maW5hbGl6ZSh0aGlzLnN0YXJ0Tm9kZShzdGFydFRva2VuKSwgbmV3IE5vZGUuQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybiwgcmlnaHQpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHBhdHRlcm47XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdmFyaWFibGUtc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKGtpbmQpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ3lpZWxkJykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRva2VuLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLyAmJiB0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgfHwgdG9rZW4udmFsdWUgIT09ICdsZXQnIHx8IGtpbmQgIT09ICd2YXInKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoKHRoaXMuY29udGV4dC5pc01vZHVsZSB8fCB0aGlzLmNvbnRleHQuYXdhaXQpICYmIHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJ2F3YWl0Jykge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSWRlbnRpZmllcih0b2tlbi52YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcblx0ICAgICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMsICd2YXInKTtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBpZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQoaWQubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFZhck5hbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnPScpKSB7XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIGluaXQgPSB0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoaWQudHlwZSAhPT0gc3ludGF4XzEuU3ludGF4LklkZW50aWZpZXIgJiYgIW9wdGlvbnMuaW5Gb3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJz0nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgb3B0ID0geyBpbkZvcjogb3B0aW9ucy5pbkZvciB9O1xuXHQgICAgICAgIHZhciBsaXN0ID0gW107XG5cdCAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xuXHQgICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKCcsJykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKG9wdCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGlzdDtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVmFyaWFibGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3ZhcicpO1xuXHQgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLnBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoeyBpbkZvcjogZmFsc2UgfSk7XG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZW1wdHktc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWV4cHJlc3Npb24tc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pZi1zdGF0ZW1lbnRcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJZkNsYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiB0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQ7XG5cdCAgICAgICAgdmFyIGFsdGVybmF0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdpZicpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XG5cdCAgICAgICAgdmFyIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgICAgIGNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnBhcnNlSWZDbGF1c2UoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kby13aGlsZS1zdGF0ZW1lbnRcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdkbycpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gcHJldmlvdXNJbkl0ZXJhdGlvbjtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRG9XaGlsZVN0YXRlbWVudChib2R5LCB0ZXN0KSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2hpbGUtc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgYm9keTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3doaWxlJyk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICB2YXIgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcpJykgJiYgdGhpcy5jb25maWcudG9sZXJhbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0aGlzLm5leHRUb2tlbigpKTtcblx0ICAgICAgICAgICAgYm9keSA9IHRoaXMuZmluYWxpemUodGhpcy5jcmVhdGVOb2RlKCksIG5ldyBOb2RlLkVtcHR5U3RhdGVtZW50KCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLldoaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3Itc3RhdGVtZW50XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mb3ItaW4tYW5kLWZvci1vZi1zdGF0ZW1lbnRzXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBpbml0ID0gbnVsbDtcblx0ICAgICAgICB2YXIgdGVzdCA9IG51bGw7XG5cdCAgICAgICAgdmFyIHVwZGF0ZSA9IG51bGw7XG5cdCAgICAgICAgdmFyIGZvckluID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2ZvcicpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcoJyk7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJzsnKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCd2YXInKSkge1xuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0FsbG93SW4gPSB0aGlzLmNvbnRleHQuYWxsb3dJbjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KHsgaW5Gb3I6IHRydWUgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblx0ICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2wgPSBkZWNsYXJhdGlvbnNbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCAmJiAoZGVjbC5pZC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXJyYXlQYXR0ZXJuIHx8IGRlY2wuaWQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4Lk9iamVjdFBhdHRlcm4gfHwgdGhpcy5jb250ZXh0LnN0cmljdCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgJ2Zvci1pbicpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsICd2YXInKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvckluID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywgJ3ZhcicpKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdjb25zdCcpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xuXHQgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtpbmQgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHRoaXMubG9va2FoZWFkLnZhbHVlID09PSAnaW4nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuSWRlbnRpZmllcihraW5kKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0luID0gdGhpcy5jb250ZXh0LmFsbG93SW47XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KGtpbmQsIHsgaW5Gb3I6IHRydWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaEtleXdvcmQoJ2luJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUoaW5pdCwgbmV3IE5vZGUuVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMsIGtpbmQpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEgJiYgZGVjbGFyYXRpb25zWzBdLmluaXQgPT09IG51bGwgJiYgdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdvZicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmZpbmFsaXplKGluaXQsIG5ldyBOb2RlLlZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zLCBraW5kKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBpbml0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ySW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbml0ID0gdGhpcy5maW5hbGl6ZShpbml0LCBuZXcgTm9kZS5WYXJpYWJsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9ucywga2luZCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbml0U3RhcnRUb2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dJbiA9IHRoaXMuY29udGV4dC5hbGxvd0luO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93SW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGluaXQgPSB0aGlzLmluaGVyaXRDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdpbicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuaXNBc3NpZ25tZW50VGFyZ2V0IHx8IGluaXQudHlwZSA9PT0gc3ludGF4XzEuU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRMSFNJbkZvckluKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnJlaW50ZXJwcmV0RXhwcmVzc2lvbkFzUGF0dGVybihpbml0KTtcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gaW5pdDtcblx0ICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ29mJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pc0Fzc2lnbm1lbnRUYXJnZXQgfHwgaW5pdC50eXBlID09PSBzeW50YXhfMS5TeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZUVycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZExIU0luRm9yTG9vcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWludGVycHJldEV4cHJlc3Npb25Bc1BhdHRlcm4oaW5pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICBpbml0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3JJbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJywnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdFNlcSA9IFtpbml0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubWF0Y2goJywnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRTZXEucHVzaCh0aGlzLmlzb2xhdGVDb3ZlckdyYW1tYXIodGhpcy5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdCA9IHRoaXMuZmluYWxpemUodGhpcy5zdGFydE5vZGUoaW5pdFN0YXJ0VG9rZW4pLCBuZXcgTm9kZS5TZXF1ZW5jZUV4cHJlc3Npb24oaW5pdFNlcSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnOycpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCc7JykpIHtcblx0ICAgICAgICAgICAgICAgIHRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCc7Jyk7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpKSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBib2R5O1xuXHQgICAgICAgIGlmICghdGhpcy5tYXRjaCgnKScpICYmIHRoaXMuY29uZmlnLnRvbGVyYW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XG5cdCAgICAgICAgICAgIGJvZHkgPSB0aGlzLmZpbmFsaXplKHRoaXMuY3JlYXRlTm9kZSgpLCBuZXcgTm9kZS5FbXB0eVN0YXRlbWVudCgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c0luSXRlcmF0aW9uID0gdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSB0cnVlO1xuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VTdGF0ZW1lbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb24gPSBwcmV2aW91c0luSXRlcmF0aW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykgP1xuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZvclN0YXRlbWVudChpbml0LCB0ZXN0LCB1cGRhdGUsIGJvZHkpKSA6XG5cdCAgICAgICAgICAgIGZvckluID8gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5Gb3JJblN0YXRlbWVudChsZWZ0LCByaWdodCwgYm9keSkpIDpcblx0ICAgICAgICAgICAgICAgIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jb250aW51ZS1zdGF0ZW1lbnRcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblx0ICAgICAgICB2YXIgbGFiZWwgPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgaWQubmFtZTtcblx0ICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5Vbmtub3duTGFiZWwsIGlkLm5hbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgIGlmIChsYWJlbCA9PT0gbnVsbCAmJiAhdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxDb250aW51ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNvbnRpbnVlU3RhdGVtZW50KGxhYmVsKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYnJlYWstc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnJlYWtTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XG5cdCAgICAgICAgdmFyIGxhYmVsID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yKSB7XG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XG5cdCAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29udGV4dC5sYWJlbFNldCwga2V5KSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBpZC5uYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsYWJlbCA9IGlkO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcblx0ICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIXRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiAmJiAhdGhpcy5jb250ZXh0LmluU3dpdGNoKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJyZWFrU3RhdGVtZW50KGxhYmVsKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmV0dXJuLXN0YXRlbWVudFxuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsUmV0dXJuKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXHQgICAgICAgIHZhciBoYXNBcmd1bWVudCA9ICghdGhpcy5tYXRjaCgnOycpICYmICF0aGlzLm1hdGNoKCd9JykgJiZcblx0ICAgICAgICAgICAgIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IgJiYgdGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHx8XG5cdCAgICAgICAgICAgIHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDggLyogU3RyaW5nTGl0ZXJhbCAqLyB8fFxuXHQgICAgICAgICAgICB0aGlzLmxvb2thaGVhZC50eXBlID09PSAxMCAvKiBUZW1wbGF0ZSAqLztcblx0ICAgICAgICB2YXIgYXJndW1lbnQgPSBoYXNBcmd1bWVudCA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiBudWxsO1xuXHQgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlJldHVyblN0YXRlbWVudChhcmd1bWVudCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXdpdGgtc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RNb2RlV2l0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGJvZHk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd3aXRoJyk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSAmJiB0aGlzLmNvbmZpZy50b2xlcmFudCkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5maW5hbGl6ZSh0aGlzLmNyZWF0ZU5vZGUoKSwgbmV3IE5vZGUuRW1wdHlTdGF0ZW1lbnQoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xuXHQgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5XaXRoU3RhdGVtZW50KG9iamVjdCwgYm9keSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN3aXRjaC1zdGF0ZW1lbnRcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTd2l0Y2hDYXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIHRlc3Q7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgdGVzdCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcblx0ICAgICAgICAgICAgdGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCc6Jyk7XG5cdCAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSBbXTtcblx0ICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnfScpIHx8IHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2Nhc2UnKSkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuU3dpdGNoQ2FzZSh0ZXN0LCBjb25zZXF1ZW50KSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgnKScpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0luU3dpdGNoID0gdGhpcy5jb250ZXh0LmluU3dpdGNoO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pblN3aXRjaCA9IHRydWU7XG5cdCAgICAgICAgdmFyIGNhc2VzID0gW107XG5cdCAgICAgICAgdmFyIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNsYXVzZSA9IHRoaXMucGFyc2VTd2l0Y2hDYXNlKCk7XG5cdCAgICAgICAgICAgIGlmIChjbGF1c2UudGVzdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLk11bHRpcGxlRGVmYXVsdHNJblN3aXRjaCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2VzLnB1c2goY2xhdXNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5Td2l0Y2ggPSBwcmV2aW91c0luU3dpdGNoO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGFiZWxsZWQtc3RhdGVtZW50c1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxhYmVsbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgIHZhciBzdGF0ZW1lbnQ7XG5cdCAgICAgICAgaWYgKChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5JZGVudGlmaWVyKSAmJiB0aGlzLm1hdGNoKCc6JykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgdmFyIGlkID0gZXhwcjtcblx0ICAgICAgICAgICAgdmFyIGtleSA9ICckJyArIGlkLm5hbWU7XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb250ZXh0LmxhYmVsU2V0LCBrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5SZWRlY2xhcmF0aW9uLCAnTGFiZWwnLCBpZC5uYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XSA9IHRydWU7XG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMucGFyc2VDbGFzc0RlY2xhcmF0aW9uKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChkZWNsYXJhdGlvbi5nZW5lcmF0b3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLkdlbmVyYXRvckluTGVnYWN5Q29udGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBib2R5ID0gZGVjbGFyYXRpb247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbnRleHQubGFiZWxTZXRba2V5XTtcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuTGFiZWxlZFN0YXRlbWVudChpZCwgYm9keSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnN1bWVTZW1pY29sb24oKTtcblx0ICAgICAgICAgICAgc3RhdGVtZW50ID0gbmV3IE5vZGUuRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgc3RhdGVtZW50KTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10aHJvdy1zdGF0ZW1lbnRcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUaHJvd1N0YXRlbWVudCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgndGhyb3cnKTtcblx0ICAgICAgICBpZiAodGhpcy5oYXNMaW5lVGVybWluYXRvcikge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuVGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10cnktc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2F0Y2hDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2NhdGNoJyk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5wYXJzZVBhdHRlcm4ocGFyYW1zKTtcblx0ICAgICAgICB2YXIgcGFyYW1NYXAgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gJyQnICsgcGFyYW1zW2ldLnZhbHVlO1xuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtTWFwLCBrZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVCaW5kaW5nLCBwYXJhbXNbaV0udmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHBhcmFtTWFwW2tleV0gPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCAmJiBwYXJhbS50eXBlID09PSBzeW50YXhfMS5TeW50YXguSWRlbnRpZmllcikge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcpJyk7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5DYXRjaENsYXVzZShwYXJhbSwgYm9keSkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VGaW5hbGx5Q2xhdXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnZmluYWxseScpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCd0cnknKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcblx0ICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMubWF0Y2hLZXl3b3JkKCdjYXRjaCcpID8gdGhpcy5wYXJzZUNhdGNoQ2xhdXNlKCkgOiBudWxsO1xuXHQgICAgICAgIHZhciBmaW5hbGl6ZXIgPSB0aGlzLm1hdGNoS2V5d29yZCgnZmluYWxseScpID8gdGhpcy5wYXJzZUZpbmFsbHlDbGF1c2UoKSA6IG51bGw7XG5cdCAgICAgICAgaWYgKCFoYW5kbGVyICYmICFmaW5hbGl6ZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9DYXRjaE9yRmluYWxseSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlRyeVN0YXRlbWVudChibG9jaywgaGFuZGxlciwgZmluYWxpemVyKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGVidWdnZXItc3RhdGVtZW50XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ2RlYnVnZ2VyJyk7XG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRGVidWdnZXJTdGF0ZW1lbnQoKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS1zdGF0ZW1lbnRzLWFuZC1kZWNsYXJhdGlvbnNcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN0YXRlbWVudDtcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSAxIC8qIEJvb2xlYW5MaXRlcmFsICovOlxuXHQgICAgICAgICAgICBjYXNlIDUgLyogTnVsbExpdGVyYWwgKi86XG5cdCAgICAgICAgICAgIGNhc2UgNiAvKiBOdW1lcmljTGl0ZXJhbCAqLzpcblx0ICAgICAgICAgICAgY2FzZSA4IC8qIFN0cmluZ0xpdGVyYWwgKi86XG5cdCAgICAgICAgICAgIGNhc2UgMTAgLyogVGVtcGxhdGUgKi86XG5cdCAgICAgICAgICAgIGNhc2UgOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqLzpcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ3snKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJygnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnOycpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XG5cdCAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IHRoaXMucGFyc2VMYWJlbGxlZFN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgNCAvKiBLZXl3b3JkICovOlxuXHQgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmxvb2thaGVhZC52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUJyZWFrU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRpbnVlJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUNvbnRpbnVlU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlYnVnZ2VyJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9yJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUZvclN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUlmU3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JldHVybic6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3dpdGNoJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0aHJvdyc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnknOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zhcic6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VWYXJpYWJsZVN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aGlsZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXRoJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5sb29rYWhlYWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWRlZmluaXRpb25zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzTGFiZWxTZXQgPSB0aGlzLmNvbnRleHQubGFiZWxTZXQ7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5JdGVyYXRpb24gPSB0aGlzLmNvbnRleHQuaW5JdGVyYXRpb247XG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5Td2l0Y2ggPSB0aGlzLmNvbnRleHQuaW5Td2l0Y2g7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzSW5GdW5jdGlvbkJvZHkgPSB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsU2V0ID0ge307XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluSXRlcmF0aW9uID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5ID0gdHJ1ZTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQubGFiZWxTZXQgPSBwcmV2aW91c0xhYmVsU2V0O1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5pbkl0ZXJhdGlvbiA9IHByZXZpb3VzSW5JdGVyYXRpb247XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmluU3dpdGNoID0gcHJldmlvdXNJblN3aXRjaDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaW5GdW5jdGlvbkJvZHkgPSBwcmV2aW91c0luRnVuY3Rpb25Cb2R5O1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkJsb2NrU3RhdGVtZW50KGJvZHkpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnZhbGlkYXRlUGFyYW0gPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyYW0sIG5hbWUpIHtcblx0ICAgICAgICB2YXIga2V5ID0gJyQnICsgbmFtZTtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQobmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0ZWQgPSBwYXJhbTtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuZmlyc3RSZXN0cmljdGVkKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZChuYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maXJzdFJlc3RyaWN0ZWQgPSBwYXJhbTtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nhbm5lci5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQobmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlyc3RSZXN0cmljdGVkID0gcGFyYW07XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5wYXJhbVNldCwga2V5KSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3RlZCA9IHBhcmFtO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucy5wYXJhbVNldCwga2V5LCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5wYXJhbVNldFtrZXldID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlc3RFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJy4uLicpO1xuXHQgICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlUGF0dGVybihwYXJhbXMpO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoKCc9JykpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuRGVmYXVsdFJlc3RQYXJhbWV0ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5QYXJhbWV0ZXJBZnRlclJlc3RQYXJhbWV0ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5SZXN0RWxlbWVudChhcmcpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRm9ybWFsUGFyYW1ldGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgcGFyYW1zID0gW107XG5cdCAgICAgICAgdmFyIHBhcmFtID0gdGhpcy5tYXRjaCgnLi4uJykgPyB0aGlzLnBhcnNlUmVzdEVsZW1lbnQocGFyYW1zKSA6IHRoaXMucGFyc2VQYXR0ZXJuV2l0aERlZmF1bHQocGFyYW1zKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGFyYW0ob3B0aW9ucywgcGFyYW1zW2ldLCBwYXJhbXNbaV0udmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvcHRpb25zLnNpbXBsZSA9IG9wdGlvbnMuc2ltcGxlICYmIChwYXJhbSBpbnN0YW5jZW9mIE5vZGUuSWRlbnRpZmllcik7XG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbXMucHVzaChwYXJhbSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZvcm1hbFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZmlyc3RSZXN0cmljdGVkKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XG5cdCAgICAgICAgb3B0aW9ucyA9IHtcblx0ICAgICAgICAgICAgc2ltcGxlOiB0cnVlLFxuXHQgICAgICAgICAgICBwYXJhbXM6IFtdLFxuXHQgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQ6IGZpcnN0UmVzdHJpY3RlZFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJygnKTtcblx0ICAgICAgICBpZiAoIXRoaXMubWF0Y2goJyknKSkge1xuXHQgICAgICAgICAgICBvcHRpb25zLnBhcmFtU2V0ID0ge307XG5cdCAgICAgICAgICAgIHdoaWxlICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSAyIC8qIEVPRiAqLykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcihvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKScpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJyknKTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBzaW1wbGU6IG9wdGlvbnMuc2ltcGxlLFxuXHQgICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zLFxuXHQgICAgICAgICAgICBzdHJpY3RlZDogb3B0aW9ucy5zdHJpY3RlZCxcblx0ICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkOiBvcHRpb25zLmZpcnN0UmVzdHJpY3RlZCxcblx0ICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucy5tZXNzYWdlXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc2Nhbm5lci5zYXZlU3RhdGUoKTtcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNjYW5Db21tZW50cygpO1xuXHQgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuc2Nhbm5lci5sZXgoKTtcblx0ICAgICAgICAgICAgdGhpcy5zY2FubmVyLnJlc3RvcmVTdGF0ZShzdGF0ZSk7XG5cdCAgICAgICAgICAgIG1hdGNoID0gKHN0YXRlLmxpbmVOdW1iZXIgPT09IG5leHQubGluZU51bWJlcikgJiYgKG5leHQudHlwZSA9PT0gNCAvKiBLZXl3b3JkICovKSAmJiAobmV4dC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChpZGVudGlmaWVySXNPcHRpb25hbCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkID0gbnVsbDtcblx0ICAgICAgICBpZiAoIWlkZW50aWZpZXJJc09wdGlvbmFsIHx8ICF0aGlzLm1hdGNoKCcoJykpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgICAgIGlkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LnN0cmljdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5pc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNjYW5uZXIuaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuXHQgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd0F3YWl0ID0gdGhpcy5jb250ZXh0LmF3YWl0O1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBpc0FzeW5jO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoZmlyc3RSZXN0cmljdGVkKTtcblx0ICAgICAgICB2YXIgcGFyYW1zID0gZm9ybWFsUGFyYW1ldGVycy5wYXJhbXM7XG5cdCAgICAgICAgdmFyIHN0cmljdGVkID0gZm9ybWFsUGFyYW1ldGVycy5zdHJpY3RlZDtcblx0ICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLmZpcnN0UmVzdHJpY3RlZDtcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5tZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIG1lc3NhZ2UgPSBmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dTdHJpY3REaXJlY3RpdmUgPSB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmU7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gZm9ybWFsUGFyYW1ldGVycy5zaW1wbGU7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmNvbnRleHQuc3RyaWN0ICYmIHN0cmljdGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93U3RyaWN0RGlyZWN0aXZlID0gcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYXdhaXQgPSBwcmV2aW91c0FsbG93QXdhaXQ7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cdCAgICAgICAgcmV0dXJuIGlzQXN5bmMgPyB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkFzeW5jRnVuY3Rpb25EZWNsYXJhdGlvbihpZCwgcGFyYW1zLCBib2R5KSkgOlxuXHQgICAgICAgICAgICB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRGVjbGFyYXRpb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzeW5jJyk7XG5cdCAgICAgICAgaWYgKGlzQXN5bmMpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGlzQXN5bmMgPyBmYWxzZSA6IHRoaXMubWF0Y2goJyonKTtcblx0ICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1lc3NhZ2U7XG5cdCAgICAgICAgdmFyIGlkID0gbnVsbDtcblx0ICAgICAgICB2YXIgZmlyc3RSZXN0cmljdGVkO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93QXdhaXQgPSB0aGlzLmNvbnRleHQuYXdhaXQ7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IGlzQXN5bmM7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSAhaXNHZW5lcmF0b3I7XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCcoJykpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgICAgIGlkID0gKCF0aGlzLmNvbnRleHQuc3RyaWN0ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLm1hdGNoS2V5d29yZCgneWllbGQnKSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKSA6IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKHRva2VuLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLmlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG5cdCAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VzXzEuTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FubmVyLmlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcblx0ICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGZvcm1hbFBhcmFtZXRlcnMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycyhmaXJzdFJlc3RyaWN0ZWQpO1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSBmb3JtYWxQYXJhbWV0ZXJzLnBhcmFtcztcblx0ICAgICAgICB2YXIgc3RyaWN0ZWQgPSBmb3JtYWxQYXJhbWV0ZXJzLnN0cmljdGVkO1xuXHQgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IGZvcm1hbFBhcmFtZXRlcnMuZmlyc3RSZXN0cmljdGVkO1xuXHQgICAgICAgIGlmIChmb3JtYWxQYXJhbWV0ZXJzLm1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGZvcm1hbFBhcmFtZXRlcnMubWVzc2FnZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0ID0gdGhpcy5jb250ZXh0LnN0cmljdDtcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1N0cmljdERpcmVjdGl2ZSA9IHRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBmb3JtYWxQYXJhbWV0ZXJzLnNpbXBsZTtcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgZmlyc3RSZXN0cmljdGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdHJpY3QgJiYgc3RyaWN0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbihzdHJpY3RlZCwgbWVzc2FnZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSBwcmV2aW91c1N0cmljdDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dTdHJpY3REaXJlY3RpdmUgPSBwcmV2aW91c0FsbG93U3RyaWN0RGlyZWN0aXZlO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hd2FpdCA9IHByZXZpb3VzQWxsb3dBd2FpdDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblx0ICAgICAgICByZXR1cm4gaXNBc3luYyA/IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSkpIDpcblx0ICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24oaWQsIHBhcmFtcywgYm9keSwgaXNHZW5lcmF0b3IpKTtcblx0ICAgIH07XG5cdCAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kaXJlY3RpdmUtcHJvbG9ndWVzLWFuZC10aGUtdXNlLXN0cmljdC1kaXJlY3RpdmVcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VEaXJlY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IChleHByLnR5cGUgPT09IHN5bnRheF8xLlN5bnRheC5MaXRlcmFsKSA/IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pLnNsaWNlKDEsIC0xKSA6IG51bGw7XG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgZGlyZWN0aXZlID8gbmV3IE5vZGUuRGlyZWN0aXZlKGV4cHIsIGRpcmVjdGl2ZSkgOiBuZXcgTm9kZS5FeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBmaXJzdFJlc3RyaWN0ZWQgPSBudWxsO1xuXHQgICAgICAgIHZhciBib2R5ID0gW107XG5cdCAgICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlRGlyZWN0aXZlKCk7XG5cdCAgICAgICAgICAgIGJvZHkucHVzaChzdGF0ZW1lbnQpO1xuXHQgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gc3RhdGVtZW50LmRpcmVjdGl2ZTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkaXJlY3RpdmUgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJpY3QgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4oZmlyc3RSZXN0cmljdGVkLCBtZXNzYWdlc18xLk1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5hbGxvd1N0cmljdERpcmVjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4odG9rZW4sIG1lc3NhZ2VzXzEuTWVzc2FnZXMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBib2R5O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1ldGhvZC1kZWZpbml0aW9uc1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAodG9rZW4pIHtcblx0ICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSAzIC8qIElkZW50aWZpZXIgKi86XG5cdCAgICAgICAgICAgIGNhc2UgOCAvKiBTdHJpbmdMaXRlcmFsICovOlxuXHQgICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhbkxpdGVyYWwgKi86XG5cdCAgICAgICAgICAgIGNhc2UgNSAvKiBOdWxsTGl0ZXJhbCAqLzpcblx0ICAgICAgICAgICAgY2FzZSA2IC8qIE51bWVyaWNMaXRlcmFsICovOlxuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICBjYXNlIDcgLyogUHVuY3R1YXRvciAqLzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi52YWx1ZSA9PT0gJ1snO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2V0dGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gIWlzR2VuZXJhdG9yO1xuXHQgICAgICAgIHZhciBmb3JtYWxQYXJhbWV0ZXJzID0gdGhpcy5wYXJzZUZvcm1hbFBhcmFtZXRlcnMoKTtcblx0ICAgICAgICBpZiAoZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRHZXR0ZXJBcml0eSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnBhcnNlUHJvcGVydHlNZXRob2QoZm9ybWFsUGFyYW1ldGVycyk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBwcmV2aW91c0FsbG93WWllbGQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRnVuY3Rpb25FeHByZXNzaW9uKG51bGwsIGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNldHRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBpc0dlbmVyYXRvciA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBwcmV2aW91c0FsbG93WWllbGQgPSB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZDtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9ICFpc0dlbmVyYXRvcjtcblx0ICAgICAgICB2YXIgZm9ybWFsUGFyYW1ldGVycyA9IHRoaXMucGFyc2VGb3JtYWxQYXJhbWV0ZXJzKCk7XG5cdCAgICAgICAgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJBcml0eSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGZvcm1hbFBhcmFtZXRlcnMucGFyYW1zWzBdIGluc3RhbmNlb2YgTm9kZS5SZXN0RWxlbWVudCkge1xuXHQgICAgICAgICAgICB0aGlzLnRvbGVyYXRlRXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChmb3JtYWxQYXJhbWV0ZXJzKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5GdW5jdGlvbkV4cHJlc3Npb24obnVsbCwgZm9ybWFsUGFyYW1ldGVycy5wYXJhbXMsIG1ldGhvZCwgaXNHZW5lcmF0b3IpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlR2VuZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGlzR2VuZXJhdG9yID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgcHJldmlvdXNBbGxvd1lpZWxkID0gdGhpcy5jb250ZXh0LmFsbG93WWllbGQ7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSB0cnVlO1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcnNlRm9ybWFsUGFyYW1ldGVycygpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZChwYXJhbXMpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5hbGxvd1lpZWxkID0gcHJldmlvdXNBbGxvd1lpZWxkO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLCBwYXJhbXMucGFyYW1zLCBtZXRob2QsIGlzR2VuZXJhdG9yKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2VuZXJhdG9yLWZ1bmN0aW9uLWRlZmluaXRpb25zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLmlzU3RhcnRPZkV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmxvb2thaGVhZC52YWx1ZTtcblx0ICAgICAgICBzd2l0Y2ggKHRoaXMubG9va2FoZWFkLnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSA3IC8qIFB1bmN0dWF0b3IgKi86XG5cdCAgICAgICAgICAgICAgICBzdGFydCA9ICh2YWx1ZSA9PT0gJ1snKSB8fCAodmFsdWUgPT09ICcoJykgfHwgKHZhbHVlID09PSAneycpIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSAnKycpIHx8ICh2YWx1ZSA9PT0gJy0nKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJyEnKSB8fCAodmFsdWUgPT09ICd+JykgfHxcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcrKycpIHx8ICh2YWx1ZSA9PT0gJy0tJykgfHxcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICcvJykgfHwgKHZhbHVlID09PSAnLz0nKTsgLy8gcmVndWxhciBleHByZXNzaW9uIGxpdGVyYWxcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDQgLyogS2V5d29yZCAqLzpcblx0ICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHZhbHVlID09PSAnY2xhc3MnKSB8fCAodmFsdWUgPT09ICdkZWxldGUnKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgfHwgKHZhbHVlID09PSAnbGV0JykgfHwgKHZhbHVlID09PSAnbmV3JykgfHxcblx0ICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09ICdzdXBlcicpIHx8ICh2YWx1ZSA9PT0gJ3RoaXMnKSB8fCAodmFsdWUgPT09ICd0eXBlb2YnKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJ3ZvaWQnKSB8fCAodmFsdWUgPT09ICd5aWVsZCcpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN0YXJ0O1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VZaWVsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLmV4cGVjdEtleXdvcmQoJ3lpZWxkJyk7XG5cdCAgICAgICAgdmFyIGFyZ3VtZW50ID0gbnVsbDtcblx0ICAgICAgICB2YXIgZGVsZWdhdGUgPSBmYWxzZTtcblx0ICAgICAgICBpZiAoIXRoaXMuaGFzTGluZVRlcm1pbmF0b3IpIHtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzQWxsb3dZaWVsZCA9IHRoaXMuY29udGV4dC5hbGxvd1lpZWxkO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICBkZWxlZ2F0ZSA9IHRoaXMubWF0Y2goJyonKTtcblx0ICAgICAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RhcnRPZkV4cHJlc3Npb24oKSkge1xuXHQgICAgICAgICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuYWxsb3dZaWVsZCA9IHByZXZpb3VzQWxsb3dZaWVsZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuWWllbGRFeHByZXNzaW9uKGFyZ3VtZW50LCBkZWxlZ2F0ZSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNsYXNzLWRlZmluaXRpb25zXG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NFbGVtZW50ID0gZnVuY3Rpb24gKGhhc0NvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgdmFyIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIga2luZCA9ICcnO1xuXHQgICAgICAgIHZhciBrZXkgPSBudWxsO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgdmFyIGNvbXB1dGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBpc1N0YXRpYyA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBpc0FzeW5jID0gZmFsc2U7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2goJyonKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICB2YXIgaWQgPSBrZXk7XG5cdCAgICAgICAgICAgIGlmIChpZC5uYW1lID09PSAnc3RhdGljJyAmJiAodGhpcy5xdWFsaWZpZWRQcm9wZXJ0eU5hbWUodGhpcy5sb29rYWhlYWQpIHx8IHRoaXMubWF0Y2goJyonKSkpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy5sb29rYWhlYWQ7XG5cdCAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCcqJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pICYmICF0aGlzLmhhc0xpbmVUZXJtaW5hdG9yICYmICh0b2tlbi52YWx1ZSA9PT0gJ2FzeW5jJykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwdW5jdHVhdG9yID0gdGhpcy5sb29rYWhlYWQudmFsdWU7XG5cdCAgICAgICAgICAgICAgICBpZiAocHVuY3R1YXRvciAhPT0gJzonICYmIHB1bmN0dWF0b3IgIT09ICcoJyAmJiBwdW5jdHVhdG9yICE9PSAnKicpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMubG9va2FoZWFkO1xuXHQgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8gJiYgdG9rZW4udmFsdWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvcklzQXN5bmMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbG9va2FoZWFkUHJvcGVydHlLZXkgPSB0aGlzLnF1YWxpZmllZFByb3BlcnR5TmFtZSh0aGlzLmxvb2thaGVhZCk7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDMgLyogSWRlbnRpZmllciAqLykge1xuXHQgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICdnZXQnICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2dldCc7XG5cdCAgICAgICAgICAgICAgICBjb21wdXRlZCA9IHRoaXMubWF0Y2goJ1snKTtcblx0ICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFsbG93WWllbGQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZUdldHRlck1ldGhvZCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSAnc2V0JyAmJiBsb29rYWhlYWRQcm9wZXJ0eUtleSkge1xuXHQgICAgICAgICAgICAgICAga2luZCA9ICdzZXQnO1xuXHQgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSB0aGlzLm1hdGNoKCdbJyk7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVNldHRlck1ldGhvZCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyAmJiB0b2tlbi52YWx1ZSA9PT0gJyonICYmIGxvb2thaGVhZFByb3BlcnR5S2V5KSB7XG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XG5cdCAgICAgICAgICAgIGNvbXB1dGVkID0gdGhpcy5tYXRjaCgnWycpO1xuXHQgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlR2VuZXJhdG9yTWV0aG9kKCk7XG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgha2luZCAmJiBrZXkgJiYgdGhpcy5tYXRjaCgnKCcpKSB7XG5cdCAgICAgICAgICAgIGtpbmQgPSAnaW5pdCc7XG5cdCAgICAgICAgICAgIHZhbHVlID0gaXNBc3luYyA/IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEFzeW5jRnVuY3Rpb24oKSA6IHRoaXMucGFyc2VQcm9wZXJ0eU1ldGhvZEZ1bmN0aW9uKCk7XG5cdCAgICAgICAgICAgIG1ldGhvZCA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICgha2luZCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGtpbmQgPT09ICdpbml0Jykge1xuXHQgICAgICAgICAgICBraW5kID0gJ21ldGhvZCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY29tcHV0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzU3RhdGljICYmIHRoaXMuaXNQcm9wZXJ0eUtleShrZXksICdwcm90b3R5cGUnKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5TdGF0aWNQcm90b3R5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghaXNTdGF0aWMgJiYgdGhpcy5pc1Byb3BlcnR5S2V5KGtleSwgJ2NvbnN0cnVjdG9yJykpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChraW5kICE9PSAnbWV0aG9kJyB8fCAhbWV0aG9kIHx8ICh2YWx1ZSAmJiB2YWx1ZS5nZW5lcmF0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5Db25zdHJ1Y3RvclNwZWNpYWxNZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yLnZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbih0b2tlbiwgbWVzc2FnZXNfMS5NZXNzYWdlcy5EdXBsaWNhdGVDb25zdHJ1Y3Rvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvci52YWx1ZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBraW5kID0gJ2NvbnN0cnVjdG9yJztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5NZXRob2REZWZpbml0aW9uKGtleSwgY29tcHV0ZWQsIHZhbHVlLCBraW5kLCBpc1N0YXRpYykpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0VsZW1lbnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBib2R5ID0gW107XG5cdCAgICAgICAgdmFyIGhhc0NvbnN0cnVjdG9yID0geyB2YWx1ZTogZmFsc2UgfTtcblx0ICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5tYXRjaCgnfScpKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoKCc7JykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzRWxlbWVudChoYXNDb25zdHJ1Y3RvcikpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XG5cdCAgICAgICAgcmV0dXJuIGJvZHk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzQm9keSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBlbGVtZW50TGlzdCA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnRMaXN0KCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NCb2R5KGVsZW1lbnRMaXN0KSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoaWRlbnRpZmllcklzT3B0aW9uYWwpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXHQgICAgICAgIHZhciBpZCA9IChpZGVudGlmaWVySXNPcHRpb25hbCAmJiAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovKSkgPyBudWxsIDogdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXHQgICAgICAgIHZhciBzdXBlckNsYXNzID0gbnVsbDtcblx0ICAgICAgICBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2V4dGVuZHMnKSkge1xuXHQgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICBzdXBlckNsYXNzID0gdGhpcy5pc29sYXRlQ292ZXJHcmFtbWFyKHRoaXMucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNsYXNzQm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuQ2xhc3NEZWNsYXJhdGlvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XG5cdCAgICB9O1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBwcmV2aW91c1N0cmljdCA9IHRoaXMuY29udGV4dC5zdHJpY3Q7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdjbGFzcycpO1xuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLmxvb2thaGVhZC50eXBlID09PSAzIC8qIElkZW50aWZpZXIgKi8pID8gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpIDogbnVsbDtcblx0ICAgICAgICB2YXIgc3VwZXJDbGFzcyA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdleHRlbmRzJykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgc3VwZXJDbGFzcyA9IHRoaXMuaXNvbGF0ZUNvdmVyR3JhbW1hcih0aGlzLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjbGFzc0JvZHkgPSB0aGlzLnBhcnNlQ2xhc3NCb2R5KCk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkNsYXNzRXhwcmVzc2lvbihpZCwgc3VwZXJDbGFzcywgY2xhc3NCb2R5KSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2NyaXB0c1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbW9kdWxlc1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuc3RyaWN0ID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuaXNNb2R1bGUgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuc2Nhbm5lci5pc01vZHVsZSA9IHRydWU7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VEaXJlY3RpdmVQcm9sb2d1ZXMoKTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5sb29rYWhlYWQudHlwZSAhPT0gMiAvKiBFT0YgKi8pIHtcblx0ICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuTW9kdWxlKGJvZHkpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlRGlyZWN0aXZlUHJvbG9ndWVzKCk7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMubG9va2FoZWFkLnR5cGUgIT09IDIgLyogRU9GICovKSB7XG5cdCAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLlNjcmlwdChib2R5KSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaW1wb3J0c1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZU1vZHVsZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlICE9PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuSW52YWxpZE1vZHVsZVNwZWNpZmllcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgdmFyIHJhdyA9IHRoaXMuZ2V0VG9rZW5SYXcodG9rZW4pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKG5vZGUsIG5ldyBOb2RlLkxpdGVyYWwodG9rZW4udmFsdWUsIHJhdykpO1xuXHQgICAgfTtcblx0ICAgIC8vIGltcG9ydCB7PGZvbyBhcyBiYXI+fSAuLi47XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0U3BlY2lmaWVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdmFyIGltcG9ydGVkO1xuXHQgICAgICAgIHZhciBsb2NhbDtcblx0ICAgICAgICBpZiAodGhpcy5sb29rYWhlYWQudHlwZSA9PT0gMyAvKiBJZGVudGlmaWVyICovKSB7XG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpO1xuXHQgICAgICAgICAgICBsb2NhbCA9IGltcG9ydGVkO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhcycpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKCk7XG5cdCAgICAgICAgICAgIGxvY2FsID0gaW1wb3J0ZWQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICBsb2NhbCA9IHRoaXMucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4odGhpcy5uZXh0VG9rZW4oKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIHtmb28sIGJhciBhcyBiYXN9XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlTmFtZWRJbXBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCd7Jyk7XG5cdCAgICAgICAgdmFyIHNwZWNpZmllcnMgPSBbXTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcigpKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0KCcsJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5leHBlY3QoJ30nKTtcblx0ICAgICAgICByZXR1cm4gc3BlY2lmaWVycztcblx0ICAgIH07XG5cdCAgICAvLyBpbXBvcnQgPGZvbz4gLi4uO1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZU5vZGUoKTtcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaW1wb3J0IDwqIGFzIGZvbz4gLi4uO1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0KCcqJyk7XG5cdCAgICAgICAgaWYgKCF0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2VzXzEuTWVzc2FnZXMuTm9Bc0FmdGVySW1wb3J0TmFtZXNwYWNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICB2YXIgbG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWwpKTtcblx0ICAgIH07XG5cdCAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wb3J0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pbkZ1bmN0aW9uQm9keSkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZXNfMS5NZXNzYWdlcy5JbGxlZ2FsSW1wb3J0RGVjbGFyYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHRoaXMuZXhwZWN0S2V5d29yZCgnaW1wb3J0Jyk7XG5cdCAgICAgICAgdmFyIHNyYztcblx0ICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xuXHQgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZC50eXBlID09PSA4IC8qIFN0cmluZ0xpdGVyYWwgKi8pIHtcblx0ICAgICAgICAgICAgLy8gaW1wb3J0ICdmb28nO1xuXHQgICAgICAgICAgICBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgneycpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQge2Jhcn1cblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmNvbmNhdCh0aGlzLnBhcnNlTmFtZWRJbXBvcnRzKCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubWF0Y2goJyonKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gaW1wb3J0ICogYXMgZm9vXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzSWRlbnRpZmllck5hbWUodGhpcy5sb29rYWhlYWQpICYmICF0aGlzLm1hdGNoS2V5d29yZCgnZGVmYXVsdCcpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBpbXBvcnQgZm9vXG5cdCAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnLCcpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgnKicpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCBmb28sICogYXMgZm9vXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoKCd7JykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IGZvbywge2Jhcn1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVycyA9IHNwZWNpZmllcnMuY29uY2F0KHRoaXMucGFyc2VOYW1lZEltcG9ydHMoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubmV4dFRva2VuKCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIHNyYyA9IHRoaXMucGFyc2VNb2R1bGVTcGVjaWZpZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuSW1wb3J0RGVjbGFyYXRpb24oc3BlY2lmaWVycywgc3JjKSk7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZXhwb3J0c1xuXHQgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUV4cG9ydFNwZWNpZmllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlTm9kZSgpO1xuXHQgICAgICAgIHZhciBsb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSgpO1xuXHQgICAgICAgIHZhciBleHBvcnRlZCA9IGxvY2FsO1xuXHQgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2FzJykpIHtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcblx0ICAgICAgICAgICAgZXhwb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0U3BlY2lmaWVyKGxvY2FsLCBleHBvcnRlZCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VFeHBvcnREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0LmluRnVuY3Rpb25Cb2R5KSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLklsbGVnYWxFeHBvcnREZWNsYXJhdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcy5jcmVhdGVOb2RlKCk7XG5cdCAgICAgICAgdGhpcy5leHBlY3RLZXl3b3JkKCdleHBvcnQnKTtcblx0ICAgICAgICB2YXIgZXhwb3J0RGVjbGFyYXRpb247XG5cdCAgICAgICAgaWYgKHRoaXMubWF0Y2hLZXl3b3JkKCdkZWZhdWx0JykpIHtcblx0ICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoS2V5d29yZCgnZnVuY3Rpb24nKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9vICgpIHt9XG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7fVxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEtleXdvcmQoJ2NsYXNzJykpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGZvbyB7fVxuXHQgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUNsYXNzRGVjbGFyYXRpb24odHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdhc3luYycpKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmICgpIHt9XG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAoKSB7fVxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXN5bmMgeCA9PiB4XG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoQXN5bmNGdW5jdGlvbigpID8gdGhpcy5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblx0ICAgICAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQge307XG5cdCAgICAgICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBbXTtcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0ICgxICsgMik7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLm1hdGNoKCd7JykgPyB0aGlzLnBhcnNlT2JqZWN0SW5pdGlhbGl6ZXIoKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCgnWycpID8gdGhpcy5wYXJzZUFycmF5SW5pdGlhbGl6ZXIoKSA6IHRoaXMucGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaCgnKicpKSB7XG5cdCAgICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJ2Zvbyc7XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tYXRjaENvbnRleHR1YWxLZXl3b3JkKCdmcm9tJykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5sb29rYWhlYWQudmFsdWUgPyBtZXNzYWdlc18xLk1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiA6IG1lc3NhZ2VzXzEuTWVzc2FnZXMuTWlzc2luZ0Zyb21DbGF1c2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgdGhpcy5sb29rYWhlYWQudmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG5cdCAgICAgICAgICAgIHZhciBzcmMgPSB0aGlzLnBhcnNlTW9kdWxlU3BlY2lmaWVyKCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0QWxsRGVjbGFyYXRpb24oc3JjKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubG9va2FoZWFkLnR5cGUgPT09IDQgLyogS2V5d29yZCAqLykge1xuXHQgICAgICAgICAgICAvLyBleHBvcnQgdmFyIGYgPSAxO1xuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB2b2lkIDA7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy5sb29rYWhlYWQudmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2xldCc6XG5cdCAgICAgICAgICAgICAgICBjYXNlICdjb25zdCc6XG5cdCAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlTGV4aWNhbERlY2xhcmF0aW9uKHsgaW5Gb3I6IGZhbHNlIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAndmFyJzpcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcblx0ICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKHRoaXMubG9va2FoZWFkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5tYXRjaEFzeW5jRnVuY3Rpb24oKSkge1xuXHQgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbigpO1xuXHQgICAgICAgICAgICBleHBvcnREZWNsYXJhdGlvbiA9IHRoaXMuZmluYWxpemUobm9kZSwgbmV3IE5vZGUuRXhwb3J0TmFtZWREZWNsYXJhdGlvbihkZWNsYXJhdGlvbiwgW10sIG51bGwpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBzcGVjaWZpZXJzID0gW107XG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLmV4cGVjdCgneycpO1xuXHQgICAgICAgICAgICB3aGlsZSAoIXRoaXMubWF0Y2goJ30nKSkge1xuXHQgICAgICAgICAgICAgICAgaXNFeHBvcnRGcm9tSWRlbnRpZmllciA9IGlzRXhwb3J0RnJvbUlkZW50aWZpZXIgfHwgdGhpcy5tYXRjaEtleXdvcmQoJ2RlZmF1bHQnKTtcblx0ICAgICAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKCkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGNoKCd9JykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdCgnLCcpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuZXhwZWN0KCd9Jyk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoQ29udGV4dHVhbEtleXdvcmQoJ2Zyb20nKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fSBmcm9tICdmb28nO1xuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtmb299IGZyb20gJ2Zvbyc7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5wYXJzZU1vZHVsZVNwZWNpZmllcigpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lU2VtaWNvbG9uKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvcnRGcm9tSWRlbnRpZmllcikge1xuXHQgICAgICAgICAgICAgICAgLy8gZXhwb3J0IHtkZWZhdWx0fTsgLy8gbWlzc2luZyBmcm9tQ2xhdXNlXG5cdCAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMubG9va2FoZWFkLnZhbHVlID8gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4gOiBtZXNzYWdlc18xLk1lc3NhZ2VzLk1pc3NpbmdGcm9tQ2xhdXNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIHRoaXMubG9va2FoZWFkLnZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7Zm9vfTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZVNlbWljb2xvbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGV4cG9ydERlY2xhcmF0aW9uID0gdGhpcy5maW5hbGl6ZShub2RlLCBuZXcgTm9kZS5FeHBvcnROYW1lZERlY2xhcmF0aW9uKG51bGwsIHNwZWNpZmllcnMsIHNvdXJjZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwb3J0RGVjbGFyYXRpb247XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFBhcnNlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG5cdC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuXHQvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cblx0Ly8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgIGlmICghY29uZGl0aW9uKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcblx0ICAgIH1cblx0fVxuXHRleHBvcnRzLmFzc2VydCA9IGFzc2VydDtcblxuXG4vKioqLyB9LFxuLyogMTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRXJyb3JIYW5kbGVyKCkge1xuXHQgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG5cdCAgICAgICAgdGhpcy50b2xlcmFudCA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5yZWNvcmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHQgICAgfTtcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUudG9sZXJhdGUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdEVycm9yID0gZnVuY3Rpb24gKG1zZywgY29sdW1uKSB7XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChiYXNlKSB7XG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdCAgICAgICAgICAgIGlmIChPYmplY3QuY3JlYXRlICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVycm9yLCAnY29sdW1uJywgeyB2YWx1ZTogY29sdW1uIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgfTtcblx0ICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcblx0ICAgICAgICB2YXIgbXNnID0gJ0xpbmUgJyArIGxpbmUgKyAnOiAnICsgZGVzY3JpcHRpb247XG5cdCAgICAgICAgdmFyIGVycm9yID0gdGhpcy5jb25zdHJ1Y3RFcnJvcihtc2csIGNvbCk7XG5cdCAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcblx0ICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZTtcblx0ICAgICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuXHQgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgIH07XG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcblx0ICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcblx0ICAgIH07XG5cdCAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLnRvbGVyYXRlRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmUsIGNvbCwgZGVzY3JpcHRpb24pIHtcblx0ICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKGluZGV4LCBsaW5lLCBjb2wsIGRlc2NyaXB0aW9uKTtcblx0ICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xuXHQgICAgICAgICAgICB0aGlzLnJlY29yZEVycm9yKGVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkVycm9ySGFuZGxlciA9IEVycm9ySGFuZGxlcjtcblxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG5cdGV4cG9ydHMuTWVzc2FnZXMgPSB7XG5cdCAgICBCYWRHZXR0ZXJBcml0eTogJ0dldHRlciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycycsXG5cdCAgICBCYWRTZXR0ZXJBcml0eTogJ1NldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlcicsXG5cdCAgICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiAnU2V0dGVyIGZ1bmN0aW9uIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgcmVzdCBwYXJhbWV0ZXInLFxuXHQgICAgQ29uc3RydWN0b3JJc0FzeW5jOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhc3luYyBtZXRob2QnLFxuXHQgICAgQ29uc3RydWN0b3JTcGVjaWFsTWV0aG9kOiAnQ2xhc3MgY29uc3RydWN0b3IgbWF5IG5vdCBiZSBhbiBhY2Nlc3NvcicsXG5cdCAgICBEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjogJ01pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJTAgZGVjbGFyYXRpb24nLFxuXHQgICAgRGVmYXVsdFJlc3RQYXJhbWV0ZXI6ICdVbmV4cGVjdGVkIHRva2VuID0nLFxuXHQgICAgRHVwbGljYXRlQmluZGluZzogJ0R1cGxpY2F0ZSBiaW5kaW5nICUwJyxcblx0ICAgIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiAnQSBjbGFzcyBtYXkgb25seSBoYXZlIG9uZSBjb25zdHJ1Y3RvcicsXG5cdCAgICBEdXBsaWNhdGVQcm90b1Byb3BlcnR5OiAnRHVwbGljYXRlIF9fcHJvdG9fXyBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIGluIG9iamVjdCBsaXRlcmFscycsXG5cdCAgICBGb3JJbk9mTG9vcEluaXRpYWxpemVyOiAnJTAgbG9vcCB2YXJpYWJsZSBkZWNsYXJhdGlvbiBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXInLFxuXHQgICAgR2VuZXJhdG9ySW5MZWdhY3lDb250ZXh0OiAnR2VuZXJhdG9yIGRlY2xhcmF0aW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gbGVnYWN5IGNvbnRleHRzJyxcblx0ICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50Jyxcblx0ICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50Jyxcblx0ICAgIElsbGVnYWxFeHBvcnREZWNsYXJhdGlvbjogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuXHQgICAgSWxsZWdhbEltcG9ydERlY2xhcmF0aW9uOiAnVW5leHBlY3RlZCB0b2tlbicsXG5cdCAgICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiAnSWxsZWdhbCBcXCd1c2Ugc3RyaWN0XFwnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QnLFxuXHQgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG5cdCAgICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogJ0tleXdvcmQgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnMnLFxuXHQgICAgSW52YWxpZEhleEVzY2FwZVNlcXVlbmNlOiAnSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLFxuXHQgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG5cdCAgICBJbnZhbGlkTEhTSW5Gb3JJbjogJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcblx0ICAgIEludmFsaWRMSFNJbkZvckxvb3A6ICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1sb29wJyxcblx0ICAgIEludmFsaWRNb2R1bGVTcGVjaWZpZXI6ICdVbmV4cGVjdGVkIHRva2VuJyxcblx0ICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG5cdCAgICBMZXRJbkxleGljYWxCaW5kaW5nOiAnbGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZScsXG5cdCAgICBNaXNzaW5nRnJvbUNsYXVzZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuXHQgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50Jyxcblx0ICAgIE5ld2xpbmVBZnRlclRocm93OiAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93Jyxcblx0ICAgIE5vQXNBZnRlckltcG9ydE5hbWVzcGFjZTogJ1VuZXhwZWN0ZWQgdG9rZW4nLFxuXHQgICAgTm9DYXRjaE9yRmluYWxseTogJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuXHQgICAgUGFyYW1ldGVyQWZ0ZXJSZXN0UGFyYW1ldGVyOiAnUmVzdCBwYXJhbWV0ZXIgbXVzdCBiZSBsYXN0IGZvcm1hbCBwYXJhbWV0ZXInLFxuXHQgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuXHQgICAgU3RhdGljUHJvdG90eXBlOiAnQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZScsXG5cdCAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG5cdCAgICBTdHJpY3REZWxldGU6ICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuXHQgICAgU3RyaWN0RnVuY3Rpb246ICdJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrJyxcblx0ICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG5cdCAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG5cdCAgICBTdHJpY3RMSFNQb3N0Zml4OiAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcblx0ICAgIFN0cmljdExIU1ByZWZpeDogJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcblx0ICAgIFN0cmljdE1vZGVXaXRoOiAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG5cdCAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcblx0ICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcblx0ICAgIFN0cmljdFBhcmFtTmFtZTogJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcblx0ICAgIFN0cmljdFJlc2VydmVkV29yZDogJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZScsXG5cdCAgICBTdHJpY3RWYXJOYW1lOiAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcblx0ICAgIFRlbXBsYXRlT2N0YWxMaXRlcmFsOiAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHRlbXBsYXRlIHN0cmluZ3MuJyxcblx0ICAgIFVuZXhwZWN0ZWRFT1M6ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG5cdCAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG5cdCAgICBVbmV4cGVjdGVkTnVtYmVyOiAnVW5leHBlY3RlZCBudW1iZXInLFxuXHQgICAgVW5leHBlY3RlZFJlc2VydmVkOiAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcblx0ICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICdVbmV4cGVjdGVkIHN0cmluZycsXG5cdCAgICBVbmV4cGVjdGVkVGVtcGxhdGU6ICdVbmV4cGVjdGVkIHF1YXNpICUwJyxcblx0ICAgIFVuZXhwZWN0ZWRUb2tlbjogJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuXHQgICAgVW5leHBlY3RlZFRva2VuSWxsZWdhbDogJ1VuZXhwZWN0ZWQgdG9rZW4gSUxMRUdBTCcsXG5cdCAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuXHQgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLydcblx0fTtcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciBhc3NlcnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdHZhciBjaGFyYWN0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdGZ1bmN0aW9uIGhleFZhbHVlKGNoKSB7XG5cdCAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG5cdH1cblx0ZnVuY3Rpb24gb2N0YWxWYWx1ZShjaCkge1xuXHQgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cdH1cblx0dmFyIFNjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gU2Nhbm5lcihjb2RlLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgdGhpcy5zb3VyY2UgPSBjb2RlO1xuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gaGFuZGxlcjtcblx0ICAgICAgICB0aGlzLnRyYWNrQ29tbWVudCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuaXNNb2R1bGUgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLmxlbmd0aCA9IGNvZGUubGVuZ3RoO1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgIHRoaXMubGluZU51bWJlciA9IChjb2RlLmxlbmd0aCA+IDApID8gMSA6IDA7XG5cdCAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuXHQgICAgICAgIHRoaXMuY3VybHlTdGFjayA9IFtdO1xuXHQgICAgfVxuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2F2ZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnRcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnJlc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSBzdGF0ZS5pbmRleDtcblx0ICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBzdGF0ZS5saW5lTnVtYmVyO1xuXHQgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmVvZiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aDtcblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50aHJvd1VuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLnRocm93RXJyb3IodGhpcy5pbmRleCwgdGhpcy5saW5lTnVtYmVyLCB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgKyAxLCBtZXNzYWdlKTtcblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT09IHZvaWQgMCkgeyBtZXNzYWdlID0gbWVzc2FnZXNfMS5NZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW5JbGxlZ2FsOyB9XG5cdCAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIudG9sZXJhdGVFcnJvcih0aGlzLmluZGV4LCB0aGlzLmxpbmVOdW1iZXIsIHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydCArIDEsIG1lc3NhZ2UpO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNvbW1lbnRzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5za2lwU2luZ2xlTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIG9mZnNldDtcblx0ICAgICAgICAgICAgbG9jID0ge1xuXHQgICAgICAgICAgICAgICAgc3RhcnQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSBvZmZzZXRcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBlbmQ6IHt9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZU51bWJlcixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnQgLSAxXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBbc3RhcnQgKyBvZmZzZXQsIHRoaXMuaW5kZXggLSAxXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgdGhpcy5pbmRleCAtIDFdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGxvY1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkgPT09IDEwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY29tbWVudHM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIG9mZnNldCwgdGhpcy5pbmRleF0sXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XG5cdCAgICB9O1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2tpcE11bHRpTGluZUNvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvbW1lbnRzID0gW107XG5cdCAgICAgICAgdmFyIHN0YXJ0LCBsb2M7XG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XG5cdCAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5pbmRleCAtIDI7XG5cdCAgICAgICAgICAgIGxvYyA9IHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5pbmRleCAtIHRoaXMubGluZVN0YXJ0IC0gMlxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGVuZDoge31cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaCkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAxKSA9PT0gMHgwQSkge1xuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJBKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBCbG9jayBjb21tZW50IGVuZHMgd2l0aCAnKi8nLlxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpID09PSAweDJGKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrQ29tbWVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmluZGV4IC0gdGhpcy5saW5lU3RhcnRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlMaW5lOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2U6IFtzdGFydCArIDIsIHRoaXMuaW5kZXggLSAyXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIHRoaXMuaW5kZXhdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBsb2Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChlbnRyeSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50cztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBSYW4gb2ZmIHRoZSBlbmQgb2YgdGhlIGZpbGUgLSB0aGUgd2hvbGUgdGhpbmcgaXMgYSBjb21tZW50XG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGxvYy5lbmQgPSB7XG5cdCAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuaW5kZXggLSB0aGlzLmxpbmVTdGFydFxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB2YXIgZW50cnkgPSB7XG5cdCAgICAgICAgICAgICAgICBtdWx0aUxpbmU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBzbGljZTogW3N0YXJ0ICsgMiwgdGhpcy5pbmRleF0sXG5cdCAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCB0aGlzLmluZGV4XSxcblx0ICAgICAgICAgICAgICAgIGxvYzogbG9jXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZW50cnkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgcmV0dXJuIGNvbW1lbnRzO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Db21tZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY29tbWVudHM7XG5cdCAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgIGNvbW1lbnRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBzdGFydCA9ICh0aGlzLmluZGV4ID09PSAwKTtcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc1doaXRlU3BhY2UoY2gpKSB7XG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSA9PT0gMHgwQSkge1xuXHQgICAgICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAweDJGKSB7XG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAweDJGKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAyO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50ID0gdGhpcy5za2lwU2luZ2xlTGluZUNvbW1lbnQoMik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2tDb21tZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuY29uY2F0KGNvbW1lbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgyQSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuc2tpcE11bHRpTGluZUNvbW1lbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgJiYgY2ggPT09IDB4MkQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFUrMDAzRSBpcyAnPidcblx0ICAgICAgICAgICAgICAgIGlmICgodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkgPT09IDB4MkQpICYmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXggKyAyKSA9PT0gMHgzRSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyAnLS0+JyBpcyBhIHNpbmdsZS1saW5lIGNvbW1lbnRcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCgzKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4M0MgJiYgIXRoaXMuaXNNb2R1bGUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDQpID09PSAnIS0tJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gNDsgLy8gYDwhLS1gXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLnNraXBTaW5nbGVMaW5lQ29tbWVudCg0KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0NvbW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMgPSBjb21tZW50cy5jb25jYXQoY29tbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29tbWVudHM7XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnV0dXJlLXJlc2VydmVkLXdvcmRzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0Z1dHVyZVJlc2VydmVkV29yZCA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgIHN3aXRjaCAoaWQpIHtcblx0ICAgICAgICAgICAgY2FzZSAnZW51bSc6XG5cdCAgICAgICAgICAgIGNhc2UgJ2V4cG9ydCc6XG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcG9ydCc6XG5cdCAgICAgICAgICAgIGNhc2UgJ3N1cGVyJzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICBzd2l0Y2ggKGlkKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuXHQgICAgICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuXHQgICAgICAgICAgICBjYXNlICdwYWNrYWdlJzpcblx0ICAgICAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG5cdCAgICAgICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG5cdCAgICAgICAgICAgIGNhc2UgJ3B1YmxpYyc6XG5cdCAgICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XG5cdCAgICAgICAgICAgIGNhc2UgJ3lpZWxkJzpcblx0ICAgICAgICAgICAgY2FzZSAnbGV0Jzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc1Jlc3RyaWN0ZWRXb3JkID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWtleXdvcmRzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG5cdCAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuXHQgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcblx0ICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcblx0ICAgICAgICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG5cdCAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuXHQgICAgICAgICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuXHQgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG5cdCAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcblx0ICAgICAgICAgICAgY2FzZSAxMDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLmNvZGVQb2ludEF0ID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXHQgICAgICAgIGlmIChjcCA+PSAweEQ4MDAgJiYgY3AgPD0gMHhEQkZGKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KGkgKyAxKTtcblx0ICAgICAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gY3A7XG5cdCAgICAgICAgICAgICAgICBjcCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGNwO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhFc2NhcGUgPSBmdW5jdGlvbiAocHJlZml4KSB7XG5cdCAgICAgICAgdmFyIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcblx0ICAgICAgICB2YXIgY29kZSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgIHZhciBjb2RlID0gMDtcblx0ICAgICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cblx0ICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSGV4RGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyBoZXhWYWx1ZShjaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuZnJvbUNvZGVQb2ludChjb2RlKTtcblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXgrKztcblx0ICAgICAgICB3aGlsZSAoIXRoaXMuZW9mKCkpIHtcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0O1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxleElkZW50aWZpZXIoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERGRkYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycy5cblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBzdGFydDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNsaWNlKHN0YXJ0LCB0aGlzLmluZGV4KTtcblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRDb21wbGV4SWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY3AgPSB0aGlzLmNvZGVQb2ludEF0KHRoaXMuaW5kZXgpO1xuXHQgICAgICAgIHZhciBpZCA9IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5mcm9tQ29kZVBvaW50KGNwKTtcblx0ICAgICAgICB0aGlzLmluZGV4ICs9IGlkLmxlbmd0aDtcblx0ICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG5cdCAgICAgICAgdmFyIGNoO1xuXHQgICAgICAgIGlmIChjcCA9PT0gMHg1Qykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSAhPT0gMHg3NSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5IZXhFc2NhcGUoJ3UnKTtcblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWQgPSBjaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XG5cdCAgICAgICAgICAgIGNwID0gdGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KTtcblx0ICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjcCkpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNoID0gY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmZyb21Db2RlUG9pbnQoY3ApO1xuXHQgICAgICAgICAgICBpZCArPSBjaDtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCArPSBjaC5sZW5ndGg7XG5cdCAgICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblx0ICAgICAgICAgICAgaWYgKGNwID09PSAweDVDKSB7XG5cdCAgICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpICE9PSAweDc1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc2NhbkhleEVzY2FwZSgndScpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gbnVsbCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWQgKz0gY2g7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGlkO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLm9jdGFsVG9EZWNpbWFsID0gZnVuY3Rpb24gKGNoKSB7XG5cdCAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2Vcblx0ICAgICAgICB2YXIgb2N0YWwgPSAoY2ggIT09ICcwJyk7XG5cdCAgICAgICAgdmFyIGNvZGUgPSBvY3RhbFZhbHVlKGNoKTtcblx0ICAgICAgICBpZiAoIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG5cdCAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArIG9jdGFsVmFsdWUodGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXSk7XG5cdCAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG5cdCAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuXHQgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiYgIXRoaXMuZW9mKCkgJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xuXHQgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgb2N0YWxWYWx1ZSh0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBjb2RlOiBjb2RlLFxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWxcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW5hbWVzLWFuZC1rZXl3b3Jkc1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbklkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHR5cGU7XG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcblx0ICAgICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHQgICAgICAgIHZhciBpZCA9ICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gMHg1QykgPyB0aGlzLmdldENvbXBsZXhJZGVudGlmaWVyKCkgOiB0aGlzLmdldElkZW50aWZpZXIoKTtcblx0ICAgICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXG5cdCAgICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuXHQgICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgdHlwZSA9IDMgLyogSWRlbnRpZmllciAqLztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5pc0tleXdvcmQoaWQpKSB7XG5cdCAgICAgICAgICAgIHR5cGUgPSA0IC8qIEtleXdvcmQgKi87XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcblx0ICAgICAgICAgICAgdHlwZSA9IDUgLyogTnVsbExpdGVyYWwgKi87XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcblx0ICAgICAgICAgICAgdHlwZSA9IDEgLyogQm9vbGVhbkxpdGVyYWwgKi87XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0eXBlID0gMyAvKiBJZGVudGlmaWVyICovO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZSAhPT0gMyAvKiBJZGVudGlmaWVyICovICYmIChzdGFydCArIGlkLmxlbmd0aCAhPT0gdGhpcy5pbmRleCkpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XG5cdCAgICAgICAgICAgIHRoaXMudG9sZXJhdGVVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCk7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSByZXN0b3JlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICAgICAgICB2YWx1ZTogaWQsXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXB1bmN0dWF0b3JzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuUHVuY3R1YXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuXHQgICAgICAgIHZhciBzdHIgPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcblx0ICAgICAgICBzd2l0Y2ggKHN0cikge1xuXHQgICAgICAgICAgICBjYXNlICcoJzpcblx0ICAgICAgICAgICAgY2FzZSAneyc6XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cmx5U3RhY2sucHVzaCgneycpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJy4nOlxuXHQgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnLicgJiYgdGhpcy5zb3VyY2VbdGhpcy5pbmRleCArIDFdID09PSAnLicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTcHJlYWQgb3BlcmF0b3I6IC4uLlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4uJztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICd9Jzpcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICcpJzpcblx0ICAgICAgICAgICAgY2FzZSAnOyc6XG5cdCAgICAgICAgICAgIGNhc2UgJywnOlxuXHQgICAgICAgICAgICBjYXNlICdbJzpcblx0ICAgICAgICAgICAgY2FzZSAnXSc6XG5cdCAgICAgICAgICAgIGNhc2UgJzonOlxuXHQgICAgICAgICAgICBjYXNlICc/Jzpcblx0ICAgICAgICAgICAgY2FzZSAnfic6XG5cdCAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3IuXG5cdCAgICAgICAgICAgICAgICBzdHIgPSB0aGlzLnNvdXJjZS5zdWJzdHIodGhpcy5pbmRleCwgNCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoc3RyID09PSAnPj4+PScpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIDMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdHIgPT09ICc9PT0nIHx8IHN0ciA9PT0gJyE9PScgfHwgc3RyID09PSAnPj4+JyB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICc8PD0nIHx8IHN0ciA9PT0gJz4+PScgfHwgc3RyID09PSAnKio9Jykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gc3RyLnN1YnN0cigwLCAyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gJyYmJyB8fCBzdHIgPT09ICd8fCcgfHwgc3RyID09PSAnPT0nIHx8IHN0ciA9PT0gJyE9JyB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnKz0nIHx8IHN0ciA9PT0gJy09JyB8fCBzdHIgPT09ICcqPScgfHwgc3RyID09PSAnLz0nIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgPT09ICcrKycgfHwgc3RyID09PSAnLS0nIHx8IHN0ciA9PT0gJzw8JyB8fCBzdHIgPT09ICc+PicgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9PT0gJyY9JyB8fCBzdHIgPT09ICd8PScgfHwgc3RyID09PSAnXj0nIHx8IHN0ciA9PT0gJyU9JyB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID09PSAnPD0nIHx8IHN0ciA9PT0gJz49JyB8fCBzdHIgPT09ICc9PicgfHwgc3RyID09PSAnKionKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2Yoc3RyKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gc3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiA3IC8qIFB1bmN0dWF0b3IgKi8sXG5cdCAgICAgICAgICAgIHZhbHVlOiBzdHIsXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5IZXhMaXRlcmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0hleERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW0sIDE2KSxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbkJpbmFyeUxpdGVyYWwgPSBmdW5jdGlvbiAoc3RhcnQpIHtcblx0ICAgICAgICB2YXIgbnVtID0gJyc7XG5cdCAgICAgICAgdmFyIGNoO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAoY2ggIT09ICcwJyAmJiBjaCAhPT0gJzEnKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG51bS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgLy8gb25seSAwYiBvciAwQlxuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG5cdCAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjaCkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiA2IC8qIE51bWVyaWNMaXRlcmFsICovLFxuXHQgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtLCAyKSxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uIChwcmVmaXgsIHN0YXJ0KSB7XG5cdCAgICAgICAgdmFyIG51bSA9ICcnO1xuXHQgICAgICAgIHZhciBvY3RhbCA9IGZhbHNlO1xuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KHByZWZpeC5jaGFyQ29kZUF0KDApKSkge1xuXHQgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG5cdCAgICAgICAgICAgIG51bSA9ICcwJyArIHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIW9jdGFsICYmIG51bS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgLy8gb25seSAwbyBvciAwT1xuXHQgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkgfHwgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bSwgOCksXG5cdCAgICAgICAgICAgIG9jdGFsOiBvY3RhbCxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBJbXBsaWNpdCBvY3RhbCwgdW5sZXNzIHRoZXJlIGlzIGEgbm9uLW9jdGFsIGRpZ2l0LlxuXHQgICAgICAgIC8vIChBbm5leCBCLjEuMSBvbiBOdW1lcmljIExpdGVyYWxzKVxuXHQgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmluZGV4ICsgMTsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5zb3VyY2VbaV07XG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJzgnIHx8IGNoID09PSAnOScpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc09jdGFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5OdW1lcmljTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3N0YXJ0XTtcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSwgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXHQgICAgICAgIHZhciBudW0gPSAnJztcblx0ICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuXHQgICAgICAgICAgICBudW0gPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG5cdCAgICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBvJy5cblx0ICAgICAgICAgICAgLy8gQmluYXJ5IG51bWJlciBpbiBFUzYgc3RhcnRzIHdpdGggJzBiJy5cblx0ICAgICAgICAgICAgaWYgKG51bSA9PT0gJzAnKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2InIHx8IGNoID09PSAnQicpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkJpbmFyeUxpdGVyYWwoc3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnbycgfHwgY2ggPT09ICdPJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChjaCAmJiBjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNPY3RhbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbXBsaWNpdE9jdGFsTGl0ZXJhbCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PY3RhbExpdGVyYWwoY2gsIHN0YXJ0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdCh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpKSkge1xuXHQgICAgICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNoID09PSAnLicpIHtcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcblx0ICAgICAgICAgICAgbnVtICs9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleF07XG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcblx0ICAgICAgICAgICAgICAgIG51bSArPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNEZWNpbWFsRGlnaXQodGhpcy5zb3VyY2UuY2hhckNvZGVBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBudW0gKz0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzSWRlbnRpZmllclN0YXJ0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogNiAvKiBOdW1lcmljTGl0ZXJhbCAqLyxcblx0ICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtKSxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtc3RyaW5nLWxpdGVyYWxzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuU3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgIHZhciBxdW90ZSA9IHRoaXMuc291cmNlW3N0YXJ0XTtcblx0ICAgICAgICBhc3NlcnRfMS5hc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgdmFyIG9jdGFsID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHN0ciA9ICcnO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICB2YXIgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG5cdCAgICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuXHQgICAgICAgICAgICAgICAgY2ggPSB0aGlzLnNvdXJjZVt0aGlzLmluZGV4KytdO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRfMSA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZF8xID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZF8xO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IHRoaXMuc2NhbkhleEVzY2FwZShjaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRIZXhFc2NhcGVTZXF1ZW5jZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOCc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzknOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggJiYgY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvY3RUb0RlYyA9IHRoaXMub2N0YWxUb0RlY2ltYWwoY2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gb2N0VG9EZWMub2N0YWwgfHwgb2N0YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUob2N0VG9EZWMuY29kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMubGluZU51bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAnXFxuJykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4ID0gc3RhcnQ7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogOCAvKiBTdHJpbmdMaXRlcmFsICovLFxuXHQgICAgICAgICAgICB2YWx1ZTogc3RyLFxuXHQgICAgICAgICAgICBvY3RhbDogb2N0YWwsXG5cdCAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcblx0ICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcblx0ICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuXHQgICAgICAgICAgICBlbmQ6IHRoaXMuaW5kZXhcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvb2tlZCA9ICcnO1xuXHQgICAgICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcblx0ICAgICAgICB2YXIgaGVhZCA9ICh0aGlzLnNvdXJjZVtzdGFydF0gPT09ICdgJyk7XG5cdCAgICAgICAgdmFyIHRhaWwgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgcmF3T2Zmc2V0ID0gMjtcblx0ICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ2AnKSB7XG5cdCAgICAgICAgICAgICAgICByYXdPZmZzZXQgPSAxO1xuXHQgICAgICAgICAgICAgICAgdGFpbCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnJCcpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ3snKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJseVN0YWNrLnB1c2goJyR7Jyk7XG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIGlmICghY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXG4nO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHInO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXHQnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlW3RoaXMuaW5kZXhdID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHRoaXMuc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN0b3JlID0gdGhpcy5pbmRleDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkXzIgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWRfMiAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQgKz0gdW5lc2NhcGVkXzI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4Jzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWQgPSB0aGlzLnNjYW5IZXhFc2NhcGUoY2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkSGV4RXNjYXBlU2VxdWVuY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IHVuZXNjYXBlZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxiJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFxmJztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2Jzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tlZCArPSAnXFx2Jztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMDEgXFwwMiBhbmQgc28gb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlRlbXBsYXRlT2N0YWxMaXRlcmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9ICdcXDAnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzT2N0YWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWw6IFxcMSBcXDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRocm93VW5leHBlY3RlZFRva2VuKG1lc3NhZ2VzXzEuTWVzc2FnZXMuVGVtcGxhdGVPY3RhbExpdGVyYWwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2VkICs9IGNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmxpbmVOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKyt0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgICsrdGhpcy5saW5lTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLnNvdXJjZVt0aGlzLmluZGV4XSA9PT0gJ1xcbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gJ1xcbic7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjb29rZWQgKz0gY2g7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFoZWFkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY3VybHlTdGFjay5wb3AoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdHlwZTogMTAgLyogVGVtcGxhdGUgKi8sXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZS5zbGljZShzdGFydCArIDEsIHRoaXMuaW5kZXggLSByYXdPZmZzZXQpLFxuXHQgICAgICAgICAgICBjb29rZWQ6IGNvb2tlZCxcblx0ICAgICAgICAgICAgaGVhZDogaGVhZCxcblx0ICAgICAgICAgICAgdGFpbDogdGFpbCxcblx0ICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICBsaW5lU3RhcnQ6IHRoaXMubGluZVN0YXJ0LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogdGhpcy5pbmRleFxuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXHQgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtcmVndWxhci1leHByZXNzaW9uLWxpdGVyYWxzXG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS50ZXN0UmVnRXhwID0gZnVuY3Rpb24gKHBhdHRlcm4sIGZsYWdzKSB7XG5cdCAgICAgICAgLy8gVGhlIEJNUCBjaGFyYWN0ZXIgdG8gdXNlIGFzIGEgcmVwbGFjZW1lbnQgZm9yIGFzdHJhbCBzeW1ib2xzIHdoZW5cblx0ICAgICAgICAvLyB0cmFuc2xhdGluZyBhbiBFUzYgXCJ1XCItZmxhZ2dlZCBwYXR0ZXJuIHRvIGFuIEVTNS1jb21wYXRpYmxlXG5cdCAgICAgICAgLy8gYXBwcm94aW1hdGlvbi5cblx0ICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCAnXFx1RkZGRicgZW5hYmxlcyBmYWxzZSBwb3NpdGl2ZXMgaW4gdW5saWtlbHlcblx0ICAgICAgICAvLyBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXsxMDQ0Zn0tXFx1ezEwNDQwfV1gIGlzIGFuIGludmFsaWRcblx0ICAgICAgICAvLyBwYXR0ZXJuIHRoYXQgd291bGQgbm90IGJlIGRldGVjdGVkIGJ5IHRoaXMgc3Vic3RpdHV0aW9uLlxuXHQgICAgICAgIHZhciBhc3RyYWxTdWJzdGl0dXRlID0gJ1xcdUZGRkYnO1xuXHQgICAgICAgIHZhciB0bXAgPSBwYXR0ZXJuO1xuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcblx0ICAgICAgICAgICAgdG1wID0gdG1wXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfXxcXFxcdShbYS1mQS1GMC05XXs0fSkvZywgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBwYXJzZUludCgkMSB8fCAkMiwgMTYpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4MTBGRkZGKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFzdHJhbFN1YnN0aXR1dGU7XG5cdCAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCBhc3RyYWxTdWJzdGl0dXRlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgUmVnRXhwKHRtcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3Jcblx0ICAgICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG5cdCAgICAgICAgLy8gdXNlcy5cblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcblx0ICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBCb2R5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgIGFzc2VydF8xLmFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcblx0ICAgICAgICB2YXIgc3RyID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICB2YXIgY2xhc3NNYXJrZXIgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgdGVybWluYXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIHdoaWxlICghdGhpcy5lb2YoKSkge1xuXHQgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXgrK107XG5cdCAgICAgICAgICAgIHN0ciArPSBjaDtcblx0ICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcblx0ICAgICAgICAgICAgICAgIGNoID0gdGhpcy5zb3VyY2VbdGhpcy5pbmRleCsrXTtcblx0ICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLXJlZ3VsYXItZXhwcmVzc2lvbi1saXRlcmFsc1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGhyb3dVbmV4cGVjdGVkVG9rZW4obWVzc2FnZXNfMS5NZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdbJykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd1VuZXhwZWN0ZWRUb2tlbihtZXNzYWdlc18xLk1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG5cdCAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuXHQgICAgfTtcblx0ICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5SZWdFeHBGbGFncyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RyID0gJyc7XG5cdCAgICAgICAgdmFyIGZsYWdzID0gJyc7XG5cdCAgICAgICAgd2hpbGUgKCF0aGlzLmVvZigpKSB7XG5cdCAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAoIWNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmICF0aGlzLmVvZigpKSB7XG5cdCAgICAgICAgICAgICAgICBjaCA9IHRoaXMuc291cmNlW3RoaXMuaW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcblx0ICAgICAgICAgICAgICAgICAgICArK3RoaXMuaW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RvcmUgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gdGhpcy5zY2FuSGV4RXNjYXBlKCd1Jyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXIgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2hhcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IHRoaXMuaW5kZXg7ICsrcmVzdG9yZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHRoaXMuc291cmNlW3Jlc3RvcmVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gcmVzdG9yZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1Jztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b2xlcmF0ZVVuZXhwZWN0ZWRUb2tlbigpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbGVyYXRlVW5leHBlY3RlZFRva2VuKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcblx0ICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZmxhZ3M7XG5cdCAgICB9O1xuXHQgICAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblJlZ0V4cCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuXHQgICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2FuUmVnRXhwQm9keSgpO1xuXHQgICAgICAgIHZhciBmbGFncyA9IHRoaXMuc2NhblJlZ0V4cEZsYWdzKCk7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0eXBlOiA5IC8qIFJlZ3VsYXJFeHByZXNzaW9uICovLFxuXHQgICAgICAgICAgICB2YWx1ZTogJycsXG5cdCAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFncyxcblx0ICAgICAgICAgICAgcmVnZXg6IHZhbHVlLFxuXHQgICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgIGxpbmVTdGFydDogdGhpcy5saW5lU3RhcnQsXG5cdCAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcblx0ICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICBTY2FubmVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuZW9mKCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogRU9GICovLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuXHQgICAgICAgICAgICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiB0aGlzLmxpbmVTdGFydCxcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmluZGV4LFxuXHQgICAgICAgICAgICAgICAgZW5kOiB0aGlzLmluZGV4XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjcCA9IHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0lkZW50aWZpZXJTdGFydChjcCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbklkZW50aWZpZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjggfHwgY3AgPT09IDB4MjkgfHwgY3AgPT09IDB4M0IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cblx0ICAgICAgICBpZiAoY3AgPT09IDB4MjcgfHwgY3AgPT09IDB4MjIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZ0xpdGVyYWwoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG5cdCAgICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuXHQgICAgICAgIGlmIChjcCA9PT0gMHgyRSkge1xuXHQgICAgICAgICAgICBpZiAoY2hhcmFjdGVyXzEuQ2hhcmFjdGVyLmlzRGVjaW1hbERpZ2l0KHRoaXMuc291cmNlLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNoYXJhY3Rlcl8xLkNoYXJhY3Rlci5pc0RlY2ltYWxEaWdpdChjcCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFRlbXBsYXRlIGxpdGVyYWxzIHN0YXJ0IHdpdGggYCAoVSswMDYwKSBmb3IgdGVtcGxhdGUgaGVhZFxuXHQgICAgICAgIC8vIG9yIH0gKFUrMDA3RCkgZm9yIHRlbXBsYXRlIG1pZGRsZSBvciB0ZW1wbGF0ZSB0YWlsLlxuXHQgICAgICAgIGlmIChjcCA9PT0gMHg2MCB8fCAoY3AgPT09IDB4N0QgJiYgdGhpcy5jdXJseVN0YWNrW3RoaXMuY3VybHlTdGFjay5sZW5ndGggLSAxXSA9PT0gJyR7JykpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRlbXBsYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFBvc3NpYmxlIGlkZW50aWZpZXIgc3RhcnQgaW4gYSBzdXJyb2dhdGUgcGFpci5cblx0ICAgICAgICBpZiAoY3AgPj0gMHhEODAwICYmIGNwIDwgMHhERkZGKSB7XG5cdCAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJfMS5DaGFyYWN0ZXIuaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdCh0aGlzLmluZGV4KSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhblB1bmN0dWF0b3IoKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2Nhbm5lcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5TY2FubmVyID0gU2Nhbm5lcjtcblxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMuVG9rZW5OYW1lID0ge307XG5cdGV4cG9ydHMuVG9rZW5OYW1lWzEgLyogQm9vbGVhbkxpdGVyYWwgKi9dID0gJ0Jvb2xlYW4nO1xuXHRleHBvcnRzLlRva2VuTmFtZVsyIC8qIEVPRiAqL10gPSAnPGVuZD4nO1xuXHRleHBvcnRzLlRva2VuTmFtZVszIC8qIElkZW50aWZpZXIgKi9dID0gJ0lkZW50aWZpZXInO1xuXHRleHBvcnRzLlRva2VuTmFtZVs0IC8qIEtleXdvcmQgKi9dID0gJ0tleXdvcmQnO1xuXHRleHBvcnRzLlRva2VuTmFtZVs1IC8qIE51bGxMaXRlcmFsICovXSA9ICdOdWxsJztcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbNiAvKiBOdW1lcmljTGl0ZXJhbCAqL10gPSAnTnVtZXJpYyc7XG5cdGV4cG9ydHMuVG9rZW5OYW1lWzcgLyogUHVuY3R1YXRvciAqL10gPSAnUHVuY3R1YXRvcic7XG5cdGV4cG9ydHMuVG9rZW5OYW1lWzggLyogU3RyaW5nTGl0ZXJhbCAqL10gPSAnU3RyaW5nJztcblx0ZXhwb3J0cy5Ub2tlbk5hbWVbOSAvKiBSZWd1bGFyRXhwcmVzc2lvbiAqL10gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuXHRleHBvcnRzLlRva2VuTmFtZVsxMCAvKiBUZW1wbGF0ZSAqL10gPSAnVGVtcGxhdGUnO1xuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8vIEdlbmVyYXRlZCBieSBnZW5lcmF0ZS14aHRtbC1lbnRpdGllcy5qcy4gRE8gTk9UIE1PRElGWSFcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLlhIVE1MRW50aXRpZXMgPSB7XG5cdCAgICBxdW90OiAnXFx1MDAyMicsXG5cdCAgICBhbXA6ICdcXHUwMDI2Jyxcblx0ICAgIGFwb3M6ICdcXHUwMDI3Jyxcblx0ICAgIGd0OiAnXFx1MDAzRScsXG5cdCAgICBuYnNwOiAnXFx1MDBBMCcsXG5cdCAgICBpZXhjbDogJ1xcdTAwQTEnLFxuXHQgICAgY2VudDogJ1xcdTAwQTInLFxuXHQgICAgcG91bmQ6ICdcXHUwMEEzJyxcblx0ICAgIGN1cnJlbjogJ1xcdTAwQTQnLFxuXHQgICAgeWVuOiAnXFx1MDBBNScsXG5cdCAgICBicnZiYXI6ICdcXHUwMEE2Jyxcblx0ICAgIHNlY3Q6ICdcXHUwMEE3Jyxcblx0ICAgIHVtbDogJ1xcdTAwQTgnLFxuXHQgICAgY29weTogJ1xcdTAwQTknLFxuXHQgICAgb3JkZjogJ1xcdTAwQUEnLFxuXHQgICAgbGFxdW86ICdcXHUwMEFCJyxcblx0ICAgIG5vdDogJ1xcdTAwQUMnLFxuXHQgICAgc2h5OiAnXFx1MDBBRCcsXG5cdCAgICByZWc6ICdcXHUwMEFFJyxcblx0ICAgIG1hY3I6ICdcXHUwMEFGJyxcblx0ICAgIGRlZzogJ1xcdTAwQjAnLFxuXHQgICAgcGx1c21uOiAnXFx1MDBCMScsXG5cdCAgICBzdXAyOiAnXFx1MDBCMicsXG5cdCAgICBzdXAzOiAnXFx1MDBCMycsXG5cdCAgICBhY3V0ZTogJ1xcdTAwQjQnLFxuXHQgICAgbWljcm86ICdcXHUwMEI1Jyxcblx0ICAgIHBhcmE6ICdcXHUwMEI2Jyxcblx0ICAgIG1pZGRvdDogJ1xcdTAwQjcnLFxuXHQgICAgY2VkaWw6ICdcXHUwMEI4Jyxcblx0ICAgIHN1cDE6ICdcXHUwMEI5Jyxcblx0ICAgIG9yZG06ICdcXHUwMEJBJyxcblx0ICAgIHJhcXVvOiAnXFx1MDBCQicsXG5cdCAgICBmcmFjMTQ6ICdcXHUwMEJDJyxcblx0ICAgIGZyYWMxMjogJ1xcdTAwQkQnLFxuXHQgICAgZnJhYzM0OiAnXFx1MDBCRScsXG5cdCAgICBpcXVlc3Q6ICdcXHUwMEJGJyxcblx0ICAgIEFncmF2ZTogJ1xcdTAwQzAnLFxuXHQgICAgQWFjdXRlOiAnXFx1MDBDMScsXG5cdCAgICBBY2lyYzogJ1xcdTAwQzInLFxuXHQgICAgQXRpbGRlOiAnXFx1MDBDMycsXG5cdCAgICBBdW1sOiAnXFx1MDBDNCcsXG5cdCAgICBBcmluZzogJ1xcdTAwQzUnLFxuXHQgICAgQUVsaWc6ICdcXHUwMEM2Jyxcblx0ICAgIENjZWRpbDogJ1xcdTAwQzcnLFxuXHQgICAgRWdyYXZlOiAnXFx1MDBDOCcsXG5cdCAgICBFYWN1dGU6ICdcXHUwMEM5Jyxcblx0ICAgIEVjaXJjOiAnXFx1MDBDQScsXG5cdCAgICBFdW1sOiAnXFx1MDBDQicsXG5cdCAgICBJZ3JhdmU6ICdcXHUwMENDJyxcblx0ICAgIElhY3V0ZTogJ1xcdTAwQ0QnLFxuXHQgICAgSWNpcmM6ICdcXHUwMENFJyxcblx0ICAgIEl1bWw6ICdcXHUwMENGJyxcblx0ICAgIEVUSDogJ1xcdTAwRDAnLFxuXHQgICAgTnRpbGRlOiAnXFx1MDBEMScsXG5cdCAgICBPZ3JhdmU6ICdcXHUwMEQyJyxcblx0ICAgIE9hY3V0ZTogJ1xcdTAwRDMnLFxuXHQgICAgT2NpcmM6ICdcXHUwMEQ0Jyxcblx0ICAgIE90aWxkZTogJ1xcdTAwRDUnLFxuXHQgICAgT3VtbDogJ1xcdTAwRDYnLFxuXHQgICAgdGltZXM6ICdcXHUwMEQ3Jyxcblx0ICAgIE9zbGFzaDogJ1xcdTAwRDgnLFxuXHQgICAgVWdyYXZlOiAnXFx1MDBEOScsXG5cdCAgICBVYWN1dGU6ICdcXHUwMERBJyxcblx0ICAgIFVjaXJjOiAnXFx1MDBEQicsXG5cdCAgICBVdW1sOiAnXFx1MDBEQycsXG5cdCAgICBZYWN1dGU6ICdcXHUwMEREJyxcblx0ICAgIFRIT1JOOiAnXFx1MDBERScsXG5cdCAgICBzemxpZzogJ1xcdTAwREYnLFxuXHQgICAgYWdyYXZlOiAnXFx1MDBFMCcsXG5cdCAgICBhYWN1dGU6ICdcXHUwMEUxJyxcblx0ICAgIGFjaXJjOiAnXFx1MDBFMicsXG5cdCAgICBhdGlsZGU6ICdcXHUwMEUzJyxcblx0ICAgIGF1bWw6ICdcXHUwMEU0Jyxcblx0ICAgIGFyaW5nOiAnXFx1MDBFNScsXG5cdCAgICBhZWxpZzogJ1xcdTAwRTYnLFxuXHQgICAgY2NlZGlsOiAnXFx1MDBFNycsXG5cdCAgICBlZ3JhdmU6ICdcXHUwMEU4Jyxcblx0ICAgIGVhY3V0ZTogJ1xcdTAwRTknLFxuXHQgICAgZWNpcmM6ICdcXHUwMEVBJyxcblx0ICAgIGV1bWw6ICdcXHUwMEVCJyxcblx0ICAgIGlncmF2ZTogJ1xcdTAwRUMnLFxuXHQgICAgaWFjdXRlOiAnXFx1MDBFRCcsXG5cdCAgICBpY2lyYzogJ1xcdTAwRUUnLFxuXHQgICAgaXVtbDogJ1xcdTAwRUYnLFxuXHQgICAgZXRoOiAnXFx1MDBGMCcsXG5cdCAgICBudGlsZGU6ICdcXHUwMEYxJyxcblx0ICAgIG9ncmF2ZTogJ1xcdTAwRjInLFxuXHQgICAgb2FjdXRlOiAnXFx1MDBGMycsXG5cdCAgICBvY2lyYzogJ1xcdTAwRjQnLFxuXHQgICAgb3RpbGRlOiAnXFx1MDBGNScsXG5cdCAgICBvdW1sOiAnXFx1MDBGNicsXG5cdCAgICBkaXZpZGU6ICdcXHUwMEY3Jyxcblx0ICAgIG9zbGFzaDogJ1xcdTAwRjgnLFxuXHQgICAgdWdyYXZlOiAnXFx1MDBGOScsXG5cdCAgICB1YWN1dGU6ICdcXHUwMEZBJyxcblx0ICAgIHVjaXJjOiAnXFx1MDBGQicsXG5cdCAgICB1dW1sOiAnXFx1MDBGQycsXG5cdCAgICB5YWN1dGU6ICdcXHUwMEZEJyxcblx0ICAgIHRob3JuOiAnXFx1MDBGRScsXG5cdCAgICB5dW1sOiAnXFx1MDBGRicsXG5cdCAgICBPRWxpZzogJ1xcdTAxNTInLFxuXHQgICAgb2VsaWc6ICdcXHUwMTUzJyxcblx0ICAgIFNjYXJvbjogJ1xcdTAxNjAnLFxuXHQgICAgc2Nhcm9uOiAnXFx1MDE2MScsXG5cdCAgICBZdW1sOiAnXFx1MDE3OCcsXG5cdCAgICBmbm9mOiAnXFx1MDE5MicsXG5cdCAgICBjaXJjOiAnXFx1MDJDNicsXG5cdCAgICB0aWxkZTogJ1xcdTAyREMnLFxuXHQgICAgQWxwaGE6ICdcXHUwMzkxJyxcblx0ICAgIEJldGE6ICdcXHUwMzkyJyxcblx0ICAgIEdhbW1hOiAnXFx1MDM5MycsXG5cdCAgICBEZWx0YTogJ1xcdTAzOTQnLFxuXHQgICAgRXBzaWxvbjogJ1xcdTAzOTUnLFxuXHQgICAgWmV0YTogJ1xcdTAzOTYnLFxuXHQgICAgRXRhOiAnXFx1MDM5NycsXG5cdCAgICBUaGV0YTogJ1xcdTAzOTgnLFxuXHQgICAgSW90YTogJ1xcdTAzOTknLFxuXHQgICAgS2FwcGE6ICdcXHUwMzlBJyxcblx0ICAgIExhbWJkYTogJ1xcdTAzOUInLFxuXHQgICAgTXU6ICdcXHUwMzlDJyxcblx0ICAgIE51OiAnXFx1MDM5RCcsXG5cdCAgICBYaTogJ1xcdTAzOUUnLFxuXHQgICAgT21pY3JvbjogJ1xcdTAzOUYnLFxuXHQgICAgUGk6ICdcXHUwM0EwJyxcblx0ICAgIFJobzogJ1xcdTAzQTEnLFxuXHQgICAgU2lnbWE6ICdcXHUwM0EzJyxcblx0ICAgIFRhdTogJ1xcdTAzQTQnLFxuXHQgICAgVXBzaWxvbjogJ1xcdTAzQTUnLFxuXHQgICAgUGhpOiAnXFx1MDNBNicsXG5cdCAgICBDaGk6ICdcXHUwM0E3Jyxcblx0ICAgIFBzaTogJ1xcdTAzQTgnLFxuXHQgICAgT21lZ2E6ICdcXHUwM0E5Jyxcblx0ICAgIGFscGhhOiAnXFx1MDNCMScsXG5cdCAgICBiZXRhOiAnXFx1MDNCMicsXG5cdCAgICBnYW1tYTogJ1xcdTAzQjMnLFxuXHQgICAgZGVsdGE6ICdcXHUwM0I0Jyxcblx0ICAgIGVwc2lsb246ICdcXHUwM0I1Jyxcblx0ICAgIHpldGE6ICdcXHUwM0I2Jyxcblx0ICAgIGV0YTogJ1xcdTAzQjcnLFxuXHQgICAgdGhldGE6ICdcXHUwM0I4Jyxcblx0ICAgIGlvdGE6ICdcXHUwM0I5Jyxcblx0ICAgIGthcHBhOiAnXFx1MDNCQScsXG5cdCAgICBsYW1iZGE6ICdcXHUwM0JCJyxcblx0ICAgIG11OiAnXFx1MDNCQycsXG5cdCAgICBudTogJ1xcdTAzQkQnLFxuXHQgICAgeGk6ICdcXHUwM0JFJyxcblx0ICAgIG9taWNyb246ICdcXHUwM0JGJyxcblx0ICAgIHBpOiAnXFx1MDNDMCcsXG5cdCAgICByaG86ICdcXHUwM0MxJyxcblx0ICAgIHNpZ21hZjogJ1xcdTAzQzInLFxuXHQgICAgc2lnbWE6ICdcXHUwM0MzJyxcblx0ICAgIHRhdTogJ1xcdTAzQzQnLFxuXHQgICAgdXBzaWxvbjogJ1xcdTAzQzUnLFxuXHQgICAgcGhpOiAnXFx1MDNDNicsXG5cdCAgICBjaGk6ICdcXHUwM0M3Jyxcblx0ICAgIHBzaTogJ1xcdTAzQzgnLFxuXHQgICAgb21lZ2E6ICdcXHUwM0M5Jyxcblx0ICAgIHRoZXRhc3ltOiAnXFx1MDNEMScsXG5cdCAgICB1cHNpaDogJ1xcdTAzRDInLFxuXHQgICAgcGl2OiAnXFx1MDNENicsXG5cdCAgICBlbnNwOiAnXFx1MjAwMicsXG5cdCAgICBlbXNwOiAnXFx1MjAwMycsXG5cdCAgICB0aGluc3A6ICdcXHUyMDA5Jyxcblx0ICAgIHp3bmo6ICdcXHUyMDBDJyxcblx0ICAgIHp3ajogJ1xcdTIwMEQnLFxuXHQgICAgbHJtOiAnXFx1MjAwRScsXG5cdCAgICBybG06ICdcXHUyMDBGJyxcblx0ICAgIG5kYXNoOiAnXFx1MjAxMycsXG5cdCAgICBtZGFzaDogJ1xcdTIwMTQnLFxuXHQgICAgbHNxdW86ICdcXHUyMDE4Jyxcblx0ICAgIHJzcXVvOiAnXFx1MjAxOScsXG5cdCAgICBzYnF1bzogJ1xcdTIwMUEnLFxuXHQgICAgbGRxdW86ICdcXHUyMDFDJyxcblx0ICAgIHJkcXVvOiAnXFx1MjAxRCcsXG5cdCAgICBiZHF1bzogJ1xcdTIwMUUnLFxuXHQgICAgZGFnZ2VyOiAnXFx1MjAyMCcsXG5cdCAgICBEYWdnZXI6ICdcXHUyMDIxJyxcblx0ICAgIGJ1bGw6ICdcXHUyMDIyJyxcblx0ICAgIGhlbGxpcDogJ1xcdTIwMjYnLFxuXHQgICAgcGVybWlsOiAnXFx1MjAzMCcsXG5cdCAgICBwcmltZTogJ1xcdTIwMzInLFxuXHQgICAgUHJpbWU6ICdcXHUyMDMzJyxcblx0ICAgIGxzYXF1bzogJ1xcdTIwMzknLFxuXHQgICAgcnNhcXVvOiAnXFx1MjAzQScsXG5cdCAgICBvbGluZTogJ1xcdTIwM0UnLFxuXHQgICAgZnJhc2w6ICdcXHUyMDQ0Jyxcblx0ICAgIGV1cm86ICdcXHUyMEFDJyxcblx0ICAgIGltYWdlOiAnXFx1MjExMScsXG5cdCAgICB3ZWllcnA6ICdcXHUyMTE4Jyxcblx0ICAgIHJlYWw6ICdcXHUyMTFDJyxcblx0ICAgIHRyYWRlOiAnXFx1MjEyMicsXG5cdCAgICBhbGVmc3ltOiAnXFx1MjEzNScsXG5cdCAgICBsYXJyOiAnXFx1MjE5MCcsXG5cdCAgICB1YXJyOiAnXFx1MjE5MScsXG5cdCAgICByYXJyOiAnXFx1MjE5MicsXG5cdCAgICBkYXJyOiAnXFx1MjE5MycsXG5cdCAgICBoYXJyOiAnXFx1MjE5NCcsXG5cdCAgICBjcmFycjogJ1xcdTIxQjUnLFxuXHQgICAgbEFycjogJ1xcdTIxRDAnLFxuXHQgICAgdUFycjogJ1xcdTIxRDEnLFxuXHQgICAgckFycjogJ1xcdTIxRDInLFxuXHQgICAgZEFycjogJ1xcdTIxRDMnLFxuXHQgICAgaEFycjogJ1xcdTIxRDQnLFxuXHQgICAgZm9yYWxsOiAnXFx1MjIwMCcsXG5cdCAgICBwYXJ0OiAnXFx1MjIwMicsXG5cdCAgICBleGlzdDogJ1xcdTIyMDMnLFxuXHQgICAgZW1wdHk6ICdcXHUyMjA1Jyxcblx0ICAgIG5hYmxhOiAnXFx1MjIwNycsXG5cdCAgICBpc2luOiAnXFx1MjIwOCcsXG5cdCAgICBub3RpbjogJ1xcdTIyMDknLFxuXHQgICAgbmk6ICdcXHUyMjBCJyxcblx0ICAgIHByb2Q6ICdcXHUyMjBGJyxcblx0ICAgIHN1bTogJ1xcdTIyMTEnLFxuXHQgICAgbWludXM6ICdcXHUyMjEyJyxcblx0ICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxuXHQgICAgcmFkaWM6ICdcXHUyMjFBJyxcblx0ICAgIHByb3A6ICdcXHUyMjFEJyxcblx0ICAgIGluZmluOiAnXFx1MjIxRScsXG5cdCAgICBhbmc6ICdcXHUyMjIwJyxcblx0ICAgIGFuZDogJ1xcdTIyMjcnLFxuXHQgICAgb3I6ICdcXHUyMjI4Jyxcblx0ICAgIGNhcDogJ1xcdTIyMjknLFxuXHQgICAgY3VwOiAnXFx1MjIyQScsXG5cdCAgICBpbnQ6ICdcXHUyMjJCJyxcblx0ICAgIHRoZXJlNDogJ1xcdTIyMzQnLFxuXHQgICAgc2ltOiAnXFx1MjIzQycsXG5cdCAgICBjb25nOiAnXFx1MjI0NScsXG5cdCAgICBhc3ltcDogJ1xcdTIyNDgnLFxuXHQgICAgbmU6ICdcXHUyMjYwJyxcblx0ICAgIGVxdWl2OiAnXFx1MjI2MScsXG5cdCAgICBsZTogJ1xcdTIyNjQnLFxuXHQgICAgZ2U6ICdcXHUyMjY1Jyxcblx0ICAgIHN1YjogJ1xcdTIyODInLFxuXHQgICAgc3VwOiAnXFx1MjI4MycsXG5cdCAgICBuc3ViOiAnXFx1MjI4NCcsXG5cdCAgICBzdWJlOiAnXFx1MjI4NicsXG5cdCAgICBzdXBlOiAnXFx1MjI4NycsXG5cdCAgICBvcGx1czogJ1xcdTIyOTUnLFxuXHQgICAgb3RpbWVzOiAnXFx1MjI5NycsXG5cdCAgICBwZXJwOiAnXFx1MjJBNScsXG5cdCAgICBzZG90OiAnXFx1MjJDNScsXG5cdCAgICBsY2VpbDogJ1xcdTIzMDgnLFxuXHQgICAgcmNlaWw6ICdcXHUyMzA5Jyxcblx0ICAgIGxmbG9vcjogJ1xcdTIzMEEnLFxuXHQgICAgcmZsb29yOiAnXFx1MjMwQicsXG5cdCAgICBsb3o6ICdcXHUyNUNBJyxcblx0ICAgIHNwYWRlczogJ1xcdTI2NjAnLFxuXHQgICAgY2x1YnM6ICdcXHUyNjYzJyxcblx0ICAgIGhlYXJ0czogJ1xcdTI2NjUnLFxuXHQgICAgZGlhbXM6ICdcXHUyNjY2Jyxcblx0ICAgIGxhbmc6ICdcXHUyN0U4Jyxcblx0ICAgIHJhbmc6ICdcXHUyN0U5J1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGVycm9yX2hhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgc2Nhbm5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciB0b2tlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdHZhciBSZWFkZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gUmVhZGVyKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gW107XG5cdCAgICAgICAgdGhpcy5jdXJseSA9IHRoaXMucGFyZW4gPSAtMTtcblx0ICAgIH1cblx0ICAgIC8vIEEgZnVuY3Rpb24gZm9sbG93aW5nIG9uZSBvZiB0aG9zZSB0b2tlbnMgaXMgYW4gZXhwcmVzc2lvbi5cblx0ICAgIFJlYWRlci5wcm90b3R5cGUuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb24gKHQpIHtcblx0ICAgICAgICByZXR1cm4gWycoJywgJ3snLCAnWycsICdpbicsICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsICduZXcnLFxuXHQgICAgICAgICAgICAncmV0dXJuJywgJ2Nhc2UnLCAnZGVsZXRlJywgJ3Rocm93JywgJ3ZvaWQnLFxuXHQgICAgICAgICAgICAvLyBhc3NpZ25tZW50IG9wZXJhdG9yc1xuXHQgICAgICAgICAgICAnPScsICcrPScsICctPScsICcqPScsICcqKj0nLCAnLz0nLCAnJT0nLCAnPDw9JywgJz4+PScsICc+Pj49Jyxcblx0ICAgICAgICAgICAgJyY9JywgJ3w9JywgJ149JywgJywnLFxuXHQgICAgICAgICAgICAvLyBiaW5hcnkvdW5hcnkgb3BlcmF0b3JzXG5cdCAgICAgICAgICAgICcrJywgJy0nLCAnKicsICcqKicsICcvJywgJyUnLCAnKysnLCAnLS0nLCAnPDwnLCAnPj4nLCAnPj4+JywgJyYnLFxuXHQgICAgICAgICAgICAnfCcsICdeJywgJyEnLCAnficsICcmJicsICd8fCcsICc/JywgJzonLCAnPT09JywgJz09JywgJz49Jyxcblx0ICAgICAgICAgICAgJzw9JywgJzwnLCAnPicsICchPScsICchPT0nXS5pbmRleE9mKHQpID49IDA7XG5cdCAgICB9O1xuXHQgICAgLy8gRGV0ZXJtaW5lIGlmIGZvcndhcmQgc2xhc2ggKC8pIGlzIGFuIG9wZXJhdG9yIG9yIHBhcnQgb2YgYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmlzUmVnZXhTdGFydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlcy5sZW5ndGggLSAxXTtcblx0ICAgICAgICB2YXIgcmVnZXggPSAocHJldmlvdXMgIT09IG51bGwpO1xuXHQgICAgICAgIHN3aXRjaCAocHJldmlvdXMpIHtcblx0ICAgICAgICAgICAgY2FzZSAndGhpcyc6XG5cdCAgICAgICAgICAgIGNhc2UgJ10nOlxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlICcpJzpcblx0ICAgICAgICAgICAgICAgIHZhciBrZXl3b3JkID0gdGhpcy52YWx1ZXNbdGhpcy5wYXJlbiAtIDFdO1xuXHQgICAgICAgICAgICAgICAgcmVnZXggPSAoa2V5d29yZCA9PT0gJ2lmJyB8fCBrZXl3b3JkID09PSAnd2hpbGUnIHx8IGtleXdvcmQgPT09ICdmb3InIHx8IGtleXdvcmQgPT09ICd3aXRoJyk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAnfSc6XG5cdCAgICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcblx0ICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuXHQgICAgICAgICAgICAgICAgcmVnZXggPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlc1t0aGlzLmN1cmx5IC0gM10gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24oKXt9IC80MlxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA0XTtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZXNbdGhpcy5jdXJseSAtIDRdID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24sIGUuZy4gZnVuY3Rpb24gZigpe30gLzQyL1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9IHRoaXMudmFsdWVzW3RoaXMuY3VybHkgLSA1XTtcblx0ICAgICAgICAgICAgICAgICAgICByZWdleCA9IGNoZWNrID8gIXRoaXMuYmVmb3JlRnVuY3Rpb25FeHByZXNzaW9uKGNoZWNrKSA6IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVnZXg7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHRva2VuKSB7XG5cdCAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDcgLyogUHVuY3R1YXRvciAqLyB8fCB0b2tlbi50eXBlID09PSA0IC8qIEtleXdvcmQgKi8pIHtcblx0ICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAneycpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY3VybHkgPSB0aGlzLnZhbHVlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udmFsdWUgPT09ICcoJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wYXJlbiA9IHRoaXMudmFsdWVzLmxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHRva2VuLnZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2gobnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZWFkZXI7XG5cdH0oKSk7XG5cdHZhciBUb2tlbml6ZXIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gVG9rZW5pemVyKGNvZGUsIGNvbmZpZykge1xuXHQgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbmV3IGVycm9yX2hhbmRsZXJfMS5FcnJvckhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLmVycm9ySGFuZGxlci50b2xlcmFudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgY29uZmlnLnRvbGVyYW50KSA6IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuc2Nhbm5lciA9IG5ldyBzY2FubmVyXzEuU2Nhbm5lcihjb2RlLCB0aGlzLmVycm9ySGFuZGxlcik7XG5cdCAgICAgICAgdGhpcy5zY2FubmVyLnRyYWNrQ29tbWVudCA9IGNvbmZpZyA/ICh0eXBlb2YgY29uZmlnLmNvbW1lbnQgPT09ICdib29sZWFuJyAmJiBjb25maWcuY29tbWVudCkgOiBmYWxzZTtcblx0ICAgICAgICB0aGlzLnRyYWNrUmFuZ2UgPSBjb25maWcgPyAodHlwZW9mIGNvbmZpZy5yYW5nZSA9PT0gJ2Jvb2xlYW4nICYmIGNvbmZpZy5yYW5nZSkgOiBmYWxzZTtcblx0ICAgICAgICB0aGlzLnRyYWNrTG9jID0gY29uZmlnID8gKHR5cGVvZiBjb25maWcubG9jID09PSAnYm9vbGVhbicgJiYgY29uZmlnLmxvYykgOiBmYWxzZTtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuXHQgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IFJlYWRlcigpO1xuXHQgICAgfVxuXHQgICAgVG9rZW5pemVyLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JIYW5kbGVyLmVycm9ycztcblx0ICAgIH07XG5cdCAgICBUb2tlbml6ZXIucHJvdG90eXBlLmdldE5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21tZW50cyA9IHRoaXMuc2Nhbm5lci5zY2FuQ29tbWVudHMoKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50cmFja0NvbW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyArK2kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvbW1lbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc2xpY2UoZS5zbGljZVswXSwgZS5zbGljZVsxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGUubXVsdGlMaW5lID8gJ0Jsb2NrQ29tbWVudCcgOiAnTGluZUNvbW1lbnQnLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5yYW5nZSA9IGUucmFuZ2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQubG9jID0gZS5sb2M7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goY29tbWVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCF0aGlzLnNjYW5uZXIuZW9mKCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsb2MgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0xvYykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvYyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuc2Nhbm5lci5saW5lTnVtYmVyLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNjYW5uZXIuaW5kZXggLSB0aGlzLnNjYW5uZXIubGluZVN0YXJ0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZDoge31cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UmVnZXggPSAodGhpcy5zY2FubmVyLnNvdXJjZVt0aGlzLnNjYW5uZXIuaW5kZXhdID09PSAnLycpICYmIHRoaXMucmVhZGVyLmlzUmVnZXhTdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gc3RhcnRSZWdleCA/IHRoaXMuc2Nhbm5lci5zY2FuUmVnRXhwKCkgOiB0aGlzLnNjYW5uZXIubGV4KCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiB0b2tlbl8xLlRva2VuTmFtZVt0b2tlbi50eXBlXSxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrUmFuZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeS5yYW5nZSA9IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrTG9jKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5zY2FubmVyLmxpbmVOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zY2FubmVyLmluZGV4IC0gdGhpcy5zY2FubmVyLmxpbmVTdGFydFxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkubG9jID0gbG9jO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogUmVndWxhckV4cHJlc3Npb24gKi8pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHRva2VuLnBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gdG9rZW4uZmxhZ3M7XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7IHBhdHRlcm46IHBhdHRlcm4sIGZsYWdzOiBmbGFncyB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChlbnRyeSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRva2VuaXplcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5cblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXMtZXh0ZW5kYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZChvLyosIG9iamVjdHMqLykge1xuICBpZiAoIWlzT2JqZWN0KG8pKSB7IG8gPSB7fTsgfVxuXG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICBhc3NpZ24obywgb2JqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59O1xuXG5mdW5jdGlvbiBhc3NpZ24oYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXNPd24oYiwga2V5KSkge1xuICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYGtleWAgaXMgYW4gb3duIHByb3BlcnR5IG9mIGBvYmpgLlxuICovXG5cbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgc2VjdGlvbnMgPSByZXF1aXJlKCdzZWN0aW9uLW1hdHRlcicpO1xuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2xpYi9kZWZhdWx0cycpO1xuY29uc3Qgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG5jb25zdCBleGNlcnB0ID0gcmVxdWlyZSgnLi9saWIvZXhjZXJwdCcpO1xuY29uc3QgZW5naW5lcyA9IHJlcXVpcmUoJy4vbGliL2VuZ2luZXMnKTtcbmNvbnN0IHRvRmlsZSA9IHJlcXVpcmUoJy4vbGliL3RvLWZpbGUnKTtcbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyBvciBvYmplY3Qgd2l0aCBgY29udGVudGAgcHJvcGVydHksIGV4dHJhY3RzXG4gKiBhbmQgcGFyc2VzIGZyb250LW1hdHRlciBmcm9tIHRoZSBzdHJpbmcsIHRoZW4gcmV0dXJucyBhbiBvYmplY3RcbiAqIHdpdGggYGRhdGFgLCBgY29udGVudGAgYW5kIG90aGVyIFt1c2VmdWwgcHJvcGVydGllc10oI3JldHVybmVkLW9iamVjdCkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1hdHRlciA9IHJlcXVpcmUoJ2dyYXktbWF0dGVyJyk7XG4gKiBjb25zb2xlLmxvZyhtYXR0ZXIoJy0tLVxcbnRpdGxlOiBIb21lXFxuLS0tXFxuT3RoZXIgc3R1ZmYnKSk7XG4gKiAvLz0+IHsgZGF0YTogeyB0aXRsZTogJ0hvbWUnfSwgY29udGVudDogJ090aGVyIHN0dWZmJyB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYGlucHV0YCBTdHJpbmcsIG9yIG9iamVjdCB3aXRoIGBjb250ZW50YCBzdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0dGVyKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICByZXR1cm4geyBkYXRhOiB7fSwgY29udGVudDogaW5wdXQsIGV4Y2VycHQ6ICcnLCBvcmlnOiBpbnB1dCB9O1xuICB9XG5cbiAgbGV0IGZpbGUgPSB0b0ZpbGUoaW5wdXQpO1xuICBjb25zdCBjYWNoZWQgPSBtYXR0ZXIuY2FjaGVbZmlsZS5jb250ZW50XTtcblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBmaWxlID0gT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbiAgICAgIGZpbGUub3JpZyA9IGNhY2hlZC5vcmlnO1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuXG4gICAgLy8gb25seSBjYWNoZSBpZiB0aGVyZSBhcmUgbm8gb3B0aW9ucyBwYXNzZWQuIGlmIHdlIGNhY2hlIHdoZW4gb3B0aW9uc1xuICAgIC8vIGFyZSBwYXNzZWQsIHdlIHdvdWxkIG5lZWQgdG8gYWxzbyBjYWNoZSBvcHRpb25zIHZhbHVlcywgd2hpY2ggd291bGRcbiAgICAvLyBuZWdhdGUgYW55IHBlcmZvcm1hbmNlIGJlbmVmaXRzIG9mIGNhY2hpbmdcbiAgICBtYXR0ZXIuY2FjaGVbZmlsZS5jb250ZW50XSA9IGZpbGU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VNYXR0ZXIoZmlsZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGFyc2UgZnJvbnQgbWF0dGVyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNYXR0ZXIoZmlsZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdHMob3B0aW9ucyk7XG4gIGNvbnN0IG9wZW4gPSBvcHRzLmRlbGltaXRlcnNbMF07XG4gIGNvbnN0IGNsb3NlID0gJ1xcbicgKyBvcHRzLmRlbGltaXRlcnNbMV07XG4gIGxldCBzdHIgPSBmaWxlLmNvbnRlbnQ7XG5cbiAgaWYgKG9wdHMubGFuZ3VhZ2UpIHtcbiAgICBmaWxlLmxhbmd1YWdlID0gb3B0cy5sYW5ndWFnZTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBvcGVuaW5nIGRlbGltaXRlclxuICBjb25zdCBvcGVuTGVuID0gb3Blbi5sZW5ndGg7XG4gIGlmICghdXRpbHMuc3RhcnRzV2l0aChzdHIsIG9wZW4sIG9wZW5MZW4pKSB7XG4gICAgZXhjZXJwdChmaWxlLCBvcHRzKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBhZnRlciB0aGUgb3BlbmluZyBkZWxpbWl0ZXIgaXNcbiAgLy8gYSBjaGFyYWN0ZXIgZnJvbSB0aGUgZGVsaW1pdGVyLCB0aGVuIGl0J3Mgbm90IGEgZnJvbnQtXG4gIC8vIG1hdHRlciBkZWxpbWl0ZXJcbiAgaWYgKHN0ci5jaGFyQXQob3BlbkxlbikgPT09IG9wZW4uc2xpY2UoLTEpKSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICAvLyBzdHJpcCB0aGUgb3BlbmluZyBkZWxpbWl0ZXJcbiAgc3RyID0gc3RyLnNsaWNlKG9wZW5MZW4pO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIC8vIHVzZSB0aGUgbGFuZ3VhZ2UgZGVmaW5lZCBhZnRlciBmaXJzdCBkZWxpbWl0ZXIsIGlmIGl0IGV4aXN0c1xuICBjb25zdCBsYW5ndWFnZSA9IG1hdHRlci5sYW5ndWFnZShzdHIsIG9wdHMpO1xuICBpZiAobGFuZ3VhZ2UubmFtZSkge1xuICAgIGZpbGUubGFuZ3VhZ2UgPSBsYW5ndWFnZS5uYW1lO1xuICAgIHN0ciA9IHN0ci5zbGljZShsYW5ndWFnZS5yYXcubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGNsb3NpbmcgZGVsaW1pdGVyXG4gIGxldCBjbG9zZUluZGV4ID0gc3RyLmluZGV4T2YoY2xvc2UpO1xuICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcbiAgICBjbG9zZUluZGV4ID0gbGVuO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSByYXcgZnJvbnQtbWF0dGVyIGJsb2NrXG4gIGZpbGUubWF0dGVyID0gc3RyLnNsaWNlKDAsIGNsb3NlSW5kZXgpO1xuXG4gIGNvbnN0IGJsb2NrID0gZmlsZS5tYXR0ZXIucmVwbGFjZSgvXlxccyojW15cXG5dKy9nbSwgJycpLnRyaW0oKTtcbiAgaWYgKGJsb2NrID09PSAnJykge1xuICAgIGZpbGUuaXNFbXB0eSA9IHRydWU7XG4gICAgZmlsZS5lbXB0eSA9IGZpbGUuY29udGVudDtcbiAgICBmaWxlLmRhdGEgPSB7fTtcbiAgfSBlbHNlIHtcblxuICAgIC8vIGNyZWF0ZSBmaWxlLmRhdGEgYnkgcGFyc2luZyB0aGUgcmF3IGZpbGUubWF0dGVyIGJsb2NrXG4gICAgZmlsZS5kYXRhID0gcGFyc2UoZmlsZS5sYW5ndWFnZSwgZmlsZS5tYXR0ZXIsIG9wdHMpO1xuICB9XG5cbiAgLy8gdXBkYXRlIGZpbGUuY29udGVudFxuICBpZiAoY2xvc2VJbmRleCA9PT0gbGVuKSB7XG4gICAgZmlsZS5jb250ZW50ID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgZmlsZS5jb250ZW50ID0gc3RyLnNsaWNlKGNsb3NlSW5kZXggKyBjbG9zZS5sZW5ndGgpO1xuICAgIGlmIChmaWxlLmNvbnRlbnRbMF0gPT09ICdcXHInKSB7XG4gICAgICBmaWxlLmNvbnRlbnQgPSBmaWxlLmNvbnRlbnQuc2xpY2UoMSk7XG4gICAgfVxuICAgIGlmIChmaWxlLmNvbnRlbnRbMF0gPT09ICdcXG4nKSB7XG4gICAgICBmaWxlLmNvbnRlbnQgPSBmaWxlLmNvbnRlbnQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgZXhjZXJwdChmaWxlLCBvcHRzKTtcblxuICBpZiAob3B0cy5zZWN0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0cy5zZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VjdGlvbnMoZmlsZSwgb3B0cy5zZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gZmlsZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgZW5naW5lc1xuICovXG5cbm1hdHRlci5lbmdpbmVzID0gZW5naW5lcztcblxuLyoqXG4gKiBTdHJpbmdpZnkgYW4gb2JqZWN0IHRvIFlBTUwgb3IgdGhlIHNwZWNpZmllZCBsYW5ndWFnZSwgYW5kXG4gKiBhcHBlbmQgaXQgdG8gdGhlIGdpdmVuIHN0cmluZy4gQnkgZGVmYXVsdCwgb25seSBZQU1MIGFuZCBKU09OXG4gKiBjYW4gYmUgc3RyaW5naWZpZWQuIFNlZSB0aGUgW2VuZ2luZXNdKCNlbmdpbmVzKSBzZWN0aW9uIHRvIGxlYXJuXG4gKiBob3cgdG8gc3RyaW5naWZ5IG90aGVyIGxhbmd1YWdlcy5cbiAqXG4gKiBgYGBqc1xuICogY29uc29sZS5sb2cobWF0dGVyLnN0cmluZ2lmeSgnZm9vIGJhciBiYXonLCB7dGl0bGU6ICdIb21lJ30pKTtcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAtLS1cbiAqIC8vIHRpdGxlOiBIb21lXG4gKiAvLyAtLS1cbiAqIC8vIGZvbyBiYXIgYmF6XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gYGZpbGVgIFRoZSBjb250ZW50IHN0cmluZyB0byBhcHBlbmQgdG8gc3RyaW5naWZpZWQgZnJvbnQtbWF0dGVyLCBvciBhIGZpbGUgb2JqZWN0IHdpdGggYGZpbGUuY29udGVudGAgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGBkYXRhYCBGcm9udCBtYXR0ZXIgdG8gc3RyaW5naWZ5LlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBbT3B0aW9uc10oI29wdGlvbnMpIHRvIHBhc3MgdG8gZ3JheS1tYXR0ZXIgYW5kIFtqcy15YW1sXS5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIHN0cmluZyBjcmVhdGVkIGJ5IHdyYXBwaW5nIHN0cmluZ2lmaWVkIHlhbWwgd2l0aCBkZWxpbWl0ZXJzLCBhbmQgYXBwZW5kaW5nIHRoYXQgdG8gdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubWF0dGVyLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKGZpbGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykgZmlsZSA9IG1hdHRlcihmaWxlLCBvcHRpb25zKTtcbiAgcmV0dXJuIHN0cmluZ2lmeShmaWxlLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3luY2hyb25vdXNseSByZWFkIGEgZmlsZSBmcm9tIHRoZSBmaWxlIHN5c3RlbSBhbmQgcGFyc2VcbiAqIGZyb250IG1hdHRlci4gUmV0dXJucyB0aGUgc2FtZSBvYmplY3QgYXMgdGhlIFttYWluIGZ1bmN0aW9uXSgjbWF0dGVyKS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgZmlsZSA9IG1hdHRlci5yZWFkKCcuL2NvbnRlbnQvYmxvZy1wb3N0Lm1kJyk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgZmlsZXBhdGhgIGZpbGUgcGF0aCBvZiB0aGUgZmlsZSB0byByZWFkLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYCBbT3B0aW9uc10oI29wdGlvbnMpIHRvIHBhc3MgdG8gZ3JheS1tYXR0ZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgW2FuIG9iamVjdF0oI3JldHVybmVkLW9iamVjdCkgd2l0aCBgZGF0YWAgYW5kIGBjb250ZW50YFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tYXR0ZXIucmVhZCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0ciA9IGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCwgJ3V0ZjgnKTtcbiAgY29uc3QgZmlsZSA9IG1hdHRlcihzdHIsIG9wdGlvbnMpO1xuICBmaWxlLnBhdGggPSBmaWxlcGF0aDtcbiAgcmV0dXJuIGZpbGU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYHN0cmluZ2AgaGFzIGZyb250IG1hdHRlci5cbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmluZ2BcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGZyb250IG1hdHRlciBleGlzdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1hdHRlci50ZXN0ID0gZnVuY3Rpb24oc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB1dGlscy5zdGFydHNXaXRoKHN0ciwgZGVmYXVsdHMob3B0aW9ucykuZGVsaW1pdGVyc1swXSk7XG59O1xuXG4vKipcbiAqIERldGVjdCB0aGUgbGFuZ3VhZ2UgdG8gdXNlLCBpZiBvbmUgaXMgZGVmaW5lZCBhZnRlciB0aGVcbiAqIGZpcnN0IGZyb250LW1hdHRlciBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJpbmdgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBgcmF3YCAoYWN0dWFsIGxhbmd1YWdlIHN0cmluZyksIGFuZCBgbmFtZWAsIHRoZSBsYW5ndWFnZSB3aXRoIHdoaXRlc3BhY2UgdHJpbW1lZFxuICovXG5cbm1hdHRlci5sYW5ndWFnZSA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdHMob3B0aW9ucyk7XG4gIGNvbnN0IG9wZW4gPSBvcHRzLmRlbGltaXRlcnNbMF07XG5cbiAgaWYgKG1hdHRlci50ZXN0KHN0cikpIHtcbiAgICBzdHIgPSBzdHIuc2xpY2Uob3Blbi5sZW5ndGgpO1xuICB9XG5cbiAgY29uc3QgbGFuZ3VhZ2UgPSBzdHIuc2xpY2UoMCwgc3RyLnNlYXJjaCgvXFxyP1xcbi8pKTtcbiAgcmV0dXJuIHtcbiAgICByYXc6IGxhbmd1YWdlLFxuICAgIG5hbWU6IGxhbmd1YWdlID8gbGFuZ3VhZ2UudHJpbSgpIDogJydcbiAgfTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBtYXR0ZXJgXG4gKi9cblxubWF0dGVyLmNhY2hlID0ge307XG5tYXR0ZXIuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBtYXR0ZXIuY2FjaGUgPSB7fTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IG1hdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZW5naW5lcyA9IHJlcXVpcmUoJy4vZW5naW5lcycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgLy8gZW5zdXJlIHRoYXQgZGVsaW1pdGVycyBhcmUgYW4gYXJyYXlcbiAgb3B0cy5kZWxpbWl0ZXJzID0gdXRpbHMuYXJyYXlpZnkob3B0cy5kZWxpbXMgfHwgb3B0cy5kZWxpbWl0ZXJzIHx8ICctLS0nKTtcbiAgaWYgKG9wdHMuZGVsaW1pdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICBvcHRzLmRlbGltaXRlcnMucHVzaChvcHRzLmRlbGltaXRlcnNbMF0pO1xuICB9XG5cbiAgb3B0cy5sYW5ndWFnZSA9IChvcHRzLmxhbmd1YWdlIHx8IG9wdHMubGFuZyB8fCAneWFtbCcpLnRvTG93ZXJDYXNlKCk7XG4gIG9wdHMuZW5naW5lcyA9IE9iamVjdC5hc3NpZ24oe30sIGVuZ2luZXMsIG9wdHMucGFyc2Vycywgb3B0cy5lbmdpbmVzKTtcbiAgcmV0dXJuIG9wdHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgbGV0IGVuZ2luZSA9IG9wdGlvbnMuZW5naW5lc1tuYW1lXSB8fCBvcHRpb25zLmVuZ2luZXNbYWxpYXNlKG5hbWUpXTtcbiAgaWYgKHR5cGVvZiBlbmdpbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmF5LW1hdHRlciBlbmdpbmUgXCInICsgbmFtZSArICdcIiBpcyBub3QgcmVnaXN0ZXJlZCcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5naW5lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZW5naW5lID0geyBwYXJzZTogZW5naW5lIH07XG4gIH1cbiAgcmV0dXJuIGVuZ2luZTtcbn07XG5cbmZ1bmN0aW9uIGFsaWFzZShuYW1lKSB7XG4gIHN3aXRjaCAobmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnanMnOlxuICAgIGNhc2UgJ2phdmFzY3JpcHQnOlxuICAgICAgcmV0dXJuICdqYXZhc2NyaXB0JztcbiAgICBjYXNlICdjb2ZmZWUnOlxuICAgIGNhc2UgJ2NvZmZlZXNjcmlwdCc6XG4gICAgY2FzZSAnY3Nvbic6XG4gICAgICByZXR1cm4gJ2NvZmZlZSc7XG4gICAgY2FzZSAneWFtbCc6XG4gICAgY2FzZSAneW1sJzpcbiAgICAgIHJldHVybiAneWFtbCc7XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHlhbWwgPSByZXF1aXJlKCdqcy15YW1sJyk7XG5cbi8qKlxuICogRGVmYXVsdCBlbmdpbmVzXG4gKi9cblxuY29uc3QgZW5naW5lcyA9IGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBZQU1MXG4gKi9cblxuZW5naW5lcy55YW1sID0ge1xuICBwYXJzZTogeWFtbC5zYWZlTG9hZC5iaW5kKHlhbWwpLFxuICBzdHJpbmdpZnk6IHlhbWwuc2FmZUR1bXAuYmluZCh5YW1sKVxufTtcblxuLyoqXG4gKiBKU09OXG4gKi9cblxuZW5naW5lcy5qc29uID0ge1xuICBwYXJzZTogSlNPTi5wYXJzZS5iaW5kKEpTT04pLFxuICBzdHJpbmdpZnk6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtyZXBsYWNlcjogbnVsbCwgc3BhY2U6IDJ9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBvcHRzLnJlcGxhY2VyLCBvcHRzLnNwYWNlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBKYXZhU2NyaXB0XG4gKi9cblxuZW5naW5lcy5qYXZhc2NyaXB0ID0ge1xuICBwYXJzZTogZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zLCB3cmFwKSB7XG4gICAgLyogZXNsaW50IG5vLWV2YWw6IDAgKi9cbiAgICB0cnkge1xuICAgICAgaWYgKHdyYXAgIT09IGZhbHNlKSB7XG4gICAgICAgIHN0ciA9ICcoZnVuY3Rpb24oKSB7XFxucmV0dXJuICcgKyBzdHIudHJpbSgpICsgJztcXG59KCkpOyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZhbChzdHIpIHx8IHt9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHdyYXAgIT09IGZhbHNlICYmIC8odW5leHBlY3RlZHxpZGVudGlmaWVyKS9pLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZShzdHIsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihlcnIpO1xuICAgIH1cbiAgfSxcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZ2lmeWluZyBKYXZhU2NyaXB0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZmlsZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdHMob3B0aW9ucyk7XG5cbiAgaWYgKGZpbGUuZGF0YSA9PSBudWxsKSB7XG4gICAgZmlsZS5kYXRhID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMuZXhjZXJwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRzLmV4Y2VycHQoZmlsZSwgb3B0cyk7XG4gIH1cblxuICBjb25zdCBzZXAgPSBmaWxlLmRhdGEuZXhjZXJwdF9zZXBhcmF0b3IgfHwgb3B0cy5leGNlcnB0X3NlcGFyYXRvcjtcbiAgaWYgKHNlcCA9PSBudWxsICYmIChvcHRzLmV4Y2VycHQgPT09IGZhbHNlIHx8IG9wdHMuZXhjZXJwdCA9PSBudWxsKSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9XG5cbiAgY29uc3QgZGVsaW1pdGVyID0gdHlwZW9mIG9wdHMuZXhjZXJwdCA9PT0gJ3N0cmluZydcbiAgICA/IG9wdHMuZXhjZXJwdFxuICAgIDogKHNlcCB8fCBvcHRzLmRlbGltaXRlcnNbMF0pO1xuXG4gIC8vIGlmIGVuYWJsZWQsIGdldCB0aGUgZXhjZXJwdCBkZWZpbmVkIGFmdGVyIGZyb250LW1hdHRlclxuICBjb25zdCBpZHggPSBmaWxlLmNvbnRlbnQuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGZpbGUuZXhjZXJwdCA9IGZpbGUuY29udGVudC5zbGljZSgwLCBpZHgpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXRFbmdpbmUgPSByZXF1aXJlKCcuL2VuZ2luZScpO1xuY29uc3QgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGFuZ3VhZ2UsIHN0ciwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gZGVmYXVsdHMob3B0aW9ucyk7XG4gIGNvbnN0IGVuZ2luZSA9IGdldEVuZ2luZShsYW5ndWFnZSwgb3B0cyk7XG4gIGlmICh0eXBlb2YgZW5naW5lLnBhcnNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgXCInICsgbGFuZ3VhZ2UgKyAnLnBhcnNlXCIgdG8gYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBlbmdpbmUucGFyc2Uoc3RyLCBvcHRzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcbmNvbnN0IGdldEVuZ2luZSA9IHJlcXVpcmUoJy4vZW5naW5lJyk7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmaWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gIGlmIChkYXRhID09IG51bGwgJiYgb3B0aW9ucyA9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlT2YoZmlsZSkpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGRhdGEgPSBmaWxlLmRhdGE7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgZmlsZSB0byBiZSBhIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHIgPSBmaWxlLmNvbnRlbnQ7XG4gIGNvbnN0IG9wdHMgPSBkZWZhdWx0cyhvcHRpb25zKTtcbiAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgIGlmICghb3B0cy5kYXRhKSByZXR1cm4gZmlsZTtcbiAgICBkYXRhID0gb3B0cy5kYXRhO1xuICB9XG5cbiAgY29uc3QgbGFuZ3VhZ2UgPSBmaWxlLmxhbmd1YWdlIHx8IG9wdHMubGFuZ3VhZ2U7XG4gIGNvbnN0IGVuZ2luZSA9IGdldEVuZ2luZShsYW5ndWFnZSwgb3B0cyk7XG4gIGlmICh0eXBlb2YgZW5naW5lLnN0cmluZ2lmeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIFwiJyArIGxhbmd1YWdlICsgJy5zdHJpbmdpZnlcIiB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZmlsZS5kYXRhLCBkYXRhKTtcbiAgY29uc3Qgb3BlbiA9IG9wdHMuZGVsaW1pdGVyc1swXTtcbiAgY29uc3QgY2xvc2UgPSBvcHRzLmRlbGltaXRlcnNbMV07XG4gIGNvbnN0IG1hdHRlciA9IGVuZ2luZS5zdHJpbmdpZnkoZGF0YSwgb3B0aW9ucykudHJpbSgpO1xuICBsZXQgYnVmID0gJyc7XG5cbiAgaWYgKG1hdHRlciAhPT0gJ3t9Jykge1xuICAgIGJ1ZiA9IG5ld2xpbmUob3BlbikgKyBuZXdsaW5lKG1hdHRlcikgKyBuZXdsaW5lKGNsb3NlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsZS5leGNlcnB0ID09PSAnc3RyaW5nJyAmJiBmaWxlLmV4Y2VycHQgIT09ICcnKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKGZpbGUuZXhjZXJwdC50cmltKCkpID09PSAtMSkge1xuICAgICAgYnVmICs9IG5ld2xpbmUoZmlsZS5leGNlcnB0KSArIG5ld2xpbmUoY2xvc2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgKyBuZXdsaW5lKHN0cik7XG59O1xuXG5mdW5jdGlvbiBuZXdsaW5lKHN0cikge1xuICByZXR1cm4gc3RyLnNsaWNlKC0xKSAhPT0gJ1xcbicgPyBzdHIgKyAnXFxuJyA6IHN0cjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuY29uc3Qgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5zdXJlIGFuIG9iamVjdCBpcyByZXR1cm5lZFxuICogd2l0aCB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZpbGUpIHtcbiAgaWYgKHR5cGVPZihmaWxlKSAhPT0gJ29iamVjdCcpIHtcbiAgICBmaWxlID0geyBjb250ZW50OiBmaWxlIH07XG4gIH1cblxuICBpZiAodHlwZU9mKGZpbGUuZGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgZmlsZS5kYXRhID0ge307XG4gIH1cblxuICAvLyBpZiBmaWxlIHdhcyBwYXNzZWQgYXMgYW4gb2JqZWN0LCBlbnN1cmUgdGhhdFxuICAvLyBcImZpbGUuY29udGVudFwiIGlzIHNldFxuICBpZiAoZmlsZS5jb250ZW50cyAmJiBmaWxlLmNvbnRlbnQgPT0gbnVsbCkge1xuICAgIGZpbGUuY29udGVudCA9IGZpbGUuY29udGVudHM7XG4gIH1cblxuICAvLyBzZXQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgZmlsZSBvYmplY3RcbiAgdXRpbHMuZGVmaW5lKGZpbGUsICdvcmlnJywgdXRpbHMudG9CdWZmZXIoZmlsZS5jb250ZW50KSk7XG4gIHV0aWxzLmRlZmluZShmaWxlLCAnbGFuZ3VhZ2UnLCBmaWxlLmxhbmd1YWdlIHx8ICcnKTtcbiAgdXRpbHMuZGVmaW5lKGZpbGUsICdtYXR0ZXInLCBmaWxlLm1hdHRlciB8fCAnJyk7XG4gIHV0aWxzLmRlZmluZShmaWxlLCAnc3RyaW5naWZ5JywgZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGFuZ3VhZ2UpIHtcbiAgICAgIGZpbGUubGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5KGZpbGUsIGRhdGEsIG9wdGlvbnMpO1xuICB9KTtcblxuICAvLyBzdHJpcCBCT00gYW5kIGVuc3VyZSB0aGF0IFwiZmlsZS5jb250ZW50XCIgaXMgYSBzdHJpbmdcbiAgZmlsZS5jb250ZW50ID0gdXRpbHMudG9TdHJpbmcoZmlsZS5jb250ZW50KTtcbiAgZmlsZS5pc0VtcHR5ID0gZmFsc2U7XG4gIGZpbGUuZXhjZXJwdCA9ICcnO1xuICByZXR1cm4gZmlsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN0cmlwQm9tID0gcmVxdWlyZSgnc3RyaXAtYm9tLXN0cmluZycpO1xuY29uc3QgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xuXG5leHBvcnRzLmRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWwpIHtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbGAgaXMgYSBidWZmZXJcbiAqL1xuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlT2YodmFsKSA9PT0gJ2J1ZmZlcic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsYCBpcyBhbiBvYmplY3RcbiAqL1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlT2YodmFsKSA9PT0gJ29iamVjdCc7XG59O1xuXG4vKipcbiAqIENhc3QgYGlucHV0YCB0byBhIGJ1ZmZlclxuICovXG5cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyA/IEJ1ZmZlci5mcm9tKGlucHV0KSA6IGlucHV0O1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGEgc3RyaW5nLlxuICovXG5cbmV4cG9ydHMudG9TdHJpbmcgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoZXhwb3J0cy5pc0J1ZmZlcihpbnB1dCkpIHJldHVybiBzdHJpcEJvbShTdHJpbmcoaW5wdXQpKTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZyBvciBidWZmZXInKTtcbiAgfVxuICByZXR1cm4gc3RyaXBCb20oaW5wdXQpO1xufTtcblxuLyoqXG4gKiBDYXN0IGB2YWxgIHRvIGFuIGFycmF5LlxuICovXG5cbmV4cG9ydHMuYXJyYXlpZnkgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IChBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXSkgOiBbXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIHN0YXJ0cyB3aXRoIGBzdWJzdHJgLlxuICovXG5cbmV4cG9ydHMuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RyLCBsZW4pIHtcbiAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSBsZW4gPSBzdWJzdHIubGVuZ3RoO1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIGxlbikgPT09IHN1YnN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvKiFcbiAqIGlzLWV4dGVuZGFibGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGVuZGFibGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRlbmRhYmxlKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgeWFtbCA9IHJlcXVpcmUoJy4vbGliL2pzLXlhbWwuanMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHlhbWw7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIGxvYWRlciA9IHJlcXVpcmUoJy4vanMteWFtbC9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2pzLXlhbWwvZHVtcGVyJyk7XG5cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiAnICsgbmFtZSArICcgaXMgZGVwcmVjYXRlZCBhbmQgY2Fubm90IGJlIHVzZWQuJyk7XG4gIH07XG59XG5cblxubW9kdWxlLmV4cG9ydHMuVHlwZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYScpO1xubW9kdWxlLmV4cG9ydHMuRkFJTFNBRkVfU0NIRU1BICAgICA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZmFpbHNhZmUnKTtcbm1vZHVsZS5leHBvcnRzLkpTT05fU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2NvcmUnKTtcbm1vZHVsZS5leHBvcnRzLkRFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vanMteWFtbC9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZCAgICAgICAgICAgID0gbG9hZGVyLnNhZmVMb2FkO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWRBbGwgICAgICAgICA9IGxvYWRlci5zYWZlTG9hZEFsbDtcbm1vZHVsZS5leHBvcnRzLmR1bXAgICAgICAgICAgICAgICAgPSBkdW1wZXIuZHVtcDtcbm1vZHVsZS5leHBvcnRzLnNhZmVEdW1wICAgICAgICAgICAgPSBkdW1wZXIuc2FmZUR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9qcy15YW1sL2V4Y2VwdGlvbicpO1xuXG4vLyBEZXByZWNhdGVkIHNjaGVtYSBuYW1lcyBmcm9tIEpTLVlBTUwgMi4wLnhcbm1vZHVsZS5leHBvcnRzLk1JTklNQUxfU0NIRU1BID0gcmVxdWlyZSgnLi9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuU0FGRV9TQ0hFTUEgICAgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfc2FmZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgPSByZXF1aXJlKCcuL2pzLXlhbWwvc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xuXG4vLyBEZXByZWNhdGVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMS54Lnhcbm1vZHVsZS5leHBvcnRzLnNjYW4gICAgICAgICAgID0gZGVwcmVjYXRlZCgnc2NhbicpO1xubW9kdWxlLmV4cG9ydHMucGFyc2UgICAgICAgICAgPSBkZXByZWNhdGVkKCdwYXJzZScpO1xubW9kdWxlLmV4cG9ydHMuY29tcG9zZSAgICAgICAgPSBkZXByZWNhdGVkKCdjb21wb3NlJyk7XG5tb2R1bGUuZXhwb3J0cy5hZGRDb25zdHJ1Y3RvciA9IGRlcHJlY2F0ZWQoJ2FkZENvbnN0cnVjdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHx8IChzdWJqZWN0ID09PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnKSAmJiAoc3ViamVjdCAhPT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHJldHVybiBzZXF1ZW5jZTtcbiAgZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKG51bWJlciA9PT0gMCkgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgREVGQVVMVF9GVUxMX1NDSEVNQSA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHRfZnVsbCcpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfVEFCICAgICAgICAgICAgICAgICAgPSAweDA5OyAvKiBUYWIgKi9cbnZhciBDSEFSX0xJTkVfRkVFRCAgICAgICAgICAgID0gMHgwQTsgLyogTEYgKi9cbnZhciBDSEFSX0NBUlJJQUdFX1JFVFVSTiAgICAgID0gMHgwRDsgLyogQ1IgKi9cbnZhciBDSEFSX1NQQUNFICAgICAgICAgICAgICAgID0gMHgyMDsgLyogU3BhY2UgKi9cbnZhciBDSEFSX0VYQ0xBTUFUSU9OICAgICAgICAgID0gMHgyMTsgLyogISAqL1xudmFyIENIQVJfRE9VQkxFX1FVT1RFICAgICAgICAgPSAweDIyOyAvKiBcIiAqL1xudmFyIENIQVJfU0hBUlAgICAgICAgICAgICAgICAgPSAweDIzOyAvKiAjICovXG52YXIgQ0hBUl9QRVJDRU5UICAgICAgICAgICAgICA9IDB4MjU7IC8qICUgKi9cbnZhciBDSEFSX0FNUEVSU0FORCAgICAgICAgICAgID0gMHgyNjsgLyogJiAqL1xudmFyIENIQVJfU0lOR0xFX1FVT1RFICAgICAgICAgPSAweDI3OyAvKiAnICovXG52YXIgQ0hBUl9BU1RFUklTSyAgICAgICAgICAgICA9IDB4MkE7IC8qICogKi9cbnZhciBDSEFSX0NPTU1BICAgICAgICAgICAgICAgID0gMHgyQzsgLyogLCAqL1xudmFyIENIQVJfTUlOVVMgICAgICAgICAgICAgICAgPSAweDJEOyAvKiAtICovXG52YXIgQ0hBUl9DT0xPTiAgICAgICAgICAgICAgICA9IDB4M0E7IC8qIDogKi9cbnZhciBDSEFSX0VRVUFMUyAgICAgICAgICAgICAgID0gMHgzRDsgLyogPSAqL1xudmFyIENIQVJfR1JFQVRFUl9USEFOICAgICAgICAgPSAweDNFOyAvKiA+ICovXG52YXIgQ0hBUl9RVUVTVElPTiAgICAgICAgICAgICA9IDB4M0Y7IC8qID8gKi9cbnZhciBDSEFSX0NPTU1FUkNJQUxfQVQgICAgICAgID0gMHg0MDsgLyogQCAqL1xudmFyIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVCAgPSAweDVCOyAvKiBbICovXG52YXIgQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVCA9IDB4NUQ7IC8qIF0gKi9cbnZhciBDSEFSX0dSQVZFX0FDQ0VOVCAgICAgICAgID0gMHg2MDsgLyogYCAqL1xudmFyIENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUICAgPSAweDdCOyAvKiB7ICovXG52YXIgQ0hBUl9WRVJUSUNBTF9MSU5FICAgICAgICA9IDB4N0M7IC8qIHwgKi9cbnZhciBDSEFSX1JJR0hUX0NVUkxZX0JSQUNLRVQgID0gMHg3RDsgLyogfSAqL1xuXG52YXIgRVNDQVBFX1NFUVVFTkNFUyA9IHt9O1xuXG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDBdICAgPSAnXFxcXDAnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA3XSAgID0gJ1xcXFxhJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOF0gICA9ICdcXFxcYic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDldICAgPSAnXFxcXHQnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBBXSAgID0gJ1xcXFxuJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQl0gICA9ICdcXFxcdic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MENdICAgPSAnXFxcXGYnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBEXSAgID0gJ1xcXFxyJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgxQl0gICA9ICdcXFxcZSc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjJdICAgPSAnXFxcXFwiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg1Q10gICA9ICdcXFxcXFxcXCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4ODVdICAgPSAnXFxcXE4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweEEwXSAgID0gJ1xcXFxfJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI4XSA9ICdcXFxcTCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MjAyOV0gPSAnXFxcXFAnO1xuXG52YXIgREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVggPSBbXG4gICd5JywgJ1knLCAneWVzJywgJ1llcycsICdZRVMnLCAnb24nLCAnT24nLCAnT04nLFxuICAnbicsICdOJywgJ25vJywgJ05vJywgJ05PJywgJ29mZicsICdPZmYnLCAnT0ZGJ1xuXTtcblxuZnVuY3Rpb24gY29tcGlsZVN0eWxlTWFwKHNjaGVtYSwgbWFwKSB7XG4gIHZhciByZXN1bHQsIGtleXMsIGluZGV4LCBsZW5ndGgsIHRhZywgc3R5bGUsIHR5cGU7XG5cbiAgaWYgKG1hcCA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHJlc3VsdCA9IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdGFnID0ga2V5c1tpbmRleF07XG4gICAgc3R5bGUgPSBTdHJpbmcobWFwW3RhZ10pO1xuXG4gICAgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJyEhJykge1xuICAgICAgdGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWcuc2xpY2UoMik7XG4gICAgfVxuICAgIHR5cGUgPSBzY2hlbWEuY29tcGlsZWRUeXBlTWFwWydmYWxsYmFjayddW3RhZ107XG5cbiAgICBpZiAodHlwZSAmJiBfaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlLnN0eWxlQWxpYXNlcywgc3R5bGUpKSB7XG4gICAgICBzdHlsZSA9IHR5cGUuc3R5bGVBbGlhc2VzW3N0eWxlXTtcbiAgICB9XG5cbiAgICByZXN1bHRbdGFnXSA9IHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSGV4KGNoYXJhY3Rlcikge1xuICB2YXIgc3RyaW5nLCBoYW5kbGUsIGxlbmd0aDtcblxuICBzdHJpbmcgPSBjaGFyYWN0ZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cbiAgaWYgKGNoYXJhY3RlciA8PSAweEZGKSB7XG4gICAgaGFuZGxlID0gJ3gnO1xuICAgIGxlbmd0aCA9IDI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyIDw9IDB4RkZGRikge1xuICAgIGhhbmRsZSA9ICd1JztcbiAgICBsZW5ndGggPSA0O1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkZGRkZGKSB7XG4gICAgaGFuZGxlID0gJ1UnO1xuICAgIGxlbmd0aCA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2NvZGUgcG9pbnQgd2l0aGluIGEgc3RyaW5nIG1heSBub3QgYmUgZ3JlYXRlciB0aGFuIDB4RkZGRkZGRkYnKTtcbiAgfVxuXG4gIHJldHVybiAnXFxcXCcgKyBoYW5kbGUgKyBjb21tb24ucmVwZWF0KCcwJywgbGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIFN0YXRlKG9wdGlvbnMpIHtcbiAgdGhpcy5zY2hlbWEgICAgICAgID0gb3B0aW9uc1snc2NoZW1hJ10gfHwgREVGQVVMVF9GVUxMX1NDSEVNQTtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy5leHBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRFeHBsaWNpdDtcblxuICB0aGlzLnRhZyA9IG51bGw7XG4gIHRoaXMucmVzdWx0ID0gJyc7XG5cbiAgdGhpcy5kdXBsaWNhdGVzID0gW107XG4gIHRoaXMudXNlZER1cGxpY2F0ZXMgPSBudWxsO1xufVxuXG4vLyBJbmRlbnRzIGV2ZXJ5IGxpbmUgaW4gYSBzdHJpbmcuIEVtcHR5IGxpbmVzIChcXG4gb25seSkgYXJlIG5vdCBpbmRlbnRlZC5cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdHJpbmcsIHNwYWNlcykge1xuICB2YXIgaW5kID0gY29tbW9uLnJlcGVhdCgnICcsIHNwYWNlcyksXG4gICAgICBwb3NpdGlvbiA9IDAsXG4gICAgICBuZXh0ID0gLTEsXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIGxpbmUsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChwb3NpdGlvbiA8IGxlbmd0aCkge1xuICAgIG5leHQgPSBzdHJpbmcuaW5kZXhPZignXFxuJywgcG9zaXRpb24pO1xuICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbik7XG4gICAgICBwb3NpdGlvbiA9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSA9IHN0cmluZy5zbGljZShwb3NpdGlvbiwgbmV4dCArIDEpO1xuICAgICAgcG9zaXRpb24gPSBuZXh0ICsgMTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5sZW5ndGggJiYgbGluZSAhPT0gJ1xcbicpIHJlc3VsdCArPSBpbmQ7XG5cbiAgICByZXN1bHQgKz0gbGluZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKSB7XG4gIHJldHVybiAnXFxuJyArIGNvbW1vbi5yZXBlYXQoJyAnLCBzdGF0ZS5pbmRlbnQgKiBsZXZlbCk7XG59XG5cbmZ1bmN0aW9uIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCB0eXBlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB0eXBlID0gc3RhdGUuaW1wbGljaXRUeXBlc1tpbmRleF07XG5cbiAgICBpZiAodHlwZS5yZXNvbHZlKHN0cikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWzMzXSBzLXdoaXRlIDo6PSBzLXNwYWNlIHwgcy10YWJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjKSB7XG4gIHJldHVybiBjID09PSBDSEFSX1NQQUNFIHx8IGMgPT09IENIQVJfVEFCO1xufVxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGNoYXJhY3RlciBjYW4gYmUgcHJpbnRlZCB3aXRob3V0IGVzY2FwaW5nLlxuLy8gRnJvbSBZQU1MIDEuMjogXCJhbnkgYWxsb3dlZCBjaGFyYWN0ZXJzIGtub3duIHRvIGJlIG5vbi1wcmludGFibGVcbi8vIHNob3VsZCBhbHNvIGJlIGVzY2FwZWQuIFtIb3dldmVyLF0gVGhpcyBpc27igJl0IG1hbmRhdG9yeVwiXG4vLyBEZXJpdmVkIGZyb20gbmItY2hhciAtIFxcdCAtICN4ODUgLSAjeEEwIC0gI3gyMDI4IC0gI3gyMDI5LlxuZnVuY3Rpb24gaXNQcmludGFibGUoYykge1xuICByZXR1cm4gICgweDAwMDIwIDw9IGMgJiYgYyA8PSAweDAwMDA3RSlcbiAgICAgIHx8ICgoMHgwMDBBMSA8PSBjICYmIGMgPD0gMHgwMEQ3RkYpICYmIGMgIT09IDB4MjAyOCAmJiBjICE9PSAweDIwMjkpXG4gICAgICB8fCAoKDB4MEUwMDAgPD0gYyAmJiBjIDw9IDB4MDBGRkZEKSAmJiBjICE9PSAweEZFRkYgLyogQk9NICovKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBbMjRdIGItbGluZS1mZWVkICAgICAgIDo6PSAgICAgI3hBICAgIC8qIExGICovXG4vLyBbMjVdIGItY2FycmlhZ2UtcmV0dXJuIDo6PSAgICAgI3hEICAgIC8qIENSICovXG4vLyBbM10gIGMtYnl0ZS1vcmRlci1tYXJrIDo6PSAgICAgI3hGRUZGXG5mdW5jdGlvbiBpc05zQ2hhcihjKSB7XG4gIHJldHVybiBpc1ByaW50YWJsZShjKSAmJiAhaXNXaGl0ZXNwYWNlKGMpXG4gICAgLy8gYnl0ZS1vcmRlci1tYXJrXG4gICAgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gYi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9DQVJSSUFHRV9SRVRVUk5cbiAgICAmJiBjICE9PSBDSEFSX0xJTkVfRkVFRDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmUoYywgcHJldikge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5iLWNoYXIgLSBjLWZsb3ctaW5kaWNhdG9yIC0gXCI6XCIgLSBcIiNcIlxuICAvLyB3aGVyZSBuYi1jaGFyIDo6PSBjLXByaW50YWJsZSAtIGItY2hhciAtIGMtYnl0ZS1vcmRlci1tYXJrLlxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gMHhGRUZGXG4gICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIC0gXCI6XCIgLSBcIiNcIlxuICAgIC8vIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIFwiI1wiXG4gICAgJiYgYyAhPT0gQ0hBUl9DT0xPTlxuICAgICYmICgoYyAhPT0gQ0hBUl9TSEFSUCkgfHwgKHByZXYgJiYgaXNOc0NoYXIocHJldikpKTtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHBsYWluIHN0eWxlLlxuZnVuY3Rpb24gaXNQbGFpblNhZmVGaXJzdChjKSB7XG4gIC8vIFVzZXMgYSBzdWJzZXQgb2YgbnMtY2hhciAtIGMtaW5kaWNhdG9yXG4gIC8vIHdoZXJlIG5zLWNoYXIgPSBuYi1jaGFyIC0gcy13aGl0ZS5cbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpICYmIGMgIT09IDB4RkVGRlxuICAgICYmICFpc1doaXRlc3BhY2UoYykgLy8gLSBzLXdoaXRlXG4gICAgLy8gLSAoYy1pbmRpY2F0b3IgOjo9XG4gICAgLy8g4oCcLeKAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLOKAnSB8IOKAnFvigJ0gfCDigJxd4oCdIHwg4oCce+KAnSB8IOKAnH3igJ1cbiAgICAmJiBjICE9PSBDSEFSX01JTlVTXG4gICAgJiYgYyAhPT0gQ0hBUl9RVUVTVElPTlxuICAgICYmIGMgIT09IENIQVJfQ09MT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTU1BXG4gICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfTEVGVF9DVVJMWV9CUkFDS0VUXG4gICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gICAgLy8gfCDigJwj4oCdIHwg4oCcJuKAnSB8IOKAnCrigJ0gfCDigJwh4oCdIHwg4oCcfOKAnSB8IOKAnD3igJ0gfCDigJw+4oCdIHwg4oCcJ+KAnSB8IOKAnFwi4oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUFxuICAgICYmIGMgIT09IENIQVJfQU1QRVJTQU5EXG4gICAgJiYgYyAhPT0gQ0hBUl9BU1RFUklTS1xuICAgICYmIGMgIT09IENIQVJfRVhDTEFNQVRJT05cbiAgICAmJiBjICE9PSBDSEFSX1ZFUlRJQ0FMX0xJTkVcbiAgICAmJiBjICE9PSBDSEFSX0VRVUFMU1xuICAgICYmIGMgIT09IENIQVJfR1JFQVRFUl9USEFOXG4gICAgJiYgYyAhPT0gQ0hBUl9TSU5HTEVfUVVPVEVcbiAgICAmJiBjICE9PSBDSEFSX0RPVUJMRV9RVU9URVxuICAgIC8vIHwg4oCcJeKAnSB8IOKAnEDigJ0gfCDigJxg4oCdKVxuICAgICYmIGMgIT09IENIQVJfUEVSQ0VOVFxuICAgICYmIGMgIT09IENIQVJfQ09NTUVSQ0lBTF9BVFxuICAgICYmIGMgIT09IENIQVJfR1JBVkVfQUNDRU5UO1xufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYmxvY2sgaW5kZW50YXRpb24gaW5kaWNhdG9yIGlzIHJlcXVpcmVkLlxuZnVuY3Rpb24gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpIHtcbiAgdmFyIGxlYWRpbmdTcGFjZVJlID0gL15cXG4qIC87XG4gIHJldHVybiBsZWFkaW5nU3BhY2VSZS50ZXN0KHN0cmluZyk7XG59XG5cbnZhciBTVFlMRV9QTEFJTiAgID0gMSxcbiAgICBTVFlMRV9TSU5HTEUgID0gMixcbiAgICBTVFlMRV9MSVRFUkFMID0gMyxcbiAgICBTVFlMRV9GT0xERUQgID0gNCxcbiAgICBTVFlMRV9ET1VCTEUgID0gNTtcblxuLy8gRGV0ZXJtaW5lcyB3aGljaCBzY2FsYXIgc3R5bGVzIGFyZSBwb3NzaWJsZSBhbmQgcmV0dXJucyB0aGUgcHJlZmVycmVkIHN0eWxlLlxuLy8gbGluZVdpZHRoID0gLTEgPT4gbm8gbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyLmxlbmd0aCA+IDAuXG4vLyBQb3N0LWNvbmRpdGlvbnM6XG4vLyAgICBTVFlMRV9QTEFJTiBvciBTVFlMRV9TSU5HTEUgPT4gbm8gXFxuIGFyZSBpbiB0aGUgc3RyaW5nLlxuLy8gICAgU1RZTEVfTElURVJBTCA9PiBubyBsaW5lcyBhcmUgc3VpdGFibGUgZm9yIGZvbGRpbmcgKG9yIGxpbmVXaWR0aCBpcyAtMSkuXG4vLyAgICBTVFlMRV9GT0xERUQgPT4gYSBsaW5lID4gbGluZVdpZHRoIGFuZCBjYW4gYmUgZm9sZGVkIChhbmQgbGluZVdpZHRoICE9IC0xKS5cbmZ1bmN0aW9uIGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIGluZGVudFBlckxldmVsLCBsaW5lV2lkdGgsIHRlc3RBbWJpZ3VvdXNUeXBlKSB7XG4gIHZhciBpO1xuICB2YXIgY2hhciwgcHJldl9jaGFyO1xuICB2YXIgaGFzTGluZUJyZWFrID0gZmFsc2U7XG4gIHZhciBoYXNGb2xkYWJsZUxpbmUgPSBmYWxzZTsgLy8gb25seSBjaGVja2VkIGlmIHNob3VsZFRyYWNrV2lkdGhcbiAgdmFyIHNob3VsZFRyYWNrV2lkdGggPSBsaW5lV2lkdGggIT09IC0xO1xuICB2YXIgcHJldmlvdXNMaW5lQnJlYWsgPSAtMTsgLy8gY291bnQgdGhlIGZpcnN0IGxpbmUgY29ycmVjdGx5XG4gIHZhciBwbGFpbiA9IGlzUGxhaW5TYWZlRmlyc3Qoc3RyaW5nLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgJiYgIWlzV2hpdGVzcGFjZShzdHJpbmcuY2hhckNvZGVBdChzdHJpbmcubGVuZ3RoIC0gMSkpO1xuXG4gIGlmIChzaW5nbGVMaW5lT25seSkge1xuICAgIC8vIENhc2U6IG5vIGJsb2NrIHN0eWxlcy5cbiAgICAvLyBDaGVjayBmb3IgZGlzYWxsb3dlZCBjaGFyYWN0ZXJzIHRvIHJ1bGUgb3V0IHBsYWluIGFuZCBzaW5nbGUuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcHJldl9jaGFyID0gaSA+IDAgPyBzdHJpbmcuY2hhckNvZGVBdChpIC0gMSkgOiBudWxsO1xuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2X2NoYXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlOiBibG9jayBzdHlsZXMgcGVybWl0dGVkLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjaGFyID09PSBDSEFSX0xJTkVfRkVFRCkge1xuICAgICAgICBoYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAvLyBDaGVjayBpZiBhbnkgbGluZSBjYW4gYmUgZm9sZGVkLlxuICAgICAgICBpZiAoc2hvdWxkVHJhY2tXaWR0aCkge1xuICAgICAgICAgIGhhc0ZvbGRhYmxlTGluZSA9IGhhc0ZvbGRhYmxlTGluZSB8fFxuICAgICAgICAgICAgLy8gRm9sZGFibGUgbGluZSA9IHRvbyBsb25nLCBhbmQgbm90IG1vcmUtaW5kZW50ZWQuXG4gICAgICAgICAgICAoaSAtIHByZXZpb3VzTGluZUJyZWFrIC0gMSA+IGxpbmVXaWR0aCAmJlxuICAgICAgICAgICAgIHN0cmluZ1twcmV2aW91c0xpbmVCcmVhayArIDFdICE9PSAnICcpO1xuICAgICAgICAgIHByZXZpb3VzTGluZUJyZWFrID0gaTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgICAgIH1cbiAgICAgIHByZXZfY2hhciA9IGkgPiAwID8gc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpIDogbnVsbDtcbiAgICAgIHBsYWluID0gcGxhaW4gJiYgaXNQbGFpblNhZmUoY2hhciwgcHJldl9jaGFyKTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICByZXR1cm4gcGxhaW4gJiYgIXRlc3RBbWJpZ3VvdXNUeXBlKHN0cmluZylcbiAgICAgID8gU1RZTEVfUExBSU4gOiBTVFlMRV9TSU5HTEU7XG4gIH1cbiAgLy8gRWRnZSBjYXNlOiBibG9jayBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgY2FuIG9ubHkgaGF2ZSBvbmUgZGlnaXQuXG4gIGlmIChpbmRlbnRQZXJMZXZlbCA+IDkgJiYgbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIFNUWUxFX0RPVUJMRTtcbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgYmxvY2sgc3R5bGVzIGFyZSB2YWxpZC5cbiAgLy8gUHJlZmVyIGxpdGVyYWwgc3R5bGUgdW5sZXNzIHdlIHdhbnQgdG8gZm9sZC5cbiAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG59XG5cbi8vIE5vdGU6IGxpbmUgYnJlYWtpbmcvZm9sZGluZyBpcyBpbXBsZW1lbnRlZCBmb3Igb25seSB0aGUgZm9sZGVkIHN0eWxlLlxuLy8gTkIuIFdlIGRyb3AgdGhlIGxhc3QgdHJhaWxpbmcgbmV3bGluZSAoaWYgYW55KSBvZiBhIHJldHVybmVkIGJsb2NrIHNjYWxhclxuLy8gIHNpbmNlIHRoZSBkdW1wZXIgYWRkcyBpdHMgb3duIG5ld2xpbmUuIFRoaXMgYWx3YXlzIHdvcmtzOlxuLy8gICAg4oCiIE5vIGVuZGluZyBuZXdsaW5lID0+IHVuYWZmZWN0ZWQ7IGFscmVhZHkgdXNpbmcgc3RyaXAgXCItXCIgY2hvbXBpbmcuXG4vLyAgICDigKIgRW5kaW5nIG5ld2xpbmUgICAgPT4gcmVtb3ZlZCB0aGVuIHJlc3RvcmVkLlxuLy8gIEltcG9ydGFudGx5LCB0aGlzIGtlZXBzIHRoZSBcIitcIiBjaG9tcCBpbmRpY2F0b3IgZnJvbSBnYWluaW5nIGFuIGV4dHJhIGxpbmUuXG5mdW5jdGlvbiB3cml0ZVNjYWxhcihzdGF0ZSwgc3RyaW5nLCBsZXZlbCwgaXNrZXkpIHtcbiAgc3RhdGUuZHVtcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlICYmXG4gICAgICAgIERFUFJFQ0FURURfQk9PTEVBTlNfU1lOVEFYLmluZGV4T2Yoc3RyaW5nKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBcIidcIiArIHN0cmluZyArIFwiJ1wiO1xuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSBzdGF0ZS5pbmRlbnQgKiBNYXRoLm1heCgxLCBsZXZlbCk7IC8vIG5vIDAtaW5kZW50IHNjYWxhcnNcbiAgICAvLyBBcyBpbmRlbnRhdGlvbiBnZXRzIGRlZXBlciwgbGV0IHRoZSB3aWR0aCBkZWNyZWFzZSBtb25vdG9uaWNhbGx5XG4gICAgLy8gdG8gdGhlIGxvd2VyIGJvdW5kIG1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKS5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbXBsaWVzXG4gICAgLy8gIHN0YXRlLmxpbmVXaWR0aCDiiaQgNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGlzIGZpeGVkIGF0IHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyAgc3RhdGUubGluZVdpZHRoID4gNDAgKyBzdGF0ZS5pbmRlbnQ6IHdpZHRoIGRlY3JlYXNlcyB1bnRpbCB0aGUgbG93ZXIgYm91bmQuXG4gICAgLy8gVGhpcyBiZWhhdmVzIGJldHRlciB0aGFuIGEgY29uc3RhbnQgbWluaW11bSB3aWR0aCB3aGljaCBkaXNhbGxvd3MgbmFycm93ZXIgb3B0aW9ucyxcbiAgICAvLyBvciBhbiBpbmRlbnQgdGhyZXNob2xkIHdoaWNoIGNhdXNlcyB0aGUgd2lkdGggdG8gc3VkZGVubHkgaW5jcmVhc2UuXG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aCA9PT0gLTFcbiAgICAgID8gLTEgOiBNYXRoLm1heChNYXRoLm1pbihzdGF0ZS5saW5lV2lkdGgsIDQwKSwgc3RhdGUubGluZVdpZHRoIC0gaW5kZW50KTtcblxuICAgIC8vIFdpdGhvdXQga25vd2luZyBpZiBrZXlzIGFyZSBpbXBsaWNpdC9leHBsaWNpdCwgYXNzdW1lIGltcGxpY2l0IGZvciBzYWZldHkuXG4gICAgdmFyIHNpbmdsZUxpbmVPbmx5ID0gaXNrZXlcbiAgICAgIC8vIE5vIGJsb2NrIHN0eWxlcyBpbiBmbG93IG1vZGUuXG4gICAgICB8fCAoc3RhdGUuZmxvd0xldmVsID4gLTEgJiYgbGV2ZWwgPj0gc3RhdGUuZmxvd0xldmVsKTtcbiAgICBmdW5jdGlvbiB0ZXN0QW1iaWd1aXR5KHN0cmluZykge1xuICAgICAgcmV0dXJuIHRlc3RJbXBsaWNpdFJlc29sdmluZyhzdGF0ZSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNob29zZVNjYWxhclN0eWxlKHN0cmluZywgc2luZ2xlTGluZU9ubHksIHN0YXRlLmluZGVudCwgbGluZVdpZHRoLCB0ZXN0QW1iaWd1aXR5KSkge1xuICAgICAgY2FzZSBTVFlMRV9QTEFJTjpcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIGNhc2UgU1RZTEVfU0lOR0xFOlxuICAgICAgICByZXR1cm4gXCInXCIgKyBzdHJpbmcucmVwbGFjZSgvJy9nLCBcIicnXCIpICsgXCInXCI7XG4gICAgICBjYXNlIFNUWUxFX0xJVEVSQUw6XG4gICAgICAgIHJldHVybiAnfCcgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhzdHJpbmcsIGluZGVudCkpO1xuICAgICAgY2FzZSBTVFlMRV9GT0xERUQ6XG4gICAgICAgIHJldHVybiAnPicgKyBibG9ja0hlYWRlcihzdHJpbmcsIHN0YXRlLmluZGVudClcbiAgICAgICAgICArIGRyb3BFbmRpbmdOZXdsaW5lKGluZGVudFN0cmluZyhmb2xkU3RyaW5nKHN0cmluZywgbGluZVdpZHRoKSwgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0RPVUJMRTpcbiAgICAgICAgcmV0dXJuICdcIicgKyBlc2NhcGVTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpICsgJ1wiJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdpbXBvc3NpYmxlIGVycm9yOiBpbnZhbGlkIHNjYWxhciBzdHlsZScpO1xuICAgIH1cbiAgfSgpKTtcbn1cblxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0cmluZyBpcyB2YWxpZCBmb3IgYSBibG9jayBzY2FsYXIsIDEgPD0gaW5kZW50UGVyTGV2ZWwgPD0gOS5cbmZ1bmN0aW9uIGJsb2NrSGVhZGVyKHN0cmluZywgaW5kZW50UGVyTGV2ZWwpIHtcbiAgdmFyIGluZGVudEluZGljYXRvciA9IG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSA/IFN0cmluZyhpbmRlbnRQZXJMZXZlbCkgOiAnJztcblxuICAvLyBub3RlIHRoZSBzcGVjaWFsIGNhc2U6IHRoZSBzdHJpbmcgJ1xcbicgY291bnRzIGFzIGEgXCJ0cmFpbGluZ1wiIGVtcHR5IGxpbmUuXG4gIHZhciBjbGlwID0gICAgICAgICAgc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJ1xcbic7XG4gIHZhciBrZWVwID0gY2xpcCAmJiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAyXSA9PT0gJ1xcbicgfHwgc3RyaW5nID09PSAnXFxuJyk7XG4gIHZhciBjaG9tcCA9IGtlZXAgPyAnKycgOiAoY2xpcCA/ICcnIDogJy0nKTtcblxuICByZXR1cm4gaW5kZW50SW5kaWNhdG9yICsgY2hvbXAgKyAnXFxuJztcbn1cblxuLy8gKFNlZSB0aGUgbm90ZSBmb3Igd3JpdGVTY2FsYXIuKVxuZnVuY3Rpb24gZHJvcEVuZGluZ05ld2xpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbi8vIE5vdGU6IGEgbG9uZyBsaW5lIHdpdGhvdXQgYSBzdWl0YWJsZSBicmVhayBwb2ludCB3aWxsIGV4Y2VlZCB0aGUgd2lkdGggbGltaXQuXG4vLyBQcmUtY29uZGl0aW9uczogZXZlcnkgY2hhciBpbiBzdHIgaXNQcmludGFibGUsIHN0ci5sZW5ndGggPiAwLCB3aWR0aCA+IDAuXG5mdW5jdGlvbiBmb2xkU3RyaW5nKHN0cmluZywgd2lkdGgpIHtcbiAgLy8gSW4gZm9sZGVkIHN0eWxlLCAkayQgY29uc2VjdXRpdmUgbmV3bGluZXMgb3V0cHV0IGFzICRrKzEkIG5ld2xpbmVz4oCUXG4gIC8vIHVubGVzcyB0aGV5J3JlIGJlZm9yZSBvciBhZnRlciBhIG1vcmUtaW5kZW50ZWQgbGluZSwgb3IgYXQgdGhlIHZlcnlcbiAgLy8gYmVnaW5uaW5nIG9yIGVuZCwgaW4gd2hpY2ggY2FzZSAkayQgbWFwcyB0byAkayQuXG4gIC8vIFRoZXJlZm9yZSwgcGFyc2UgZWFjaCBjaHVuayBhcyBuZXdsaW5lKHMpIGZvbGxvd2VkIGJ5IGEgY29udGVudCBsaW5lLlxuICB2YXIgbGluZVJlID0gLyhcXG4rKShbXlxcbl0qKS9nO1xuXG4gIC8vIGZpcnN0IGxpbmUgKHBvc3NpYmx5IGFuIGVtcHR5IGxpbmUpXG4gIHZhciByZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0TEYgPSBzdHJpbmcuaW5kZXhPZignXFxuJyk7XG4gICAgbmV4dExGID0gbmV4dExGICE9PSAtMSA/IG5leHRMRiA6IHN0cmluZy5sZW5ndGg7XG4gICAgbGluZVJlLmxhc3RJbmRleCA9IG5leHRMRjtcbiAgICByZXR1cm4gZm9sZExpbmUoc3RyaW5nLnNsaWNlKDAsIG5leHRMRiksIHdpZHRoKTtcbiAgfSgpKTtcbiAgLy8gSWYgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBmaXJzdCBjb250ZW50IGxpbmUgeWV0LCBkb24ndCBhZGQgYW4gZXh0cmEgXFxuLlxuICB2YXIgcHJldk1vcmVJbmRlbnRlZCA9IHN0cmluZ1swXSA9PT0gJ1xcbicgfHwgc3RyaW5nWzBdID09PSAnICc7XG4gIHZhciBtb3JlSW5kZW50ZWQ7XG5cbiAgLy8gcmVzdCBvZiB0aGUgbGluZXNcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gbGluZVJlLmV4ZWMoc3RyaW5nKSkpIHtcbiAgICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0sIGxpbmUgPSBtYXRjaFsyXTtcbiAgICBtb3JlSW5kZW50ZWQgPSAobGluZVswXSA9PT0gJyAnKTtcbiAgICByZXN1bHQgKz0gcHJlZml4XG4gICAgICArICghcHJldk1vcmVJbmRlbnRlZCAmJiAhbW9yZUluZGVudGVkICYmIGxpbmUgIT09ICcnXG4gICAgICAgID8gJ1xcbicgOiAnJylcbiAgICAgICsgZm9sZExpbmUobGluZSwgd2lkdGgpO1xuICAgIHByZXZNb3JlSW5kZW50ZWQgPSBtb3JlSW5kZW50ZWQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHcmVlZHkgbGluZSBicmVha2luZy5cbi8vIFBpY2tzIHRoZSBsb25nZXN0IGxpbmUgdW5kZXIgdGhlIGxpbWl0IGVhY2ggdGltZSxcbi8vIG90aGVyd2lzZSBzZXR0bGVzIGZvciB0aGUgc2hvcnRlc3QgbGluZSBvdmVyIHRoZSBsaW1pdC5cbi8vIE5CLiBNb3JlLWluZGVudGVkIGxpbmVzICpjYW5ub3QqIGJlIGZvbGRlZCwgYXMgdGhhdCB3b3VsZCBhZGQgYW4gZXh0cmEgXFxuLlxuZnVuY3Rpb24gZm9sZExpbmUobGluZSwgd2lkdGgpIHtcbiAgaWYgKGxpbmUgPT09ICcnIHx8IGxpbmVbMF0gPT09ICcgJykgcmV0dXJuIGxpbmU7XG5cbiAgLy8gU2luY2UgYSBtb3JlLWluZGVudGVkIGxpbmUgYWRkcyBhIFxcbiwgYnJlYWtzIGNhbid0IGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2UuXG4gIHZhciBicmVha1JlID0gLyBbXiBdL2c7IC8vIG5vdGU6IHRoZSBtYXRjaCBpbmRleCB3aWxsIGFsd2F5cyBiZSA8PSBsZW5ndGgtMi5cbiAgdmFyIG1hdGNoO1xuICAvLyBzdGFydCBpcyBhbiBpbmNsdXNpdmUgaW5kZXguIGVuZCwgY3VyciwgYW5kIG5leHQgYXJlIGV4Y2x1c2l2ZS5cbiAgdmFyIHN0YXJ0ID0gMCwgZW5kLCBjdXJyID0gMCwgbmV4dCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICAvLyBJbnZhcmlhbnRzOiAwIDw9IHN0YXJ0IDw9IGxlbmd0aC0xLlxuICAvLyAgIDAgPD0gY3VyciA8PSBuZXh0IDw9IG1heCgwLCBsZW5ndGgtMikuIGN1cnIgLSBzdGFydCA8PSB3aWR0aC5cbiAgLy8gSW5zaWRlIHRoZSBsb29wOlxuICAvLyAgIEEgbWF0Y2ggaW1wbGllcyBsZW5ndGggPj0gMiwgc28gY3VyciBhbmQgbmV4dCBhcmUgPD0gbGVuZ3RoLTIuXG4gIHdoaWxlICgobWF0Y2ggPSBicmVha1JlLmV4ZWMobGluZSkpKSB7XG4gICAgbmV4dCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIG1haW50YWluIGludmFyaWFudDogY3VyciAtIHN0YXJ0IDw9IHdpZHRoXG4gICAgaWYgKG5leHQgLSBzdGFydCA+IHdpZHRoKSB7XG4gICAgICBlbmQgPSAoY3VyciA+IHN0YXJ0KSA/IGN1cnIgOiBuZXh0OyAvLyBkZXJpdmUgZW5kIDw9IGxlbmd0aC0yXG4gICAgICByZXN1bHQgKz0gJ1xcbicgKyBsaW5lLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgLy8gc2tpcCB0aGUgc3BhY2UgdGhhdCB3YXMgb3V0cHV0IGFzIFxcblxuICAgICAgc3RhcnQgPSBlbmQgKyAxOyAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHN0YXJ0IDw9IGxlbmd0aC0xXG4gICAgfVxuICAgIGN1cnIgPSBuZXh0O1xuICB9XG5cbiAgLy8gQnkgdGhlIGludmFyaWFudHMsIHN0YXJ0IDw9IGxlbmd0aC0xLCBzbyB0aGVyZSBpcyBzb21ldGhpbmcgbGVmdCBvdmVyLlxuICAvLyBJdCBpcyBlaXRoZXIgdGhlIHdob2xlIHN0cmluZyBvciBhIHBhcnQgc3RhcnRpbmcgZnJvbSBub24td2hpdGVzcGFjZS5cbiAgcmVzdWx0ICs9ICdcXG4nO1xuICAvLyBJbnNlcnQgYSBicmVhayBpZiB0aGUgcmVtYWluZGVyIGlzIHRvbyBsb25nIGFuZCB0aGVyZSBpcyBhIGJyZWFrIGF2YWlsYWJsZS5cbiAgaWYgKGxpbmUubGVuZ3RoIC0gc3RhcnQgPiB3aWR0aCAmJiBjdXJyID4gc3RhcnQpIHtcbiAgICByZXN1bHQgKz0gbGluZS5zbGljZShzdGFydCwgY3VycikgKyAnXFxuJyArIGxpbmUuc2xpY2UoY3VyciArIDEpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuc2xpY2UoMSk7IC8vIGRyb3AgZXh0cmEgXFxuIGpvaW5lclxufVxuXG4vLyBFc2NhcGVzIGEgZG91YmxlLXF1b3RlZCBzdHJpbmcuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgdmFyIGNoYXIsIG5leHRDaGFyO1xuICB2YXIgZXNjYXBlU2VxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhciA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIENoZWNrIGZvciBzdXJyb2dhdGUgcGFpcnMgKHJlZmVyZW5jZSBVbmljb2RlIDMuMCBzZWN0aW9uIFwiMy43IFN1cnJvZ2F0ZXNcIikuXG4gICAgaWYgKGNoYXIgPj0gMHhEODAwICYmIGNoYXIgPD0gMHhEQkZGLyogaGlnaCBzdXJyb2dhdGUgKi8pIHtcbiAgICAgIG5leHRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKG5leHRDaGFyID49IDB4REMwMCAmJiBuZXh0Q2hhciA8PSAweERGRkYvKiBsb3cgc3Vycm9nYXRlICovKSB7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN1cnJvZ2F0ZSBwYWlyIGFuZCBzdG9yZSBpdCBlc2NhcGVkLlxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlSGV4KChjaGFyIC0gMHhEODAwKSAqIDB4NDAwICsgbmV4dENoYXIgLSAweERDMDAgKyAweDEwMDAwKTtcbiAgICAgICAgLy8gQWR2YW5jZSBpbmRleCBvbmUgZXh0cmEgc2luY2Ugd2UgYWxyZWFkeSB1c2VkIHRoYXQgY2hhciBoZXJlLlxuICAgICAgICBpKys7IGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuICAgIHJlc3VsdCArPSAhZXNjYXBlU2VxICYmIGlzUHJpbnRhYmxlKGNoYXIpXG4gICAgICA/IHN0cmluZ1tpXVxuICAgICAgOiBlc2NhcGVTZXEgfHwgZW5jb2RlSGV4KGNoYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLlxuICAgIGlmICh3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RbaW5kZXhdLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBpZiAoaW5kZXggIT09IDApIF9yZXN1bHQgKz0gJywnICsgKCFzdGF0ZS5jb25kZW5zZUZsb3cgPyAnICcgOiAnJyk7XG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICdbJyArIF9yZXN1bHQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgY29tcGFjdCkge1xuICB2YXIgX3Jlc3VsdCA9ICcnLFxuICAgICAgX3RhZyAgICA9IHN0YXRlLnRhZyxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RbaW5kZXhdLCB0cnVlLCB0cnVlKSkge1xuICAgICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgIF9yZXN1bHQgKz0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSAnO1xuICAgICAgfVxuXG4gICAgICBfcmVzdWx0ICs9IHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ1tdJzsgLy8gRW1wdHkgc2VxdWVuY2UgaWYgbm8gdmFsaWQgdmFsdWVzLlxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICBwYWlyQnVmZmVyID0gJyc7XG4gICAgaWYgKGluZGV4ICE9PSAwKSBwYWlyQnVmZmVyICs9ICcsICc7XG5cbiAgICBpZiAoc3RhdGUuY29uZGVuc2VGbG93KSBwYWlyQnVmZmVyICs9ICdcIic7XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3RLZXksIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQga2V5O1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpIHBhaXJCdWZmZXIgKz0gJz8gJztcblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcCArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnXCInIDogJycpICsgJzonICsgKHN0YXRlLmNvbmRlbnNlRmxvdyA/ICcnIDogJyAnKTtcblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0VmFsdWUsIGZhbHNlLCBmYWxzZSkpIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRoaXMgcGFpciBiZWNhdXNlIG9mIGludmFsaWQgdmFsdWUuXG4gICAgfVxuXG4gICAgcGFpckJ1ZmZlciArPSBzdGF0ZS5kdW1wO1xuXG4gICAgLy8gQm90aCBrZXkgYW5kIHZhbHVlIGFyZSB2YWxpZC5cbiAgICBfcmVzdWx0ICs9IHBhaXJCdWZmZXI7XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ3snICsgX3Jlc3VsdCArICd9Jztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QsIGNvbXBhY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBleHBsaWNpdFBhaXIsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIC8vIEFsbG93IHNvcnRpbmcga2V5cyBzbyB0aGF0IHRoZSBvdXRwdXQgZmlsZSBpcyBkZXRlcm1pbmlzdGljXG4gIGlmIChzdGF0ZS5zb3J0S2V5cyA9PT0gdHJ1ZSkge1xuICAgIC8vIERlZmF1bHQgc29ydGluZ1xuICAgIG9iamVjdEtleUxpc3Quc29ydCgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0ZS5zb3J0S2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEN1c3RvbSBzb3J0IGZ1bmN0aW9uXG4gICAgb2JqZWN0S2V5TGlzdC5zb3J0KHN0YXRlLnNvcnRLZXlzKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5zb3J0S2V5cykge1xuICAgIC8vIFNvbWV0aGluZyBpcyB3cm9uZ1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdzb3J0S2V5cyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0S2V5TGlzdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpckJ1ZmZlciA9ICcnO1xuXG4gICAgaWYgKCFjb21wYWN0IHx8IGluZGV4ICE9PSAwKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBvYmplY3RLZXkgPSBvYmplY3RLZXlMaXN0W2luZGV4XTtcbiAgICBvYmplY3RWYWx1ZSA9IG9iamVjdFtvYmplY3RLZXldO1xuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0S2V5LCB0cnVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXG4gICAgfVxuXG4gICAgZXhwbGljaXRQYWlyID0gKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RWYWx1ZSwgdHJ1ZSwgZXhwbGljaXRQYWlyKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6JztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOiAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiAgfHwgdHlwZS5wcmVkaWNhdGUpICYmXG4gICAgICAgICghdHlwZS5pbnN0YW5jZU9mIHx8ICgodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpICYmIChvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpKSkgJiZcbiAgICAgICAgKCF0eXBlLnByZWRpY2F0ZSAgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcblxuICAgICAgc3RhdGUudGFnID0gZXhwbGljaXQgPyB0eXBlLnRhZyA6ICc/JztcblxuICAgICAgaWYgKHR5cGUucmVwcmVzZW50KSB7XG4gICAgICAgIHN0eWxlID0gc3RhdGUuc3R5bGVNYXBbdHlwZS50YWddIHx8IHR5cGUuZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbCh0eXBlLnJlcHJlc2VudCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnQob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5yZXByZXNlbnQsIHN0eWxlKSkge1xuICAgICAgICAgIF9yZXN1bHQgPSB0eXBlLnJlcHJlc2VudFtzdHlsZV0ob2JqZWN0LCBzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJyE8JyArIHR5cGUudGFnICsgJz4gdGFnIHJlc29sdmVyIGFjY2VwdHMgbm90IFwiJyArIHN0eWxlICsgJ1wiIHN0eWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kdW1wID0gX3Jlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTZXJpYWxpemVzIGBvYmplY3RgIGFuZCB3cml0ZXMgaXQgdG8gZ2xvYmFsIGByZXN1bHRgLlxuLy8gUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIG9yIGZhbHNlIG9uIGludmFsaWQgb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdCwgYmxvY2ssIGNvbXBhY3QsIGlza2V5KSB7XG4gIHN0YXRlLnRhZyA9IG51bGw7XG4gIHN0YXRlLmR1bXAgPSBvYmplY3Q7XG5cbiAgaWYgKCFkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIGZhbHNlKSkge1xuICAgIGRldGVjdFR5cGUoc3RhdGUsIG9iamVjdCwgdHJ1ZSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IF90b1N0cmluZy5jYWxsKHN0YXRlLmR1bXApO1xuXG4gIGlmIChibG9jaykge1xuICAgIGJsb2NrID0gKHN0YXRlLmZsb3dMZXZlbCA8IDAgfHwgc3RhdGUuZmxvd0xldmVsID4gbGV2ZWwpO1xuICB9XG5cbiAgdmFyIG9iamVjdE9yQXJyYXkgPSB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgZHVwbGljYXRlSW5kZXgsXG4gICAgICBkdXBsaWNhdGU7XG5cbiAgaWYgKG9iamVjdE9yQXJyYXkpIHtcbiAgICBkdXBsaWNhdGVJbmRleCA9IHN0YXRlLmR1cGxpY2F0ZXMuaW5kZXhPZihvYmplY3QpO1xuICAgIGR1cGxpY2F0ZSA9IGR1cGxpY2F0ZUluZGV4ICE9PSAtMTtcbiAgfVxuXG4gIGlmICgoc3RhdGUudGFnICE9PSBudWxsICYmIHN0YXRlLnRhZyAhPT0gJz8nKSB8fCBkdXBsaWNhdGUgfHwgKHN0YXRlLmluZGVudCAhPT0gMiAmJiBsZXZlbCA+IDApKSB7XG4gICAgY29tcGFjdCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGR1cGxpY2F0ZSAmJiBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0pIHtcbiAgICBzdGF0ZS5kdW1wID0gJypyZWZfJyArIGR1cGxpY2F0ZUluZGV4O1xuICB9IGVsc2Uge1xuICAgIGlmIChvYmplY3RPckFycmF5ICYmIGR1cGxpY2F0ZSAmJiAhc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgICBzdGF0ZS51c2VkRHVwbGljYXRlc1tkdXBsaWNhdGVJbmRleF0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIGlmIChibG9jayAmJiAoT2JqZWN0LmtleXMoc3RhdGUuZHVtcCkubGVuZ3RoICE9PSAwKSkge1xuICAgICAgICB3cml0ZUJsb2NrTWFwcGluZyhzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgc3RhdGUuZHVtcCA9ICcmcmVmXycgKyBkdXBsaWNhdGVJbmRleCArIHN0YXRlLmR1bXA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICB2YXIgYXJyYXlMZXZlbCA9IChzdGF0ZS5ub0FycmF5SW5kZW50ICYmIChsZXZlbCA+IDApKSA/IGxldmVsIC0gMSA6IGxldmVsO1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBhcnJheUxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dTZXF1ZW5jZShzdGF0ZSwgYXJyYXlMZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICAgIGlmIChzdGF0ZS50YWcgIT09ICc/Jykge1xuICAgICAgICB3cml0ZVNjYWxhcihzdGF0ZSwgc3RhdGUuZHVtcCwgbGV2ZWwsIGlza2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIHN0YXRlLmR1bXAgPSAnITwnICsgc3RhdGUudGFnICsgJz4gJyArIHN0YXRlLmR1bXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMob2JqZWN0LCBzdGF0ZSkge1xuICB2YXIgb2JqZWN0cyA9IFtdLFxuICAgICAgZHVwbGljYXRlc0luZGV4ZXMgPSBbXSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBkdXBsaWNhdGVzSW5kZXhlcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgc3RhdGUuZHVwbGljYXRlcy5wdXNoKG9iamVjdHNbZHVwbGljYXRlc0luZGV4ZXNbaW5kZXhdXSk7XG4gIH1cbiAgc3RhdGUudXNlZER1cGxpY2F0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUob2JqZWN0LCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcykge1xuICB2YXIgb2JqZWN0S2V5TGlzdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoO1xuXG4gIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzSW5kZXhlcy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgZHVwbGljYXRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtpbmRleF0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgIGluc3BlY3ROb2RlKG9iamVjdFtvYmplY3RLZXlMaXN0W2luZGV4XV0sIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShvcHRpb25zKTtcblxuICBpZiAoIXN0YXRlLm5vUmVmcykgZ2V0RHVwbGljYXRlUmVmZXJlbmNlcyhpbnB1dCwgc3RhdGUpO1xuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIGlucHV0LCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhZmVEdW1wKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBkdW1wKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZHVtcCAgICAgPSBkdW1wO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgPSBzYWZlRHVtcDtcbiIsIi8vIFlBTUwgZXJyb3IgY2xhc3MuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ1ODk4NFxuLy9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSAodGhpcy5yZWFzb24gfHwgJyh1bmtub3duIHJlYXNvbiknKSArICh0aGlzLm1hcmsgPyAnICcgKyB0aGlzLm1hcmsudG9TdHJpbmcoKSA6ICcnKTtcblxuICAvLyBJbmNsdWRlIHN0YWNrIHRyYWNlIGluIGVycm9yIG9iamVjdFxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAvLyBDaHJvbWUgYW5kIE5vZGVKU1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZGLCBJRSAxMCsgYW5kIFNhZmFyaSA2Ky4gRmFsbGJhY2sgZm9yIG90aGVyc1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrIHx8ICcnO1xuICB9XG59XG5cblxuLy8gSW5oZXJpdCBmcm9tIEVycm9yXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbllBTUxFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gWUFNTEV4Y2VwdGlvbjtcblxuXG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGNvbXBhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZSArICc6ICc7XG5cbiAgcmVzdWx0ICs9IHRoaXMucmVhc29uIHx8ICcodW5rbm93biByZWFzb24pJztcblxuICBpZiAoIWNvbXBhY3QgJiYgdGhpcy5tYXJrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIHRoaXMubWFyay50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBZQU1MRXhjZXB0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4sbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgTWFyayAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbWFyaycpO1xudmFyIERFRkFVTFRfU0FGRV9TQ0hFTUEgPSByZXF1aXJlKCcuL3NjaGVtYS9kZWZhdWx0X3NhZmUnKTtcbnZhciBERUZBVUxUX0ZVTExfU0NIRU1BID0gcmVxdWlyZSgnLi9zY2hlbWEvZGVmYXVsdF9mdWxsJyk7XG5cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblxudmFyIENPTlRFWFRfRkxPV19JTiAgID0gMTtcbnZhciBDT05URVhUX0ZMT1dfT1VUICA9IDI7XG52YXIgQ09OVEVYVF9CTE9DS19JTiAgPSAzO1xudmFyIENPTlRFWFRfQkxPQ0tfT1VUID0gNDtcblxuXG52YXIgQ0hPTVBJTkdfQ0xJUCAgPSAxO1xudmFyIENIT01QSU5HX1NUUklQID0gMjtcbnZhciBDSE9NUElOR19LRUVQICA9IDM7XG5cblxudmFyIFBBVFRFUk5fTk9OX1BSSU5UQUJMRSAgICAgICAgID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDg0XFx4ODYtXFx4OUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xudmFyIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTID0gL1tcXHg4NVxcdTIwMjhcXHUyMDI5XS87XG52YXIgUEFUVEVSTl9GTE9XX0lORElDQVRPUlMgICAgICAgPSAvWyxcXFtcXF1cXHtcXH1dLztcbnZhciBQQVRURVJOX1RBR19IQU5ETEUgICAgICAgICAgICA9IC9eKD86IXwhIXwhW2EtelxcLV0rISkkL2k7XG52YXIgUEFUVEVSTl9UQUdfVVJJICAgICAgICAgICAgICAgPSAvXig/OiF8W14sXFxbXFxdXFx7XFx9XSkoPzolWzAtOWEtZl17Mn18WzAtOWEtelxcLSM7XFwvXFw/OkAmPVxcK1xcJCxfXFwuIX5cXConXFwoXFwpXFxbXFxdXSkqJC9pO1xuXG5cbmZ1bmN0aW9uIF9jbGFzcyhvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopOyB9XG5cbmZ1bmN0aW9uIGlzX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwQS8qIExGICovKSB8fCAoYyA9PT0gMHgwRC8qIENSICovKTtcbn1cblxuZnVuY3Rpb24gaXNfV0hJVEVfU1BBQ0UoYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8IChjID09PSAweDIwLyogU3BhY2UgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XU19PUl9FT0woYykge1xuICByZXR1cm4gKGMgPT09IDB4MDkvKiBUYWIgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgyMC8qIFNwYWNlICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEEvKiBMRiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19GTE9XX0lORElDQVRPUihjKSB7XG4gIHJldHVybiBjID09PSAweDJDLyogLCAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1Qi8qIFsgKi8gfHxcbiAgICAgICAgIGMgPT09IDB4NUQvKiBdICovIHx8XG4gICAgICAgICBjID09PSAweDdCLyogeyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg3RC8qIH0gKi87XG59XG5cbmZ1bmN0aW9uIGZyb21IZXhDb2RlKGMpIHtcbiAgdmFyIGxjO1xuXG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlKi9cbiAgbGMgPSBjIHwgMHgyMDtcblxuICBpZiAoKDB4NjEvKiBhICovIDw9IGxjKSAmJiAobGMgPD0gMHg2Ni8qIGYgKi8pKSB7XG4gICAgcmV0dXJuIGxjIC0gMHg2MSArIDEwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVkSGV4TGVuKGMpIHtcbiAgaWYgKGMgPT09IDB4NzgvKiB4ICovKSB7IHJldHVybiAyOyB9XG4gIGlmIChjID09PSAweDc1LyogdSAqLykgeyByZXR1cm4gNDsgfVxuICBpZiAoYyA9PT0gMHg1NS8qIFUgKi8pIHsgcmV0dXJuIDg7IH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGZyb21EZWNpbWFsQ29kZShjKSB7XG4gIGlmICgoMHgzMC8qIDAgKi8gPD0gYykgJiYgKGMgPD0gMHgzOS8qIDkgKi8pKSB7XG4gICAgcmV0dXJuIGMgLSAweDMwO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFc2NhcGVTZXF1ZW5jZShjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuICByZXR1cm4gKGMgPT09IDB4MzAvKiAwICovKSA/ICdcXHgwMCcgOlxuICAgICAgICAoYyA9PT0gMHg2MS8qIGEgKi8pID8gJ1xceDA3JyA6XG4gICAgICAgIChjID09PSAweDYyLyogYiAqLykgPyAnXFx4MDgnIDpcbiAgICAgICAgKGMgPT09IDB4NzQvKiB0ICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHgwOS8qIFRhYiAqLykgPyAnXFx4MDknIDpcbiAgICAgICAgKGMgPT09IDB4NkUvKiBuICovKSA/ICdcXHgwQScgOlxuICAgICAgICAoYyA9PT0gMHg3Ni8qIHYgKi8pID8gJ1xceDBCJyA6XG4gICAgICAgIChjID09PSAweDY2LyogZiAqLykgPyAnXFx4MEMnIDpcbiAgICAgICAgKGMgPT09IDB4NzIvKiByICovKSA/ICdcXHgwRCcgOlxuICAgICAgICAoYyA9PT0gMHg2NS8qIGUgKi8pID8gJ1xceDFCJyA6XG4gICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pID8gJyAnIDpcbiAgICAgICAgKGMgPT09IDB4MjIvKiBcIiAqLykgPyAnXFx4MjInIDpcbiAgICAgICAgKGMgPT09IDB4MkYvKiAvICovKSA/ICcvJyA6XG4gICAgICAgIChjID09PSAweDVDLyogXFwgKi8pID8gJ1xceDVDJyA6XG4gICAgICAgIChjID09PSAweDRFLyogTiAqLykgPyAnXFx4ODUnIDpcbiAgICAgICAgKGMgPT09IDB4NUYvKiBfICovKSA/ICdcXHhBMCcgOlxuICAgICAgICAoYyA9PT0gMHg0Qy8qIEwgKi8pID8gJ1xcdTIwMjgnIDpcbiAgICAgICAgKGMgPT09IDB4NTAvKiBQICovKSA/ICdcXHUyMDI5JyA6ICcnO1xufVxuXG5mdW5jdGlvbiBjaGFyRnJvbUNvZGVwb2ludChjKSB7XG4gIGlmIChjIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICB9XG4gIC8vIEVuY29kZSBVVEYtMTYgc3Vycm9nYXRlIHBhaXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTE2I0NvZGVfcG9pbnRzX1UuMkIwMTAwMDBfdG9fVS4yQjEwRkZGRlxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAoKGMgLSAweDAxMDAwMCkgPj4gMTApICsgMHhEODAwLFxuICAgICgoYyAtIDB4MDEwMDAwKSAmIDB4MDNGRikgKyAweERDMDBcbiAgKTtcbn1cblxudmFyIHNpbXBsZUVzY2FwZUNoZWNrID0gbmV3IEFycmF5KDI1Nik7IC8vIGludGVnZXIsIGZvciBmYXN0IGFjY2Vzc1xudmFyIHNpbXBsZUVzY2FwZU1hcCA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBzaW1wbGVFc2NhcGVDaGVja1tpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpID8gMSA6IDA7XG4gIHNpbXBsZUVzY2FwZU1hcFtpXSA9IHNpbXBsZUVzY2FwZVNlcXVlbmNlKGkpO1xufVxuXG5cbmZ1bmN0aW9uIFN0YXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICB0aGlzLmZpbGVuYW1lICA9IG9wdGlvbnNbJ2ZpbGVuYW1lJ10gIHx8IG51bGw7XG4gIHRoaXMuc2NoZW1hICAgID0gb3B0aW9uc1snc2NoZW1hJ10gICAgfHwgREVGQVVMVF9GVUxMX1NDSEVNQTtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuICB0aGlzLmpzb24gICAgICA9IG9wdGlvbnNbJ2pzb24nXSAgICAgIHx8IGZhbHNlO1xuICB0aGlzLmxpc3RlbmVyICA9IG9wdGlvbnNbJ2xpc3RlbmVyJ10gIHx8IG51bGw7XG5cbiAgdGhpcy5pbXBsaWNpdFR5cGVzID0gdGhpcy5zY2hlbWEuY29tcGlsZWRJbXBsaWNpdDtcbiAgdGhpcy50eXBlTWFwICAgICAgID0gdGhpcy5zY2hlbWEuY29tcGlsZWRUeXBlTWFwO1xuXG4gIHRoaXMubGVuZ3RoICAgICA9IGlucHV0Lmxlbmd0aDtcbiAgdGhpcy5wb3NpdGlvbiAgID0gMDtcbiAgdGhpcy5saW5lICAgICAgID0gMDtcbiAgdGhpcy5saW5lU3RhcnQgID0gMDtcbiAgdGhpcy5saW5lSW5kZW50ID0gMDtcblxuICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gIC8qXG4gIHRoaXMudmVyc2lvbjtcbiAgdGhpcy5jaGVja0xpbmVCcmVha3M7XG4gIHRoaXMudGFnTWFwO1xuICB0aGlzLmFuY2hvck1hcDtcbiAgdGhpcy50YWc7XG4gIHRoaXMuYW5jaG9yO1xuICB0aGlzLmtpbmQ7XG4gIHRoaXMucmVzdWx0OyovXG5cbn1cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgWUFNTEV4Y2VwdGlvbihcbiAgICBtZXNzYWdlLFxuICAgIG5ldyBNYXJrKHN0YXRlLmZpbGVuYW1lLCBzdGF0ZS5pbnB1dCwgc3RhdGUucG9zaXRpb24sIHN0YXRlLmxpbmUsIChzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydCkpKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB0aHJvdyBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dXYXJuaW5nKHN0YXRlLCBtZXNzYWdlKSB7XG4gIGlmIChzdGF0ZS5vbldhcm5pbmcpIHtcbiAgICBzdGF0ZS5vbldhcm5pbmcuY2FsbChudWxsLCBnZW5lcmF0ZUVycm9yKHN0YXRlLCBtZXNzYWdlKSk7XG4gIH1cbn1cblxuXG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7XG5cbiAgWUFNTDogZnVuY3Rpb24gaGFuZGxlWWFtbERpcmVjdGl2ZShzdGF0ZSwgbmFtZSwgYXJncykge1xuXG4gICAgdmFyIG1hdGNoLCBtYWpvciwgbWlub3I7XG5cbiAgICBpZiAoc3RhdGUudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0aW9uIG9mICVZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1lBTUwgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSBvbmUgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBtYXRjaCA9IC9eKFswLTldKylcXC4oWzAtOV0rKSQvLmV4ZWMoYXJnc1swXSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIGFyZ3VtZW50IG9mIHRoZSBZQU1MIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIG1ham9yID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICBtaW5vciA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG5cbiAgICBpZiAobWFqb3IgIT09IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgWUFNTCB2ZXJzaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgIH1cblxuICAgIHN0YXRlLnZlcnNpb24gPSBhcmdzWzBdO1xuICAgIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IChtaW5vciA8IDIpO1xuXG4gICAgaWYgKG1pbm9yICE9PSAxICYmIG1pbm9yICE9PSAyKSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuICB9LFxuXG4gIFRBRzogZnVuY3Rpb24gaGFuZGxlVGFnRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgaGFuZGxlLCBwcmVmaXg7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdUQUcgZGlyZWN0aXZlIGFjY2VwdHMgZXhhY3RseSB0d28gYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gYXJnc1swXTtcbiAgICBwcmVmaXggPSBhcmdzWzFdO1xuXG4gICAgaWYgKCFQQVRURVJOX1RBR19IQU5ETEUudGVzdChoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaWxsLWZvcm1lZCB0YWcgaGFuZGxlIChmaXJzdCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCBoYW5kbGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGhlcmUgaXMgYSBwcmV2aW91c2x5IGRlY2xhcmVkIHN1ZmZpeCBmb3IgXCInICsgaGFuZGxlICsgJ1wiIHRhZyBoYW5kbGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHByZWZpeCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBwcmVmaXggKHNlY29uZCBhcmd1bWVudCkgb2YgdGhlIFRBRyBkaXJlY3RpdmUnKTtcbiAgICB9XG5cbiAgICBzdGF0ZS50YWdNYXBbaGFuZGxlXSA9IHByZWZpeDtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBjYXB0dXJlU2VnbWVudChzdGF0ZSwgc3RhcnQsIGVuZCwgY2hlY2tKc29uKSB7XG4gIHZhciBfcG9zaXRpb24sIF9sZW5ndGgsIF9jaGFyYWN0ZXIsIF9yZXN1bHQ7XG5cbiAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgX3Jlc3VsdCA9IHN0YXRlLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGNoZWNrSnNvbikge1xuICAgICAgZm9yIChfcG9zaXRpb24gPSAwLCBfbGVuZ3RoID0gX3Jlc3VsdC5sZW5ndGg7IF9wb3NpdGlvbiA8IF9sZW5ndGg7IF9wb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIF9jaGFyYWN0ZXIgPSBfcmVzdWx0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcbiAgICAgICAgaWYgKCEoX2NoYXJhY3RlciA9PT0gMHgwOSB8fFxuICAgICAgICAgICAgICAoMHgyMCA8PSBfY2hhcmFjdGVyICYmIF9jaGFyYWN0ZXIgPD0gMHgxMEZGRkYpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCB2YWxpZCBKU09OIGNoYXJhY3RlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQQVRURVJOX05PTl9QUklOVEFCTEUudGVzdChfcmVzdWx0KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RoZSBzdHJlYW0gY29udGFpbnMgbm9uLXByaW50YWJsZSBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuXG4gICAgc3RhdGUucmVzdWx0ICs9IF9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBwaW5ncyhzdGF0ZSwgZGVzdGluYXRpb24sIHNvdXJjZSwgb3ZlcnJpZGFibGVLZXlzKSB7XG4gIHZhciBzb3VyY2VLZXlzLCBrZXksIGluZGV4LCBxdWFudGl0eTtcblxuICBpZiAoIWNvbW1vbi5pc09iamVjdChzb3VyY2UpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2Nhbm5vdCBtZXJnZSBtYXBwaW5nczsgdGhlIHByb3ZpZGVkIHNvdXJjZSBvYmplY3QgaXMgdW5hY2NlcHRhYmxlJyk7XG4gIH1cblxuICBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblxuICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBzb3VyY2VLZXlzLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaW5kZXhdO1xuXG4gICAgaWYgKCFfaGFzT3duUHJvcGVydHkuY2FsbChkZXN0aW5hdGlvbiwga2V5KSkge1xuICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgb3ZlcnJpZGFibGVLZXlzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBzdGFydExpbmUsIHN0YXJ0UG9zKSB7XG4gIHZhciBpbmRleCwgcXVhbnRpdHk7XG5cbiAgLy8gVGhlIG91dHB1dCBpcyBhIHBsYWluIG9iamVjdCBoZXJlLCBzbyBrZXlzIGNhbiBvbmx5IGJlIHN0cmluZ3MuXG4gIC8vIFdlIG5lZWQgdG8gY29udmVydCBrZXlOb2RlIHRvIGEgc3RyaW5nLCBidXQgZG9pbmcgc28gY2FuIGhhbmcgdGhlIHByb2Nlc3NcbiAgLy8gKGRlZXBseSBuZXN0ZWQgYXJyYXlzIHRoYXQgZXhwbG9kZSBleHBvbmVudGlhbGx5IHVzaW5nIGFsaWFzZXMpLlxuICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlKSkge1xuICAgIGtleU5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChrZXlOb2RlKTtcblxuICAgIGZvciAoaW5kZXggPSAwLCBxdWFudGl0eSA9IGtleU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlOb2RlW2luZGV4XSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25lc3RlZCBhcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW5zaWRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBrZXlOb2RlID09PSAnb2JqZWN0JyAmJiBfY2xhc3Moa2V5Tm9kZVtpbmRleF0pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBrZXlOb2RlW2luZGV4XSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEF2b2lkIGNvZGUgZXhlY3V0aW9uIGluIGxvYWQoKSB2aWEgdG9TdHJpbmcgcHJvcGVydHlcbiAgLy8gKHN0aWxsIHVzZSBpdHMgb3duIHRvU3RyaW5nIGZvciBhcnJheXMsIHRpbWVzdGFtcHMsXG4gIC8vIGFuZCB3aGF0ZXZlciB1c2VyIHNjaGVtYSBleHRlbnNpb25zIGhhcHBlbiB0byBoYXZlIEBAdG9TdHJpbmdUYWcpXG4gIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGtleU5vZGUgPSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG5cbiAga2V5Tm9kZSA9IFN0cmluZyhrZXlOb2RlKTtcblxuICBpZiAoX3Jlc3VsdCA9PT0gbnVsbCkge1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfVxuXG4gIGlmIChrZXlUYWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZU5vZGUpKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSB2YWx1ZU5vZGUubGVuZ3RoOyBpbmRleCA8IHF1YW50aXR5OyBpbmRleCArPSAxKSB7XG4gICAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZVtpbmRleF0sIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlTWFwcGluZ3Moc3RhdGUsIF9yZXN1bHQsIHZhbHVlTm9kZSwgb3ZlcnJpZGFibGVLZXlzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdGF0ZS5qc29uICYmXG4gICAgICAgICFfaGFzT3duUHJvcGVydHkuY2FsbChvdmVycmlkYWJsZUtleXMsIGtleU5vZGUpICYmXG4gICAgICAgIF9oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIGtleU5vZGUpKSB7XG4gICAgICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lIHx8IHN0YXRlLmxpbmU7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXJ0UG9zIHx8IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2R1cGxpY2F0ZWQgbWFwcGluZyBrZXknKTtcbiAgICB9XG4gICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICBkZWxldGUgb3ZlcnJpZGFibGVLZXlzW2tleU5vZGVdO1xuICB9XG5cbiAgcmV0dXJuIF9yZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRMaW5lQnJlYWsoc3RhdGUpIHtcbiAgdmFyIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoID09PSAweDBBLyogTEYgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDBELyogQ1IgKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSBsaW5lIGJyZWFrIGlzIGV4cGVjdGVkJyk7XG4gIH1cblxuICBzdGF0ZS5saW5lICs9IDE7XG4gIHN0YXRlLmxpbmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBhbGxvd0NvbW1lbnRzLCBjaGVja0luZGVudCkge1xuICB2YXIgbGluZUJyZWFrcyA9IDAsXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dDb21tZW50cyAmJiBjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfSB3aGlsZSAoY2ggIT09IDB4MEEvKiBMRiAqLyAmJiBjaCAhPT0gMHgwRC8qIENSICovICYmIGNoICE9PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICBsaW5lQnJlYWtzKys7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgICAgd2hpbGUgKGNoID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja0luZGVudCAhPT0gLTEgJiYgbGluZUJyZWFrcyAhPT0gMCAmJiBzdGF0ZS5saW5lSW5kZW50IDwgY2hlY2tJbmRlbnQpIHtcbiAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICdkZWZpY2llbnQgaW5kZW50YXRpb24nKTtcbiAgfVxuXG4gIHJldHVybiBsaW5lQnJlYWtzO1xufVxuXG5mdW5jdGlvbiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgLy8gQ29uZGl0aW9uIHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgaXMgdGVzdGVkXG4gIC8vIGluIHBhcmVudCBvbiBlYWNoIGNhbGwsIGZvciBlZmZpY2llbmN5LiBObyBuZWVkcyB0byB0ZXN0IGhlcmUgYWdhaW4uXG4gIGlmICgoY2ggPT09IDB4MkQvKiAtICovIHx8IGNoID09PSAweDJFLyogLiAqLykgJiZcbiAgICAgIGNoID09PSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbiArIDEpICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAyKSkge1xuXG4gICAgX3Bvc2l0aW9uICs9IDM7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMCB8fCBpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIGNvdW50KSB7XG4gIGlmIChjb3VudCA9PT0gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gIH0gZWxzZSBpZiAoY291bnQgPiAxKSB7XG4gICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGNvdW50IC0gMSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiByZWFkUGxhaW5TY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQsIHdpdGhpbkZsb3dDb2xsZWN0aW9uKSB7XG4gIHZhciBwcmVjZWRpbmcsXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQsXG4gICAgICBfbGluZSxcbiAgICAgIF9saW5lU3RhcnQsXG4gICAgICBfbGluZUluZGVudCxcbiAgICAgIF9raW5kID0gc3RhdGUua2luZCxcbiAgICAgIF9yZXN1bHQgPSBzdGF0ZS5yZXN1bHQsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChpc19XU19PUl9FT0woY2gpICAgICAgfHxcbiAgICAgIGlzX0ZMT1dfSU5ESUNBVE9SKGNoKSB8fFxuICAgICAgY2ggPT09IDB4MjMvKiAjICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNi8qICYgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDJBLyogKiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjEvKiAhICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg3Qy8qIHwgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDNFLyogPiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjcvKiAnICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyMi8qIFwiICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyNS8qICUgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDQwLyogQCAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4NjAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoZm9sbG93aW5nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgIGlmIChpc19XU19PUl9FT0woZm9sbG93aW5nKSB8fFxuICAgICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgcHJlY2VkaW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiAtIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKHByZWNlZGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHx8XG4gICAgICAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihjaCkpIHtcbiAgICAgIGJyZWFrO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgX2xpbmVJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIC0xKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPj0gbm9kZUluZGVudCkge1xuICAgICAgICBoYXNQZW5kaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zaXRpb24gPSBjYXB0dXJlRW5kO1xuICAgICAgICBzdGF0ZS5saW5lID0gX2xpbmU7XG4gICAgICAgIHN0YXRlLmxpbmVTdGFydCA9IF9saW5lU3RhcnQ7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQgPSBfbGluZUluZGVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdDb250ZW50KSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBzdGF0ZS5saW5lIC0gX2xpbmUpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIH1cblxuICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCBmYWxzZSk7XG5cbiAgaWYgKHN0YXRlLnJlc3VsdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9IF9raW5kO1xuICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNoLFxuICAgICAgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI3LyogJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjcvKiAnICovKSB7XG4gICAgICAgIGNhcHR1cmVTdGFydCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgc2luZ2xlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWREb3VibGVRdW90ZWRTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGNhcHR1cmVFbmQsXG4gICAgICBoZXhMZW5ndGgsXG4gICAgICBoZXhSZXN1bHQsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyMi8qIFwiICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcbiAgc3RhdGUucG9zaXRpb24rKztcbiAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBpZiAoY2ggPT09IDB4MjIvKiBcIiAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBzdGF0ZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KTtcblxuICAgICAgICAvLyBUT0RPOiByZXdvcmsgdG8gaW5saW5lIGZuIHdpdGggbm8gdHlwZSBjYXN0P1xuICAgICAgfSBlbHNlIGlmIChjaCA8IDI1NiAmJiBzaW1wbGVFc2NhcGVDaGVja1tjaF0pIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IHNpbXBsZUVzY2FwZU1hcFtjaF07XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICAgIH0gZWxzZSBpZiAoKHRtcCA9IGVzY2FwZWRIZXhMZW4oY2gpKSA+IDApIHtcbiAgICAgICAgaGV4TGVuZ3RoID0gdG1wO1xuICAgICAgICBoZXhSZXN1bHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBoZXhMZW5ndGggPiAwOyBoZXhMZW5ndGgtLSkge1xuICAgICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgICAgIGlmICgodG1wID0gZnJvbUhleENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICAgICAgICBoZXhSZXN1bHQgPSAoaGV4UmVzdWx0IDw8IDQpICsgdG1wO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdleHBlY3RlZCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY2hhckZyb21Db2RlcG9pbnQoaGV4UmVzdWx0KTtcblxuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biBlc2NhcGUgc2VxdWVuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBjYXB0dXJlU2VnbWVudChzdGF0ZSwgY2FwdHVyZVN0YXJ0LCBjYXB0dXJlRW5kLCB0cnVlKTtcbiAgICAgIHdyaXRlRm9sZGVkTGluZXMoc3RhdGUsIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCBub2RlSW5kZW50KSk7XG4gICAgICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBzdGF0ZS5saW5lU3RhcnQgJiYgdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gYSBkb3VibGUgcXVvdGVkIHNjYWxhcicpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcbn1cblxuZnVuY3Rpb24gcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciByZWFkTmV4dCA9IHRydWUsXG4gICAgICBfbGluZSxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0ge30sXG4gICAgICBrZXlOb2RlLFxuICAgICAga2V5VGFnLFxuICAgICAgdmFsdWVOb2RlLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4NUIvKiBbICovKSB7XG4gICAgdGVybWluYXRvciA9IDB4NUQ7LyogXSAqL1xuICAgIGlzTWFwcGluZyA9IGZhbHNlO1xuICAgIF9yZXN1bHQgPSBbXTtcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHg3Qi8qIHsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg3RDsvKiB9ICovXG4gICAgaXNNYXBwaW5nID0gdHJ1ZTtcbiAgICBfcmVzdWx0ID0ge307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IHRlcm1pbmF0b3IpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICBzdGF0ZS50YWcgPSBfdGFnO1xuICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgIHN0YXRlLmtpbmQgPSBpc01hcHBpbmcgPyAnbWFwcGluZycgOiAnc2VxdWVuY2UnO1xuICAgICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXJlYWROZXh0KSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbWlzc2VkIGNvbW1hIGJldHdlZW4gZmxvdyBjb2xsZWN0aW9uIGVudHJpZXMnKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoaXNFeHBsaWNpdFBhaXIgfHwgc3RhdGUubGluZSA9PT0gX2xpbmUpICYmIGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgaXNQYWlyID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuICAgICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfRkxPV19JTiwgZmFsc2UsIHRydWUpO1xuICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChpc01hcHBpbmcpIHtcbiAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcmVzdWx0LnB1c2goa2V5Tm9kZSk7XG4gICAgfVxuXG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJDLyogLCAqLykge1xuICAgICAgcmVhZE5leHQgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkTmV4dCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbicpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTY2FsYXIoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIGNhcHR1cmVTdGFydCxcbiAgICAgIGZvbGRpbmcsXG4gICAgICBjaG9tcGluZyAgICAgICA9IENIT01QSU5HX0NMSVAsXG4gICAgICBkaWRSZWFkQ29udGVudCA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWRJbmRlbnQgPSBmYWxzZSxcbiAgICAgIHRleHRJbmRlbnQgICAgID0gbm9kZUluZGVudCxcbiAgICAgIGVtcHR5TGluZXMgICAgID0gMCxcbiAgICAgIGF0TW9yZUluZGVudGVkID0gZmFsc2UsXG4gICAgICB0bXAsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg3Qy8qIHwgKi8pIHtcbiAgICBmb2xkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4M0UvKiA+ICovKSB7XG4gICAgZm9sZGluZyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGUua2luZCA9ICdzY2FsYXInO1xuICBzdGF0ZS5yZXN1bHQgPSAnJztcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDB4MkIvKiArICovIHx8IGNoID09PSAweDJELyogLSAqLykge1xuICAgICAgaWYgKENIT01QSU5HX0NMSVAgPT09IGNob21waW5nKSB7XG4gICAgICAgIGNob21waW5nID0gKGNoID09PSAweDJCLyogKyAqLykgPyBDSE9NUElOR19LRUVQIDogQ0hPTVBJTkdfU1RSSVA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGEgY2hvbXBpbmcgbW9kZSBpZGVudGlmaWVyJyk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCh0bXAgPSBmcm9tRGVjaW1hbENvZGUoY2gpKSA+PSAwKSB7XG4gICAgICBpZiAodG1wID09PSAwKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgZXhwbGljaXQgaW5kZW50YXRpb24gd2lkdGggb2YgYSBibG9jayBzY2FsYXI7IGl0IGNhbm5vdCBiZSBsZXNzIHRoYW4gb25lJyk7XG4gICAgICB9IGVsc2UgaWYgKCFkZXRlY3RlZEluZGVudCkge1xuICAgICAgICB0ZXh0SW5kZW50ID0gbm9kZUluZGVudCArIHRtcCAtIDE7XG4gICAgICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdyZXBlYXQgb2YgYW4gaW5kZW50YXRpb24gd2lkdGggaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpO1xuXG4gICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICByZWFkTGluZUJyZWFrKHN0YXRlKTtcbiAgICBzdGF0ZS5saW5lSW5kZW50ID0gMDtcblxuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoKCFkZXRlY3RlZEluZGVudCB8fCBzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkgJiZcbiAgICAgICAgICAgKGNoID09PSAweDIwLyogU3BhY2UgKi8pKSB7XG4gICAgICBzdGF0ZS5saW5lSW5kZW50Kys7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKCFkZXRlY3RlZEluZGVudCAmJiBzdGF0ZS5saW5lSW5kZW50ID4gdGV4dEluZGVudCkge1xuICAgICAgdGV4dEluZGVudCA9IHN0YXRlLmxpbmVJbmRlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGVtcHR5TGluZXMrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEVuZCBvZiB0aGUgc2NhbGFyLlxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgdGV4dEluZGVudCkge1xuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBjaG9tcGluZy5cbiAgICAgIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfS0VFUCkge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgICAgfSBlbHNlIGlmIChjaG9tcGluZyA9PT0gQ0hPTVBJTkdfQ0xJUCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHRoZSBzY2FsYXIgaXMgbm90IGVtcHR5LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCcmVhayB0aGlzIGB3aGlsZWAgY3ljbGUgYW5kIGdvIHRvIHRoZSBmdW5jaXRvbidzIGVwaWxvZ3VlLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRm9sZGVkIHN0eWxlOiB1c2UgZmFuY3kgcnVsZXMgdG8gaGFuZGxlIGxpbmUgYnJlYWtzLlxuICAgIGlmIChmb2xkaW5nKSB7XG5cbiAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggd2hpdGUgc3BhY2UgY2hhcmFjdGVycyAobW9yZS1pbmRlbnRlZCBsaW5lcykgYXJlIG5vdCBmb2xkZWQuXG4gICAgICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGF0TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gZXhjZXB0IGZvciB0aGUgZmlyc3QgY29udGVudCBsaW5lIChjZi4gRXhhbXBsZSA4LjEpXG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG5cbiAgICAgIC8vIEVuZCBvZiBtb3JlLWluZGVudGVkIGJsb2NrLlxuICAgICAgfSBlbHNlIGlmIChhdE1vcmVJbmRlbnRlZCkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZW1wdHlMaW5lcyArIDEpO1xuXG4gICAgICAvLyBKdXN0IG9uZSBsaW5lIGJyZWFrIC0gcGVyY2VpdmUgYXMgdGhlIHNhbWUgbGluZS5cbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlMaW5lcyA9PT0gMCkge1xuICAgICAgICBpZiAoZGlkUmVhZENvbnRlbnQpIHsgLy8gaS5lLiBvbmx5IGlmIHdlIGhhdmUgYWxyZWFkeSByZWFkIHNvbWUgc2NhbGFyIGNvbnRlbnQuXG4gICAgICAgICAgc3RhdGUucmVzdWx0ICs9ICcgJztcbiAgICAgICAgfVxuXG4gICAgICAvLyBTZXZlcmFsIGxpbmUgYnJlYWtzIC0gcGVyY2VpdmUgYXMgZGlmZmVyZW50IGxpbmVzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMpO1xuICAgICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBzdHlsZToganVzdCBhZGQgZXhhY3QgbnVtYmVyIG9mIGxpbmUgYnJlYWtzIGJldHdlZW4gY29udGVudCBsaW5lcy5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gS2VlcCBhbGwgbGluZSBicmVha3MgZXhjZXB0IHRoZSBoZWFkZXIgbGluZSBicmVhay5cbiAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBkaWRSZWFkQ29udGVudCA/IDEgKyBlbXB0eUxpbmVzIDogZW1wdHlMaW5lcyk7XG4gICAgfVxuXG4gICAgZGlkUmVhZENvbnRlbnQgPSB0cnVlO1xuICAgIGRldGVjdGVkSW5kZW50ID0gdHJ1ZTtcbiAgICBlbXB0eUxpbmVzID0gMDtcbiAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlICghaXNfRU9MKGNoKSAmJiAoY2ggIT09IDApKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgX2xpbmUsXG4gICAgICBfdGFnICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBfYW5jaG9yICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgPSBbXSxcbiAgICAgIGZvbGxvd2luZyxcbiAgICAgIGRldGVjdGVkICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG5cbiAgICBpZiAoY2ggIT09IDB4MkQvKiAtICovKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICBpZiAoIWlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50IDw9IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgX3Jlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7XG4gICAgY29tcG9zZU5vZGUoc3RhdGUsIG5vZGVJbmRlbnQsIENPTlRFWFRfQkxPQ0tfSU4sIGZhbHNlLCB0cnVlKTtcbiAgICBfcmVzdWx0LnB1c2goc3RhdGUucmVzdWx0KTtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2JhZCBpbmRlbnRhdGlvbiBvZiBhIHNlcXVlbmNlIGVudHJ5Jyk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgbm9kZUluZGVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnc2VxdWVuY2UnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBub2RlSW5kZW50LCBmbG93SW5kZW50KSB7XG4gIHZhciBmb2xsb3dpbmcsXG4gICAgICBhbGxvd0NvbXBhY3QsXG4gICAgICBfbGluZSxcbiAgICAgIF9wb3MsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgICAgICA9IHN0YXRlLmFuY2hvcixcbiAgICAgIF9yZXN1bHQgICAgICAgPSB7fSxcbiAgICAgIG92ZXJyaWRhYmxlS2V5cyA9IHt9LFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuICAgIF9saW5lID0gc3RhdGUubGluZTsgLy8gU2F2ZSB0aGUgY3VycmVudCBsaW5lLlxuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIC8vXG4gICAgLy8gRXhwbGljaXQgbm90YXRpb24gY2FzZS4gVGhlcmUgYXJlIHR3byBzZXBhcmF0ZSBibG9ja3M6XG4gICAgLy8gZmlyc3QgZm9yIHRoZSBrZXkgKGRlbm90ZWQgYnkgXCI/XCIpIGFuZCBzZWNvbmQgZm9yIHRoZSB2YWx1ZSAoZGVub3RlZCBieSBcIjpcIilcbiAgICAvL1xuICAgIGlmICgoY2ggPT09IDB4M0YvKiA/ICovIHx8IGNoID09PSAweDNBLyogOiAqLykgJiYgaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcblxuICAgICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAvLyBpLmUuIDB4M0EvKiA6ICovID09PSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGV4cGxpY2l0IGtleS5cbiAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0NvbXBhY3QgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnaW5jb21wbGV0ZSBleHBsaWNpdCBtYXBwaW5nIHBhaXI7IGEga2V5IG5vZGUgaXMgbWlzc2VkOyBvciBmb2xsb3dlZCBieSBhIG5vbi10YWJ1bGF0ZWQgZW1wdHkgbGluZScpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICAgICAgY2ggPSBmb2xsb3dpbmc7XG5cbiAgICAvL1xuICAgIC8vIEltcGxpY2l0IG5vdGF0aW9uIGNhc2UuIEZsb3ctc3R5bGUgbm9kZSBhcyB0aGUga2V5IGZpcnN0LCB0aGVuIFwiOlwiLCBhbmQgdGhlIHZhbHVlLlxuICAgIC8vXG4gICAgfSBlbHNlIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsKTtcbiAgICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgICAgYWxsb3dDb21wYWN0ID0gZmFsc2U7XG4gICAgICAgICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYW4gaW1wbGljaXQgbWFwcGluZyBwYWlyOyBhIGNvbG9uIGlzIG1pc3NlZCcpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW4gbm90IHJlYWQgYSBibG9jayBtYXBwaW5nIGVudHJ5OyBhIG11bHRpbGluZSBrZXkgbWF5IG5vdCBiZSBhbiBpbXBsaWNpdCBrZXknKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUudGFnID0gX3RhZztcbiAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEtlZXAgdGhlIHJlc3VsdCBvZiBgY29tcG9zZU5vZGVgLlxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrOyAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX09VVCwgdHJ1ZSwgYWxsb3dDb21wYWN0KSkge1xuICAgICAgICBpZiAoYXRFeHBsaWNpdEtleSkge1xuICAgICAgICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRFeHBsaWNpdEtleSkge1xuICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgdmFsdWVOb2RlLCBfbGluZSwgX3Bvcyk7XG4gICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwpO1xuICB9XG5cbiAgLy8gRXhwb3NlIHRoZSByZXN1bHRpbmcgbWFwcGluZy5cbiAgaWYgKGRldGVjdGVkKSB7XG4gICAgc3RhdGUudGFnID0gX3RhZztcbiAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgIHN0YXRlLmtpbmQgPSAnbWFwcGluZyc7XG4gICAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBkZXRlY3RlZDtcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24sXG4gICAgICBpc1ZlcmJhdGltID0gZmFsc2UsXG4gICAgICBpc05hbWVkICAgID0gZmFsc2UsXG4gICAgICB0YWdIYW5kbGUsXG4gICAgICB0YWdOYW1lLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjEvKiAhICovKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGlvbiBvZiBhIHRhZyBwcm9wZXJ0eScpO1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgzQy8qIDwgKi8pIHtcbiAgICBpc1ZlcmJhdGltID0gdHJ1ZTtcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICBpc05hbWVkID0gdHJ1ZTtcbiAgICB0YWdIYW5kbGUgPSAnISEnO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICB9IGVsc2Uge1xuICAgIHRhZ0hhbmRsZSA9ICchJztcbiAgfVxuXG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIGlmIChpc1ZlcmJhdGltKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoY2ggIT09IDAgJiYgY2ggIT09IDB4M0UvKiA+ICovKTtcblxuICAgIGlmIChzdGF0ZS5wb3NpdGlvbiA8IHN0YXRlLmxlbmd0aCkge1xuICAgICAgdGFnTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSB2ZXJiYXRpbSB0YWcnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgyMS8qICEgKi8pIHtcbiAgICAgICAgaWYgKCFpc05hbWVkKSB7XG4gICAgICAgICAgdGFnSGFuZGxlID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uIC0gMSwgc3RhdGUucG9zaXRpb24gKyAxKTtcblxuICAgICAgICAgIGlmICghUEFUVEVSTl9UQUdfSEFORExFLnRlc3QodGFnSGFuZGxlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ25hbWVkIHRhZyBoYW5kbGUgY2Fubm90IGNvbnRhaW4gc3VjaCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNOYW1lZCA9IHRydWU7XG4gICAgICAgICAgX3Bvc2l0aW9uID0gc3RhdGUucG9zaXRpb24gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgc3VmZml4IGNhbm5vdCBjb250YWluIGV4Y2xhbWF0aW9uIG1hcmtzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUy50ZXN0KHRhZ05hbWUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBmbG93IGluZGljYXRvciBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ05hbWUgJiYgIVBBVFRFUk5fVEFHX1VSSS50ZXN0KHRhZ05hbWUpKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVyczogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnISEnKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI2LyogJiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyQS8qICogKi8pIHJldHVybiBmYWxzZTtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBhbGlhcyA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGUsXG4gICAgICBmbG93SW5kZW50LFxuICAgICAgYmxvY2tJbmRlbnQ7XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ29wZW4nLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS50YWcgICAgPSBudWxsO1xuICBzdGF0ZS5hbmNob3IgPSBudWxsO1xuICBzdGF0ZS5raW5kICAgPSBudWxsO1xuICBzdGF0ZS5yZXN1bHQgPSBudWxsO1xuXG4gIGFsbG93QmxvY2tTdHlsZXMgPSBhbGxvd0Jsb2NrU2NhbGFycyA9IGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9XG4gICAgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0IHx8XG4gICAgQ09OVEVYVF9CTE9DS19JTiAgPT09IG5vZGVDb250ZXh0O1xuXG4gIGlmIChhbGxvd1RvU2Vlaykge1xuICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgIGF0TmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICBpbmRlbnRTdGF0dXMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICB3aGlsZSAocmVhZFRhZ1Byb3BlcnR5KHN0YXRlKSB8fCByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpKSB7XG4gICAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICAgIGF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGFsbG93QmxvY2tTdHlsZXM7XG5cbiAgICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgICBpbmRlbnRTdGF0dXMgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zKSB7XG4gICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYXROZXdMaW5lIHx8IGFsbG93Q29tcGFjdDtcbiAgfVxuXG4gIGlmIChpbmRlbnRTdGF0dXMgPT09IDEgfHwgQ09OVEVYVF9CTE9DS19PVVQgPT09IG5vZGVDb250ZXh0KSB7XG4gICAgaWYgKENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQgfHwgQ09OVEVYVF9GTE9XX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsb3dJbmRlbnQgPSBwYXJlbnRJbmRlbnQgKyAxO1xuICAgIH1cblxuICAgIGJsb2NrSW5kZW50ID0gc3RhdGUucG9zaXRpb24gLSBzdGF0ZS5saW5lU3RhcnQ7XG5cbiAgICBpZiAoaW5kZW50U3RhdHVzID09PSAxKSB7XG4gICAgICBpZiAoYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmXG4gICAgICAgICAgKHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCkgfHxcbiAgICAgICAgICAgcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgYmxvY2tJbmRlbnQsIGZsb3dJbmRlbnQpKSB8fFxuICAgICAgICAgIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGFsbG93QmxvY2tTY2FsYXJzICYmIHJlYWRCbG9ja1NjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgICByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSB8fFxuICAgICAgICAgICAgcmVhZERvdWJsZVF1b3RlZFNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRBbGlhcyhzdGF0ZSkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgfHwgc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYWxpYXMgbm9kZSBzaG91bGQgbm90IGhhdmUgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWFkUGxhaW5TY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQsIENPTlRFWFRfRkxPV19JTiA9PT0gbm9kZUNvbnRleHQpKSB7XG4gICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRlbnRTdGF0dXMgPT09IDApIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogYmxvY2sgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIHRvIGhhdmUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbCBhcyB0aGUgcGFyZW50LlxuICAgICAgLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyNzk5Nzg0XG4gICAgICBoYXNDb250ZW50ID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zICYmIHJlYWRCbG9ja1NlcXVlbmNlKHN0YXRlLCBibG9ja0luZGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChzdGF0ZS50YWcgPT09ICc/Jykge1xuICAgICAgLy8gSW1wbGljaXQgcmVzb2x2aW5nIGlzIG5vdCBhbGxvd2VkIGZvciBub24tc2NhbGFyIHR5cGVzLCBhbmQgJz8nXG4gICAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBraW5kIGNvbmZvcm1pdHkgaW4gY2FzZSB1c2VyIGV4cGxpY2l0bHkgYXNzaWducyAnPydcbiAgICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAgIC8vXG4gICAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHN0YXRlLmtpbmQgIT09ICdzY2FsYXInKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodHlwZUluZGV4ID0gMCwgdHlwZVF1YW50aXR5ID0gc3RhdGUuaW1wbGljaXRUeXBlcy5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgICBpZiAodHlwZS5yZXNvbHZlKHN0YXRlLnJlc3VsdCkpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICAgICAgc3RhdGUucmVzdWx0ID0gdHlwZS5jb25zdHJ1Y3Qoc3RhdGUucmVzdWx0KTtcbiAgICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5hbmNob3JNYXBbc3RhdGUuYW5jaG9yXSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXSwgc3RhdGUudGFnKSkge1xuICAgICAgdHlwZSA9IHN0YXRlLnR5cGVNYXBbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXVtzdGF0ZS50YWddO1xuXG4gICAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5hY2NlcHRhYmxlIG5vZGUga2luZCBmb3IgITwnICsgc3RhdGUudGFnICsgJz4gdGFnOyBpdCBzaG91bGQgYmUgXCInICsgdHlwZS5raW5kICsgJ1wiLCBub3QgXCInICsgc3RhdGUua2luZCArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gdGFnICE8JyArIHN0YXRlLnRhZyArICc+Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0ge307XG4gIHN0YXRlLmFuY2hvck1hcCA9IHt9O1xuXG4gIHdoaWxlICgoY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSkgIT09IDApIHtcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiAwIHx8IGNoICE9PSAweDI1LyogJSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgZGlyZWN0aXZlTmFtZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuICAgIGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblxuICAgIGlmIChkaXJlY3RpdmVOYW1lLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkaXJlY3RpdmUgbmFtZSBtdXN0IG5vdCBiZSBsZXNzIHRoYW4gb25lIGNoYXJhY3RlciBpbiBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfRU9MKGNoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkgYnJlYWs7XG5cbiAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX1dTX09SX0VPTChjaCkpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVBcmdzLnB1c2goc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChjaCAhPT0gMCkgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG5cbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoZGlyZWN0aXZlSGFuZGxlcnMsIGRpcmVjdGl2ZU5hbWUpKSB7XG4gICAgICBkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmVOYW1lXShzdGF0ZSwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vua25vd24gZG9jdW1lbnQgZGlyZWN0aXZlIFwiJyArIGRpcmVjdGl2ZU5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH1cblxuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPT09IDAgJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pICAgICA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAxKSA9PT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gKyAyKSA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKTtcblxuICB9IGVsc2UgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlcyBlbmQgbWFyayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgY29tcG9zZU5vZGUoc3RhdGUsIHN0YXRlLmxpbmVJbmRlbnQgLSAxLCBDT05URVhUX0JMT0NLX09VVCwgZmFsc2UsIHRydWUpO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgaWYgKHN0YXRlLmNoZWNrTGluZUJyZWFrcyAmJlxuICAgICAgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MudGVzdChzdGF0ZS5pbnB1dC5zbGljZShkb2N1bWVudFN0YXJ0LCBzdGF0ZS5wb3NpdGlvbikpKSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnbm9uLUFTQ0lJIGxpbmUgYnJlYWtzIGFyZSBpbnRlcnByZXRlZCBhcyBjb250ZW50Jyk7XG4gIH1cblxuICBzdGF0ZS5kb2N1bWVudHMucHVzaChzdGF0ZS5yZXN1bHQpO1xuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcblxuICAgIGlmIChzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSA9PT0gMHgyRS8qIC4gKi8pIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDM7XG4gICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdlbmQgb2YgdGhlIHN0cmVhbSBvciBhIGRvY3VtZW50IHNlcGFyYXRvciBpcyBleHBlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5wdXQubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAvLyBBZGQgdGFpbGluZyBgXFxuYCBpZiBub3QgZXhpc3RzXG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT09IDB4MEEvKiBMRiAqLyAmJlxuICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBELyogQ1IgKi8pIHtcbiAgICAgIGlucHV0ICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIEJPTVxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKGlucHV0LCBvcHRpb25zKTtcblxuICB2YXIgbnVsbHBvcyA9IGlucHV0LmluZGV4T2YoJ1xcMCcpO1xuXG4gIGlmIChudWxscG9zICE9PSAtMSkge1xuICAgIHN0YXRlLnBvc2l0aW9uID0gbnVsbHBvcztcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbnVsbCBieXRlIGlzIG5vdCBhbGxvd2VkIGluIGlucHV0Jyk7XG4gIH1cblxuICAvLyBVc2UgMCBhcyBzdHJpbmcgdGVybWluYXRvci4gVGhhdCBzaWduaWZpY2FudGx5IHNpbXBsaWZpZXMgYm91bmRzIGNoZWNrLlxuICBzdGF0ZS5pbnB1dCArPSAnXFwwJztcblxuICB3aGlsZSAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MjAvKiBTcGFjZSAqLykge1xuICAgIHN0YXRlLmxpbmVJbmRlbnQgKz0gMTtcbiAgICBzdGF0ZS5wb3NpdGlvbiArPSAxO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBvc2l0aW9uIDwgKHN0YXRlLmxlbmd0aCAtIDEpKSB7XG4gICAgcmVhZERvY3VtZW50KHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5kb2N1bWVudHM7XG59XG5cblxuZnVuY3Rpb24gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgaWYgKGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGl0ZXJhdG9yO1xuICAgIGl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50cztcbiAgfVxuXG4gIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBpdGVyYXRvcihkb2N1bWVudHNbaW5kZXhdKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGxvYWQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRvY3VtZW50cyA9IGxvYWREb2N1bWVudHMoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIGlmIChkb2N1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQqL1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBkb2N1bWVudHNbMF07XG4gIH1cbiAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0sIGJ1dCBmb3VuZCBtb3JlJyk7XG59XG5cblxuZnVuY3Rpb24gc2FmZUxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIGl0ZXJhdG9yICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gbG9hZEFsbChpbnB1dCwgaXRlcmF0b3IsIGNvbW1vbi5leHRlbmQoeyBzY2hlbWE6IERFRkFVTFRfU0FGRV9TQ0hFTUEgfSwgb3B0aW9ucykpO1xufVxuXG5cbmZ1bmN0aW9uIHNhZmVMb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBsb2FkKGlucHV0LCBjb21tb24uZXh0ZW5kKHsgc2NoZW1hOiBERUZBVUxUX1NBRkVfU0NIRU1BIH0sIG9wdGlvbnMpKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICA9IGxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICA9IGxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCA9IHNhZmVMb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMuc2FmZUxvYWQgICAgPSBzYWZlTG9hZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5mdW5jdGlvbiBNYXJrKG5hbWUsIGJ1ZmZlciwgcG9zaXRpb24sIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm5hbWUgICAgID0gbmFtZTtcbiAgdGhpcy5idWZmZXIgICA9IGJ1ZmZlcjtcbiAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcbn1cblxuXG5NYXJrLnByb3RvdHlwZS5nZXRTbmlwcGV0ID0gZnVuY3Rpb24gZ2V0U25pcHBldChpbmRlbnQsIG1heExlbmd0aCkge1xuICB2YXIgaGVhZCwgc3RhcnQsIHRhaWwsIGVuZCwgc25pcHBldDtcblxuICBpZiAoIXRoaXMuYnVmZmVyKSByZXR1cm4gbnVsbDtcblxuICBpbmRlbnQgPSBpbmRlbnQgfHwgNDtcbiAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDc1O1xuXG4gIGhlYWQgPSAnJztcbiAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChzdGFydCA+IDAgJiYgJ1xceDAwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScuaW5kZXhPZih0aGlzLmJ1ZmZlci5jaGFyQXQoc3RhcnQgLSAxKSkgPT09IC0xKSB7XG4gICAgc3RhcnQgLT0gMTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiAtIHN0YXJ0ID4gKG1heExlbmd0aCAvIDIgLSAxKSkge1xuICAgICAgaGVhZCA9ICcgLi4uICc7XG4gICAgICBzdGFydCArPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdGFpbCA9ICcnO1xuICBlbmQgPSB0aGlzLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChlbmQgPCB0aGlzLmJ1ZmZlci5sZW5ndGggJiYgJ1xceDAwXFxyXFxuXFx4ODVcXHUyMDI4XFx1MjAyOScuaW5kZXhPZih0aGlzLmJ1ZmZlci5jaGFyQXQoZW5kKSkgPT09IC0xKSB7XG4gICAgZW5kICs9IDE7XG4gICAgaWYgKGVuZCAtIHRoaXMucG9zaXRpb24gPiAobWF4TGVuZ3RoIC8gMiAtIDEpKSB7XG4gICAgICB0YWlsID0gJyAuLi4gJztcbiAgICAgIGVuZCAtPSA1O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc25pcHBldCA9IHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgaW5kZW50KSArIGhlYWQgKyBzbmlwcGV0ICsgdGFpbCArICdcXG4nICtcbiAgICAgICAgIGNvbW1vbi5yZXBlYXQoJyAnLCBpbmRlbnQgKyB0aGlzLnBvc2l0aW9uIC0gc3RhcnQgKyBoZWFkLmxlbmd0aCkgKyAnXic7XG59O1xuXG5cbk1hcmsucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoY29tcGFjdCkge1xuICB2YXIgc25pcHBldCwgd2hlcmUgPSAnJztcblxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgd2hlcmUgKz0gJ2luIFwiJyArIHRoaXMubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJ2F0IGxpbmUgJyArICh0aGlzLmxpbmUgKyAxKSArICcsIGNvbHVtbiAnICsgKHRoaXMuY29sdW1uICsgMSk7XG5cbiAgaWYgKCFjb21wYWN0KSB7XG4gICAgc25pcHBldCA9IHRoaXMuZ2V0U25pcHBldCgpO1xuXG4gICAgaWYgKHNuaXBwZXQpIHtcbiAgICAgIHdoZXJlICs9ICc6XFxuJyArIHNuaXBwZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcms7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cbnZhciBjb21tb24gICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBUeXBlICAgICAgICAgID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lLCByZXN1bHQpIHtcbiAgdmFyIGV4Y2x1ZGUgPSBbXTtcblxuICBzY2hlbWEuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uIChpbmNsdWRlZFNjaGVtYSkge1xuICAgIHJlc3VsdCA9IGNvbXBpbGVMaXN0KGluY2x1ZGVkU2NoZW1hLCBuYW1lLCByZXN1bHQpO1xuICB9KTtcblxuICBzY2hlbWFbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFR5cGUpIHtcbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocHJldmlvdXNUeXBlLCBwcmV2aW91c0luZGV4KSB7XG4gICAgICBpZiAocHJldmlvdXNUeXBlLnRhZyA9PT0gY3VycmVudFR5cGUudGFnICYmIHByZXZpb3VzVHlwZS5raW5kID09PSBjdXJyZW50VHlwZS5raW5kKSB7XG4gICAgICAgIGV4Y2x1ZGUucHVzaChwcmV2aW91c0luZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRUeXBlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGUuaW5kZXhPZihpbmRleCkgPT09IC0xO1xuICB9KTtcbn1cblxuXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHNjYWxhcjoge30sXG4gICAgICAgIHNlcXVlbmNlOiB7fSxcbiAgICAgICAgbWFwcGluZzoge30sXG4gICAgICAgIGZhbGxiYWNrOiB7fVxuICAgICAgfSwgaW5kZXgsIGxlbmd0aDtcblxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XG4gICAgcmVzdWx0W3R5cGUua2luZF1bdHlwZS50YWddID0gcmVzdWx0WydmYWxsYmFjayddW3R5cGUudGFnXSA9IHR5cGU7XG4gIH1cblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBhcmd1bWVudHNbaW5kZXhdLmZvckVhY2goY29sbGVjdFR5cGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gU2NoZW1hKGRlZmluaXRpb24pIHtcbiAgdGhpcy5pbmNsdWRlICA9IGRlZmluaXRpb24uaW5jbHVkZSAgfHwgW107XG4gIHRoaXMuaW1wbGljaXQgPSBkZWZpbml0aW9uLmltcGxpY2l0IHx8IFtdO1xuICB0aGlzLmV4cGxpY2l0ID0gZGVmaW5pdGlvbi5leHBsaWNpdCB8fCBbXTtcblxuICB0aGlzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiB0eXBlLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5jb21waWxlZEltcGxpY2l0ID0gY29tcGlsZUxpc3QodGhpcywgJ2ltcGxpY2l0JywgW10pO1xuICB0aGlzLmNvbXBpbGVkRXhwbGljaXQgPSBjb21waWxlTGlzdCh0aGlzLCAnZXhwbGljaXQnLCBbXSk7XG4gIHRoaXMuY29tcGlsZWRUeXBlTWFwICA9IGNvbXBpbGVNYXAodGhpcy5jb21waWxlZEltcGxpY2l0LCB0aGlzLmNvbXBpbGVkRXhwbGljaXQpO1xufVxuXG5cblNjaGVtYS5ERUZBVUxUID0gbnVsbDtcblxuXG5TY2hlbWEuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlU2NoZW1hKCkge1xuICB2YXIgc2NoZW1hcywgdHlwZXM7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgc2NoZW1hcyA9IFNjaGVtYS5ERUZBVUxUO1xuICAgICAgdHlwZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHNjaGVtYXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB0eXBlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBTY2hlbWEuY3JlYXRlIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBzY2hlbWFzID0gY29tbW9uLnRvQXJyYXkoc2NoZW1hcyk7XG4gIHR5cGVzID0gY29tbW9uLnRvQXJyYXkodHlwZXMpO1xuXG4gIGlmICghc2NoZW1hcy5ldmVyeShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWE7IH0pKSB7XG4gICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIHN1cGVyIHNjaGVtYXMgKG9yIGEgc2luZ2xlIFNjaGVtYSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVNjaGVtYSBvYmplY3QuJyk7XG4gIH1cblxuICBpZiAoIXR5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlIGluc3RhbmNlb2YgVHlwZTsgfSkpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU3BlY2lmaWVkIGxpc3Qgb2YgWUFNTCB0eXBlcyAob3IgYSBzaW5nbGUgVHlwZSBvYmplY3QpIGNvbnRhaW5zIGEgbm9uLVR5cGUgb2JqZWN0LicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIGluY2x1ZGU6IHNjaGVtYXMsXG4gICAgZXhwbGljaXQ6IHR5cGVzXG4gIH0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwNDkyM1xuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIENvcmUgc2NoZW1hIGhhcyBubyBkaXN0aW5jdGlvbnMgZnJvbSBKU09OIHNjaGVtYSBpcyBKUy1ZQU1MLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vanNvbicpXG4gIF1cbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgbG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gSlMtWUFNTCdzIGRlZmF1bHQgc2FmZSBzY2hlbWEgYW5kIGluY2x1ZGVzXG4vLyBKYXZhU2NyaXB0LXNwZWNpZmljIHR5cGVzOiAhIWpzL3VuZGVmaW5lZCwgISFqcy9yZWdleHAgYW5kICEhanMvZnVuY3Rpb24uXG4vL1xuLy8gQWxzbyB0aGlzIHNjaGVtYSBpcyB1c2VkIGFzIGRlZmF1bHQgYmFzZSBzY2hlbWEgYXQgYFNjaGVtYS5jcmVhdGVgIGZ1bmN0aW9uLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWEuREVGQVVMVCA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9kZWZhdWx0X3NhZmUnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvanMvdW5kZWZpbmVkJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9qcy9yZWdleHAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2pzL2Z1bmN0aW9uJylcbiAgXVxufSk7XG4iLCIvLyBKUy1ZQU1MJ3MgZGVmYXVsdCBzY2hlbWEgZm9yIGBzYWZlTG9hZGAgZnVuY3Rpb24uXG4vLyBJdCBpcyBub3QgZGVzY3JpYmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vL1xuLy8gVGhpcyBzY2hlbWEgaXMgYmFzZWQgb24gc3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hIGFuZCBpbmNsdWRlcyBtb3N0IG9mXG4vLyBleHRyYSB0eXBlcyBkZXNjcmliZWQgYXQgWUFNTCB0YWcgcmVwb3NpdG9yeS4gKGh0dHA6Ly95YW1sLm9yZy90eXBlLylcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2NvcmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvdGltZXN0YW1wJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tZXJnZScpXG4gIF0sXG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9iaW5hcnknKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL29tYXAnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3BhaXJzJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zZXQnKVxuICBdXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBGYWlsc2FmZSBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDIzNDZcblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGV4cGxpY2l0OiBbXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9zdHInKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL3NlcScpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWFwJylcbiAgXVxufSk7XG4iLCIvLyBTdGFuZGFyZCBZQU1MJ3MgSlNPTiBzY2hlbWEuXG4vLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI4MDMyMzFcbi8vXG4vLyBOT1RFOiBKUy1ZQU1MIGRvZXMgbm90IHN1cHBvcnQgc2NoZW1hLXNwZWNpZmljIHRhZyByZXNvbHV0aW9uIHJlc3RyaWN0aW9ucy5cbi8vIFNvLCB0aGlzIHNjaGVtYSBpcyBub3Qgc3VjaCBzdHJpY3QgYXMgZGVmaW5lZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy8gSXQgYWxsb3dzIG51bWJlcnMgaW4gYmluYXJ5IG5vdGFpb24sIHVzZSBgTnVsbGAgYW5kIGBOVUxMYCBhcyBgbnVsbGAsIGV0Yy5cblxuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNjaGVtYSh7XG4gIGluY2x1ZGU6IFtcbiAgICByZXF1aXJlKCcuL2ZhaWxzYWZlJylcbiAgXSxcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL251bGwnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2Jvb2wnKSxcbiAgICByZXF1aXJlKCcuLi90eXBlL2ludCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvZmxvYXQnKVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxFeGNlcHRpb24gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbicpO1xuXG52YXIgVFlQRV9DT05TVFJVQ1RPUl9PUFRJT05TID0gW1xuICAna2luZCcsXG4gICdyZXNvbHZlJyxcbiAgJ2NvbnN0cnVjdCcsXG4gICdpbnN0YW5jZU9mJyxcbiAgJ3ByZWRpY2F0ZScsXG4gICdyZXByZXNlbnQnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy50YWcgICAgICAgICAgPSB0YWc7XG4gIHRoaXMua2luZCAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXNvbHZlICAgICAgPSBvcHRpb25zWydyZXNvbHZlJ10gICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICA9IG9wdGlvbnNbJ2NvbnN0cnVjdCddICAgIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhOyB9O1xuICB0aGlzLmluc3RhbmNlT2YgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgIHx8IG51bGw7XG4gIHRoaXMucHJlZGljYXRlICAgID0gb3B0aW9uc1sncHJlZGljYXRlJ10gICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgPSBvcHRpb25zWydyZXByZXNlbnQnXSAgICB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSA9IG9wdGlvbnNbJ2RlZmF1bHRTdHlsZSddIHx8IG51bGw7XG4gIHRoaXMuc3R5bGVBbGlhc2VzID0gY29tcGlsZVN0eWxlQWxpYXNlcyhvcHRpb25zWydzdHlsZUFsaWFzZXMnXSB8fCBudWxsKTtcblxuICBpZiAoWUFNTF9OT0RFX0tJTkRTLmluZGV4T2YodGhpcy5raW5kKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVW5rbm93biBraW5kIFwiJyArIHRoaXMua2luZCArICdcIiBpcyBzcGVjaWZpZWQgZm9yIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG52YXIgTm9kZUJ1ZmZlcjtcblxudHJ5IHtcbiAgLy8gQSB0cmljayBmb3IgYnJvd3NlcmlmaWVkIHZlcnNpb24sIHRvIG5vdCBpbmNsdWRlIGBCdWZmZXJgIHNoaW1cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZTtcbiAgTm9kZUJ1ZmZlciA9IF9yZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG59IGNhdGNoIChfXykge31cblxudmFyIFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIC8vIFdyYXAgaW50byBCdWZmZXIgZm9yIE5vZGVKUyBhbmQgbGVhdmUgQXJyYXkgZm9yIGJyb3dzZXJcbiAgaWYgKE5vZGVCdWZmZXIpIHtcbiAgICAvLyBTdXBwb3J0IG5vZGUgNi4rIEJ1ZmZlciBBUEkgd2hlbiBhdmFpbGFibGVcbiAgICByZXR1cm4gTm9kZUJ1ZmZlci5mcm9tID8gTm9kZUJ1ZmZlci5mcm9tKHJlc3VsdCkgOiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEJvb2xlYW4oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ3RydWUnIHx8IGRhdGEgPT09ICdUcnVlJyB8fCBkYXRhID09PSAnVFJVRScpKSB8fFxuICAgICAgICAgKG1heCA9PT0gNSAmJiAoZGF0YSA9PT0gJ2ZhbHNlJyB8fCBkYXRhID09PSAnRmFsc2UnIHx8IGRhdGEgPT09ICdGQUxTRScpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEJvb2xlYW4oZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJ3RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUUlVFJztcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQm9vbGVhbixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sQm9vbGVhbixcbiAgcHJlZGljYXRlOiBpc0Jvb2xlYW4sXG4gIHJlcHJlc2VudDoge1xuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ3RydWUnIDogJ2ZhbHNlJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUUlVFJyA6ICdGQUxTRSc7IH0sXG4gICAgY2FtZWxjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVHJ1ZScgOiAnRmFsc2UnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OjB8WzEtOV1bMC05X10qKSg/OlxcXFwuWzAtOV9dKik/KD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gLjJlNCwgLjJcbiAgLy8gc3BlY2lhbCBjYXNlLCBzZWVtcyBub3QgZnJvbSBzcGVjXG4gICd8XFxcXC5bMC05X10rKD86W2VFXVstK10/WzAtOV0rKT8nICtcbiAgLy8gMjA6NTlcbiAgJ3xbLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFxcXC5bMC05X10qJyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduLCBiYXNlLCBkaWdpdHM7XG5cbiAgdmFsdWUgID0gZGF0YS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICBzaWduICAgPSB2YWx1ZVswXSA9PT0gJy0nID8gLTEgOiAxO1xuICBkaWdpdHMgPSBbXTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignOicpID49IDApIHtcbiAgICB2YWx1ZS5zcGxpdCgnOicpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIGRpZ2l0cy51bnNoaWZ0KHBhcnNlRmxvYXQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMC4wO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IGQgKiBiYXNlO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcbn1cblxuXG52YXIgU0NJRU5USUZJQ19XSVRIT1VUX0RPVCA9IC9eWy0rXT9bMC05XStlLztcblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgdmFyIHJlcztcblxuICBpZiAoaXNOYU4ob2JqZWN0KSkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLm5hbic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5OQU4nO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuTmFOJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy5pbmYnO1xuICAgICAgY2FzZSAndXBwZXJjYXNlJzogcmV0dXJuICcuSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICctLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy0uSU5GJztcbiAgICAgIGNhc2UgJ2NhbWVsY2FzZSc6IHJldHVybiAnLS5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSkge1xuICAgIHJldHVybiAnLTAuMCc7XG4gIH1cblxuICByZXMgPSBvYmplY3QudG9TdHJpbmcoMTApO1xuXG4gIC8vIEpTIHN0cmluZ2lmaWVyIGNhbiBidWlsZCBzY2llbnRpZmljIGZvcm1hdCB3aXRob3V0IGRvdHM6IDVlLTEwMCxcbiAgLy8gd2hpbGUgWUFNTCByZXF1cmVzIGRvdDogNS5lLTEwMC4gRml4IGl0IHdpdGggc2ltcGxlIGhhY2tcblxuICByZXR1cm4gU0NJRU5USUZJQ19XSVRIT1VUX0RPVC50ZXN0KHJlcykgPyByZXMucmVwbGFjZSgnZScsICcuZScpIDogcmVzO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBOdW1iZXJdJykgJiZcbiAgICAgICAgIChvYmplY3QgJSAxICE9PSAwIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNPY3RDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzICYmIGNoICE9PSAnXyc7XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMCkgb3IgYmFzZSA2MFxuXG4gIC8vIHZhbHVlIHNob3VsZCBub3Qgc3RhcnQgd2l0aCBgX2A7XG4gIGlmIChjaCA9PT0gJ18nKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKGNoID09PSAnOicpIGJyZWFrO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICAvLyBpZiAhYmFzZTYwIC0gZG9uZTtcbiAgaWYgKGNoICE9PSAnOicpIHJldHVybiB0cnVlO1xuXG4gIC8vIGJhc2U2MCBhbG1vc3Qgbm90IHVzZWQsIG5vIG5lZWRzIHRvIG9wdGltaXplXG4gIHJldHVybiAvXig6WzAtNV0/WzAtOV0pKyQvLnRlc3QoZGF0YS5zbGljZShpbmRleCkpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sSW50ZWdlcihkYXRhKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGEsIHNpZ24gPSAxLCBjaCwgYmFzZSwgZGlnaXRzID0gW107XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdChwYXJzZUludCh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwO1xuICAgIGJhc2UgPSAxO1xuXG4gICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhbHVlICs9IChkICogYmFzZSk7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgPT09IDAgJiYgIWNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6aW50Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxJbnRlZ2VyLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxJbnRlZ2VyLFxuICBwcmVkaWNhdGU6IGlzSW50ZWdlcixcbiAgcmVwcmVzZW50OiB7XG4gICAgYmluYXJ5OiAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBiJyArIG9iai50b1N0cmluZygyKSA6ICctMGInICsgb2JqLnRvU3RyaW5nKDIpLnNsaWNlKDEpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcwJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTAnICArIG9iai50b1N0cmluZyg4KS5zbGljZSgxKTsgfSxcbiAgICBkZWNpbWFsOiAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqLnRvU3RyaW5nKDEwKTsgfSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgaGV4YWRlY2ltYWw6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSA6ICAnLTB4JyArIG9iai50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5zbGljZSgxKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlc3ByaW1hO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xudHJ5IHtcbiAgLy8gd29ya2Fyb3VuZCB0byBleGNsdWRlIHBhY2thZ2UgZnJvbSBicm93c2VyaWZ5IGxpc3QuXG4gIHZhciBfcmVxdWlyZSA9IHJlcXVpcmU7XG4gIGVzcHJpbWEgPSBfcmVxdWlyZSgnZXNwcmltYScpO1xufSBjYXRjaCAoXykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZWRlY2xhcmUgKi9cbiAgLyogZ2xvYmFsIHdpbmRvdyAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGVzcHJpbWEgPSB3aW5kb3cuZXNwcmltYTtcbn1cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9ICcoJyArIGRhdGEgKyAnKScsXG4gICAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pO1xuXG4gICAgaWYgKGFzdC50eXBlICAgICAgICAgICAgICAgICAgICAhPT0gJ1Byb2dyYW0nICAgICAgICAgICAgIHx8XG4gICAgICAgIGFzdC5ib2R5Lmxlbmd0aCAgICAgICAgICAgICAhPT0gMSAgICAgICAgICAgICAgICAgICAgIHx8XG4gICAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICAgIChhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicgJiZcbiAgICAgICAgICBhc3QuYm9keVswXS5leHByZXNzaW9uLnR5cGUgIT09ICdGdW5jdGlvbkV4cHJlc3Npb24nKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uKGRhdGEpIHtcbiAgLypqc2xpbnQgZXZpbDp0cnVlKi9cblxuICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgIGFzdCAgICA9IGVzcHJpbWEucGFyc2Uoc291cmNlLCB7IHJhbmdlOiB0cnVlIH0pLFxuICAgICAgcGFyYW1zID0gW10sXG4gICAgICBib2R5O1xuXG4gIGlmIChhc3QudHlwZSAgICAgICAgICAgICAgICAgICAgIT09ICdQcm9ncmFtJyAgICAgICAgICAgICB8fFxuICAgICAgYXN0LmJvZHkubGVuZ3RoICAgICAgICAgICAgICE9PSAxICAgICAgICAgICAgICAgICAgICAgfHxcbiAgICAgIGFzdC5ib2R5WzBdLnR5cGUgICAgICAgICAgICAhPT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnIHx8XG4gICAgICAoYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi50eXBlICE9PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nICYmXG4gICAgICAgIGFzdC5ib2R5WzBdLmV4cHJlc3Npb24udHlwZSAhPT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF0uZXhwcmVzc2lvbi5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgaWYgKGFzdC5ib2R5WzBdLmV4cHJlc3Npb24uYm9keS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihwYXJhbXMsIHNvdXJjZS5zbGljZShib2R5WzBdICsgMSwgYm9keVsxXSAtIDEpKTtcbiAgfVxuICAvLyBFUzYgYXJyb3cgZnVuY3Rpb25zIGNhbiBvbWl0IHRoZSBCbG9ja1N0YXRlbWVudC4gSW4gdGhhdCBjYXNlLCBqdXN0IHJldHVyblxuICAvLyB0aGUgYm9keS5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgRnVuY3Rpb24ocGFyYW1zLCAncmV0dXJuICcgKyBzb3VyY2Uuc2xpY2UoYm9keVswXSwgYm9keVsxXSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHJlZ2V4cCA9IGRhdGEsXG4gICAgICB0YWlsICAgPSAvXFwvKFtnaW1dKikkLy5leGVjKGRhdGEpLFxuICAgICAgbW9kaWZpZXJzID0gJyc7XG5cbiAgLy8gaWYgcmVnZXhwIHN0YXJ0cyB3aXRoICcvJyBpdCBjYW4gaGF2ZSBtb2RpZmllcnMgYW5kIG11c3QgYmUgcHJvcGVybHkgY2xvc2VkXG4gIC8vIGAvZm9vL2dpbWAgLSBtb2RpZmllcnMgdGFpbCBjYW4gYmUgbWF4aW11bSAzIGNoYXJzXG4gIGlmIChyZWdleHBbMF0gPT09ICcvJykge1xuICAgIGlmICh0YWlsKSBtb2RpZmllcnMgPSB0YWlsWzFdO1xuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gaWYgZXhwcmVzc2lvbiBzdGFydHMgd2l0aCAvLCBpcyBzaG91bGQgYmUgcHJvcGVybHkgdGVybWluYXRlZFxuICAgIGlmIChyZWdleHBbcmVnZXhwLmxlbmd0aCAtIG1vZGlmaWVycy5sZW5ndGggLSAxXSAhPT0gJy8nKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKHJlZ2V4cFswXSA9PT0gJy8nKSB7XG4gICAgaWYgKHRhaWwpIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgcmVnZXhwID0gcmVnZXhwLnNsaWNlKDEsIHJlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG1vZGlmaWVycyk7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHAob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHZhciByZXN1bHQgPSAnLycgKyBvYmplY3Quc291cmNlICsgJy8nO1xuXG4gIGlmIChvYmplY3QuZ2xvYmFsKSByZXN1bHQgKz0gJ2cnO1xuICBpZiAob2JqZWN0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKG9iamVjdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9yZWdleHAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RKYXZhc2NyaXB0UmVnRXhwLFxuICBwcmVkaWNhdGU6IGlzUmVnRXhwLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudEphdmFzY3JpcHRSZWdFeHBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgcHJlZGljYXRlOiBpc1VuZGVmaW5lZCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IHt9OyB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTWVyZ2UoZGF0YSkge1xuICByZXR1cm4gZGF0YSA9PT0gJzw8JyB8fCBkYXRhID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTWVyZ2Vcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxOdWxsKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aDtcblxuICByZXR1cm4gKG1heCA9PT0gMSAmJiBkYXRhID09PSAnficpIHx8XG4gICAgICAgICAobWF4ID09PSA0ICYmIChkYXRhID09PSAnbnVsbCcgfHwgZGF0YSA9PT0gJ051bGwnIHx8IGRhdGEgPT09ICdOVUxMJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PT0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sTnVsbCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sTnVsbCxcbiAgcHJlZGljYXRlOiBpc051bGwsXG4gIHJlcHJlc2VudDoge1xuICAgIGNhbm9uaWNhbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ34nOyAgICB9LFxuICAgIGxvd2VyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ251bGwnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ05VTEwnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ051bGwnOyB9XG4gIH0sXG4gIGRlZmF1bHRTdHlsZTogJ2xvd2VyY2FzZSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX3RvU3RyaW5nICAgICAgID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxPbWFwKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBvYmplY3RLZXlzID0gW10sIGluZGV4LCBsZW5ndGgsIHBhaXIsIHBhaXJLZXksIHBhaXJIYXNLZXksXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuICAgIHBhaXJIYXNLZXkgPSBmYWxzZTtcblxuICAgIGlmIChfdG9TdHJpbmcuY2FsbChwYWlyKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSBwYWlySGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAob2JqZWN0S2V5cy5pbmRleE9mKHBhaXJLZXkpID09PSAtMSkgb2JqZWN0S2V5cy5wdXNoKHBhaXJLZXkpO1xuICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxPbWFwKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sT21hcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sT21hcFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIFtdO1xuXG4gIHZhciBpbmRleCwgbGVuZ3RoLCBwYWlyLCBrZXlzLCByZXN1bHQsXG4gICAgICBvYmplY3QgPSBkYXRhO1xuXG4gIHJlc3VsdCA9IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwYWlyKTtcblxuICAgIHJlc3VsdFtpbmRleF0gPSBbIGtleXNbMF0sIHBhaXJba2V5c1swXV0gXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFBhaXJzLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxQYWlyc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0pJCcpOyAgICAgICAgICAgICAgICAgICAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7ICAgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuIiwidmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdib29sZWFuJykgcmV0dXJuICdib29sZWFuJztcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3N0cmluZyc7XG4gIGlmICh0eXBlID09PSAnbnVtYmVyJykgcmV0dXJuICdudW1iZXInO1xuICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHJldHVybiAnc3ltYm9sJztcbiAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXNHZW5lcmF0b3JGbih2YWwpID8gJ2dlbmVyYXRvcmZ1bmN0aW9uJyA6ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoaXNBcnJheSh2YWwpKSByZXR1cm4gJ2FycmF5JztcbiAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcbiAgaWYgKGlzQXJndW1lbnRzKHZhbCkpIHJldHVybiAnYXJndW1lbnRzJztcbiAgaWYgKGlzRGF0ZSh2YWwpKSByZXR1cm4gJ2RhdGUnO1xuICBpZiAoaXNFcnJvcih2YWwpKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKGlzUmVnZXhwKHZhbCkpIHJldHVybiAncmVnZXhwJztcblxuICBzd2l0Y2ggKGN0b3JOYW1lKHZhbCkpIHtcbiAgICBjYXNlICdTeW1ib2wnOiByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSAnUHJvbWlzZSc6IHJldHVybiAncHJvbWlzZSc7XG5cbiAgICAvLyBTZXQsIE1hcCwgV2Vha1NldCwgV2Vha01hcFxuICAgIGNhc2UgJ1dlYWtNYXAnOiByZXR1cm4gJ3dlYWttYXAnO1xuICAgIGNhc2UgJ1dlYWtTZXQnOiByZXR1cm4gJ3dlYWtzZXQnO1xuICAgIGNhc2UgJ01hcCc6IHJldHVybiAnbWFwJztcbiAgICBjYXNlICdTZXQnOiByZXR1cm4gJ3NldCc7XG5cbiAgICAvLyA4LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQ4QXJyYXknOiByZXR1cm4gJ2ludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhBcnJheSc6IHJldHVybiAndWludDhhcnJheSc7XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOiByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcblxuICAgIC8vIDE2LWJpdCB0eXBlZCBhcnJheXNcbiAgICBjYXNlICdJbnQxNkFycmF5JzogcmV0dXJuICdpbnQxNmFycmF5JztcbiAgICBjYXNlICdVaW50MTZBcnJheSc6IHJldHVybiAndWludDE2YXJyYXknO1xuXG4gICAgLy8gMzItYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDMyQXJyYXknOiByZXR1cm4gJ2ludDMyYXJyYXknO1xuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzogcmV0dXJuICd1aW50MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzogcmV0dXJuICdmbG9hdDMyYXJyYXknO1xuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6IHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgfVxuXG4gIGlmIChpc0dlbmVyYXRvck9iaih2YWwpKSB7XG4gICAgcmV0dXJuICdnZW5lcmF0b3InO1xuICB9XG5cbiAgLy8gTm9uLXBsYWluIG9iamVjdHNcbiAgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzogcmV0dXJuICdvYmplY3QnO1xuICAgIC8vIGl0ZXJhdG9yc1xuICAgIGNhc2UgJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc6IHJldHVybiAnbWFwaXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc6IHJldHVybiAnc2V0aXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nIEl0ZXJhdG9yXSc6IHJldHVybiAnc3RyaW5naXRlcmF0b3InO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXkgSXRlcmF0b3JdJzogcmV0dXJuICdhcnJheWl0ZXJhdG9yJztcbiAgfVxuXG4gIC8vIG90aGVyXG4gIHJldHVybiB0eXBlLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCAodHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInKTtcbn1cblxuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNSZWdleHAodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC5mbGFncyA9PT0gJ3N0cmluZydcbiAgICAmJiB0eXBlb2YgdmFsLmlnbm9yZUNhc2UgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwubXVsdGlsaW5lID09PSAnYm9vbGVhbidcbiAgICAmJiB0eXBlb2YgdmFsLmdsb2JhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvckZuKG5hbWUsIHZhbCkge1xuICByZXR1cm4gY3Rvck5hbWUobmFtZSkgPT09ICdHZW5lcmF0b3JGdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC50aHJvdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiB2YWwucmV0dXJuID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5uZXh0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWwpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHZhbC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB2YWwuY2FsbGVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdjYWxsZWUnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBTYWZhcmkgNS03ICg4LTEwIHlyLW9sZCBicm93c2VyKSxcbiAqIHRha2UgYSBsb29rIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaXMtYnVmZmVyXG4gKi9cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyMSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLm1hcmtlZCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRzJDUgPSB7ZXhwb3J0czoge319O1xuXG4gIGZ1bmN0aW9uIGdldERlZmF1bHRzJDEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2VVcmw6IG51bGwsXG4gICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgaGVhZGVySWRzOiB0cnVlLFxuICAgICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICAgIGxhbmdQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgbWFuZ2xlOiB0cnVlLFxuICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgICBzYW5pdGl6ZXI6IG51bGwsXG4gICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgc21hcnRMaXN0czogZmFsc2UsXG4gICAgICBzbWFydHlwYW50czogZmFsc2UsXG4gICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgICAgeGh0bWw6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzJDEobmV3RGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbiAgfVxuXG4gIGRlZmF1bHRzJDUuZXhwb3J0cyA9IHtcbiAgICBkZWZhdWx0czogZ2V0RGVmYXVsdHMkMSgpLFxuICAgIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyQxLFxuICAgIGNoYW5nZURlZmF1bHRzOiBjaGFuZ2VEZWZhdWx0cyQxXG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG4gIHZhciBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbiAgdmFyIGVzY2FwZVJlcGxhY2UgPSAvWyY8PlwiJ10vZztcbiAgdmFyIGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS87XG4gIHZhciBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvZztcbiAgdmFyIGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICB2YXIgZ2V0RXNjYXBlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBnZXRFc2NhcGVSZXBsYWNlbWVudChjaCkge1xuICAgIHJldHVybiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZSQyKGh0bWwsIGVuY29kZSkge1xuICAgIGlmIChlbmNvZGUpIHtcbiAgICAgIGlmIChlc2NhcGVUZXN0LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgdmFyIHVuZXNjYXBlVGVzdCA9IC8mKCMoPzpcXGQrKXwoPzojeFswLTlBLUZhLWZdKyl8KD86XFx3KykpOz8vaWc7XG5cbiAgZnVuY3Rpb24gdW5lc2NhcGUkMShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIGZ1bmN0aW9uIChfLCBuKSB7XG4gICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG5cbiAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuICBmdW5jdGlvbiBlZGl0JDEocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gcmVnZXguc291cmNlIHx8IHJlZ2V4O1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKGNhcmV0LCAnJDEnKTtcbiAgICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LFxuICAgICAgZ2V0UmVnZXg6IGZ1bmN0aW9uIGdldFJlZ2V4KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG4gIHZhciBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5cbiAgZnVuY3Rpb24gY2xlYW5VcmwkMShzYW5pdGl6ZSwgYmFzZSwgaHJlZikge1xuICAgIGlmIChzYW5pdGl6ZSkge1xuICAgICAgdmFyIHByb3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3QgPSBkZWNvZGVVUklDb21wb25lbnQodW5lc2NhcGUkMShocmVmKSkucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgdmFyIGJhc2VVcmxzID0ge307XG4gIHZhciBqdXN0RG9tYWluID0gL15bXjpdKzpcXC8qW14vXSokLztcbiAgdmFyIHByb3RvY29sID0gL14oW146XSs6KVtcXHNcXFNdKiQvO1xuICB2YXIgZG9tYWluID0gL14oW146XSs6XFwvKlteL10qKVtcXHNcXFNdKiQvO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICAgIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IHJ0cmltJDEoYmFzZSwgJy8nLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXNlID0gYmFzZVVybHNbJyAnICsgYmFzZV07XG4gICAgdmFyIHJlbGF0aXZlQmFzZSA9IGJhc2UuaW5kZXhPZignOicpID09PSAtMTtcblxuICAgIGlmIChocmVmLnN1YnN0cmluZygwLCAyKSA9PT0gJy8vJykge1xuICAgICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZShwcm90b2NvbCwgJyQxJykgKyBocmVmO1xuICAgIH0gZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZShkb21haW4sICckMScpICsgaHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub29wVGVzdCQxID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIG5vb3BUZXN0KCkge31cbiAgfTtcblxuICBmdW5jdGlvbiBtZXJnZSQyKG9iaikge1xuICAgIHZhciBpID0gMSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXk7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Q2VsbHMkMSh0YWJsZVJvdywgY291bnQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAgIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICAgIHZhciByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cikge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSxcbiAgICAgICAgICBjdXJyID0gb2Zmc2V0O1xuXG4gICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpIHtcbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgIHJldHVybiAnfCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgfVxuICAgIH0pLFxuICAgICAgICBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbHM7XG4gIH0gLy8gUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAgLy8gL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAgLy8gaW52ZXJ0OiBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuXG5cbiAgZnVuY3Rpb24gcnRyaW0kMShzdHIsIGMsIGludmVydCkge1xuICAgIHZhciBsID0gc3RyLmxlbmd0aDtcblxuICAgIGlmIChsID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuXG5cbiAgICB2YXIgc3VmZkxlbiA9IDA7IC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuXG4gICAgd2hpbGUgKHN1ZmZMZW4gPCBsKSB7XG4gICAgICB2YXIgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG5cbiAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiAhaW52ZXJ0KSB7XG4gICAgICAgIHN1ZmZMZW4rKztcbiAgICAgIH0gZWxzZSBpZiAoY3VyckNoYXIgIT09IGMgJiYgaW52ZXJ0KSB7XG4gICAgICAgIHN1ZmZMZW4rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIGwgLSBzdWZmTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldCQxKHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGxldmVsID0gMCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICBsZXZlbC0tO1xuXG4gICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxKG9wdCkge1xuICAgIGlmIChvcHQgJiYgb3B0LnNhbml0aXplICYmICFvcHQuc2lsZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBzYW5pdGl6ZSBhbmQgc2FuaXRpemVyIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjcuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy8jL1VTSU5HX0FEVkFOQ0VELm1kI29wdGlvbnMnKTtcbiAgICB9XG4gIH0gLy8gY29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU0NTAxMTMvODA2Nzc3XG5cblxuICBmdW5jdGlvbiByZXBlYXRTdHJpbmckMShwYXR0ZXJuLCBjb3VudCkge1xuICAgIGlmIChjb3VudCA8IDEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICB3aGlsZSAoY291bnQgPiAxKSB7XG4gICAgICBpZiAoY291bnQgJiAxKSB7XG4gICAgICAgIHJlc3VsdCArPSBwYXR0ZXJuO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA+Pj0gMTtcbiAgICAgIHBhdHRlcm4gKz0gcGF0dGVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBoZWxwZXJzID0ge1xuICAgIGVzY2FwZTogZXNjYXBlJDIsXG4gICAgdW5lc2NhcGU6IHVuZXNjYXBlJDEsXG4gICAgZWRpdDogZWRpdCQxLFxuICAgIGNsZWFuVXJsOiBjbGVhblVybCQxLFxuICAgIHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG4gICAgbm9vcFRlc3Q6IG5vb3BUZXN0JDEsXG4gICAgbWVyZ2U6IG1lcmdlJDIsXG4gICAgc3BsaXRDZWxsczogc3BsaXRDZWxscyQxLFxuICAgIHJ0cmltOiBydHJpbSQxLFxuICAgIGZpbmRDbG9zaW5nQnJhY2tldDogZmluZENsb3NpbmdCcmFja2V0JDEsXG4gICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uOiBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMSxcbiAgICByZXBlYXRTdHJpbmc6IHJlcGVhdFN0cmluZyQxXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDQgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIHZhciBydHJpbSA9IGhlbHBlcnMucnRyaW0sXG4gICAgICBzcGxpdENlbGxzID0gaGVscGVycy5zcGxpdENlbGxzLFxuICAgICAgX2VzY2FwZSA9IGhlbHBlcnMuZXNjYXBlLFxuICAgICAgZmluZENsb3NpbmdCcmFja2V0ID0gaGVscGVycy5maW5kQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdykge1xuICAgIHZhciBocmVmID0gbGluay5ocmVmO1xuICAgIHZhciB0aXRsZSA9IGxpbmsudGl0bGUgPyBfZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICB2YXIgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5jb2RlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBydHJpbSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS50cmltKCk7IC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuXG4gICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB2YXIgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgIC8vIENvbW1vbk1hcmsgcmVxdWlyZXMgc3BhY2UgYmVmb3JlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubnB0YWJsZSA9IGZ1bmN0aW9uIG5wdGFibGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5ucHRhYmxlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyhjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKSksXG4gICAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgIGNlbGxzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXSxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGwgPSBpdGVtLmNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBzcGxpdENlbGxzKGl0ZW0uY2VsbHNbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciBidWxsID0gY2FwWzJdO1xuICAgICAgICB2YXIgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICB2YXIgbGlzdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07IC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuXG4gICAgICAgIHZhciBpdGVtTWF0Y2ggPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5ibG9jay5pdGVtKTtcbiAgICAgICAgdmFyIG5leHQgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgIGJjdXJyLFxuICAgICAgICAgICAgYm5leHQsXG4gICAgICAgICAgICBhZGRCYWNrLFxuICAgICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgICBpc3Rhc2ssXG4gICAgICAgICAgICBpc2NoZWNrZWQsXG4gICAgICAgICAgICBlbmRNYXRjaDtcbiAgICAgICAgdmFyIGwgPSBpdGVtTWF0Y2gubGVuZ3RoO1xuICAgICAgICBiY3VyciA9IHRoaXMucnVsZXMuYmxvY2subGlzdEl0ZW1TdGFydC5leGVjKGl0ZW1NYXRjaFswXSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gaXRlbU1hdGNoW2ldO1xuICAgICAgICAgIHJhdyA9IGl0ZW07XG5cbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGN1cnJlbnQgaXRlbSBjb250YWlucyB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgICAgICAgICBlbmRNYXRjaCA9IGl0ZW0ubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXG5cXFxccypcXFxcbiB7MCwnICsgKGJjdXJyWzBdLmxlbmd0aCAtIDEpICsgJ31cXFxcUycpKTtcblxuICAgICAgICAgICAgaWYgKGVuZE1hdGNoKSB7XG4gICAgICAgICAgICAgIGFkZEJhY2sgPSBpdGVtLmxlbmd0aCAtIGVuZE1hdGNoLmluZGV4ICsgaXRlbU1hdGNoLnNsaWNlKGkgKyAxKS5qb2luKCdcXG4nKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcuc3Vic3RyaW5nKDAsIGxpc3QucmF3Lmxlbmd0aCAtIGFkZEJhY2spO1xuICAgICAgICAgICAgICBpdGVtID0gaXRlbS5zdWJzdHJpbmcoMCwgZW5kTWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgICByYXcgPSBpdGVtO1xuICAgICAgICAgICAgICBsID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuXG5cbiAgICAgICAgICBpZiAoaSAhPT0gbCAtIDEpIHtcbiAgICAgICAgICAgIGJuZXh0ID0gdGhpcy5ydWxlcy5ibG9jay5saXN0SXRlbVN0YXJ0LmV4ZWMoaXRlbU1hdGNoW2kgKyAxXSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljID8gYm5leHRbMV0ubGVuZ3RoID49IGJjdXJyWzBdLmxlbmd0aCB8fCBibmV4dFsxXS5sZW5ndGggPiAzIDogYm5leHRbMV0ubGVuZ3RoID4gYmN1cnJbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIG5lc3RlZCBsaXN0IG9yIGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgICBpdGVtTWF0Y2guc3BsaWNlKGksIDIsIGl0ZW1NYXRjaFtpXSArICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIGJuZXh0WzFdLmxlbmd0aCA8IGJjdXJyWzBdLmxlbmd0aCAmJiAhaXRlbU1hdGNoW2ldLm1hdGNoKC9cXG4kLykgPyAnJyA6ICdcXG4nKSArIGl0ZW1NYXRjaFtpICsgMV0pO1xuICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAvLyBkaWZmZXJlbnQgYnVsbGV0IHN0eWxlXG4gICAgICAgICAgICAhdGhpcy5vcHRpb25zLnBlZGFudGljIHx8IHRoaXMub3B0aW9ucy5zbWFydExpc3RzID8gYm5leHRbMl1bYm5leHRbMl0ubGVuZ3RoIC0gMV0gIT09IGJ1bGxbYnVsbC5sZW5ndGggLSAxXSA6IGlzb3JkZXJlZCA9PT0gKGJuZXh0WzJdLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgICAgICAgYWRkQmFjayA9IGl0ZW1NYXRjaC5zbGljZShpICsgMSkuam9pbignXFxuJykubGVuZ3RoO1xuICAgICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnN1YnN0cmluZygwLCBsaXN0LnJhdy5sZW5ndGggLSBhZGRCYWNrKTtcbiAgICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiY3VyciA9IGJuZXh0O1xuICAgICAgICAgIH0gLy8gUmVtb3ZlIHRoZSBsaXN0IGl0ZW0ncyBidWxsZXRcbiAgICAgICAgICAvLyBzbyBpdCBpcyBzZWVuIGFzIHRoZSBuZXh0IHRva2VuLlxuXG5cbiAgICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrWy4pXSkgPy8sICcnKTsgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuXG4gICAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKSA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgIH0gLy8gdHJpbSBpdGVtIG5ld2xpbmVzIGF0IGVuZFxuXG5cbiAgICAgICAgICBpdGVtID0gcnRyaW0oaXRlbSwgJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgICByYXcgPSByYXcgKyAnXFxuJztcbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuXG5cbiAgICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChyYXcpO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgICBuZXh0ID0gcmF3LnNsaWNlKC0yKSA9PT0gJ1xcblxcbic7XG4gICAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIENoZWNrIGZvciB0YXNrIGxpc3QgaXRlbXNcblxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy50ZXN0KGl0ZW0pO1xuICAgICAgICAgICAgaXNjaGVja2VkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGl0ZW1bMV0gIT09ICcgJztcbiAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgICB0YXNrOiBpc3Rhc2ssXG4gICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICBsb29zZTogbG9vc2UsXG4gICAgICAgICAgICB0ZXh0OiBpdGVtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAncGFyYWdyYXBoJyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWYgPSBmdW5jdGlvbiBkZWYoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgY2VsbHM6IGNhcFszXSA/IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtLnJhdyA9IGNhcFswXTtcbiAgICAgICAgICB2YXIgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5jZWxsc1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5jZWxsc1tpXS5yZXBsYWNlKC9eICpcXHwgKnwgKlxcfCAqJC9nLCAnJyksIGl0ZW0uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmxoZWFkaW5nID0gZnVuY3Rpb24gbGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucGFyYWdyYXBoID0gZnVuY3Rpb24gcGFyYWdyYXBoKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJyA/IGNhcFsxXS5zbGljZSgwLCAtMSkgOiBjYXBbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5lc2NhcGUgPSBmdW5jdGlvbiBlc2NhcGUoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZXNjYXBlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IF9lc2NhcGUoY2FwWzFdKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGFnID0gZnVuY3Rpb24gdGFnKHNyYywgaW5MaW5rLCBpblJhd0Jsb2NrKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoIWluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgIGluTGluayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgIGluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgIGluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplID8gJ3RleHQnIDogJ2h0bWwnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGluTGluazogaW5MaW5rLFxuICAgICAgICAgIGluUmF3QmxvY2s6IGluUmF3QmxvY2ssXG4gICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRyaW1tZWRVcmwgPSBjYXBbMl0udHJpbSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIC9ePC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgICBpZiAoIS8+JC8udGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gZW5kaW5nIGFuZ2xlIGJyYWNrZXQgY2Fubm90IGJlIGVzY2FwZWRcblxuXG4gICAgICAgICAgdmFyIHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcblxuICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZpbmQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgIHZhciBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuXG4gICAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNhcFswXS5pbmRleE9mKCchJykgPT09IDAgPyA1IDogNDtcbiAgICAgICAgICAgIHZhciBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICAgIGNhcFswXSA9IGNhcFswXS5zdWJzdHJpbmcoMCwgbGlua0xlbikudHJpbSgpO1xuICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSBjYXBbMl07XG4gICAgICAgIHZhciB0aXRsZSA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgIHZhciBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuXG4gICAgICAgIGlmICgvXjwvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEvPiQvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgICAgfSwgY2FwWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlZmxpbmsgPSBmdW5jdGlvbiByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICAgIHZhciBjYXA7XG5cbiAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgICB2YXIgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtU3Ryb25nID0gZnVuY3Rpb24gZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC8oPzpbMC05QS1aYS16XFx4QUFcXHhCMlxceEIzXFx4QjVcXHhCOVxceEJBXFx4QkMtXFx4QkVcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVEMC1cXHUwNUVBXFx1MDVFRi1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2MC1cXHUwNjY5XFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0MwLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QzdcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUU2LVxcdTA5RjFcXHUwOUY0LVxcdTA5RjlcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTZGXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjY2LVxcdTBCNkZcXHUwQjcxLVxcdTBCNzdcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQkU2LVxcdTBCRjJcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0VcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwNC1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDU4LVxcdTBENjFcXHUwRDY2LVxcdTBENzhcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERFNi1cXHUwREVGXFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjIwLVxcdTBGMzNcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGLVxcdTEwNDlcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTA5MC1cXHUxMDk5XFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNjktXFx1MTM3Q1xcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTdFMC1cXHUxN0U5XFx1MTdGMC1cXHUxN0Y5XFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBODAtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjgzLVxcdTFCQTBcXHUxQkFFLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MFxcdTIwNzFcXHUyMDc0LVxcdTIwNzlcXHUyMDdGLVxcdTIwODlcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE1MC1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyQ0ZEXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRlxcdTMxMzEtXFx1MzE4RVxcdTMxOTItXFx1MzE5NVxcdTMxQTAtXFx1MzFCRlxcdTMxRjAtXFx1MzFGRlxcdTMyMjAtXFx1MzIyOVxcdTMyNDgtXFx1MzI0RlxcdTMyNTEtXFx1MzI1RlxcdTMyODAtXFx1MzI4OVxcdTMyQjEtXFx1MzJCRlxcdTM0MDAtXFx1NERCRlxcdTRFMDAtXFx1OUZGQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdCRlxcdUE3QzItXFx1QTdDQVxcdUE3RjUtXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4MzAtXFx1QTgzNVxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RDAtXFx1QThEOVxcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QThGRVxcdUE5MDAtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2OVxcdUFCNzAtXFx1QUJFMlxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdUREMDctXFx1REQzM1xcdURENDAtXFx1REQ3OFxcdUREOEFcXHVERDhCXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMS1cXHVERUZCXFx1REYwMC1cXHVERjIzXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM1OC1cXHVEQzc2XFx1REM3OS1cXHVEQzlFXFx1RENBNy1cXHVEQ0FGXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVEQ0ZCLVxcdUREMUJcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJDLVxcdUREQ0ZcXHVEREQyLVxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzVcXHVERTQwLVxcdURFNDhcXHVERTYwLVxcdURFN0VcXHVERTgwLVxcdURFOUZcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERUVCLVxcdURFRUZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjU4LVxcdURGNzJcXHVERjc4LVxcdURGOTFcXHVERkE5LVxcdURGQUZdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXFx1RENGQS1cXHVERDIzXFx1REQzMC1cXHVERDM5XFx1REU2MC1cXHVERTdFXFx1REU4MC1cXHVERUE5XFx1REVCMFxcdURFQjFcXHVERjAwLVxcdURGMjdcXHVERjMwLVxcdURGNDVcXHVERjUxLVxcdURGNTRcXHVERkIwLVxcdURGQ0JcXHVERkUwLVxcdURGRjZdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM1Mi1cXHVEQzZGXFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMy1cXHVERDI2XFx1REQzNi1cXHVERDNGXFx1REQ0NFxcdURENDdcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREMC1cXHVERERBXFx1REREQ1xcdURERTEtXFx1RERGNFxcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERUYwLVxcdURFRjlcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1MC1cXHVEQzU5XFx1REM1Ri1cXHVEQzYxXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMUFcXHVERjMwLVxcdURGM0JdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0YyXFx1RENGRi1cXHVERDA2XFx1REQwOVxcdUREMEMtXFx1REQxM1xcdUREMTVcXHVERDE2XFx1REQxOC1cXHVERDJGXFx1REQzRlxcdURENDFcXHVERDUwLVxcdURENTlcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNTAtXFx1REM2Q1xcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENTAtXFx1REQ1OVxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdUREQTAtXFx1RERBOVxcdURFRTAtXFx1REVGMlxcdURGQjBcXHVERkMwLVxcdURGRDRdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODIyXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XFx1RDg4MC1cXHVEODgzXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjVCLVxcdURGNjFcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REU0MC1cXHVERTk2XFx1REYwMC1cXHVERjRBXFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBcXHVERkUxXFx1REZFM118XFx1RDgyMVtcXHVEQzAwLVxcdURGRjddfFxcdUQ4MjNbXFx1REMwMC1cXHVEQ0Q1XFx1REQwMC1cXHVERDA4XXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENTAtXFx1REQ1MlxcdURENjQtXFx1REQ2N1xcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzRbXFx1REVFMC1cXHVERUYzXFx1REY2MC1cXHVERjc4XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzhbXFx1REQwMC1cXHVERDJDXFx1REQzNy1cXHVERDNEXFx1REQ0MC1cXHVERDQ5XFx1REQ0RVxcdURFQzAtXFx1REVFQlxcdURFRjAtXFx1REVGOV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0M3LVxcdURDQ0ZcXHVERDAwLVxcdURENDNcXHVERDRCXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURDNzEtXFx1RENBQlxcdURDQUQtXFx1RENBRlxcdURDQjEtXFx1RENCNFxcdUREMDEtXFx1REQyRFxcdUREMkYtXFx1REQzRFxcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4M0NbXFx1REQwMC1cXHVERDBDXXxcXHVEODNFW1xcdURGRjAtXFx1REZGOV18XFx1RDg2OVtcXHVEQzAwLVxcdURFRERcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1RDg4NFtcXHVEQzAwLVxcdURGNEFdKS8pKSByZXR1cm47IC8vIF8gY2FuJ3QgYmUgYmV0d2VlbiB0d28gYWxwaGFudW1lcmljcy4gXFxwe0x9XFxwe059IGluY2x1ZGVzIG5vbi1lbmdsaXNoIGFscGhhYmV0L251bWJlcnMgYXMgd2VsbFxuXG4gICAgICB2YXIgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcblxuICAgICAgaWYgKCFuZXh0Q2hhciB8fCBuZXh0Q2hhciAmJiAocHJldkNoYXIgPT09ICcnIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSkge1xuICAgICAgICB2YXIgbExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciByRGVsaW0sXG4gICAgICAgICAgICByTGVuZ3RoLFxuICAgICAgICAgICAgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsXG4gICAgICAgICAgICBtaWREZWxpbVRvdGFsID0gMDtcbiAgICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5yRGVsaW1VbmQ7XG4gICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7IC8vIEJ1bXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcblxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgIGlmICghckRlbGltKSBjb250aW51ZTsgLy8gbWF0Y2hlZCB0aGUgZmlyc3QgYWx0ZXJuYXRpdmUgaW4gcnVsZXMuanMgKHNraXAgdGhlICogaW4gX19hYmMqYWJjX18pXG5cbiAgICAgICAgICByTGVuZ3RoID0gckRlbGltLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChtYXRjaFszXSB8fCBtYXRjaFs0XSkge1xuICAgICAgICAgICAgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgICAgaWYgKGxMZW5ndGggJSAzICYmICEoKGxMZW5ndGggKyByTGVuZ3RoKSAlIDMpKSB7XG4gICAgICAgICAgICAgIG1pZERlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IHJEZWxpbWl0ZXIsIHJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcblxuICAgICAgICAgIGlmIChkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCAtIHJMZW5ndGggPD0gMCAmJiAhbWFza2VkU3JjLnNsaWNlKGVuZFJlZy5sYXN0SW5kZXgpLm1hdGNoKGVuZFJlZykpIHtcbiAgICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgIHJhdzogc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGggKyAxKSxcbiAgICAgICAgICAgICAgdGV4dDogc3JjLnNsaWNlKDEsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIHJMZW5ndGgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgIHRleHQ6IHNyYy5zbGljZSgyLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyByTGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICB2YXIgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICB2YXIgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuXG4gICAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmIChpblJhd0Jsb2NrKSB7XG4gICAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBfZXNjYXBlKGNhcFswXSkgOiBjYXBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb2tlbml6ZXI7XG4gIH0oKTtcblxuICB2YXIgbm9vcFRlc3QgPSBoZWxwZXJzLm5vb3BUZXN0LFxuICAgICAgZWRpdCA9IGhlbHBlcnMuZWRpdCxcbiAgICAgIG1lcmdlJDEgPSBoZWxwZXJzLm1lcmdlO1xuICAvKipcbiAgICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICAgKi9cblxuICB2YXIgYmxvY2skMSA9IHtcbiAgICBuZXdsaW5lOiAvXig/OiAqKD86XFxufCQpKSsvLFxuICAgIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICAgIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKlxcbil8fnszLH0pKFteXFxuXSopXFxuKD86fChbXFxzXFxTXSo/KVxcbikoPzogezAsM31cXDFbfmBdKiAqKD86XFxuK3wkKXwkKS8sXG4gICAgaHI6IC9eIHswLDN9KCg/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcKiAqKXszLH0pKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14gezAsM30oI3sxLDZ9KSg/PVxcc3wkKSguKikoPzpcXG4rfCQpLyxcbiAgICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICAgIGxpc3Q6IC9eKCB7MCwzfSkoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyEgezAsM31idWxsIClcXG4qfFxccyokKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGUpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICpcXG4/ICo8PyhbXlxccz5dKyk+Pyg/Oig/OiArXFxuPyAqfCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICBucHRhYmxlOiBub29wVGVzdCxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gICAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICAgIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHwgK1xcbilbXlxcbl0rKSopLyxcbiAgICB0ZXh0OiAvXlteXFxuXSsvXG4gIH07XG4gIGJsb2NrJDEuX2xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXFtcXFtcXF1dfFteXFxbXFxdXSkrLztcbiAgYmxvY2skMS5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuICBibG9jayQxLmRlZiA9IGVkaXQoYmxvY2skMS5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2skMS5fbGFiZWwpLnJlcGxhY2UoJ3RpdGxlJywgYmxvY2skMS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuICBibG9jayQxLml0ZW0gPSAvXiggKikoYnVsbCkgP1teXFxuXSooPzpcXG4oPyEgKmJ1bGwgPylbXlxcbl0qKSovO1xuICBibG9jayQxLml0ZW0gPSBlZGl0KGJsb2NrJDEuaXRlbSwgJ2dtJykucmVwbGFjZSgvYnVsbC9nLCBibG9jayQxLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pLnJlcGxhY2UoJ2J1bGwnLCBibG9jayQxLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5saXN0ID0gZWRpdChibG9jayQxLmxpc3QpLnJlcGxhY2UoL2J1bGwvZywgYmxvY2skMS5idWxsZXQpLnJlcGxhY2UoJ2hyJywgJ1xcXFxuKyg/PVxcXFwxPyg/Oig/Oi0gKil7Myx9fCg/Ol8gKil7Myx9fCg/OlxcXFwqICopezMsfSkoPzpcXFxcbit8JCkpJykucmVwbGFjZSgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jayQxLmRlZi5zb3VyY2UgKyAnKScpLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbicgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJyArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZScgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInICsgJ3x0cmFja3x1bCc7XG4gIGJsb2NrJDEuX2NvbW1lbnQgPSAvPCEtLSg/IS0/PilbXFxzXFxTXSo/KD86LS0+fCQpLztcbiAgYmxvY2skMS5odG1sID0gZWRpdChibG9jayQxLmh0bWwsICdpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrJDEuX2NvbW1lbnQpLnJlcGxhY2UoJ3RhZycsIGJsb2NrJDEuX3RhZykucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LykuZ2V0UmVnZXgoKTtcbiAgYmxvY2skMS5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrJDEuX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jayQxLmhyKS5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKS5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrJDEuX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgLmdldFJlZ2V4KCk7XG4gIGJsb2NrJDEuYmxvY2txdW90ZSA9IGVkaXQoYmxvY2skMS5ibG9ja3F1b3RlKS5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBibG9jayQxLnBhcmFncmFwaCkuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrJDEubm9ybWFsID0gbWVyZ2UkMSh7fSwgYmxvY2skMSk7XG4gIC8qKlxuICAgKiBHRk0gQmxvY2sgR3JhbW1hclxuICAgKi9cblxuICBibG9jayQxLmdmbSA9IG1lcmdlJDEoe30sIGJsb2NrJDEubm9ybWFsLCB7XG4gICAgbnB0YWJsZTogJ14gKihbXnxcXFxcbiBdLipcXFxcfC4qKVxcXFxuJyAvLyBIZWFkZXJcbiAgICArICcgezAsM30oWy06XSsgKlxcXFx8Wy18IDpdKiknIC8vIEFsaWduXG4gICAgKyAnKD86XFxcXG4oKD86KD8hXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJyxcbiAgICAvLyBDZWxsc1xuICAgIHRhYmxlOiAnXiAqXFxcXHwoLispXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfVxcXFx8PyggKlstOl0rWy18IDpdKiknIC8vIEFsaWduXG4gICAgKyAnKD86XFxcXG4gKigoPzooPyFcXFxcbnxocnxoZWFkaW5nfGJsb2NrcXVvdGV8Y29kZXxmZW5jZXN8bGlzdHxodG1sKS4qKD86XFxcXG58JCkpKilcXFxcbip8JCknIC8vIENlbGxzXG5cbiAgfSk7XG4gIGJsb2NrJDEuZ2ZtLm5wdGFibGUgPSBlZGl0KGJsb2NrJDEuZ2ZtLm5wdGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2skMS5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuICBibG9jayQxLmdmbS50YWJsZSA9IGVkaXQoYmxvY2skMS5nZm0udGFibGUpLnJlcGxhY2UoJ2hyJywgYmxvY2skMS5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2skMS5fdGFnKSAvLyB0YWJsZXMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuICAvKipcbiAgICogUGVkYW50aWMgZ3JhbW1hciAob3JpZ2luYWwgSm9obiBHcnViZXIncyBsb29zZSBtYXJrZG93biBzcGVjaWZpY2F0aW9uKVxuICAgKi9cblxuICBibG9jayQxLnBlZGFudGljID0gbWVyZ2UkMSh7fSwgYmxvY2skMS5ub3JtYWwsIHtcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKScgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpLnJlcGxhY2UoJ2NvbW1lbnQnLCBibG9jayQxLl9jb21tZW50KS5yZXBsYWNlKC90YWcvZywgJyg/ISg/OicgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YicgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0LFxuICAgIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgcGFyYWdyYXBoOiBlZGl0KGJsb2NrJDEubm9ybWFsLl9wYXJhZ3JhcGgpLnJlcGxhY2UoJ2hyJywgYmxvY2skMS5ocikucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJykucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jayQxLmxoZWFkaW5nKS5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKS5yZXBsYWNlKCd8ZmVuY2VzJywgJycpLnJlcGxhY2UoJ3xsaXN0JywgJycpLnJlcGxhY2UoJ3xodG1sJywgJycpLmdldFJlZ2V4KClcbiAgfSk7XG4gIC8qKlxuICAgKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICAgKi9cblxuICB2YXIgaW5saW5lJDEgPSB7XG4gICAgZXNjYXBlOiAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLyxcbiAgICBhdXRvbGluazogL148KHNjaGVtZTpbXlxcc1xceDAwLVxceDFmPD5dKnxlbWFpbCk+LyxcbiAgICB1cmw6IG5vb3BUZXN0LFxuICAgIHRhZzogJ15jb21tZW50JyArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JyxcbiAgICAvLyBDREFUQSBzZWN0aW9uXG4gICAgbGluazogL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvLFxuICAgIHJlZmxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFxbKD8hXFxzKlxcXSkoKD86XFxcXFtcXFtcXF1dP3xbXlxcW1xcXVxcXFxdKSspXFxdLyxcbiAgICBub2xpbms6IC9eIT9cXFsoPyFcXHMqXFxdKSgoPzpcXFtbXlxcW1xcXV0qXFxdfFxcXFxbXFxbXFxdXXxbXlxcW1xcXV0pKilcXF0oPzpcXFtcXF0pPy8sXG4gICAgcmVmbGlua1NlYXJjaDogJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJyxcbiAgICBlbVN0cm9uZzoge1xuICAgICAgbERlbGltOiAvXig/OlxcKisoPzooW3B1bmN0X10pfFteXFxzKl0pKXxeXysoPzooW3B1bmN0Kl0pfChbXlxcc19dKSkvLFxuICAgICAgLy8gICAgICAgICgxKSBhbmQgKDIpIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyLiAoMykgYW5kICg0KSBjYW4gb25seSBiZSBMZWZ0LiAgKDUpIGFuZCAoNikgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0LlxuICAgICAgLy8gICAgICAgICgpIFNraXAgb3RoZXIgZGVsaW1pdGVyICgxKSAjKioqICAgICAgICAgICAgICAgICgyKSBhKioqIywgYSoqKiAgICAgICAgICAgICAgICAgICAoMykgIyoqKmEsICoqKmEgICAgICAgICAgICAgICAgICg0KSAqKiojICAgICAgICAgICAgICAoNSkgIyoqKiMgICAgICAgICAgICAgICAgICg2KSBhKioqYVxuICAgICAgckRlbGltQXN0OiAvXFxfXFxfW15fXSo/XFwqW15fXSo/XFxfXFxffFtwdW5jdF9dKFxcKispKD89W1xcc118JCl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtwdW5jdF9cXHNdfCQpfFtwdW5jdF9cXHNdKFxcKispKD89W15wdW5jdCpfXFxzXSl8W1xcc10oXFwqKykoPz1bcHVuY3RfXSl8W3B1bmN0X10oXFwqKykoPz1bcHVuY3RfXSl8W15wdW5jdCpfXFxzXShcXCorKSg/PVtecHVuY3QqX1xcc10pLyxcbiAgICAgIHJEZWxpbVVuZDogL1xcKlxcKlteKl0qP1xcX1teKl0qP1xcKlxcKnxbcHVuY3QqXShcXF8rKSg/PVtcXHNdfCQpfFtecHVuY3QqX1xcc10oXFxfKykoPz1bcHVuY3QqXFxzXXwkKXxbcHVuY3QqXFxzXShcXF8rKSg/PVtecHVuY3QqX1xcc10pfFtcXHNdKFxcXyspKD89W3B1bmN0Kl0pfFtwdW5jdCpdKFxcXyspKD89W3B1bmN0Kl0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuXG4gICAgfSxcbiAgICBjb2RlOiAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvLFxuICAgIGJyOiAvXiggezIsfXxcXFxcKVxcbig/IVxccyokKS8sXG4gICAgZGVsOiBub29wVGVzdCxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqX118XFxiX3wkKXxbXiBdKD89IHsyLH1cXG4pKSkvLFxuICAgIHB1bmN0dWF0aW9uOiAvXihbXFxzcHVuY3R1YXRpb25dKS9cbiAgfTsgLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuICAvLyB3aXRob3V0ICogYW5kIF8gdG8gaGFuZGxlIHRoZSBkaWZmZXJlbnQgZW1waGFzaXMgbWFya2VycyAqIGFuZCBfXG5cbiAgaW5saW5lJDEuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKStcXFxcLS4sLzo7PD0+P0BcXFxcW1xcXFxdYF57fH1+JztcbiAgaW5saW5lJDEucHVuY3R1YXRpb24gPSBlZGl0KGlubGluZSQxLnB1bmN0dWF0aW9uKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUkMS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7IC8vIHNlcXVlbmNlcyBlbSBzaG91bGQgc2tpcCBvdmVyIFt0aXRsZV0obGluayksIGBjb2RlYCwgPGh0bWw+XG5cbiAgaW5saW5lJDEuYmxvY2tTa2lwID0gL1xcW1teXFxdXSo/XFxdXFwoW15cXCldKj9cXCl8YFteYF0qP2B8PFtePl0qPz4vZztcbiAgaW5saW5lJDEuZXNjYXBlZEVtU3QgPSAvXFxcXFxcKnxcXFxcXy9nO1xuICBpbmxpbmUkMS5fY29tbWVudCA9IGVkaXQoYmxvY2skMS5fY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLmVtU3Ryb25nLmxEZWxpbSA9IGVkaXQoaW5saW5lJDEuZW1TdHJvbmcubERlbGltKS5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUkMS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLmVtU3Ryb25nLnJEZWxpbUFzdCA9IGVkaXQoaW5saW5lJDEuZW1TdHJvbmcuckRlbGltQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZSQxLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuZW1TdHJvbmcuckRlbGltVW5kID0gZWRpdChpbmxpbmUkMS5lbVN0cm9uZy5yRGVsaW1VbmQsICdnJykucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lJDEuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5fZXNjYXBlcyA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS9nO1xuICBpbmxpbmUkMS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuICBpbmxpbmUkMS5fZW1haWwgPSAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLztcbiAgaW5saW5lJDEuYXV0b2xpbmsgPSBlZGl0KGlubGluZSQxLmF1dG9saW5rKS5yZXBsYWNlKCdzY2hlbWUnLCBpbmxpbmUkMS5fc2NoZW1lKS5yZXBsYWNlKCdlbWFpbCcsIGlubGluZSQxLl9lbWFpbCkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbiAgaW5saW5lJDEudGFnID0gZWRpdChpbmxpbmUkMS50YWcpLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUkMS5fY29tbWVudCkucmVwbGFjZSgnYXR0cmlidXRlJywgaW5saW5lJDEuX2F0dHJpYnV0ZSkuZ2V0UmVnZXgoKTtcbiAgaW5saW5lJDEuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbiAgaW5saW5lJDEuX2hyZWYgPSAvPCg/OlxcXFwufFteXFxuPD5cXFxcXSkrPnxbXlxcc1xceDAwLVxceDFmXSovO1xuICBpbmxpbmUkMS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcbiAgaW5saW5lJDEubGluayA9IGVkaXQoaW5saW5lJDEubGluaykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUkMS5fbGFiZWwpLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUkMS5faHJlZikucmVwbGFjZSgndGl0bGUnLCBpbmxpbmUkMS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGlubGluZSQxLnJlZmxpbmsgPSBlZGl0KGlubGluZSQxLnJlZmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lJDEuX2xhYmVsKS5nZXRSZWdleCgpO1xuICBpbmxpbmUkMS5yZWZsaW5rU2VhcmNoID0gZWRpdChpbmxpbmUkMS5yZWZsaW5rU2VhcmNoLCAnZycpLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUkMS5yZWZsaW5rKS5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUkMS5ub2xpbmspLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lJDEubm9ybWFsID0gbWVyZ2UkMSh7fSwgaW5saW5lJDEpO1xuICAvKipcbiAgICogUGVkYW50aWMgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lJDEucGVkYW50aWMgPSBtZXJnZSQxKHt9LCBpbmxpbmUkMS5ub3JtYWwsIHtcbiAgICBzdHJvbmc6IHtcbiAgICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgICAgZW5kQXN0OiAvXFwqXFwqKD8hXFwqKS9nLFxuICAgICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gICAgfSxcbiAgICBlbToge1xuICAgICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgICAgbWlkZGxlOiAvXigpXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKil8Xl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pLyxcbiAgICAgIGVuZEFzdDogL1xcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL18oPyFfKS9nXG4gICAgfSxcbiAgICBsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZSQxLl9sYWJlbCkuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lJDEuX2xhYmVsKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogR0ZNIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZSQxLmdmbSA9IG1lcmdlJDEoe30sIGlubGluZSQxLm5vcm1hbCwge1xuICAgIGVzY2FwZTogZWRpdChpbmxpbmUkMS5lc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgICBfYmFja3BlZGFsOiAvKD86W14/IS4sOjsqX34oKSZdK3xcXChbXildKlxcKXwmKD8hW2EtekEtWjAtOV0rOyQpfFs/IS4sOjsqX34pXSsoPyEkKSkrLyxcbiAgICBkZWw6IC9eKH5+PykoPz1bXlxcc35dKShbXFxzXFxTXSo/W15cXHN+XSlcXDEoPz1bXn5dfCQpLyxcbiAgICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpL1xuICB9KTtcbiAgaW5saW5lJDEuZ2ZtLnVybCA9IGVkaXQoaW5saW5lJDEuZ2ZtLnVybCwgJ2knKS5yZXBsYWNlKCdlbWFpbCcsIGlubGluZSQxLmdmbS5fZXh0ZW5kZWRfZW1haWwpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUkMS5icmVha3MgPSBtZXJnZSQxKHt9LCBpbmxpbmUkMS5nZm0sIHtcbiAgICBicjogZWRpdChpbmxpbmUkMS5icikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgICB0ZXh0OiBlZGl0KGlubGluZSQxLmdmbS50ZXh0KS5yZXBsYWNlKCdcXFxcYl8nLCAnXFxcXGJffCB7Mix9XFxcXG4nKS5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpLmdldFJlZ2V4KClcbiAgfSk7XG4gIHZhciBydWxlcyA9IHtcbiAgICBibG9jazogYmxvY2skMSxcbiAgICBpbmxpbmU6IGlubGluZSQxXG4gIH07XG5cbiAgdmFyIFRva2VuaXplciQxID0gVG9rZW5pemVyXzE7XG4gIHZhciBkZWZhdWx0cyQzID0gZGVmYXVsdHMkNS5leHBvcnRzLmRlZmF1bHRzO1xuICB2YXIgYmxvY2sgPSBydWxlcy5ibG9jayxcbiAgICAgIGlubGluZSA9IHJ1bGVzLmlubGluZTtcbiAgdmFyIHJlcGVhdFN0cmluZyA9IGhlbHBlcnMucmVwZWF0U3RyaW5nO1xuICAvKipcbiAgICogc21hcnR5cGFudHMgdGV4dCByZXBsYWNlbWVudFxuICAgKi9cblxuICBmdW5jdGlvbiBzbWFydHlwYW50cyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCBcIlxcdTIwMTRcIikgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csIFwiXFx1MjAxM1wiKSAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgXCIkMVxcdTIwMThcIikgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCBcIlxcdTIwMTlcIikgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csIFwiJDFcXHUyMDFDXCIpIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCBcIlxcdTIwMURcIikgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csIFwiXFx1MjAyNlwiKTtcbiAgfVxuICAvKipcbiAgICogbWFuZ2xlIGVtYWlsIGFkZHJlc3Nlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gICAgdmFyIG91dCA9ICcnLFxuICAgICAgICBpLFxuICAgICAgICBjaDtcbiAgICB2YXIgbCA9IHRleHQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIExleGVyXG4gICAqL1xuXG5cbiAgdmFyIExleGVyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLnRva2Vucy5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDM7XG4gICAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyJDEoKTtcbiAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgcnVsZXMgPSB7XG4gICAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICAgIGlubGluZTogaW5saW5lLm5vcm1hbFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrLnBlZGFudGljO1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuYnJlYWtzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5nZm07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbml6ZXIucnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3NlIFJ1bGVzXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggTWV0aG9kXG4gICAgICovXG4gICAgTGV4ZXIubGV4ID0gZnVuY3Rpb24gbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBMZXhlci5sZXhJbmxpbmUgPSBmdW5jdGlvbiBsZXhJbmxpbmUoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gTGV4ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmxleCA9IGZ1bmN0aW9uIGxleChzcmMpIHtcbiAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKS5yZXBsYWNlKC9cXHQvZywgJyAgICAnKTtcbiAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2VucywgdHJ1ZSk7XG4gICAgICB0aGlzLmlubGluZSh0aGlzLnRva2Vucyk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZ1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5ibG9ja1Rva2VucyA9IGZ1bmN0aW9uIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zLCB0b3ApIHtcbiAgICAgIGlmICh0b2tlbnMgPT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRva2VuLCBpLCBsLCBsYXN0VG9rZW47XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGZlbmNlc1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBoZWFkaW5nXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5wdGFibGUoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGhyXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYmxvY2txdW90ZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0b3ApO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIGwgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbi5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLml0ZW1zW2ldLnRleHQsIFtdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGh0bWxcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmh0bWwoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlZlxuXG5cbiAgICAgICAgaWYgKHRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFibGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcblxuXG4gICAgICAgIGlmICh0b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKHNyYykpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9wcm90by5pbmxpbmUgPSBmdW5jdGlvbiBpbmxpbmUodG9rZW5zKSB7XG4gICAgICB2YXIgaSwgaiwgaywgbDIsIHJvdywgdG9rZW47XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICAgICAgICBjZWxsczogW11cbiAgICAgICAgICAgICAgfTsgLy8gaGVhZGVyXG5cbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmhlYWRlcltqXSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLmhlYWRlcltqXSwgdG9rZW4udG9rZW5zLmhlYWRlcltqXSk7XG4gICAgICAgICAgICAgIH0gLy8gY2VsbHNcblxuXG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4uY2VsbHNbal07XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmNlbGxzW2pdID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbi50b2tlbnMuY2VsbHNbal1ba10gPSBbXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHJvd1trXSwgdG9rZW4udG9rZW5zLmNlbGxzW2pdW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLmlubGluZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lKHRva2VuLml0ZW1zW2pdLnRva2Vucyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2VucywgaW5MaW5rLCBpblJhd0Jsb2NrKSB7XG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChpbkxpbmsgPT09IHZvaWQgMCkge1xuICAgICAgICBpbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluUmF3QmxvY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBpblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiwgbGFzdFRva2VuOyAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuXG4gICAgICB2YXIgbWFza2VkU3JjID0gc3JjO1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIGtlZXBQcmV2Q2hhciwgcHJldkNoYXI7IC8vIE1hc2sgb3V0IHJlZmxpbmtzXG5cbiAgICAgIGlmICh0aGlzLnRva2Vucy5saW5rcykge1xuICAgICAgICB2YXIgbGlua3MgPSBPYmplY3Qua2V5cyh0aGlzLnRva2Vucy5saW5rcyk7XG5cbiAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArIHJlcGVhdFN0cmluZygnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuXG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgcmVwZWF0U3RyaW5nKCdhJywgbWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgfSAvLyBNYXNrIG91dCBlc2NhcGVkIGVtICYgc3Ryb25nIGRlbGltaXRlcnNcblxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmVzY2FwZWRFbVN0LmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuZXNjYXBlZEVtU3QubGFzdEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTsgLy8gZXNjYXBlXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMsIGluTGluaywgaW5SYXdCbG9jaykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIGluTGluayA9IHRva2VuLmluTGluaztcbiAgICAgICAgICBpblJhd0Jsb2NrID0gdG9rZW4uaW5SYXdCbG9jaztcbiAgICAgICAgICB2YXIgX2xhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAoX2xhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgX2xhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIF9sYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgIF9sYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0cnVlLCBpblJhd0Jsb2NrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gcmVmbGluaywgbm9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgX2xhc3RUb2tlbjIgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIHRydWUsIGluUmF3QmxvY2spO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX2xhc3RUb2tlbjIgJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIF9sYXN0VG9rZW4yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgX2xhc3RUb2tlbjIucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgIF9sYXN0VG9rZW4yLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGVtICYgc3Ryb25nXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgaW5MaW5rLCBpblJhd0Jsb2NrKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGJyXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5icihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZGVsIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGF1dG9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMsIG1hbmdsZSkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB1cmwgKGdmbSlcblxuXG4gICAgICAgIGlmICghaW5MaW5rICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnVybChzcmMsIG1hbmdsZSkpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChzcmMsIGluUmF3QmxvY2ssIHNtYXJ0eXBhbnRzKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhMZXhlciwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJydWxlc1wiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmxvY2s6IGJsb2NrLFxuICAgICAgICAgIGlubGluZTogaW5saW5lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExleGVyO1xuICB9KCk7XG5cbiAgdmFyIGRlZmF1bHRzJDIgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIHZhciBjbGVhblVybCA9IGhlbHBlcnMuY2xlYW5VcmwsXG4gICAgICBlc2NhcGUkMSA9IGhlbHBlcnMuZXNjYXBlO1xuICAvKipcbiAgICogUmVuZGVyZXJcbiAgICovXG5cbiAgdmFyIFJlbmRlcmVyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMkMjtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmNvZGUgPSBmdW5jdGlvbiBjb2RlKF9jb2RlLCBpbmZvc3RyaW5nLCBlc2NhcGVkKSB7XG4gICAgICB2YXIgbGFuZyA9IChpbmZvc3RyaW5nIHx8ICcnKS5tYXRjaCgvXFxTKi8pWzBdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5vcHRpb25zLmhpZ2hsaWdodChfY29kZSwgbGFuZyk7XG5cbiAgICAgICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gX2NvZGUpIHtcbiAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICBfY29kZSA9IG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfY29kZSA9IF9jb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcblxuICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZT4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZSQxKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIicgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeCArIGVzY2FwZSQxKGxhbmcsIHRydWUpICsgJ1wiPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlJDEoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKF9odG1sKSB7XG4gICAgICByZXR1cm4gX2h0bWw7XG4gICAgfTtcblxuICAgIF9wcm90by5oZWFkaW5nID0gZnVuY3Rpb24gaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3LCBzbHVnZ2VyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJyBpZD1cIicgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdykgKyAnXCI+JyArIHRleHQgKyAnPC9oJyArIGxldmVsICsgJz5cXG4nO1xuICAgICAgfSAvLyBpZ25vcmUgSURzXG5cblxuICAgICAgcmV0dXJuICc8aCcgKyBsZXZlbCArICc+JyArIHRleHQgKyAnPC9oJyArIGxldmVsICsgJz5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdCA9IGZ1bmN0aW9uIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICAgIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgICAgIHN0YXJ0YXR0ID0gb3JkZXJlZCAmJiBzdGFydCAhPT0gMSA/ICcgc3RhcnQ9XCInICsgc3RhcnQgKyAnXCInIDogJyc7XG4gICAgICByZXR1cm4gJzwnICsgdHlwZSArIHN0YXJ0YXR0ICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdGl0ZW0gPSBmdW5jdGlvbiBsaXN0aXRlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5jaGVja2JveCA9IGZ1bmN0aW9uIGNoZWNrYm94KGNoZWNrZWQpIHtcbiAgICAgIHJldHVybiAnPGlucHV0ICcgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKSArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJyArICh0aGlzLm9wdGlvbnMueGh0bWwgPyAnIC8nIDogJycpICsgJz4gJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnBhcmFncmFwaCA9IGZ1bmN0aW9uIHBhcmFncmFwaCh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShoZWFkZXIsIGJvZHkpIHtcbiAgICAgIGlmIChib2R5KSBib2R5ID0gJzx0Ym9keT4nICsgYm9keSArICc8L3Rib2R5Pic7XG4gICAgICByZXR1cm4gJzx0YWJsZT5cXG4nICsgJzx0aGVhZD5cXG4nICsgaGVhZGVyICsgJzwvdGhlYWQ+XFxuJyArIGJvZHkgKyAnPC90YWJsZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGVyb3cgPSBmdW5jdGlvbiB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZWNlbGwgPSBmdW5jdGlvbiB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICB2YXIgdGFnID0gZmxhZ3MuYWxpZ24gPyAnPCcgKyB0eXBlICsgJyBhbGlnbj1cIicgKyBmbGFncy5hbGlnbiArICdcIj4nIDogJzwnICsgdHlwZSArICc+JztcbiAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfSAvLyBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcblxuICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUkMShocmVmKSArICdcIic7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcblxuICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICByZXR1cm4gX3RleHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBUZXh0UmVuZGVyZXJcbiAgICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gICAqL1xuXG4gIHZhciBUZXh0UmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cblxuICAgIHZhciBfcHJvdG8gPSBUZXh0UmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgLy8gbm8gbmVlZCBmb3IgYmxvY2sgbGV2ZWwgcmVuZGVyZXJzXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgcmV0dXJuIF90ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gJycgKyB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAgICovXG5cbiAgdmFyIFNsdWdnZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2x1Z2dlcigpIHtcbiAgICAgIHRoaXMuc2VlbiA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBTbHVnZ2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKSAvLyByZW1vdmUgdW53YW50ZWQgY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9bXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGXFxcXCchXCIjJCUmKCkqKywuLzo7PD0+P0BbXFxdXmB7fH1+XS9nLCAnJykucmVwbGFjZSgvXFxzL2csICctJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZ2V0TmV4dFNhZmVTbHVnID0gZnVuY3Rpb24gZ2V0TmV4dFNhZmVTbHVnKG9yaWdpbmFsU2x1ZywgaXNEcnlSdW4pIHtcbiAgICAgIHZhciBzbHVnID0gb3JpZ2luYWxTbHVnO1xuICAgICAgdmFyIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gMDtcblxuICAgICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IHRoaXMuc2VlbltvcmlnaW5hbFNsdWddO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvcisrO1xuICAgICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgICB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXSA9IG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgICB0aGlzLnNlZW5bc2x1Z10gPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2x1ZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBzdHJpbmcgdG8gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZHJ5cnVuIEdlbmVyYXRlcyB0aGUgbmV4dCB1bmlxdWUgc2x1ZyB3aXRob3V0IHVwZGF0aW5nIHRoZSBpbnRlcm5hbCBhY2N1bXVsYXRvci5cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2x1ZyA9IGZ1bmN0aW9uIHNsdWcodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2x1ZyA9IHRoaXMuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gICAgfTtcblxuICAgIHJldHVybiBTbHVnZ2VyO1xuICB9KCk7XG5cbiAgdmFyIFJlbmRlcmVyJDEgPSBSZW5kZXJlcl8xO1xuICB2YXIgVGV4dFJlbmRlcmVyJDEgPSBUZXh0UmVuZGVyZXJfMTtcbiAgdmFyIFNsdWdnZXIkMSA9IFNsdWdnZXJfMTtcbiAgdmFyIGRlZmF1bHRzJDEgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuZGVmYXVsdHM7XG4gIHZhciB1bmVzY2FwZSA9IGhlbHBlcnMudW5lc2NhcGU7XG4gIC8qKlxuICAgKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gICAqL1xuXG4gIHZhciBQYXJzZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMkMTtcbiAgICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXIkMSgpO1xuICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IFRleHRSZW5kZXJlciQxKCk7XG4gICAgICB0aGlzLnNsdWdnZXIgPSBuZXcgU2x1Z2dlciQxKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBQYXJzZSBNZXRob2RcbiAgICAgKi9cblxuXG4gICAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICA7XG5cbiAgICBQYXJzZXIucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBMb29wXG4gICAgICovXG4gICAgO1xuXG4gICAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIHRvcCkge1xuICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgayxcbiAgICAgICAgICBsMixcbiAgICAgICAgICBsMyxcbiAgICAgICAgICByb3csXG4gICAgICAgICAgY2VsbCxcbiAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICB0b2tlbixcbiAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGxvb3NlLFxuICAgICAgICAgIGl0ZW1Cb2R5LFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIGNoZWNrYm94O1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhlYWRpbmcodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpLCB0b2tlbi5kZXB0aCwgdW5lc2NhcGUodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHRoaXMudGV4dFJlbmRlcmVyKSksIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGUodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoZWFkZXIgPSAnJzsgLy8gaGVhZGVyXG5cbiAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLmhlYWRlci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLmhlYWRlcltqXSksIHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFsaWduOiB0b2tlbi5hbGlnbltqXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0b2tlbi50b2tlbnMuY2VsbHNbal07XG4gICAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUocm93W2tdKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oaXRlbUJvZHksIHRhc2ssIGNoZWNrZWQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gcGFyc2UgaW5saW5lIGNvbnRlbnQgaWYgcGFyYW1ldGVyIG1hcmtkb3duPTFcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keSA9IHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgbCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRva2VuO1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmltYWdlKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2NvZGVzcGFuJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGVsJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcbiAgfSgpO1xuXG4gIHZhciBMZXhlciA9IExleGVyXzE7XG4gIHZhciBQYXJzZXIgPSBQYXJzZXJfMTtcbiAgdmFyIFRva2VuaXplciA9IFRva2VuaXplcl8xO1xuICB2YXIgUmVuZGVyZXIgPSBSZW5kZXJlcl8xO1xuICB2YXIgVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyXzE7XG4gIHZhciBTbHVnZ2VyID0gU2x1Z2dlcl8xO1xuICB2YXIgbWVyZ2UgPSBoZWxwZXJzLm1lcmdlLFxuICAgICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uID0gaGVscGVycy5jaGVja1Nhbml0aXplRGVwcmVjYXRpb24sXG4gICAgICBlc2NhcGUgPSBoZWxwZXJzLmVzY2FwZTtcbiAgdmFyIGdldERlZmF1bHRzID0gZGVmYXVsdHMkNS5leHBvcnRzLmdldERlZmF1bHRzLFxuICAgICAgY2hhbmdlRGVmYXVsdHMgPSBkZWZhdWx0cyQ1LmV4cG9ydHMuY2hhbmdlRGVmYXVsdHMsXG4gICAgICBkZWZhdWx0cyA9IGRlZmF1bHRzJDUuZXhwb3J0cy5kZWZhdWx0cztcbiAgLyoqXG4gICAqIE1hcmtlZFxuICAgKi9cblxuICBmdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdGhyb3cgZXJyb3IgaW4gY2FzZSBvZiBub24gc3RyaW5nIGlucHV0XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICd1bmRlZmluZWQnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG4gICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgdmFyIHRva2VucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5zID0gTGV4ZXIubGV4KHNyYywgb3B0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgIHZhciBvdXQ7XG5cbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQgPSBQYXJzZXIucGFyc2UodG9rZW5zLCBvcHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGVyciA/IGNhbGxiYWNrKGVycikgOiBjYWxsYmFjayhudWxsLCBvdXQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG4gICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHJldHVybiBkb25lKCk7XG4gICAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2NvZGUnKSB7XG4gICAgICAgICAgcGVuZGluZysrO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uIChlcnIsIGNvZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsICYmIGNvZGUgIT09IHRva2VuLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi50ZXh0ID0gY29kZTtcbiAgICAgICAgICAgICAgICB0b2tlbi5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBlbmRpbmctLTtcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGVuZGluZyA9PT0gMCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIF90b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpO1xuXG4gICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoX3Rva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyLnBhcnNlKF90b2tlbnMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuXG4gICAgICBpZiAob3B0LnNpbGVudCkge1xuICAgICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpICsgJzwvcHJlPic7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPcHRpb25zXG4gICAqL1xuXG5cbiAgbWFya2VkLm9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICBtZXJnZShtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xuICB9O1xuXG4gIG1hcmtlZC5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuICBtYXJrZWQuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgLyoqXG4gICAqIFVzZSBFeHRlbnNpb25cbiAgICovXG5cbiAgbWFya2VkLnVzZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICB2YXIgb3B0cyA9IG1lcmdlKHt9LCBleHRlbnNpb24pO1xuXG4gICAgaWYgKGV4dGVuc2lvbi5yZW5kZXJlcikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gbWFya2VkLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcigpO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcHJvcF07XG5cbiAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnJlbmRlcmVyW3Byb3BdLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZXh0ZW5zaW9uLnJlbmRlcmVyKSB7XG4gICAgICAgICAgX2xvb3AocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIGlmIChleHRlbnNpb24udG9rZW5pemVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyKCk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG5cbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnRva2VuaXplcltwcm9wXS5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi50b2tlbml6ZXIpIHtcbiAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbi53YWxrVG9rZW5zKSB7XG4gICAgICB2YXIgd2Fsa1Rva2VucyA9IG1hcmtlZC5kZWZhdWx0cy53YWxrVG9rZW5zO1xuXG4gICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgZXh0ZW5zaW9uLndhbGtUb2tlbnModG9rZW4pO1xuXG4gICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbWFya2VkLnNldE9wdGlvbnMob3B0cyk7XG4gIH07XG4gIC8qKlxuICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAqL1xuXG5cbiAgbWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0b2tlbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sodG9rZW4pO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnRva2Vucy5oZWFkZXIpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoY2VsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi50b2tlbnMuY2VsbHMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSBJbmxpbmVcbiAgICovXG5cblxuICBtYXJrZWQucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBvcHQpIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZC5wYXJzZUlubGluZSgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG4gICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHRva2VucyA9IExleGVyLmxleElubGluZShzcmMsIG9wdCk7XG5cbiAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuXG4gICAgICBpZiAob3B0LnNpbGVudCkge1xuICAgICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUoZS5tZXNzYWdlICsgJycsIHRydWUpICsgJzwvcHJlPic7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRXhwb3NlXG4gICAqL1xuXG5cbiAgbWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbiAgbWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcbiAgbWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG4gIG1hcmtlZC5UZXh0UmVuZGVyZXIgPSBUZXh0UmVuZGVyZXI7XG4gIG1hcmtlZC5MZXhlciA9IExleGVyO1xuICBtYXJrZWQubGV4ZXIgPSBMZXhlci5sZXg7XG4gIG1hcmtlZC5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG4gIG1hcmtlZC5TbHVnZ2VyID0gU2x1Z2dlcjtcbiAgbWFya2VkLnBhcnNlID0gbWFya2VkO1xuICB2YXIgbWFya2VkXzEgPSBtYXJrZWQ7XG5cbiAgcmV0dXJuIG1hcmtlZF8xO1xuXG59KSkpO1xuIiwiKGZ1bmN0aW9uIChQcmlzbSkge1xuXHQvLyAkIHNldCB8IGdyZXAgJ15bQS1aXVteWzpzcGFjZTpdXSo9JyB8IGN1dCAtZD0gLWYxIHwgdHIgJ1xcbicgJ3wnXG5cdC8vICsgTENfQUxMLCBSQU5ET00sIFJFUExZLCBTRUNPTkRTLlxuXHQvLyArIG1ha2Ugc3VyZSBQUzEuLjQgYXJlIGhlcmUgYXMgdGhleSBhcmUgbm90IGFsd2F5cyBzZXQsXG5cdC8vIC0gc29tZSB1c2VsZXNzIHRoaW5ncy5cblx0dmFyIGVudlZhcnMgPSAnXFxcXGIoPzpCQVNIfEJBU0hPUFRTfEJBU0hfQUxJQVNFU3xCQVNIX0FSR0N8QkFTSF9BUkdWfEJBU0hfQ01EU3xCQVNIX0NPTVBMRVRJT05fQ09NUEFUX0RJUnxCQVNIX0xJTkVOT3xCQVNIX1JFTUFUQ0h8QkFTSF9TT1VSQ0V8QkFTSF9WRVJTSU5GT3xCQVNIX1ZFUlNJT058Q09MT1JURVJNfENPTFVNTlN8Q09NUF9XT1JEQlJFQUtTfERCVVNfU0VTU0lPTl9CVVNfQUREUkVTU3xERUZBVUxUU19QQVRIfERFU0tUT1BfU0VTU0lPTnxESVJTVEFDS3xESVNQTEFZfEVVSUR8R0RNU0VTU0lPTnxHRE1fTEFOR3xHTk9NRV9LRVlSSU5HX0NPTlRST0x8R05PTUVfS0VZUklOR19QSUR8R1BHX0FHRU5UX0lORk98R1JPVVBTfEhJU1RDT05UUk9MfEhJU1RGSUxFfEhJU1RGSUxFU0laRXxISVNUU0laRXxIT01FfEhPU1ROQU1FfEhPU1RUWVBFfElGU3xJTlNUQU5DRXxKT0J8TEFOR3xMQU5HVUFHRXxMQ19BRERSRVNTfExDX0FMTHxMQ19JREVOVElGSUNBVElPTnxMQ19NRUFTVVJFTUVOVHxMQ19NT05FVEFSWXxMQ19OQU1FfExDX05VTUVSSUN8TENfUEFQRVJ8TENfVEVMRVBIT05FfExDX1RJTUV8TEVTU0NMT1NFfExFU1NPUEVOfExJTkVTfExPR05BTUV8TFNfQ09MT1JTfE1BQ0hUWVBFfE1BSUxDSEVDS3xNQU5EQVRPUllfUEFUSHxOT19BVF9CUklER0V8T0xEUFdEfE9QVEVSUnxPUFRJTkR8T1JCSVRfU09DS0VURElSfE9TVFlQRXxQQVBFUlNJWkV8UEFUSHxQSVBFU1RBVFVTfFBQSUR8UFMxfFBTMnxQUzN8UFM0fFBXRHxSQU5ET018UkVQTFl8U0VDT05EU3xTRUxJTlVYX0lOSVR8U0VTU0lPTnxTRVNTSU9OVFlQRXxTRVNTSU9OX01BTkFHRVJ8U0hFTEx8U0hFTExPUFRTfFNITFZMfFNTSF9BVVRIX1NPQ0t8VEVSTXxVSUR8VVBTVEFSVF9FVkVOVFN8VVBTVEFSVF9JTlNUQU5DRXxVUFNUQVJUX0pPQnxVUFNUQVJUX1NFU1NJT058VVNFUnxXSU5ET1dJRHxYQVVUSE9SSVRZfFhER19DT05GSUdfRElSU3xYREdfQ1VSUkVOVF9ERVNLVE9QfFhER19EQVRBX0RJUlN8WERHX0dSRUVURVJfREFUQV9ESVJ8WERHX01FTlVfUFJFRklYfFhER19SVU5USU1FX0RJUnxYREdfU0VBVHxYREdfU0VBVF9QQVRIfFhER19TRVNTSU9OX0RFU0tUT1B8WERHX1NFU1NJT05fSUR8WERHX1NFU1NJT05fUEFUSHxYREdfU0VTU0lPTl9UWVBFfFhER19WVE5SfFhNT0RJRklFUlMpXFxcXGInO1xuXG5cdHZhciBjb21tYW5kQWZ0ZXJIZXJlZG9jID0ge1xuXHRcdHBhdHRlcm46IC8oXihbXCInXT8pXFx3K1xcMilbIFxcdF0rXFxTLiovLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdwdW5jdHVhdGlvbicsIC8vIHRoaXMgbG9va3MgcmVhc29uYWJseSB3ZWxsIGluIGFsbCB0aGVtZXNcblx0XHRpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cdH07XG5cblx0dmFyIGluc2lkZVN0cmluZyA9IHtcblx0XHQnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2MsXG5cdFx0J2Vudmlyb25tZW50Jzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdcXFxcJCcgKyBlbnZWYXJzKSxcblx0XHRcdGFsaWFzOiAnY29uc3RhbnQnXG5cdFx0fSxcblx0XHQndmFyaWFibGUnOiBbXG5cdFx0XHQvLyBbMF06IEFyaXRobWV0aWMgRW52aXJvbm1lbnRcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogL1xcJD9cXChcXChbXFxzXFxTXSs/XFwpXFwpLyxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAkKCggYW5kICkpIGFzIHZhcmlhYmxlXG5cdFx0XHRcdFx0J3ZhcmlhYmxlJzogW1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvKF5cXCRcXChcXChbXFxzXFxTXSspXFwpXFwpLyxcblx0XHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdC9eXFwkXFwoXFwoL1xuXHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0J251bWJlcic6IC9cXGIweFtcXGRBLUZhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlXS0/XFxkKyk/Lyxcblx0XHRcdFx0XHQvLyBPcGVyYXRvcnMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvYmFzaHJlZi5odG1sI1NoZWxsLUFyaXRobWV0aWNcblx0XHRcdFx0XHQnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fDw8PT98Pj49P3wmJnxcXHxcXHx8Wz0hK1xcLSovJTw+XiZ8XT0/fFs/fjpdLyxcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyAkIHNpZ24gYXQgdGhlIGJlZ2lubmluZyBoaWdobGlnaHQgKCggYW5kICkpIGFzIHB1bmN0dWF0aW9uXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcKFxcKD98XFwpXFwpP3wsfDsvXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG5cdFx0XHR7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXCgoPzpcXChbXildK1xcKXxbXigpXSkrXFwpfGBbXmBdK2AvLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCd2YXJpYWJsZSc6IC9eXFwkXFwofF5gfFxcKSR8YCQvXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBbMl06IEJyYWNlIGV4cGFuc2lvblxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdvcGVyYXRvcic6IC86Wy09PytdP3xbIVxcL118IyM/fCUlP3xcXF5cXF4/fCwsPy8sXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1tcXFtcXF1dLyxcblx0XHRcdFx0XHQnZW52aXJvbm1lbnQnOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJyhcXFxceyknICsgZW52VmFycyksXG5cdFx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvXFwkKD86XFx3K3xbIz8qIUAkXSkvXG5cdFx0XSxcblx0XHQvLyBFc2NhcGUgc2VxdWVuY2VzIGZyb20gZWNobyBhbmQgcHJpbnRmJ3MgbWFudWFscywgYW5kIGVzY2FwZWQgcXVvdGVzLlxuXHRcdCdlbnRpdHknOiAvXFxcXCg/OlthYmNlRWZucnR2XFxcXFwiXXxPP1swLTddezEsM318VVswLTlhLWZBLUZdezh9fHVbMC05YS1mQS1GXXs0fXx4WzAtOWEtZkEtRl17MSwyfSkvXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmJhc2ggPSB7XG5cdFx0J3NoZWJhbmcnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXiMhXFxzKlxcLy4qLyxcblx0XHRcdGFsaWFzOiAnaW1wb3J0YW50J1xuXHRcdH0sXG5cdFx0J2NvbW1lbnQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cIntcXFxcJF0pIy4qLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdmdW5jdGlvbi1uYW1lJzogW1xuXHRcdFx0Ly8gYSkgZnVuY3Rpb24gZm9vIHtcblx0XHRcdC8vIGIpIGZvbygpIHtcblx0XHRcdC8vIGMpIGZ1bmN0aW9uIGZvbygpIHtcblx0XHRcdC8vIGJ1dCBub3Qg4oCcZm9vIHvigJ1cblx0XHRcdHtcblx0XHRcdFx0Ly8gYSkgYW5kIGMpXG5cdFx0XHRcdHBhdHRlcm46IC8oXFxiZnVuY3Rpb25cXHMrKVtcXHctXSsoPz0oPzpcXHMqXFwoPzpcXHMqXFwpKT9cXHMqXFx7KS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHQvLyBiKVxuXHRcdFx0XHRwYXR0ZXJuOiAvXFxiW1xcdy1dKyg/PVxccypcXChcXHMqXFwpXFxzKlxceykvLFxuXHRcdFx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHRcdFx0fVxuXHRcdF0sXG5cdFx0Ly8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiBmb3IgYW5kIHNlbGVjdCBiZWdpbm5pbmdzLlxuXHRcdCdmb3Itb3Itc2VsZWN0Jzoge1xuXHRcdFx0cGF0dGVybjogLyhcXGIoPzpmb3J8c2VsZWN0KVxccyspXFx3Kyg/PVxccytpblxccykvLFxuXHRcdFx0YWxpYXM6ICd2YXJpYWJsZScsXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIHRoZSBsZWZ0LWhhbmQgcGFydFxuXHRcdC8vIG9mIGFzc2lnbm1lbnRzICjigJw94oCdIGFuZCDigJwrPeKAnSkuXG5cdFx0J2Fzc2lnbi1sZWZ0Jzoge1xuXHRcdFx0cGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpXFx3Kyg/OlxcLlxcdyspKig/PVxcKz89KS8sXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2Vudmlyb25tZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnKF58W1xcXFxzO3wmXXxbPD5dXFxcXCgpJyArIGVudlZhcnMpLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsaWFzOiAndmFyaWFibGUnLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0Ly8gSGlnaGxpZ2h0IHBhcmFtZXRlciBuYW1lcyBhcyB2YXJpYWJsZXNcblx0XHQncGFyYW1ldGVyJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFxccyktezEsMn0oPzpcXHcrOlsrLV0/KT9cXHcrKD86XFwuXFx3KykqKD89Wz1cXHNdfCQpLyxcblx0XHRcdGFsaWFzOiAndmFyaWFibGUnLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3N0cmluZyc6IFtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIEhlcmUtZG9jdW1lbnRzIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcmVfZG9jdW1lbnRcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFtePF0pPDwtP1xccyopKFxcdyspXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMi8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVTdHJpbmdcblx0XHRcdH0sXG5cdFx0XHQvLyBIZXJlLWRvY3VtZW50IHdpdGggcXVvdGVzIGFyb3VuZCB0aGUgdGFnXG5cdFx0XHQvLyDihpIgTm8gZXhwYW5zaW9uIChzbyBubyDigJxpbnNpZGXigJ0pLlxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoW1wiJ10pKFxcdyspXFwyXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J2Jhc2gnOiBjb21tYW5kQWZ0ZXJIZXJlZG9jXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyDigJxOb3JtYWzigJ0gc3RyaW5nXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuXHRcdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSg/OlxcXFxcXFxcKSopXCIoPzpcXFxcW1xcc1xcU118XFwkXFwoW14pXStcXCl8XFwkKD8hXFwoKXxgW15gXStgfFteXCJcXFxcYCRdKSpcIi8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVTdHJpbmdcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NpbmdsZS1RdW90ZXMuaHRtbFxuXHRcdFx0XHRwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcblx0XHRcdFx0cGF0dGVybjogL1xcJCcoPzpbXidcXFxcXXxcXFxcW1xcc1xcU10pKicvLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdlbnRpdHknOiBpbnNpZGVTdHJpbmcuZW50aXR5XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdLFxuXHRcdCdlbnZpcm9ubWVudCc6IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuXHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHR9LFxuXHRcdCd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcblx0XHQnZnVuY3Rpb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2FyZ298Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGphdmF8am9ic3xqb2lufGtpbGx8a2lsbGFsbHxsZXNzfGxpbmt8bG58bG9jYXRlfGxvZ25hbWV8bG9ncm90YXRlfGxvb2t8bHBjfGxwcnxscHJpbnR8bHByaW50ZHxscHJpbnRxfGxwcm18bHN8bHNvZnxseW54fG1ha2V8bWFufG1jfG1kYWRtfG1rY29uZmlnfG1rZGlyfG1rZTJmc3xta2ZpZm98bWtmc3xta2lzb2ZzfG1rbm9kfG1rc3dhcHxtbXZ8bW9yZXxtb3N0fG1vdW50fG10b29sc3xtdHJ8bXV0dHxtdnxuYW5vfG5jfG5ldHN0YXR8bmljZXxubHxub2RlfG5vaHVwfG5vdGlmeS1zZW5kfG5wbXxuc2xvb2t1cHxvcHxvcGVufHBhcnRlZHxwYXNzd2R8cGFzdGV8cGF0aGNoa3xwaW5nfHBraWxsfHBucG18cG9kbWFufHBvZG1hbi1jb21wb3NlfHBvcGR8cHJ8cHJpbnRjYXB8cHJpbnRlbnZ8cHN8cHVzaGR8cHZ8cXVvdGF8cXVvdGFjaGVja3xxdW90YWN0bHxyYW18cmFyfHJjcHxyZWJvb3R8cmVtc3luY3xyZW5hbWV8cmVuaWNlfHJldnxybXxybWRpcnxycG18cnN5bmN8c2NwfHNjcmVlbnxzZGlmZnxzZWR8c2VuZG1haWx8c2VxfHNlcnZpY2V8c2Z0cHxzaHxzaGVsbGNoZWNrfHNodWZ8c2h1dGRvd258c2xlZXB8c2xvY2F0ZXxzb3J0fHNwbGl0fHNzaHxzdGF0fHN0cmFjZXxzdXxzdWRvfHN1bXxzdXNwZW5kfHN3YXBvbnxzeW5jfHN5c2N0bHx0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2tleXdvcmQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcblx0XHQnYnVpbHRpbic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Ly8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuXHRcdFx0YWxpYXM6ICdjbGFzcy1uYW1lJ1xuXHRcdH0sXG5cdFx0J2Jvb2xlYW4nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnZmlsZS1kZXNjcmlwdG9yJzoge1xuXHRcdFx0cGF0dGVybjogL1xcQiZcXGRcXGIvLFxuXHRcdFx0YWxpYXM6ICdpbXBvcnRhbnQnXG5cdFx0fSxcblx0XHQnb3BlcmF0b3InOiB7XG5cdFx0XHQvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cblx0XHRcdHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmaWxlLWRlc2NyaXB0b3InOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL15cXGQvLFxuXHRcdFx0XHRcdGFsaWFzOiAnaW1wb3J0YW50J1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG5cdFx0J251bWJlcic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHR9O1xuXG5cdGNvbW1hbmRBZnRlckhlcmVkb2MuaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG5cblx0LyogUGF0dGVybnMgaW4gY29tbWFuZCBzdWJzdGl0dXRpb24uICovXG5cdHZhciB0b0JlQ29waWVkID0gW1xuXHRcdCdjb21tZW50Jyxcblx0XHQnZnVuY3Rpb24tbmFtZScsXG5cdFx0J2Zvci1vci1zZWxlY3QnLFxuXHRcdCdhc3NpZ24tbGVmdCcsXG5cdFx0J3BhcmFtZXRlcicsXG5cdFx0J3N0cmluZycsXG5cdFx0J2Vudmlyb25tZW50Jyxcblx0XHQnZnVuY3Rpb24nLFxuXHRcdCdrZXl3b3JkJyxcblx0XHQnYnVpbHRpbicsXG5cdFx0J2Jvb2xlYW4nLFxuXHRcdCdmaWxlLWRlc2NyaXB0b3InLFxuXHRcdCdvcGVyYXRvcicsXG5cdFx0J3B1bmN0dWF0aW9uJyxcblx0XHQnbnVtYmVyJ1xuXHRdO1xuXHR2YXIgaW5zaWRlID0gaW5zaWRlU3RyaW5nLnZhcmlhYmxlWzFdLmluc2lkZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b0JlQ29waWVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0aW5zaWRlW3RvQmVDb3BpZWRbaV1dID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2hbdG9CZUNvcGllZFtpXV07XG5cdH1cblxuXHRQcmlzbS5sYW5ndWFnZXMuc2ggPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcblx0UHJpc20ubGFuZ3VhZ2VzLnNoZWxsID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG59KFByaXNtKSk7XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0dmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcblx0XHQnY29tbWVudCc6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLyxcblx0XHQnYXRydWxlJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdAW1xcXFx3LV0oPzonICsgL1teO3tcXHNcIiddfFxccysoPyFcXHMpLy5zb3VyY2UgKyAnfCcgKyBzdHJpbmcuc291cmNlICsgJykqPycgKyAvKD86O3woPz1cXHMqXFx7KSkvLnNvdXJjZSksXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3J1bGUnOiAvXkBbXFx3LV0rLyxcblx0XHRcdFx0J3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdGFsaWFzOiAnc2VsZWN0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdrZXl3b3JkJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHRcdH1cblx0XHR9LFxuXHRcdCd1cmwnOiB7XG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmdW5jdGlvbic6IC9edXJsL2ksXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuXHRcdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcblx0XHRcdFx0XHRhbGlhczogJ3VybCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3NlbGVjdG9yJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogc3RyaW5nLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQncHJvcGVydHknOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG5cdFx0J2Z1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuXG5cdHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRpZiAobWFya3VwKSB7XG5cdFx0bWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcblx0XHRtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdH1cblxufShQcmlzbSkpO1xuIiwiUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcblx0J2NsYXNzLW5hbWUnOiBbXG5cdFx0UHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXC4oPzpjb25zdHJ1Y3Rvcnxwcm90b3R5cGUpKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQna2V5d29yZCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKCg/Ol58XFx9KVxccyopY2F0Y2hcXGIvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteLl18XFwuXFwuXFwuXFxzKilcXGIoPzphc3xhc3NlcnQoPz1cXHMqXFx7KXxhc3luYyg/PVxccyooPzpmdW5jdGlvblxcYnxcXCh8WyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseSg/PVxccyooPzpcXHt8JCkpfGZvcnxmcm9tKD89XFxzKig/OlsnXCJdfCQpKXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccyooPzpbI1xcWyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdF0sXG5cdC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuXHQnZnVuY3Rpb24nOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG5cdCdudW1iZXInOiB7XG5cdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0LyhefFteXFx3JF0pLy5zb3VyY2UgK1xuXHRcdFx0Jyg/OicgK1xuXHRcdFx0KFxuXHRcdFx0XHQvLyBjb25zdGFudFxuXHRcdFx0XHQvTmFOfEluZmluaXR5Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBiaW5hcnkgaW50ZWdlclxuXHRcdFx0XHQvMFtiQl1bMDFdKyg/Ol9bMDFdKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIG9jdGFsIGludGVnZXJcblx0XHRcdFx0LzBbb09dWzAtN10rKD86X1swLTddKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGhleGFkZWNpbWFsIGludGVnZXJcblx0XHRcdFx0LzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGRlY2ltYWwgYmlnaW50XG5cdFx0XHRcdC9cXGQrKD86X1xcZCspKm4vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGRlY2ltYWwgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSBidXQgbm8gYmlnaW50XG5cdFx0XHRcdC8oPzpcXGQrKD86X1xcZCspKig/OlxcLig/OlxcZCsoPzpfXFxkKykqKT8pP3xcXC5cXGQrKD86X1xcZCspKikoPzpbRWVdWystXT9cXGQrKD86X1xcZCspKik/Ly5zb3VyY2Vcblx0XHRcdCkgK1xuXHRcdFx0JyknICtcblx0XHRcdC8oPyFbXFx3JF0pLy5zb3VyY2Vcblx0XHQpLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2NsYXNzLW5hbWUnXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3KVxccyspW1xcdy5cXFxcXSsvO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG5cdCdyZWdleCc6IHtcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvLyBsb29rYmVoaW5kXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWR1cGUtY2hhcmFjdGVycy1jaGFyYWN0ZXItY2xhc3Ncblx0XHRcdC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKikvLnNvdXJjZSArXG5cdFx0XHQvLyBSZWdleCBwYXR0ZXJuOlxuXHRcdFx0Ly8gVGhlcmUgYXJlIDIgcmVnZXggcGF0dGVybnMgaGVyZS4gVGhlIFJlZ0V4cCBzZXQgbm90YXRpb24gcHJvcG9zYWwgYWRkZWQgc3VwcG9ydCBmb3IgbmVzdGVkIGNoYXJhY3RlclxuXHRcdFx0Ly8gY2xhc3NlcyBpZiB0aGUgYHZgIGZsYWcgaXMgcHJlc2VudC4gVW5mb3J0dW5hdGVseSwgbmVzdGVkIENDcyBhcmUgYm90aCBjb250ZXh0LWZyZWUgYW5kIGluY29tcGF0aWJsZVxuXHRcdFx0Ly8gd2l0aCB0aGUgb25seSBzeW50YXgsIHNvIHdlIGhhdmUgdG8gZGVmaW5lIDIgZGlmZmVyZW50IHJlZ2V4IHBhdHRlcm5zLlxuXHRcdFx0L1xcLy8uc291cmNlICtcblx0XHRcdCcoPzonICtcblx0XHRcdC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9Ly5zb3VyY2UgK1xuXHRcdFx0J3wnICtcblx0XHRcdC8vIGB2YCBmbGFnIHN5bnRheC4gVGhpcyBzdXBwb3J0cyAzIGxldmVscyBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzZXMuXG5cdFx0XHQvKD86XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXSkqXFxdKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9dltkZ2lteXVzXXswLDd9Ly5zb3VyY2UgK1xuXHRcdFx0JyknICtcblx0XHRcdC8vIGxvb2thaGVhZFxuXHRcdFx0Lyg/PSg/Olxcc3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcLykqKD86JHxbXFxyXFxuLC47On0pXFxdXXxcXC9cXC8pKS8uc291cmNlXG5cdFx0KSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdyZWdleC1zb3VyY2UnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9eKFxcLylbXFxzXFxTXSsoPz1cXC9bYS16XSokKS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuXHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5yZWdleFxuXHRcdFx0fSxcblx0XHRcdCdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcblx0XHRcdCdyZWdleC1mbGFncyc6IC9eW2Etel0rJC8sXG5cdFx0fVxuXHR9LFxuXHQvLyBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGtleXdvcmQgYmVjYXVzZSB3ZSB1c2UgXCJmdW5jdGlvblwiIGluc2lkZSB0aGUgbG9vay1mb3J3YXJkXG5cdCdmdW5jdGlvbi12YXJpYWJsZSc6IHtcblx0XHRwYXR0ZXJuOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXwoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKVxccyo9PikpLyxcblx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHR9LFxuXHQncGFyYW1ldGVyJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKj0+KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKj0+KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyopXFwoXFxzKnxcXF1cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKlxceykvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9XG5cdF0sXG5cdCdjb25zdGFudCc6IC9cXGJbQS1aXSg/OltBLVpfXXxcXGR4PykqXFxiL1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuXHQnaGFzaGJhbmcnOiB7XG5cdFx0cGF0dGVybjogL14jIS4qLyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0YWxpYXM6ICdjb21tZW50J1xuXHR9LFxuXHQndGVtcGxhdGUtc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfXwoPyFcXCRcXHspW15cXFxcYF0pKmAvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0cGF0dGVybjogL15gfGAkLyxcblx0XHRcdFx0YWxpYXM6ICdzdHJpbmcnXG5cdFx0XHR9LFxuXHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRcdHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHR9XG5cdH0sXG5cdCdzdHJpbmctcHJvcGVydHknOiB7XG5cdFx0cGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMig/PVxccyo6KS9tLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAncHJvcGVydHknXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuXHQnbGl0ZXJhbC1wcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvbSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGFsaWFzOiAncHJvcGVydHknXG5cdH0sXG59KTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTtcblxuXHQvLyBhZGQgYXR0cmlidXRlIHN1cHBvcnQgZm9yIGFsbCBET00gZXZlbnRzLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMjU3RhbmRhcmRfZXZlbnRzXG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZShcblx0XHQvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLFxuXHRcdCdqYXZhc2NyaXB0J1xuXHQpO1xufVxuXG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcbiIsIi8vIGh0dHBzOi8vd3d3Lmpzb24ub3JnL2pzb24tZW4uaHRtbFxuUHJpc20ubGFuZ3VhZ2VzLmpzb24gPSB7XG5cdCdwcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIoPz1cXHMqOikvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD8hXFxzKjopLyxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY29tbWVudCc6IHtcblx0XHRwYXR0ZXJuOiAvXFwvXFwvLip8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdudW1iZXInOiAvLT9cXGJcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG5cdCdwdW5jdHVhdGlvbic6IC9be31bXFxdLF0vLFxuXHQnb3BlcmF0b3InOiAvOi8sXG5cdCdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcblx0J251bGwnOiB7XG5cdFx0cGF0dGVybjogL1xcYm51bGxcXGIvLFxuXHRcdGFsaWFzOiAna2V5d29yZCdcblx0fVxufTtcblxuUHJpc20ubGFuZ3VhZ2VzLndlYm1hbmlmZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmpzb247XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0dmFyIGphdmFzY3JpcHQgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcblxuXHR2YXIgc3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qKD8hLil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKVxcKlxcLykvLnNvdXJjZTtcblx0dmFyIGJyYWNlcyA9IC8oPzpcXHsoPzpcXHsoPzpcXHtbXnt9XSpcXH18W157fV0pKlxcfXxbXnt9XSkqXFx9KS8uc291cmNlO1xuXHR2YXIgc3ByZWFkID0gLyg/OlxcezxTPipcXC57M30oPzpbXnt9XXw8QlJBQ0VTPikqXFx9KS8uc291cmNlO1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG5cdCAqL1xuXHRmdW5jdGlvbiByZShzb3VyY2UsIGZsYWdzKSB7XG5cdFx0c291cmNlID0gc291cmNlXG5cdFx0XHQucmVwbGFjZSgvPFM+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwYWNlOyB9KVxuXHRcdFx0LnJlcGxhY2UoLzxCUkFDRVM+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJyYWNlczsgfSlcblx0XHRcdC5yZXBsYWNlKC88U1BSRUFEPi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzcHJlYWQ7IH0pO1xuXHRcdHJldHVybiBSZWdFeHAoc291cmNlLCBmbGFncyk7XG5cdH1cblxuXHRzcHJlYWQgPSByZShzcHJlYWQpLnNvdXJjZTtcblxuXG5cdFByaXNtLmxhbmd1YWdlcy5qc3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCBqYXZhc2NyaXB0KTtcblx0UHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcucGF0dGVybiA9IHJlKFxuXHRcdC88XFwvPyg/OltcXHcuOi1dKyg/OjxTPisoPzpbXFx3LjokLV0rKD86PSg/OlwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCJ8Jyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJ3xbXlxcc3snXCIvPj1dK3w8QlJBQ0VTPikpP3w8U1BSRUFEPikpKjxTPipcXC8/KT8+Ly5zb3VyY2Vcblx0KTtcblxuXHRQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ3RhZyddLnBhdHRlcm4gPSAvXjxcXC8/W15cXHM+XFwvXSovO1xuXHRQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2F0dHItdmFsdWUnXS5wYXR0ZXJuID0gLz0oPyFcXHspKD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzJ1wiPl0rKS87XG5cdFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10uaW5zaWRlWydjbGFzcy1uYW1lJ10gPSAvXltBLVpdXFx3Kig/OlxcLltBLVpdXFx3KikqJC87XG5cdFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnY29tbWVudCddID0gamF2YXNjcmlwdFsnY29tbWVudCddO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdhdHRyLW5hbWUnLCB7XG5cdFx0J3NwcmVhZCc6IHtcblx0XHRcdHBhdHRlcm46IHJlKC88U1BSRUFEPi8uc291cmNlKSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuXHRcdH1cblx0fSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdzcGVjaWFsLWF0dHInLCB7XG5cdFx0J3NjcmlwdCc6IHtcblx0XHRcdC8vIEFsbG93IGZvciB0d28gbGV2ZWxzIG9mIG5lc3Rpbmdcblx0XHRcdHBhdHRlcm46IHJlKC89PEJSQUNFUz4vLnNvdXJjZSksXG5cdFx0XHRhbGlhczogJ2xhbmd1YWdlLWphdmFzY3JpcHQnLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdzY3JpcHQtcHVuY3R1YXRpb24nOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL149KD89XFx7KS8sXG5cdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuXHRcdFx0fSxcblx0XHR9XG5cdH0sIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnKTtcblxuXHQvLyBUaGUgZm9sbG93aW5nIHdpbGwgaGFuZGxlIHBsYWluIHRleHQgaW5zaWRlIHRhZ3Ncblx0dmFyIHN0cmluZ2lmeVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG5cdFx0aWYgKCF0b2tlbikge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gdG9rZW4uY29udGVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRva2VuLmNvbnRlbnQubWFwKHN0cmluZ2lmeVRva2VuKS5qb2luKCcnKTtcblx0fTtcblxuXHR2YXIgd2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcblx0XHR2YXIgb3BlbmVkVGFncyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cdFx0XHR2YXIgbm90VGFnTm9yQnJhY2UgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYgKHRva2VuLnR5cGUgPT09ICd0YWcnICYmIHRva2VuLmNvbnRlbnRbMF0gJiYgdG9rZW4uY29udGVudFswXS50eXBlID09PSAndGFnJykge1xuXHRcdFx0XHRcdC8vIFdlIGZvdW5kIGEgdGFnLCBub3cgZmluZCBpdHMga2luZFxuXG5cdFx0XHRcdFx0aWYgKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFswXS5jb250ZW50ID09PSAnPC8nKSB7XG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHRhZ1xuXHRcdFx0XHRcdFx0aWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0udGFnTmFtZSA9PT0gc3RyaW5naWZ5VG9rZW4odG9rZW4uY29udGVudFswXS5jb250ZW50WzFdKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBQb3AgbWF0Y2hpbmcgb3BlbmluZyB0YWdcblx0XHRcdFx0XHRcdFx0b3BlbmVkVGFncy5wb3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHRva2VuLmNvbnRlbnRbdG9rZW4uY29udGVudC5sZW5ndGggLSAxXS5jb250ZW50ID09PSAnLz4nKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEF1dG9jbG9zZWQgdGFnLCBpZ25vcmVcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIE9wZW5pbmcgdGFnXG5cdFx0XHRcdFx0XHRcdG9wZW5lZFRhZ3MucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0dGFnTmFtZTogc3RyaW5naWZ5VG9rZW4odG9rZW4uY29udGVudFswXS5jb250ZW50WzFdKSxcblx0XHRcdFx0XHRcdFx0XHRvcGVuZWRCcmFjZXM6IDBcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd7Jykge1xuXG5cdFx0XHRcdFx0Ly8gSGVyZSB3ZSBtaWdodCBoYXZlIGVudGVyZWQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcblx0XHRcdFx0XHRvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzKys7XG5cblx0XHRcdFx0fSBlbHNlIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcyA+IDAgJiYgdG9rZW4udHlwZSA9PT0gJ3B1bmN0dWF0aW9uJyAmJiB0b2tlbi5jb250ZW50ID09PSAnfScpIHtcblxuXHRcdFx0XHRcdC8vIEhlcmUgd2UgbWlnaHQgaGF2ZSBsZWZ0IGEgSlNYIGNvbnRleHQgaW5zaWRlIGEgdGFnXG5cdFx0XHRcdFx0b3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcy0tO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm90VGFnTm9yQnJhY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobm90VGFnTm9yQnJhY2UgfHwgdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPT09IDApIHtcblx0XHRcdFx0XHQvLyBIZXJlIHdlIGFyZSBpbnNpZGUgYSB0YWcsIGFuZCBub3QgaW5zaWRlIGEgSlNYIGNvbnRleHQuXG5cdFx0XHRcdFx0Ly8gVGhhdCdzIHBsYWluIHRleHQ6IGRyb3AgYW55IHRva2VucyBtYXRjaGVkLlxuXHRcdFx0XHRcdHZhciBwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbik7XG5cblx0XHRcdFx0XHQvLyBBbmQgbWVyZ2UgdGV4dCB3aXRoIGFkamFjZW50IHRleHRcblx0XHRcdFx0XHRpZiAoaSA8IHRva2Vucy5sZW5ndGggLSAxICYmICh0eXBlb2YgdG9rZW5zW2kgKyAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG5cdFx0XHRcdFx0XHRwbGFpblRleHQgKz0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgKyAxXSk7XG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmICh0eXBlb2YgdG9rZW5zW2kgLSAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgLSAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG5cdFx0XHRcdFx0XHRwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbnNbaSAtIDFdKSArIHBsYWluVGV4dDtcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSAtIDEsIDEpO1xuXHRcdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRva2Vuc1tpXSA9IG5ldyBQcmlzbS5Ub2tlbigncGxhaW4tdGV4dCcsIHBsYWluVGV4dCwgbnVsbCwgcGxhaW5UZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0d2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0UHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHRpZiAoZW52Lmxhbmd1YWdlICE9PSAnanN4JyAmJiBlbnYubGFuZ3VhZ2UgIT09ICd0c3gnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG5cdH0pO1xuXG59KFByaXNtKSk7XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UgaWQgYW5kIGluZGV4LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2Vcblx0ICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGluZGV4KSB7XG5cdFx0cmV0dXJuICdfX18nICsgbGFuZ3VhZ2UudG9VcHBlckNhc2UoKSArIGluZGV4ICsgJ19fXyc7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10gPSB7fSwge1xuXHRcdGJ1aWxkUGxhY2Vob2xkZXJzOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFRva2VuaXplIGFsbCBpbmxpbmUgdGVtcGxhdGluZyBleHByZXNzaW9ucyBtYXRjaGluZyBgcGxhY2Vob2xkZXJQYXR0ZXJuYC5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBgcmVwbGFjZUZpbHRlcmAgaXMgcHJvdmlkZWQsIG9ubHkgbWF0Y2hlcyBvZiBgcGxhY2Vob2xkZXJQYXR0ZXJuYCBmb3Igd2hpY2ggYHJlcGxhY2VGaWx0ZXJgIHJldHVybnNcblx0XHRcdCAqIGB0cnVlYCB3aWxsIGJlIHJlcGxhY2VkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYmVmb3JlLXRva2VuaXplYCBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZC5cblx0XHRcdCAqIEBwYXJhbSB7UmVnRXhwfSBwbGFjZWhvbGRlclBhdHRlcm4gVGhlIG1hdGNoZXMgb2YgdGhpcyBwYXR0ZXJuIHdpbGwgYmUgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzLlxuXHRcdFx0ICogQHBhcmFtIHsobWF0Y2g6IHN0cmluZykgPT4gYm9vbGVhbn0gW3JlcGxhY2VGaWx0ZXJdXG5cdFx0XHQgKi9cblx0XHRcdHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSwgcGxhY2Vob2xkZXJQYXR0ZXJuLCByZXBsYWNlRmlsdGVyKSB7XG5cdFx0XHRcdGlmIChlbnYubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRva2VuU3RhY2sgPSBlbnYudG9rZW5TdGFjayA9IFtdO1xuXG5cdFx0XHRcdGVudi5jb2RlID0gZW52LmNvZGUucmVwbGFjZShwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmVwbGFjZUZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhcmVwbGFjZUZpbHRlcihtYXRjaCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGkgPSB0b2tlblN0YWNrLmxlbmd0aDtcblx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBmb3IgZXhpc3Rpbmcgc3RyaW5nc1xuXHRcdFx0XHRcdHdoaWxlIChlbnYuY29kZS5pbmRleE9mKHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGkpKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdCsraTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDcmVhdGUgYSBzcGFyc2UgYXJyYXlcblx0XHRcdFx0XHR0b2tlblN0YWNrW2ldID0gbWF0Y2g7XG5cblx0XHRcdFx0XHRyZXR1cm4gcGxhY2Vob2xkZXI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFN3aXRjaCB0aGUgZ3JhbW1hciB0byBtYXJrdXBcblx0XHRcdFx0ZW52LmdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dG9rZW5pemVQbGFjZWhvbGRlcnM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBwcm9wZXIgdG9rZW5zIGFmdGVyIHRva2VuaXppbmcuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBhZnRlci10b2tlbml6ZWAgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQuXG5cdFx0XHQgKi9cblx0XHRcdHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSkge1xuXHRcdFx0XHRpZiAoZW52Lmxhbmd1YWdlICE9PSBsYW5ndWFnZSB8fCAhZW52LnRva2VuU3RhY2spIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTd2l0Y2ggdGhlIGdyYW1tYXIgYmFja1xuXHRcdFx0XHRlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cblx0XHRcdFx0dmFyIGogPSAwO1xuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudi50b2tlblN0YWNrKTtcblxuXHRcdFx0XHRmdW5jdGlvbiB3YWxrVG9rZW5zKHRva2Vucykge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHQvLyBhbGwgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCBhbHJlYWR5XG5cdFx0XHRcdFx0XHRpZiAoaiA+PSBrZXlzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgKHRva2VuLmNvbnRlbnQgJiYgdHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgayA9IGtleXNbal07XG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gZW52LnRva2VuU3RhY2tba107XG5cdFx0XHRcdFx0XHRcdHZhciBzID0gdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyA/IHRva2VuIDogdG9rZW4uY29udGVudDtcblx0XHRcdFx0XHRcdFx0dmFyIHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGspO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRleCA9IHMuaW5kZXhPZihwbGFjZWhvbGRlcik7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0KytqO1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHMuc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWlkZGxlID0gbmV3IFByaXNtLlRva2VuKGxhbmd1YWdlLCBQcmlzbS50b2tlbml6ZSh0LCBlbnYuZ3JhbW1hciksICdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UsIHQpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcblxuXHRcdFx0XHRcdFx0XHRcdHZhciByZXBsYWNlbWVudCA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIHdhbGtUb2tlbnMoW2JlZm9yZV0pKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmVwbGFjZW1lbnQucHVzaChtaWRkbGUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgd2Fsa1Rva2VucyhbYWZ0ZXJdKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLCBbaSwgMV0uY29uY2F0KHJlcGxhY2VtZW50KSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRva2VuLmNvbnRlbnQgPSByZXBsYWNlbWVudDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodG9rZW4uY29udGVudCAvKiAmJiB0eXBlb2YgdG9rZW4uY29udGVudCAhPT0gJ3N0cmluZycgKi8pIHtcblx0XHRcdFx0XHRcdFx0d2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG59KFByaXNtKSk7XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cdHZhciB0eXBlc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCk7XG5cdFByaXNtLmxhbmd1YWdlcy50c3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqc3gnLCB0eXBlc2NyaXB0KTtcblxuXHQvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG5cdGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydwYXJhbWV0ZXInXTtcblx0ZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuXHQvLyBUaGlzIHdpbGwgcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gVFNYIHRhZ3MgYW5kIFRTIGdlbmVyaWMgdHlwZXMuXG5cdC8vIElkZWEgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcmxob3JreVxuXHQvLyBEaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjU5NCNpc3N1ZWNvbW1lbnQtNzEwNjY2OTI4XG5cdHZhciB0YWcgPSBQcmlzbS5sYW5ndWFnZXMudHN4LnRhZztcblx0dGFnLnBhdHRlcm4gPSBSZWdFeHAoLyhefFteXFx3JF18KD89PFxcLykpLy5zb3VyY2UgKyAnKD86JyArIHRhZy5wYXR0ZXJuLnNvdXJjZSArICcpJywgdGFnLnBhdHRlcm4uZmxhZ3MpO1xuXHR0YWcubG9va2JlaGluZCA9IHRydWU7XG59KFByaXNtKSk7XG4iLCIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqYXZhc2NyaXB0Jywge1xuXHRcdCdjbGFzcy1uYW1lJzoge1xuXHRcdFx0cGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHR5cGUpXFxzKykoPyFrZXlvZlxcYikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD86XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4pPy8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXHRcdH0sXG5cdFx0J2J1aWx0aW4nOiAvXFxiKD86QXJyYXl8RnVuY3Rpb258UHJvbWlzZXxhbnl8Ym9vbGVhbnxjb25zb2xlfG5ldmVyfG51bWJlcnxzdHJpbmd8c3ltYm9sfHVua25vd24pXFxiLyxcblx0fSk7XG5cblx0Ly8gVGhlIGtleXdvcmRzIFR5cGVTY3JpcHQgYWRkcyB0byBKYXZhU2NyaXB0XG5cdFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0LmtleXdvcmQucHVzaChcblx0XHQvXFxiKD86YWJzdHJhY3R8ZGVjbGFyZXxpc3xrZXlvZnxyZWFkb25seXxyZXF1aXJlKVxcYi8sXG5cdFx0Ly8ga2V5d29yZHMgdGhhdCBoYXZlIHRvIGJlIGZvbGxvd2VkIGJ5IGFuIGlkZW50aWZpZXJcblx0XHQvXFxiKD86YXNzZXJ0c3xpbmZlcnxpbnRlcmZhY2V8bW9kdWxlfG5hbWVzcGFjZXx0eXBlKVxcYig/PVxccyooPzpbe18kYS16QS1aXFx4QTAtXFx1RkZGRl18JCkpLyxcblx0XHQvLyBUaGlzIGlzIGZvciBgaW1wb3J0IHR5cGUgKiwge31gXG5cdFx0L1xcYnR5cGVcXGIoPz1cXHMqKD86W1xceypdfCQpKS9cblx0KTtcblxuXHQvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG5cdGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsncGFyYW1ldGVyJ107XG5cdGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsnbGl0ZXJhbC1wcm9wZXJ0eSddO1xuXG5cdC8vIGEgdmVyc2lvbiBvZiB0eXBlc2NyaXB0IHNwZWNpZmljYWxseSBmb3IgaGlnaGxpZ2h0aW5nIHR5cGVzXG5cdHZhciB0eXBlSW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgndHlwZXNjcmlwdCcsIHt9KTtcblx0ZGVsZXRlIHR5cGVJbnNpZGVbJ2NsYXNzLW5hbWUnXTtcblxuXHRQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsnY2xhc3MtbmFtZSddLmluc2lkZSA9IHR5cGVJbnNpZGU7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcblx0XHQnZGVjb3JhdG9yJzoge1xuXHRcdFx0cGF0dGVybjogL0BbJFxcd1xceEEwLVxcdUZGRkZdKy8sXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2F0Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC9eQC8sXG5cdFx0XHRcdFx0YWxpYXM6ICdvcGVyYXRvcidcblx0XHRcdFx0fSxcblx0XHRcdFx0J2Z1bmN0aW9uJzogL15bXFxzXFxTXSsvXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnZ2VuZXJpYy1mdW5jdGlvbic6IHtcblx0XHRcdC8vIGUuZy4gZm9vPFQgZXh0ZW5kcyBcImJhclwiIHwgXCJiYXpcIj4oIC4uLlxuXHRcdFx0cGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KD89XFxzKlxcKCkvLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmdW5jdGlvbic6IC9eIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLyxcblx0XHRcdFx0J2dlbmVyaWMnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLzxbXFxzXFxTXSsvLCAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA8XG5cdFx0XHRcdFx0YWxpYXM6ICdjbGFzcy1uYW1lJyxcblx0XHRcdFx0XHRpbnNpZGU6IHR5cGVJbnNpZGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG5cbn0oUHJpc20pKTtcbiIsIihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHQvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFuY2hvci1wcm9wZXJ0eVxuXHQvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFsaWFzLW5vZGVcblx0dmFyIGFuY2hvck9yQWxpYXMgPSAvWyomXVteXFxzW1xcXXt9LF0rLztcblx0Ly8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy10YWctcHJvcGVydHlcblx0dmFyIHRhZyA9IC8hKD86PFtcXHdcXC0lIzsvPzpAJj0rJCwuIX4qJygpW1xcXV0rPnwoPzpbYS16QS1aXFxkLV0qISk/W1xcd1xcLSUjOy8/OkAmPSskLn4qJygpXSspPy87XG5cdC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtcHJvcGVydGllcyhuLGMpXG5cdHZhciBwcm9wZXJ0aWVzID0gJyg/OicgKyB0YWcuc291cmNlICsgJyg/OlsgXFx0XSsnICsgYW5jaG9yT3JBbGlhcy5zb3VyY2UgKyAnKT98J1xuXHRcdCsgYW5jaG9yT3JBbGlhcy5zb3VyY2UgKyAnKD86WyBcXHRdKycgKyB0YWcuc291cmNlICsgJyk/KSc7XG5cdC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI25zLXBsYWluKG4sYylcblx0Ly8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBcIiNcIiBhbmQgbXVsdGlsaW5lIGtleXNcblx0Ly8gQWxsIHRoZXNlIGxvbmcgc2NhcnJ5IGNoYXJhY3RlciBjbGFzc2VzIGFyZSBzaW1wbGlmaWVkIHZlcnNpb25zIG9mIFlBTUwncyBjaGFyYWN0ZXJzXG5cdHZhciBwbGFpbktleSA9IC8oPzpbXlxcc1xceDAwLVxceDA4XFx4MGUtXFx4MWYhXCIjJSYnKixcXC06Pj9AW1xcXWB7fH1cXHg3Zi1cXHg4NFxceDg2LVxceDlmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZdfFs/Oi1dPFBMQUlOPikoPzpbIFxcdF0qKD86KD8hWyM6XSk8UExBSU4+fDo8UExBSU4+KSkqLy5zb3VyY2Vcblx0XHQucmVwbGFjZSgvPFBMQUlOPi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiAvW15cXHNcXHgwMC1cXHgwOFxceDBlLVxceDFmLFtcXF17fVxceDdmLVxceDg0XFx4ODYtXFx4OWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZl0vLnNvdXJjZTsgfSk7XG5cdHZhciBzdHJpbmcgPSAvXCIoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKlwifCcoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqJy8uc291cmNlO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cblx0ICogQHJldHVybnMge1JlZ0V4cH1cblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZVZhbHVlUGF0dGVybih2YWx1ZSwgZmxhZ3MpIHtcblx0XHRmbGFncyA9IChmbGFncyB8fCAnJykucmVwbGFjZSgvbS9nLCAnJykgKyAnbSc7IC8vIGFkZCBtIGZsYWdcblx0XHR2YXIgcGF0dGVybiA9IC8oWzpcXC0sW3tdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/KSg/Ojw8dmFsdWU+PikoPz1bIFxcdF0qKD86JHwsfFxcXXxcXH18KD86W1xcclxcbl1cXHMqKT8jKSkvLnNvdXJjZVxuXHRcdFx0LnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXM7IH0pLnJlcGxhY2UoLzw8dmFsdWU+Pi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG5cdFx0cmV0dXJuIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG5cdH1cblxuXHRQcmlzbS5sYW5ndWFnZXMueWFtbCA9IHtcblx0XHQnc2NhbGFyJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKC8oW1xcLTpdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/W3w+XSlbIFxcdF0qKD86KCg/Olxccj9cXG58XFxyKVsgXFx0XSspXFxTW15cXHJcXG5dKig/OlxcMlteXFxyXFxuXSspKikvLnNvdXJjZVxuXHRcdFx0XHQucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcGVydGllczsgfSkpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdH0sXG5cdFx0J2NvbW1lbnQnOiAvIy4qLyxcblx0XHQna2V5Jzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKC8oKD86XnxbOlxcLSxbe1xcclxcbj9dKVsgXFx0XSooPzo8PHByb3A+PlsgXFx0XSspPyk8PGtleT4+KD89XFxzKjpcXHMpLy5zb3VyY2Vcblx0XHRcdFx0LnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3BlcnRpZXM7IH0pXG5cdFx0XHRcdC5yZXBsYWNlKC88PGtleT4+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcoPzonICsgcGxhaW5LZXkgKyAnfCcgKyBzdHJpbmcgKyAnKSc7IH0pKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRhbGlhczogJ2F0cnVsZSdcblx0XHR9LFxuXHRcdCdkaXJlY3RpdmUnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF5bIFxcdF0qKSUuKy9tLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnaW1wb3J0YW50J1xuXHRcdH0sXG5cdFx0J2RhdGV0aW1lJzoge1xuXHRcdFx0cGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9cXGR7NH0tXFxkXFxkPy1cXGRcXGQ/KD86W3RUXXxbIFxcdF0rKVxcZFxcZD86XFxkezJ9OlxcZHsyfSg/OlxcLlxcZCopPyg/OlsgXFx0XSooPzpafFstK11cXGRcXGQ/KD86OlxcZHsyfSk/KSk/fFxcZHs0fS1cXGR7Mn0tXFxkezJ9fFxcZFxcZD86XFxkezJ9KD86OlxcZHsyfSg/OlxcLlxcZCopPyk/Ly5zb3VyY2UpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnbnVtYmVyJ1xuXHRcdH0sXG5cdFx0J2Jvb2xlYW4nOiB7XG5cdFx0XHRwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL2ZhbHNlfHRydWUvLnNvdXJjZSwgJ2knKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRhbGlhczogJ2ltcG9ydGFudCdcblx0XHR9LFxuXHRcdCdudWxsJzoge1xuXHRcdFx0cGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9udWxsfH4vLnNvdXJjZSwgJ2knKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRhbGlhczogJ2ltcG9ydGFudCdcblx0XHR9LFxuXHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oc3RyaW5nKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdCdudW1iZXInOiB7XG5cdFx0XHRwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL1srLV0/KD86MHhbXFxkYS1mXSt8MG9bMC03XSt8KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspP3xcXC5pbmZ8XFwubmFuKS8uc291cmNlLCAnaScpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3RhZyc6IHRhZyxcblx0XHQnaW1wb3J0YW50JzogYW5jaG9yT3JBbGlhcyxcblx0XHQncHVuY3R1YXRpb24nOiAvLS0tfFs6W1xcXXt9XFwtLHw+P118XFwuXFwuXFwuL1xuXHR9O1xuXG5cdFByaXNtLmxhbmd1YWdlcy55bWwgPSBQcmlzbS5sYW5ndWFnZXMueWFtbDtcblxufShQcmlzbSkpO1xuIiwiXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNvcmUuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwiV2ViV29ya2VyXCIvPlxuXG52YXIgX3NlbGYgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpXG5cdD8gd2luZG93ICAgLy8gaWYgaW4gYnJvd3NlclxuXHQ6IChcblx0XHQodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpXG5cdFx0XHQ/IHNlbGYgLy8gaWYgaW4gd29ya2VyXG5cdFx0XHQ6IHt9ICAgLy8gaWYgaW4gbm9kZSBqc1xuXHQpO1xuXG4vKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBAbGljZW5zZSBNSVQgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPlxuICogQGF1dGhvciBMZWEgVmVyb3UgPGh0dHBzOi8vbGVhLnZlcm91Lm1lPlxuICogQG5hbWVzcGFjZVxuICogQHB1YmxpY1xuICovXG52YXIgUHJpc20gPSAoZnVuY3Rpb24gKF9zZWxmKSB7XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuXHR2YXIgbGFuZyA9IC8oPzpefFxccylsYW5nKD86dWFnZSk/LShbXFx3LV0rKSg/PVxcc3wkKS9pO1xuXHR2YXIgdW5pcXVlSWQgPSAwO1xuXG5cdC8vIFRoZSBncmFtbWFyIG9iamVjdCBmb3IgcGxhaW50ZXh0XG5cdHZhciBwbGFpblRleHRHcmFtbWFyID0ge307XG5cblxuXHR2YXIgXyA9IHtcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0LCBQcmlzbSB3aWxsIGF0dGVtcHQgdG8gaGlnaGxpZ2h0IGFsbCBjb2RlIGVsZW1lbnRzIChieSBjYWxsaW5nIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGx9KSBvbiB0aGVcblx0XHQgKiBjdXJyZW50IHBhZ2UgYWZ0ZXIgdGhlIHBhZ2UgZmluaXNoZWQgbG9hZGluZy4gVGhpcyBtaWdodCBiZSBhIHByb2JsZW0gaWYgZS5nLiB5b3Ugd2FudGVkIHRvIGFzeW5jaHJvbm91c2x5IGxvYWRcblx0XHQgKiBhZGRpdGlvbmFsIGxhbmd1YWdlcyBvciBwbHVnaW5zIHlvdXJzZWxmLlxuXHRcdCAqXG5cdFx0ICogQnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgUHJpc20gd2lsbCBub3QgYXV0b21hdGljYWxseSBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgb24gdGhlIHBhZ2UuXG5cdFx0ICpcblx0XHQgKiBZb3Ugb2J2aW91c2x5IGhhdmUgdG8gY2hhbmdlIHRoaXMgdmFsdWUgYmVmb3JlIHRoZSBhdXRvbWF0aWMgaGlnaGxpZ2h0aW5nIHN0YXJ0ZWQuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG5cdFx0ICogZW1wdHkgUHJpc20gb2JqZWN0IGludG8gdGhlIGdsb2JhbCBzY29wZSBiZWZvcmUgbG9hZGluZyB0aGUgUHJpc20gc2NyaXB0IGxpa2UgdGhpczpcblx0XHQgKlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogd2luZG93LlByaXNtID0gd2luZG93LlByaXNtIHx8IHt9O1xuXHRcdCAqIFByaXNtLm1hbnVhbCA9IHRydWU7XG5cdFx0ICogLy8gYWRkIGEgbmV3IDxzY3JpcHQ+IHRvIGxvYWQgUHJpc20ncyBzY3JpcHRcblx0XHQgKiBgYGBcblx0XHQgKlxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdG1hbnVhbDogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20ubWFudWFsLFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQsIGlmIFByaXNtIGlzIGluIGEgd2ViIHdvcmtlciwgaXQgYXNzdW1lcyB0aGF0IGl0IGlzIGluIGEgd29ya2VyIGl0IGNyZWF0ZWQgaXRzZWxmLCBzbyBpdCB1c2VzXG5cdFx0ICogYGFkZEV2ZW50TGlzdGVuZXJgIHRvIGNvbW11bmljYXRlIHdpdGggaXRzIHBhcmVudCBpbnN0YW5jZS4gSG93ZXZlciwgaWYgeW91J3JlIHVzaW5nIFByaXNtIG1hbnVhbGx5IGluIHlvdXJcblx0XHQgKiBvd24gd29ya2VyLCB5b3UgZG9uJ3Qgd2FudCBpdCB0byBkbyB0aGlzLlxuXHRcdCAqXG5cdFx0ICogQnkgc2V0dGluZyB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgUHJpc20gd2lsbCBub3QgYWRkIGl0cyBvd24gbGlzdGVuZXJzIHRvIHRoZSB3b3JrZXIuXG5cdFx0ICpcblx0XHQgKiBZb3Ugb2J2aW91c2x5IGhhdmUgdG8gY2hhbmdlIHRoaXMgdmFsdWUgYmVmb3JlIFByaXNtIGV4ZWN1dGVzLiBUbyBkbyB0aGlzLCB5b3UgY2FuIGFkZCBhblxuXHRcdCAqIGVtcHR5IFByaXNtIG9iamVjdCBpbnRvIHRoZSBnbG9iYWwgc2NvcGUgYmVmb3JlIGxvYWRpbmcgdGhlIFByaXNtIHNjcmlwdCBsaWtlIHRoaXM6XG5cdFx0ICpcblx0XHQgKiBgYGBqc1xuXHRcdCAqIHdpbmRvdy5QcmlzbSA9IHdpbmRvdy5QcmlzbSB8fCB7fTtcblx0XHQgKiBQcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIgPSB0cnVlO1xuXHRcdCAqIC8vIExvYWQgUHJpc20ncyBzY3JpcHRcblx0XHQgKiBgYGBcblx0XHQgKlxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcjogX3NlbGYuUHJpc20gJiYgX3NlbGYuUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyLFxuXG5cdFx0LyoqXG5cdFx0ICogQSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEFsbCBmdW5jdGlvbiBpbiB0aGlzIG5hbWVzcGFjZSB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBtYXJrZWQgYXMgX3B1YmxpY18gYXJlIGZvciBfX2ludGVybmFsIHVzZSBvbmx5X18gYW5kIG1heVxuXHRcdCAqIGNoYW5nZSBvciBkaXNhcHBlYXIgYXQgYW55IHRpbWUuXG5cdFx0ICpcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICovXG5cdFx0dXRpbDoge1xuXHRcdFx0ZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUodG9rZW5zKSB7XG5cdFx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIGVuY29kZSh0b2tlbnMuY29udGVudCksIHRva2Vucy5hbGlhcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5tYXAoZW5jb2RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gb1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB0eXBlKG51bGwpICAgICAgPT09ICdOdWxsJ1xuXHRcdFx0ICogdHlwZSh1bmRlZmluZWQpID09PSAnVW5kZWZpbmVkJ1xuXHRcdFx0ICogdHlwZSgxMjMpICAgICAgID09PSAnTnVtYmVyJ1xuXHRcdFx0ICogdHlwZSgnZm9vJykgICAgID09PSAnU3RyaW5nJ1xuXHRcdFx0ICogdHlwZSh0cnVlKSAgICAgID09PSAnQm9vbGVhbidcblx0XHRcdCAqIHR5cGUoWzEsIDJdKSAgICA9PT0gJ0FycmF5J1xuXHRcdFx0ICogdHlwZSh7fSkgICAgICAgID09PSAnT2JqZWN0J1xuXHRcdFx0ICogdHlwZShTdHJpbmcpICAgID09PSAnRnVuY3Rpb24nXG5cdFx0XHQgKiB0eXBlKC9hYmMrLykgICAgPT09ICdSZWdFeHAnXG5cdFx0XHQgKi9cblx0XHRcdHR5cGU6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIGEgdW5pcXVlIG51bWJlciBmb3IgdGhlIGdpdmVuIG9iamVjdC4gTGF0ZXIgY2FsbHMgd2lsbCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgbnVtYmVyLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0XHRcdG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdGlmICghb2JqWydfX2lkJ10pIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9ialsnX19pZCddO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIGludGVuZGVkIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGNsb25lIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7VH0gb1xuXHRcdFx0ICogQHBhcmFtIHtSZWNvcmQ8bnVtYmVyLCBhbnk+fSBbdmlzaXRlZF1cblx0XHRcdCAqIEByZXR1cm5zIHtUfVxuXHRcdFx0ICogQHRlbXBsYXRlIFRcblx0XHRcdCAqL1xuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uIGRlZXBDbG9uZShvLCB2aXNpdGVkKSB7XG5cdFx0XHRcdHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuXG5cdFx0XHRcdHZhciBjbG9uZTsgdmFyIGlkO1xuXHRcdFx0XHRzd2l0Y2ggKF8udXRpbC50eXBlKG8pKSB7XG5cdFx0XHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lW2tleV0gPSBkZWVwQ2xvbmUob1trZXldLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0KC8qKiBAdHlwZSB7QXJyYXl9ICovKC8qKiBAdHlwZSB7YW55fSAqLyhvKSkpLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVbaV0gPSBkZWVwQ2xvbmUodiwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIFByaXNtIGxhbmd1YWdlIG9mIHRoZSBnaXZlbiBlbGVtZW50IHNldCBieSBhIGBsYW5ndWFnZS14eHh4YCBvciBgbGFuZy14eHh4YCBjbGFzcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBubyBsYW5ndWFnZSBpcyBzZXQgZm9yIHRoZSBlbGVtZW50IG9yIHRoZSBlbGVtZW50IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgYG5vbmVgIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRnZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgbSA9IGxhbmcuZXhlYyhlbGVtZW50LmNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBtWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICdub25lJztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0cyB0aGUgUHJpc20gYGxhbmd1YWdlLXh4eHhgIGNsYXNzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG5cdFx0XHQgKiBAcmV0dXJucyB7dm9pZH1cblx0XHRcdCAqL1xuXHRcdFx0c2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50LCBsYW5ndWFnZSkge1xuXHRcdFx0XHQvLyByZW1vdmUgYWxsIGBsYW5ndWFnZS14eHh4YCBjbGFzc2VzXG5cdFx0XHRcdC8vICh0aGlzIG1pZ2h0IGxlYXZlIGJlaGluZCBhIGxlYWRpbmcgc3BhY2UpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShSZWdFeHAobGFuZywgJ2dpJyksICcnKTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIG5ldyBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Ncblx0XHRcdFx0Ly8gKHVzaW5nIGBjbGFzc0xpc3RgIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBzcGFjZXMgZm9yIHVzKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIHNjcmlwdCBlbGVtZW50IHRoYXQgaXMgY3VycmVudGx5IGV4ZWN1dGluZy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIGRvZXMgX19ub3RfXyB3b3JrIGZvciBsaW5lIHNjcmlwdCBlbGVtZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEByZXR1cm5zIHtIVE1MU2NyaXB0RWxlbWVudCB8IG51bGx9XG5cdFx0XHQgKi9cblx0XHRcdGN1cnJlbnRTY3JpcHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoJ2N1cnJlbnRTY3JpcHQnIGluIGRvY3VtZW50ICYmIDEgPCAyIC8qIGhhY2sgdG8gdHJpcCBUUycgZmxvdyBhbmFseXNpcyAqLykge1xuXHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSUUxMSB3b3JrYXJvdW5kXG5cdFx0XHRcdC8vIHdlJ2xsIGdldCB0aGUgc3JjIG9mIHRoZSBjdXJyZW50IHNjcmlwdCBieSBwYXJzaW5nIElFMTEncyBlcnJvciBzdGFjayB0cmFjZVxuXHRcdFx0XHQvLyB0aGlzIHdpbGwgbm90IHdvcmsgZm9yIGlubGluZSBzY3JpcHRzXG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IGZpbGUgc3JjIHVybCBmcm9tIHN0YWNrLiBTcGVjaWZpY2FsbHkgd29ya3Mgd2l0aCB0aGUgZm9ybWF0IG9mIHN0YWNrIHRyYWNlcyBpbiBJRS5cblx0XHRcdFx0XHQvLyBBIHN0YWNrIHdpbGwgbG9vayBsaWtlIHRoaXM6XG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBFcnJvclxuXHRcdFx0XHRcdC8vICAgIGF0IF8udXRpbC5jdXJyZW50U2NyaXB0IChodHRwOi8vbG9jYWxob3N0L2NvbXBvbmVudHMvcHJpc20tY29yZS5qczoxMTk6NSlcblx0XHRcdFx0XHQvLyAgICBhdCBHbG9iYWwgY29kZSAoaHR0cDovL2xvY2FsaG9zdC9jb21wb25lbnRzL3ByaXNtLWNvcmUuanM6NjA2OjEpXG5cblx0XHRcdFx0XHR2YXIgc3JjID0gKC9hdCBbXihcXHJcXG5dKlxcKCguKik6W146XSs6W146XStcXCkkL2kuZXhlYyhlcnIuc3RhY2spIHx8IFtdKVsxXTtcblx0XHRcdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgaW4gc2NyaXB0cykge1xuXHRcdFx0XHRcdFx0XHRpZiAoc2NyaXB0c1tpXS5zcmMgPT0gc3JjKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjcmlwdHNbaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB3aGV0aGVyIGEgZ2l2ZW4gY2xhc3MgaXMgYWN0aXZlIGZvciBgZWxlbWVudGAuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGNsYXNzIGNhbiBiZSBhY3RpdmF0ZWQgaWYgYGVsZW1lbnRgIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGl0IGNhbiBiZSBkZWFjdGl2YXRlZFxuXHRcdFx0ICogaWYgYGVsZW1lbnRgIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBjbGFzcy4gVGhlIF9uZWdhdGVkIHZlcnNpb25fIG9mIHRoZVxuXHRcdFx0ICogZ2l2ZW4gY2xhc3MgaXMganVzdCB0aGUgZ2l2ZW4gY2xhc3Mgd2l0aCBhIGBuby1gIHByZWZpeC5cblx0XHRcdCAqXG5cdFx0XHQgKiBXaGV0aGVyIHRoZSBjbGFzcyBpcyBhY3RpdmUgaXMgZGV0ZXJtaW5lZCBieSB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiBgZWxlbWVudGAgKHdoZXJlIGBlbGVtZW50YCBpdHNlbGYgaXNcblx0XHRcdCAqIGNsb3Nlc3QgYW5jZXN0b3IpIHRoYXQgaGFzIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LiBJZiBuZWl0aGVyIGBlbGVtZW50YCBub3IgYW55IG9mIGl0c1xuXHRcdFx0ICogYW5jZXN0b3JzIGhhdmUgdGhlIGdpdmVuIGNsYXNzIG9yIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgaXQsIHRoZW4gdGhlIGRlZmF1bHQgYWN0aXZhdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEluIHRoZSBwYXJhZG94aWNhbCBzaXR1YXRpb24gd2hlcmUgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgY29udGFpbnMgX19ib3RoX18gdGhlIGdpdmVuIGNsYXNzIGFuZCB0aGUgbmVnYXRlZFxuXHRcdFx0ICogdmVyc2lvbiBvZiBpdCwgdGhlIGNsYXNzIGlzIGNvbnNpZGVyZWQgYWN0aXZlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBbZGVmYXVsdEFjdGl2YXRpb249ZmFsc2VdXG5cdFx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0aXNBY3RpdmU6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRlZmF1bHRBY3RpdmF0aW9uKSB7XG5cdFx0XHRcdHZhciBubyA9ICduby0nICsgY2xhc3NOYW1lO1xuXG5cdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuXHRcdFx0XHRcdGlmIChjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjbGFzc0xpc3QuY29udGFpbnMobm8pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhZGVmYXVsdEFjdGl2YXRpb247XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBjdXJyZW50bHkgbG9hZGVkIGxhbmd1YWdlcyBhbmQgdGhlIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgYW5kIG1vZGlmeSBsYW5ndWFnZXMuXG5cdFx0ICpcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGxhbmd1YWdlczoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgZ3JhbW1hciBmb3IgcGxhaW4sIHVuZm9ybWF0dGVkIHRleHQuXG5cdFx0XHQgKi9cblx0XHRcdHBsYWluOiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0cGxhaW50ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0dGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHR4dDogcGxhaW5UZXh0R3JhbW1hcixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBsYW5ndWFnZSB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgYXBwZW5kcyB0aGUgZ2l2ZW4gdG9rZW5zLlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIGEgdG9rZW4gaW4gYHJlZGVmYCBhbHNvIGFwcGVhcnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSwgdGhlbiB0aGUgZXhpc3RpbmcgdG9rZW4gaW4gdGhlIGNvcGllZCBsYW5ndWFnZVxuXHRcdFx0ICogd2lsbCBiZSBvdmVyd3JpdHRlbiBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb24uXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgQmVzdCBwcmFjdGljZXNcblx0XHRcdCAqXG5cdFx0XHQgKiBTaW5jZSB0aGUgcG9zaXRpb24gb2Ygb3ZlcndyaXRpbmcgdG9rZW5zICh0b2tlbiBpbiBgcmVkZWZgIHRoYXQgb3ZlcndyaXRlIHRva2VucyBpbiB0aGUgY29waWVkIGxhbmd1YWdlKVxuXHRcdFx0ICogZG9lc24ndCBtYXR0ZXIsIHRoZXkgY2FuIHRlY2huaWNhbGx5IGJlIGluIGFueSBvcmRlci4gSG93ZXZlciwgdGhpcyBjYW4gYmUgY29uZnVzaW5nIHRvIG90aGVycyB0aGF0IHRyeWluZyB0b1xuXHRcdFx0ICogdW5kZXJzdGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBiZWNhdXNlLCBub3JtYWxseSwgdGhlIG9yZGVyIG9mIHRva2VucyBtYXR0ZXJzIGluIFByaXNtIGdyYW1tYXJzLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZXJlZm9yZSwgaXQgaXMgZW5jb3VyYWdlZCB0byBvcmRlciBvdmVyd3JpdGluZyB0b2tlbnMgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG92ZXJ3cml0dGVuIHRva2Vucy5cblx0XHRcdCAqIEZ1cnRoZXJtb3JlLCBhbGwgbm9uLW92ZXJ3cml0aW5nIHRva2VucyBzaG91bGQgYmUgcGxhY2VkIGFmdGVyIHRoZSBvdmVyd3JpdGluZyBvbmVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGxhbmd1YWdlIHRvIGV4dGVuZC4gVGhpcyBoYXMgdG8gYmUgYSBrZXkgaW4gYFByaXNtLmxhbmd1YWdlc2AuXG5cdFx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IHJlZGVmIFRoZSBuZXcgdG9rZW5zIHRvIGFwcGVuZC5cblx0XHRcdCAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGxhbmd1YWdlIGNyZWF0ZWQuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzWydjc3Mtd2l0aC1jb2xvcnMnXSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcblx0XHRcdCAqICAgICAvLyBQcmlzbS5sYW5ndWFnZXMuY3NzIGFscmVhZHkgaGFzIGEgJ2NvbW1lbnQnIHRva2VuLCBzbyB0aGlzIHRva2VuIHdpbGwgb3ZlcndyaXRlIENTUycgJ2NvbW1lbnQnIHRva2VuXG5cdFx0XHQgKiAgICAgLy8gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0XHQgKiAgICAgJ2NvbW1lbnQnOiB7IC4uLiB9LFxuXHRcdFx0ICogICAgIC8vIENTUyBkb2Vzbid0IGhhdmUgYSAnY29sb3InIHRva2VuLCBzbyB0aGlzIHRva2VuIHdpbGwgYmUgYXBwZW5kZWRcblx0XHRcdCAqICAgICAnY29sb3InOiAvXFxiKD86cmVkfGdyZWVufGJsdWUpXFxiL1xuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdGV4dGVuZDogZnVuY3Rpb24gKGlkLCByZWRlZikge1xuXHRcdFx0XHR2YXIgbGFuZyA9IF8udXRpbC5jbG9uZShfLmxhbmd1YWdlc1tpZF0pO1xuXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiByZWRlZikge1xuXHRcdFx0XHRcdGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbGFuZztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSW5zZXJ0cyB0b2tlbnMgX2JlZm9yZV8gYW5vdGhlciB0b2tlbiBpbiBhIGxhbmd1YWdlIGRlZmluaXRpb24gb3IgYW55IG90aGVyIGdyYW1tYXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgVXNhZ2Vcblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIGhlbHBlciBtZXRob2QgbWFrZXMgaXQgZWFzeSB0byBtb2RpZnkgZXhpc3RpbmcgbGFuZ3VhZ2VzLiBGb3IgZXhhbXBsZSwgdGhlIENTUyBsYW5ndWFnZSBkZWZpbml0aW9uXG5cdFx0XHQgKiBub3Qgb25seSBkZWZpbmVzIENTUyBoaWdobGlnaHRpbmcgZm9yIENTUyBkb2N1bWVudHMsIGJ1dCBhbHNvIG5lZWRzIHRvIGRlZmluZSBoaWdobGlnaHRpbmcgZm9yIENTUyBlbWJlZGRlZFxuXHRcdFx0ICogaW4gSFRNTCB0aHJvdWdoIGA8c3R5bGU+YCBlbGVtZW50cy4gVG8gZG8gdGhpcywgaXQgbmVlZHMgdG8gbW9kaWZ5IGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBhbmQgYWRkIHRoZVxuXHRcdFx0ICogYXBwcm9wcmlhdGUgdG9rZW5zLiBIb3dldmVyLCBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgaXMgYSByZWd1bGFyIEphdmFTY3JpcHQgb2JqZWN0IGxpdGVyYWwsIHNvIGlmIHlvdSBkb1xuXHRcdFx0ICogdGhpczpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5zdHlsZSA9IHtcblx0XHRcdCAqICAgICAvLyB0b2tlblxuXHRcdFx0ICogfTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqIHRoZW4gdGhlIGBzdHlsZWAgdG9rZW4gd2lsbCBiZSBhZGRlZCAoYW5kIHByb2Nlc3NlZCkgYXQgdGhlIGVuZC4gYGluc2VydEJlZm9yZWAgYWxsb3dzIHlvdSB0byBpbnNlcnQgdG9rZW5zXG5cdFx0XHQgKiBiZWZvcmUgZXhpc3RpbmcgdG9rZW5zLiBGb3IgdGhlIENTUyBleGFtcGxlIGFib3ZlLCB5b3Ugd291bGQgdXNlIGl0IGxpa2UgdGhpczpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywge1xuXHRcdFx0ICogICAgICdzdHlsZSc6IHtcblx0XHRcdCAqICAgICAgICAgLy8gdG9rZW5cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFNwZWNpYWwgY2FzZXNcblx0XHRcdCAqXG5cdFx0XHQgKiBJZiB0aGUgZ3JhbW1hcnMgb2YgYGluc2lkZWAgYW5kIGBpbnNlcnRgIGhhdmUgdG9rZW5zIHdpdGggdGhlIHNhbWUgbmFtZSwgdGhlIHRva2VucyBpbiBgaW5zaWRlYCdzIGdyYW1tYXJcblx0XHRcdCAqIHdpbGwgYmUgaWdub3JlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSB1c2VkIHRvIGluc2VydCB0b2tlbnMgYWZ0ZXIgYGJlZm9yZWA6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50Jywge1xuXHRcdFx0ICogICAgICdjb21tZW50JzogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5jb21tZW50LFxuXHRcdFx0ICogICAgIC8vIHRva2VucyBhZnRlciAnY29tbWVudCdcblx0XHRcdCAqIH0pO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgTGltaXRhdGlvbnNcblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgbWFpbiBwcm9ibGVtIGBpbnNlcnRCZWZvcmVgIGhhcyB0byBzb2x2ZSBpcyBpdGVyYXRpb24gb3JkZXIuIFNpbmNlIEVTMjAxNSwgdGhlIGl0ZXJhdGlvbiBvcmRlciBmb3Igb2JqZWN0XG5cdFx0XHQgKiBwcm9wZXJ0aWVzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIGluc2VydGlvbiBvcmRlciAoZXhjZXB0IGZvciBpbnRlZ2VyIGtleXMpIGJ1dCBzb21lIGJyb3dzZXJzIGJlaGF2ZVxuXHRcdFx0ICogZGlmZmVyZW50bHkgd2hlbiBrZXlzIGFyZSBkZWxldGVkIGFuZCByZS1pbnNlcnRlZC4gU28gYGluc2VydEJlZm9yZWAgY2FuJ3QgYmUgaW1wbGVtZW50ZWQgYnkgdGVtcG9yYXJpbHlcblx0XHRcdCAqIGRlbGV0aW5nIHByb3BlcnRpZXMgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGluc2VydCBhdCBhcmJpdHJhcnkgcG9zaXRpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgYGluc2VydEJlZm9yZWAgZG9lc24ndCBhY3R1YWxseSBpbnNlcnQgdGhlIGdpdmVuIHRva2VucyBpbnRvIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHRcdFx0ICogSW5zdGVhZCwgaXQgd2lsbCBjcmVhdGUgYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSB0YXJnZXQgb2JqZWN0IHdpdGggdGhlIG5ldyBvbmUuIFRoaXNcblx0XHRcdCAqIGNhbiBiZSBkb25lIHdpdGhvdXQgdGVtcG9yYXJpbHkgZGVsZXRpbmcgcHJvcGVydGllcywgc28gdGhlIGl0ZXJhdGlvbiBvcmRlciBpcyB3ZWxsLWRlZmluZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogSG93ZXZlciwgb25seSByZWZlcmVuY2VzIHRoYXQgY2FuIGJlIHJlYWNoZWQgZnJvbSBgUHJpc20ubGFuZ3VhZ2VzYCBvciBgaW5zZXJ0YCB3aWxsIGJlIHJlcGxhY2VkLiBJLmUuIGlmXG5cdFx0XHQgKiB5b3UgaG9sZCB0aGUgdGFyZ2V0IG9iamVjdCBpbiBhIHZhcmlhYmxlLCB0aGVuIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgd2lsbCBub3QgY2hhbmdlLlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiB2YXIgb2xkTWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblx0XHRcdCAqIHZhciBuZXdNYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHsgLi4uIH0pO1xuXHRcdFx0ICpcblx0XHRcdCAqIGFzc2VydChvbGRNYXJrdXAgIT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYXNzZXJ0KG5ld01hcmt1cCA9PT0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaW5zaWRlIFRoZSBwcm9wZXJ0eSBvZiBgcm9vdGAgKGUuZy4gYSBsYW5ndWFnZSBpZCBpbiBgUHJpc20ubGFuZ3VhZ2VzYCkgdGhhdCBjb250YWlucyB0aGVcblx0XHRcdCAqIG9iamVjdCB0byBiZSBtb2RpZmllZC5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBpbnNlcnQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleS12YWx1ZSBwYWlycyB0byBiZSBpbnNlcnRlZC5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW3Jvb3RdIFRoZSBvYmplY3QgY29udGFpbmluZyBgaW5zaWRlYCwgaS5lLiB0aGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogRGVmYXVsdHMgdG8gYFByaXNtLmxhbmd1YWdlc2AuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBncmFtbWFyIG9iamVjdC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuXHRcdFx0XHRyb290ID0gcm9vdCB8fCAvKiogQHR5cGUge2FueX0gKi8gKF8ubGFuZ3VhZ2VzKTtcblx0XHRcdFx0dmFyIGdyYW1tYXIgPSByb290W2luc2lkZV07XG5cdFx0XHRcdC8qKiBAdHlwZSB7R3JhbW1hcn0gKi9cblx0XHRcdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0XHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdFx0XHRpZiAoZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblxuXHRcdFx0XHRcdFx0aWYgKHRva2VuID09IGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIERvIG5vdCBpbnNlcnQgdG9rZW4gd2hpY2ggYWxzbyBvY2N1ciBpbiBpbnNlcnQuIFNlZSAjMTUyNVxuXHRcdFx0XHRcdFx0aWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2xkID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHRyb290W2luc2lkZV0gPSByZXQ7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdFx0Xy5sYW5ndWFnZXMuREZTKF8ubGFuZ3VhZ2VzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gb2xkICYmIGtleSAhPSBpbnNpZGUpIHtcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHJldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcblx0XHRcdERGUzogZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG5cdFx0XHRcdHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuXG5cdFx0XHRcdHZhciBvYmpJZCA9IF8udXRpbC5vYmpJZDtcblxuXHRcdFx0XHRmb3IgKHZhciBpIGluIG8pIHtcblx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChvLCBpLCBvW2ldLCB0eXBlIHx8IGkpO1xuXG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydHkgPSBvW2ldO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5VHlwZSA9IF8udXRpbC50eXBlKHByb3BlcnR5KTtcblxuXHRcdFx0XHRcdFx0aWYgKHByb3BlcnR5VHlwZSA9PT0gJ09iamVjdCcgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuXHRcdFx0XHRcdFx0XHR2aXNpdGVkW29iaklkKHByb3BlcnR5KV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRERlMocHJvcGVydHksIGNhbGxiYWNrLCBudWxsLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvcGVydHlUeXBlID09PSAnQXJyYXknICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgaSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHBsdWdpbnM6IHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpcyB0aGUgbW9zdCBoaWdoLWxldmVsIGZ1bmN0aW9uIGluIFByaXNt4oCZcyBBUEkuXG5cdFx0ICogSXQgZmV0Y2hlcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHMge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uXG5cdFx0ICogZWFjaCBvbmUgb2YgdGhlbS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjaylgLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cblx0XHQgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0QWxsOiBmdW5jdGlvbiAoYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHRfLmhpZ2hsaWdodEFsbFVuZGVyKGRvY3VtZW50LCBhc3luYywgY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBGZXRjaGVzIGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgYGNvbnRhaW5lcmAgdGhhdCBoYXZlIGEgYC5sYW5ndWFnZS14eHh4YCBjbGFzcyBhbmQgdGhlbiBjYWxsc1xuXHRcdCAqIHtAbGluayBQcmlzbS5oaWdobGlnaHRFbGVtZW50fSBvbiBlYWNoIG9uZSBvZiB0aGVtLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLWhpZ2hsaWdodGFsbGBcblx0XHQgKiAyLiBgYmVmb3JlLWFsbC1lbGVtZW50cy1oaWdobGlnaHRgXG5cdFx0ICogMy4gQWxsIGhvb2tzIG9mIHtAbGluayBQcmlzbS5oaWdobGlnaHRFbGVtZW50fSBmb3IgZWFjaCBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtQYXJlbnROb2RlfSBjb250YWluZXIgVGhlIHJvb3QgZWxlbWVudCwgd2hvc2UgZGVzY2VuZGFudHMgdGhhdCBoYXZlIGEgYC5sYW5ndWFnZS14eHh4YCBjbGFzcyB3aWxsIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIGVhY2ggZWxlbWVudCBpcyB0byBiZSBoaWdobGlnaHRlZCBhc3luY2hyb25vdXNseSB1c2luZyBXZWIgV29ya2Vycy5cblx0XHQgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZWFjaCBlbGVtZW50IGFmdGVyIGl0cyBoaWdobGlnaHRpbmcgaXMgZG9uZS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0QWxsVW5kZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGVudiA9IHtcblx0XHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0XHRjb250YWluZXI6IGNvbnRhaW5lcixcblx0XHRcdFx0c2VsZWN0b3I6ICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcblx0XHRcdH07XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0YWxsJywgZW52KTtcblxuXHRcdFx0ZW52LmVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVudi5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChlbnYuc2VsZWN0b3IpKTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0JywgZW52KTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IChlbGVtZW50ID0gZW52LmVsZW1lbnRzW2krK10pOykge1xuXHRcdFx0XHRfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhpZ2hsaWdodHMgdGhlIGNvZGUgaW5zaWRlIGEgc2luZ2xlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtc2FuaXR5LWNoZWNrYFxuXHRcdCAqIDIuIGBiZWZvcmUtaGlnaGxpZ2h0YFxuXHRcdCAqIDMuIEFsbCBob29rcyBvZiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0fS4gVGhlc2UgaG9va3Mgd2lsbCBiZSBydW4gYnkgYW4gYXN5bmNocm9ub3VzIHdvcmtlciBpZiBgYXN5bmNgIGlzIGB0cnVlYC5cblx0XHQgKiA0LiBgYmVmb3JlLWluc2VydGBcblx0XHQgKiA1LiBgYWZ0ZXItaGlnaGxpZ2h0YFxuXHRcdCAqIDYuIGBjb21wbGV0ZWBcblx0XHQgKlxuXHRcdCAqIFNvbWUgdGhlIGFib3ZlIGhvb2tzIHdpbGwgYmUgc2tpcHBlZCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGNvbnRhaW4gYW55IHRleHQgb3IgdGhlcmUgaXMgbm8gZ3JhbW1hciBsb2FkZWQgZm9yXG5cdFx0ICogdGhlIGVsZW1lbnQncyBsYW5ndWFnZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb2RlLlxuXHRcdCAqIEl0IG11c3QgaGF2ZSBhIGNsYXNzIG9mIGBsYW5ndWFnZS14eHh4YCB0byBiZSBwcm9jZXNzZWQsIHdoZXJlIGB4eHh4YCBpcyBhIHZhbGlkIGxhbmd1YWdlIGlkZW50aWZpZXIuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnNcblx0XHQgKiB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGFuZCBhdm9pZCBibG9ja2luZyB0aGUgVUkgd2hlbiBoaWdobGlnaHRpbmcgdmVyeSBsYXJnZSBjaHVua3Mgb2YgY29kZS4gVGhpcyBvcHRpb24gaXNcblx0XHQgKiBbZGlzYWJsZWQgYnkgZGVmYXVsdF0oaHR0cHM6Ly9wcmlzbWpzLmNvbS9mYXEuaHRtbCN3aHktaXMtYXN5bmNocm9ub3VzLWhpZ2hsaWdodGluZy1kaXNhYmxlZC1ieS1kZWZhdWx0KS5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IEFsbCBsYW5ndWFnZSBkZWZpbml0aW9ucyByZXF1aXJlZCB0byBoaWdobGlnaHQgdGhlIGNvZGUgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgbWFpbiBgcHJpc20uanNgIGZpbGUgZm9yXG5cdFx0ICogYXN5bmNocm9ub3VzIGhpZ2hsaWdodGluZyB0byB3b3JrLiBZb3UgY2FuIGJ1aWxkIHlvdXIgb3duIGJ1bmRsZSBvbiB0aGVcblx0XHQgKiBbRG93bmxvYWQgcGFnZV0oaHR0cHM6Ly9wcmlzbWpzLmNvbS9kb3dubG9hZC5odG1sKS5cblx0XHQgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lLlxuXHRcdCAqIE1vc3RseSB1c2VmdWwgd2hlbiBgYXN5bmNgIGlzIGB0cnVlYCwgc2luY2UgaW4gdGhhdCBjYXNlLCB0aGUgaGlnaGxpZ2h0aW5nIGlzIGRvbmUgYXN5bmNocm9ub3VzbHkuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBhc3luYywgY2FsbGJhY2spIHtcblx0XHRcdC8vIEZpbmQgbGFuZ3VhZ2Vcblx0XHRcdHZhciBsYW5ndWFnZSA9IF8udXRpbC5nZXRMYW5ndWFnZShlbGVtZW50KTtcblx0XHRcdHZhciBncmFtbWFyID0gXy5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXG5cdFx0XHQvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIGVsZW1lbnQsIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRfLnV0aWwuc2V0TGFuZ3VhZ2UoZWxlbWVudCwgbGFuZ3VhZ2UpO1xuXG5cdFx0XHQvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIHBhcmVudCwgZm9yIHN0eWxpbmdcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncHJlJykge1xuXHRcdFx0XHRfLnV0aWwuc2V0TGFuZ3VhZ2UocGFyZW50LCBsYW5ndWFnZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb2RlID0gZWxlbWVudC50ZXh0Q29udGVudDtcblxuXHRcdFx0dmFyIGVudiA9IHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlLFxuXHRcdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0XHRjb2RlOiBjb2RlXG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiBpbnNlcnRIaWdobGlnaHRlZENvZGUoaGlnaGxpZ2h0ZWRDb2RlKSB7XG5cdFx0XHRcdGVudi5oaWdobGlnaHRlZENvZGUgPSBoaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXNhbml0eS1jaGVjaycsIGVudik7XG5cblx0XHRcdC8vIHBsdWdpbnMgbWF5IGNoYW5nZS9hZGQgdGhlIHBhcmVudC9lbGVtZW50XG5cdFx0XHRwYXJlbnQgPSBlbnYuZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ByZScgJiYgIXBhcmVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcblx0XHRcdFx0cGFyZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWVudi5jb2RlKSB7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuXHRcdFx0aWYgKCFlbnYuZ3JhbW1hcikge1xuXHRcdFx0XHRpbnNlcnRIaWdobGlnaHRlZENvZGUoXy51dGlsLmVuY29kZShlbnYuY29kZSkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhc3luYyAmJiBfc2VsZi5Xb3JrZXIpIHtcblx0XHRcdFx0dmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXy5maWxlbmFtZSk7XG5cblx0XHRcdFx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdFx0XHRpbnNlcnRIaWdobGlnaHRlZENvZGUoZXZ0LmRhdGEpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHdvcmtlci5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdFx0bGFuZ3VhZ2U6IGVudi5sYW5ndWFnZSxcblx0XHRcdFx0XHRjb2RlOiBlbnYuY29kZSxcblx0XHRcdFx0XHRpbW1lZGlhdGVDbG9zZTogdHJ1ZVxuXHRcdFx0XHR9KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbnNlcnRIaWdobGlnaHRlZENvZGUoXy5oaWdobGlnaHQoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTG93LWxldmVsIGZ1bmN0aW9uLCBvbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdeKAmXJlIGRvaW5nLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS10b2tlbml6ZWBcblx0XHQgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG5cdFx0ICogMy4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBwYXNzZWQgdG8gYGdyYW1tYXJgLlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGNvZGU6IHRleHQsXG5cdFx0XHRcdGdyYW1tYXI6IGdyYW1tYXIsXG5cdFx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdFx0fTtcblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0aWYgKCFlbnYuZ3JhbW1hcikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsYW5ndWFnZSBcIicgKyBlbnYubGFuZ3VhZ2UgKyAnXCIgaGFzIG5vIGdyYW1tYXIuJyk7XG5cdFx0XHR9XG5cdFx0XHRlbnYudG9rZW5zID0gXy50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KTtcblx0XHRcdHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShlbnYudG9rZW5zKSwgZW52Lmxhbmd1YWdlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpcyB0aGUgaGVhcnQgb2YgUHJpc20sIGFuZCB0aGUgbW9zdCBsb3ctbGV2ZWwgZnVuY3Rpb24geW91IGNhbiB1c2UuIEl0IGFjY2VwdHMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dFxuXHRcdCAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0b2tlbml6ZWQgY29kZS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gaW5jbHVkZXMgbmVzdGVkIHRva2VucywgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseSBvbiBlYWNoIG9mIHRoZXNlIHRva2Vucy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGNvdWxkIGJlIHVzZWZ1bCBpbiBvdGhlciBjb250ZXh0cyBhcyB3ZWxsLCBhcyBhIHZlcnkgY3J1ZGUgcGFyc2VyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cblx0XHQgKiBAcmV0dXJucyB7VG9rZW5TdHJlYW19IEFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRva2VucywgYSB0b2tlbiBzdHJlYW0uXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogbGV0IGNvZGUgPSBgdmFyIGZvbyA9IDA7YDtcblx0XHQgKiBsZXQgdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuXHRcdCAqIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcblx0XHQgKiAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUHJpc20uVG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHQgKiAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBudW1lcmljIGxpdGVyYWw6ICR7dG9rZW4uY29udGVudH1gKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHRcdHRva2VuaXplOiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hcikge1xuXHRcdFx0dmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cdFx0XHRpZiAocmVzdCkge1xuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiByZXN0KSB7XG5cdFx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBncmFtbWFyLnJlc3Q7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0b2tlbkxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuXHRcdFx0YWRkQWZ0ZXIodG9rZW5MaXN0LCB0b2tlbkxpc3QuaGVhZCwgdGV4dCk7XG5cblx0XHRcdG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHRva2VuTGlzdC5oZWFkLCAwKTtcblxuXHRcdFx0cmV0dXJuIHRvQXJyYXkodG9rZW5MaXN0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRob29rczoge1xuXHRcdFx0YWxsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIHRoZSBnaXZlbiBjYWxsYmFjayB0byB0aGUgbGlzdCBvZiBjYWxsYmFja3MgZm9yIHRoZSBnaXZlbiBob29rLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgaG9vayBpdCBpcyByZWdpc3RlcmVkIGZvciBpcyBydW4uXG5cdFx0XHQgKiBIb29rcyBhcmUgdXN1YWxseSBkaXJlY3RseSBydW4gYnkgYSBoaWdobGlnaHQgZnVuY3Rpb24gYnV0IHlvdSBjYW4gYWxzbyBydW4gaG9va3MgeW91cnNlbGYuXG5cdFx0XHQgKlxuXHRcdFx0ICogT25lIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIHRvIG11bHRpcGxlIGhvb2tzIGFuZCB0aGUgc2FtZSBob29rIG11bHRpcGxlIHRpbWVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtIb29rQ2FsbGJhY2t9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBob29rcyA9IF8uaG9va3MuYWxsO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cblx0XHRcdFx0aG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJ1bnMgYSBob29rIGludm9raW5nIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQ2FsbGJhY2tzIHdpbGwgYmUgaW52b2tlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IGVudiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIHRoZSBob29rIHBhc3NlZCB0byBhbGwgY2FsbGJhY2tzIHJlZ2lzdGVyZWQuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdHJ1bjogZnVuY3Rpb24gKG5hbWUsIGVudikge1xuXHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gXy5ob29rcy5hbGxbbmFtZV07XG5cblx0XHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IChjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdKTspIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFRva2VuOiBUb2tlblxuXHR9O1xuXHRfc2VsZi5QcmlzbSA9IF87XG5cblxuXHQvLyBUeXBlc2NyaXB0IG5vdGU6XG5cdC8vIFRoZSBmb2xsb3dpbmcgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBUb2tlbiB0eXBlIGluIEpTRG9jOlxuXHQvL1xuXHQvLyAgIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHRva2VuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBTZWUge0BsaW5rIFRva2VuI3R5cGUgdHlwZX1cblx0ICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlblN0cmVhbX0gY29udGVudCBTZWUge0BsaW5rIFRva2VuI2NvbnRlbnQgY29udGVudH1cblx0ICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hlZFN0cj1cIlwiXSBBIGNvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbS5cblx0ICogQGNsYXNzXG5cdCAqIEBnbG9iYWxcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIGtleSBvZiBhIHBhdHRlcm4gaW4gYSB7QGxpbmsgR3JhbW1hcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBzZWUgR3JhbW1hclRva2VuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0cmluZ3Mgb3IgdG9rZW5zIGNvbnRhaW5lZCBieSB0aGlzIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogVGhpcyB3aWxsIGJlIGEgdG9rZW4gc3RyZWFtIGlmIHRoZSBwYXR0ZXJuIG1hdGNoZWQgYWxzbyBkZWZpbmVkIGFuIGBpbnNpZGVgIGdyYW1tYXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19XG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuXHRcdCAqIEBzZWUgR3JhbW1hclRva2VuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuYWxpYXMgPSBhbGlhcztcblx0XHQvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cblx0XHR0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8ICcnKS5sZW5ndGggfCAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgdG9rZW4gc3RyZWFtIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHtAbGluayBUb2tlbiBUb2tlbn0gb2JqZWN0cy5cblx0ICpcblx0ICogVG9rZW4gc3RyZWFtcyBoYXZlIHRvIGZ1bGZpbGwgYSBmZXcgcHJvcGVydGllcyB0aGF0IGFyZSBhc3N1bWVkIGJ5IG1vc3QgZnVuY3Rpb25zIChtb3N0bHkgaW50ZXJuYWwgb25lcykgdGhhdCBwcm9jZXNzXG5cdCAqIHRoZW0uXG5cdCAqXG5cdCAqIDEuIE5vIGFkamFjZW50IHN0cmluZ3MuXG5cdCAqIDIuIE5vIGVtcHR5IHN0cmluZ3MuXG5cdCAqXG5cdCAqICAgIFRoZSBvbmx5IGV4Y2VwdGlvbiBoZXJlIGlzIHRoZSB0b2tlbiBzdHJlYW0gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBlbXB0eSBzdHJpbmcgYW5kIG5vdGhpbmcgZWxzZS5cblx0ICpcblx0ICogQHR5cGVkZWYge0FycmF5PHN0cmluZyB8IFRva2VuPn0gVG9rZW5TdHJlYW1cblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGFuIEhUTUwgcmVwcmVzZW50YXRpb24uXG5cdCAqXG5cdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdCAqIDEuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgVG9rZW5TdHJlYW19IG8gVGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBiZSBjb252ZXJ0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiBjdXJyZW50IGxhbmd1YWdlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuXHQgKiBAbWVtYmVyb2YgVG9rZW5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG8sIGxhbmd1YWdlKSB7XG5cdFx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbztcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobykpIHtcblx0XHRcdHZhciBzID0gJyc7XG5cdFx0XHRvLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cyArPSBzdHJpbmdpZnkoZSwgbGFuZ3VhZ2UpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9XG5cblx0XHR2YXIgZW52ID0ge1xuXHRcdFx0dHlwZTogby50eXBlLFxuXHRcdFx0Y29udGVudDogc3RyaW5naWZ5KG8uY29udGVudCwgbGFuZ3VhZ2UpLFxuXHRcdFx0dGFnOiAnc3BhbicsXG5cdFx0XHRjbGFzc2VzOiBbJ3Rva2VuJywgby50eXBlXSxcblx0XHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlXG5cdFx0fTtcblxuXHRcdHZhciBhbGlhc2VzID0gby5hbGlhcztcblx0XHRpZiAoYWxpYXNlcykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW52LmNsYXNzZXMsIGFsaWFzZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW52LmNsYXNzZXMucHVzaChhbGlhc2VzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9ICcnO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gZW52LmF0dHJpYnV0ZXMpIHtcblx0XHRcdGF0dHJpYnV0ZXMgKz0gJyAnICsgbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgKyAnXCInO1xuXHRcdH1cblxuXHRcdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgYXR0cmlidXRlcyArICc+JyArIGVudi5jb250ZW50ICsgJzwvJyArIGVudi50YWcgKyAnPic7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3Ncblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtib29sZWFufSBsb29rYmVoaW5kXG5cdCAqIEByZXR1cm5zIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfVxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCkge1xuXHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyh0ZXh0KTtcblx0XHRpZiAobWF0Y2ggJiYgbG9va2JlaGluZCAmJiBtYXRjaFsxXSkge1xuXHRcdFx0Ly8gY2hhbmdlIHRoZSBtYXRjaCB0byByZW1vdmUgdGhlIHRleHQgbWF0Y2hlZCBieSB0aGUgUHJpc20gbG9va2JlaGluZCBncm91cFxuXHRcdFx0dmFyIGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG5cdFx0XHRtYXRjaC5pbmRleCArPSBsb29rYmVoaW5kTGVuZ3RoO1xuXHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxzdHJpbmcgfCBUb2tlbj59IHRva2VuTGlzdFxuXHQgKiBAcGFyYW0ge2FueX0gZ3JhbW1hclxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPHN0cmluZyB8IFRva2VuPn0gc3RhcnROb2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge1JlbWF0Y2hPcHRpb25zfSBbcmVtYXRjaF1cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEB0eXBlZGVmIFJlbWF0Y2hPcHRpb25zXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYXVzZVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gcmVhY2hcblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHN0YXJ0Tm9kZSwgc3RhcnRQb3MsIHJlbWF0Y2gpIHtcblx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRpZiAoIWdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pIHx8ICFncmFtbWFyW3Rva2VuXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkocGF0dGVybnMpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlbWF0Y2guY2F1c2UgPT0gdG9rZW4gKyAnLCcgKyBqKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBhdHRlcm5PYmogPSBwYXR0ZXJuc1tqXTtcblx0XHRcdFx0dmFyIGluc2lkZSA9IHBhdHRlcm5PYmouaW5zaWRlO1xuXHRcdFx0XHR2YXIgbG9va2JlaGluZCA9ICEhcGF0dGVybk9iai5sb29rYmVoaW5kO1xuXHRcdFx0XHR2YXIgZ3JlZWR5ID0gISFwYXR0ZXJuT2JqLmdyZWVkeTtcblx0XHRcdFx0dmFyIGFsaWFzID0gcGF0dGVybk9iai5hbGlhcztcblxuXHRcdFx0XHRpZiAoZ3JlZWR5ICYmICFwYXR0ZXJuT2JqLnBhdHRlcm4uZ2xvYmFsKSB7XG5cdFx0XHRcdFx0Ly8gV2l0aG91dCB0aGUgZ2xvYmFsIGZsYWcsIGxhc3RJbmRleCB3b24ndCB3b3JrXG5cdFx0XHRcdFx0dmFyIGZsYWdzID0gcGF0dGVybk9iai5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdO1xuXHRcdFx0XHRcdHBhdHRlcm5PYmoucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuT2JqLnBhdHRlcm4uc291cmNlLCBmbGFncyArICdnJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiogQHR5cGUge1JlZ0V4cH0gKi9cblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBwYXR0ZXJuT2JqLnBhdHRlcm4gfHwgcGF0dGVybk9iajtcblxuXHRcdFx0XHRmb3IgKCAvLyBpdGVyYXRlIHRoZSB0b2tlbiBsaXN0IGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHRva2VuL3N0cmluZyBwb3NpdGlvblxuXHRcdFx0XHRcdHZhciBjdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZS5uZXh0LCBwb3MgPSBzdGFydFBvcztcblx0XHRcdFx0XHRjdXJyZW50Tm9kZSAhPT0gdG9rZW5MaXN0LnRhaWw7XG5cdFx0XHRcdFx0cG9zICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aCwgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0XG5cdFx0XHRcdCkge1xuXG5cdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcG9zID49IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBzdHIgPSBjdXJyZW50Tm9kZS52YWx1ZTtcblxuXHRcdFx0XHRcdGlmICh0b2tlbkxpc3QubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0ciBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcmVtb3ZlQ291bnQgPSAxOyAvLyB0aGlzIGlzIHRoZSB0byBwYXJhbWV0ZXIgb2YgcmVtb3ZlQmV0d2VlblxuXHRcdFx0XHRcdHZhciBtYXRjaDtcblxuXHRcdFx0XHRcdGlmIChncmVlZHkpIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ID49IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4O1xuXHRcdFx0XHRcdFx0dmFyIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR2YXIgcCA9IHBvcztcblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaFxuXHRcdFx0XHRcdFx0cCArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcblx0XHRcdFx0XHRcdFx0cCArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgcG9zIChhbmQgcClcblx0XHRcdFx0XHRcdHAgLT0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0cG9zID0gcDtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbm9kZSBpcyBhIFRva2VuLCB0aGVuIHRoZSBtYXRjaCBzdGFydHMgaW5zaWRlIGFub3RoZXIgVG9rZW4sIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50Tm9kZS52YWx1ZSBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBsYXN0IG5vZGUgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBtYXRjaFxuXHRcdFx0XHRcdFx0Zm9yIChcblx0XHRcdFx0XHRcdFx0dmFyIGsgPSBjdXJyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0ayAhPT0gdG9rZW5MaXN0LnRhaWwgJiYgKHAgPCB0byB8fCB0eXBlb2Ygay52YWx1ZSA9PT0gJ3N0cmluZycpO1xuXHRcdFx0XHRcdFx0XHRrID0gay5uZXh0XG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQrKztcblx0XHRcdFx0XHRcdFx0cCArPSBrLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlbW92ZUNvdW50LS07XG5cblx0XHRcdFx0XHRcdC8vIHJlcGxhY2Ugd2l0aCB0aGUgbmV3IG1hdGNoXG5cdFx0XHRcdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcCk7XG5cdFx0XHRcdFx0XHRtYXRjaC5pbmRleCAtPSBwb3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIDAsIHN0ciwgbG9va2JlaGluZCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4O1xuXHRcdFx0XHRcdHZhciBtYXRjaFN0ciA9IG1hdGNoWzBdO1xuXHRcdFx0XHRcdHZhciBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSk7XG5cdFx0XHRcdFx0dmFyIGFmdGVyID0gc3RyLnNsaWNlKGZyb20gKyBtYXRjaFN0ci5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0dmFyIHJlYWNoID0gcG9zICsgc3RyLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiByZWFjaCA+IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdHJlbWF0Y2gucmVhY2ggPSByZWFjaDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcmVtb3ZlRnJvbSA9IGN1cnJlbnROb2RlLnByZXY7XG5cblx0XHRcdFx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCBiZWZvcmUpO1xuXHRcdFx0XHRcdFx0cG9zICs9IGJlZm9yZS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3ZlUmFuZ2UodG9rZW5MaXN0LCByZW1vdmVGcm9tLCByZW1vdmVDb3VudCk7XG5cblx0XHRcdFx0XHR2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlID8gXy50b2tlbml6ZShtYXRjaFN0ciwgaW5zaWRlKSA6IG1hdGNoU3RyLCBhbGlhcywgbWF0Y2hTdHIpO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCB3cmFwcGVkKTtcblxuXHRcdFx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRcdFx0YWRkQWZ0ZXIodG9rZW5MaXN0LCBjdXJyZW50Tm9kZSwgYWZ0ZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZW1vdmVDb3VudCA+IDEpIHtcblx0XHRcdFx0XHRcdC8vIGF0IGxlYXN0IG9uZSBUb2tlbiBvYmplY3Qgd2FzIHJlbW92ZWQsIHNvIHdlIGhhdmUgdG8gZG8gc29tZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgY3VycmVudCBwYXR0ZXJuIGlzIGdyZWVkeVxuXG5cdFx0XHRcdFx0XHQvKiogQHR5cGUge1JlbWF0Y2hPcHRpb25zfSAqL1xuXHRcdFx0XHRcdFx0dmFyIG5lc3RlZFJlbWF0Y2ggPSB7XG5cdFx0XHRcdFx0XHRcdGNhdXNlOiB0b2tlbiArICcsJyArIGosXG5cdFx0XHRcdFx0XHRcdHJlYWNoOiByZWFjaFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIGN1cnJlbnROb2RlLnByZXYsIHBvcywgbmVzdGVkUmVtYXRjaCk7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSByZWFjaCBtaWdodCBoYXZlIGJlZW4gZXh0ZW5kZWQgYmVjYXVzZSBvZiB0aGUgcmVtYXRjaGluZ1xuXHRcdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgbmVzdGVkUmVtYXRjaC5yZWFjaCA+IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IG5lc3RlZFJlbWF0Y2gucmVhY2g7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIExpbmtlZExpc3ROb2RlXG5cdCAqIEBwcm9wZXJ0eSB7VH0gdmFsdWVcblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IHByZXYgVGhlIHByZXZpb3VzIG5vZGUuXG5cdCAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBuZXh0IFRoZSBuZXh0IG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHZhciBoZWFkID0geyB2YWx1ZTogbnVsbCwgcHJldjogbnVsbCwgbmV4dDogbnVsbCB9O1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIHRhaWwgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBoZWFkLCBuZXh0OiBudWxsIH07XG5cdFx0aGVhZC5uZXh0ID0gdGFpbDtcblxuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy5oZWFkID0gaGVhZDtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHRoaXMudGFpbCA9IHRhaWw7XG5cdFx0dGhpcy5sZW5ndGggPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcblx0ICogQHBhcmFtIHtUfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7TGlua2VkTGlzdE5vZGU8VD59IFRoZSBhZGRlZCBub2RlLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkQWZ0ZXIobGlzdCwgbm9kZSwgdmFsdWUpIHtcblx0XHQvLyBhc3N1bWVzIHRoYXQgbm9kZSAhPSBsaXN0LnRhaWwgJiYgdmFsdWVzLmxlbmd0aCA+PSAwXG5cdFx0dmFyIG5leHQgPSBub2RlLm5leHQ7XG5cblx0XHR2YXIgbmV3Tm9kZSA9IHsgdmFsdWU6IHZhbHVlLCBwcmV2OiBub2RlLCBuZXh0OiBuZXh0IH07XG5cdFx0bm9kZS5uZXh0ID0gbmV3Tm9kZTtcblx0XHRuZXh0LnByZXYgPSBuZXdOb2RlO1xuXHRcdGxpc3QubGVuZ3RoKys7XG5cblx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0fVxuXHQvKipcblx0ICogUmVtb3ZlcyBgY291bnRgIG5vZGVzIGFmdGVyIHRoZSBnaXZlbiBub2RlLiBUaGUgZ2l2ZW4gbm9kZSB3aWxsIG5vdCBiZSByZW1vdmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnRcblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZVJhbmdlKGxpc3QsIG5vZGUsIGNvdW50KSB7XG5cdFx0dmFyIG5leHQgPSBub2RlLm5leHQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAmJiBuZXh0ICE9PSBsaXN0LnRhaWw7IGkrKykge1xuXHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHR9XG5cdFx0bm9kZS5uZXh0ID0gbmV4dDtcblx0XHRuZXh0LnByZXYgPSBub2RlO1xuXHRcdGxpc3QubGVuZ3RoIC09IGk7XG5cdH1cblx0LyoqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcmV0dXJucyB7VFtdfVxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BcnJheShsaXN0KSB7XG5cdFx0dmFyIGFycmF5ID0gW107XG5cdFx0dmFyIG5vZGUgPSBsaXN0LmhlYWQubmV4dDtcblx0XHR3aGlsZSAobm9kZSAhPT0gbGlzdC50YWlsKSB7XG5cdFx0XHRhcnJheS5wdXNoKG5vZGUudmFsdWUpO1xuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblxuXHRpZiAoIV9zZWxmLmRvY3VtZW50KSB7XG5cdFx0aWYgKCFfc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzXG5cdFx0XHRyZXR1cm4gXztcblx0XHR9XG5cblx0XHRpZiAoIV8uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG5cdFx0XHQvLyBJbiB3b3JrZXJcblx0XHRcdF9zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZ0KSB7XG5cdFx0XHRcdHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShldnQuZGF0YSk7XG5cdFx0XHRcdHZhciBsYW5nID0gbWVzc2FnZS5sYW5ndWFnZTtcblx0XHRcdFx0dmFyIGNvZGUgPSBtZXNzYWdlLmNvZGU7XG5cdFx0XHRcdHZhciBpbW1lZGlhdGVDbG9zZSA9IG1lc3NhZ2UuaW1tZWRpYXRlQ2xvc2U7XG5cblx0XHRcdFx0X3NlbGYucG9zdE1lc3NhZ2UoXy5oaWdobGlnaHQoY29kZSwgXy5sYW5ndWFnZXNbbGFuZ10sIGxhbmcpKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZUNsb3NlKSB7XG5cdFx0XHRcdFx0X3NlbGYuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBfO1xuXHR9XG5cblx0Ly8gR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcblx0dmFyIHNjcmlwdCA9IF8udXRpbC5jdXJyZW50U2NyaXB0KCk7XG5cblx0aWYgKHNjcmlwdCkge1xuXHRcdF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG5cdFx0aWYgKHNjcmlwdC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWFudWFsJykpIHtcblx0XHRcdF8ubWFudWFsID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2soKSB7XG5cdFx0aWYgKCFfLm1hbnVhbCkge1xuXHRcdFx0Xy5oaWdobGlnaHRBbGwoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIV8ubWFudWFsKSB7XG5cdFx0Ly8gSWYgdGhlIGRvY3VtZW50IHN0YXRlIGlzIFwibG9hZGluZ1wiLCB0aGVuIHdlJ2xsIHVzZSBET01Db250ZW50TG9hZGVkLlxuXHRcdC8vIElmIHRoZSBkb2N1bWVudCBzdGF0ZSBpcyBcImludGVyYWN0aXZlXCIgYW5kIHRoZSBwcmlzbS5qcyBzY3JpcHQgaXMgZGVmZXJyZWQsIHRoZW4gd2UnbGwgYWxzbyB1c2UgdGhlXG5cdFx0Ly8gRE9NQ29udGVudExvYWRlZCBldmVudCBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIHNvbWUgcGx1Z2lucyBvciBsYW5ndWFnZXMgd2hpY2ggaGF2ZSBhbHNvIGJlZW4gZGVmZXJyZWQgYW5kIHRoZXlcblx0XHQvLyBtaWdodCB0YWtlIGxvbmdlciBvbmUgYW5pbWF0aW9uIGZyYW1lIHRvIGV4ZWN1dGUgd2hpY2ggY2FuIGNyZWF0ZSBhIHJhY2UgY29uZGl0aW9uIHdoZXJlIG9ubHkgc29tZSBwbHVnaW5zIGhhdmVcblx0XHQvLyBiZWVuIGxvYWRlZCB3aGVuIFByaXNtLmhpZ2hsaWdodEFsbCgpIGlzIGV4ZWN1dGVkLCBkZXBlbmRpbmcgb24gaG93IGZhc3QgcmVzb3VyY2VzIGFyZSBsb2FkZWQuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9QcmlzbUpTL3ByaXNtL2lzc3Vlcy8yMTAyXG5cdFx0dmFyIHJlYWR5U3RhdGUgPSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHRcdGlmIChyZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgcmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyAmJiBzY3JpcHQgJiYgc2NyaXB0LmRlZmVyKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrLCAxNik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIF87XG5cbn0oX3NlbGYpKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUHJpc207XG59XG5cbi8vIGhhY2sgZm9yIGNvbXBvbmVudHMgdG8gd29yayBjb3JyZWN0bHkgaW4gbm9kZS5qc1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdGdsb2JhbC5QcmlzbSA9IFByaXNtO1xufVxuXG4vLyBzb21lIGFkZGl0aW9uYWwgZG9jdW1lbnRhdGlvbi90eXBlc1xuXG4vKipcbiAqIFRoZSBleHBhbnNpb24gb2YgYSBzaW1wbGUgYFJlZ0V4cGAgbGl0ZXJhbCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZWRlZiBHcmFtbWFyVG9rZW5cbiAqIEBwcm9wZXJ0eSB7UmVnRXhwfSBwYXR0ZXJuIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gb2YgdGhlIHRva2VuLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbG9va2JlaGluZD1mYWxzZV0gSWYgYHRydWVgLCB0aGVuIHRoZSBmaXJzdCBjYXB0dXJpbmcgZ3JvdXAgb2YgYHBhdHRlcm5gIHdpbGwgKGVmZmVjdGl2ZWx5KVxuICogYmVoYXZlIGFzIGEgbG9va2JlaGluZCBncm91cCBtZWFuaW5nIHRoYXQgdGhlIGNhcHR1cmVkIHRleHQgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgbWF0Y2hlZCB0ZXh0IG9mIHRoZSBuZXcgdG9rZW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtncmVlZHk9ZmFsc2VdIFdoZXRoZXIgdGhlIHRva2VuIGlzIGdyZWVkeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIEFuIG9wdGlvbmFsIGFsaWFzIG9yIGxpc3Qgb2YgYWxpYXNlcy5cbiAqIEBwcm9wZXJ0eSB7R3JhbW1hcn0gW2luc2lkZV0gVGhlIG5lc3RlZCBncmFtbWFyIG9mIHRoaXMgdG9rZW4uXG4gKlxuICogVGhlIGBpbnNpZGVgIGdyYW1tYXIgd2lsbCBiZSB1c2VkIHRvIHRva2VuaXplIHRoZSB0ZXh0IHZhbHVlIG9mIGVhY2ggdG9rZW4gb2YgdGhpcyBraW5kLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSBuZXN0ZWQgYW5kIGV2ZW4gcmVjdXJzaXZlIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuICpcbiAqIE5vdGU6IFRoaXMgY2FuIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvbi4gQmUgY2FyZWZ1bCB3aGVuIHlvdSBlbWJlZCBkaWZmZXJlbnQgbGFuZ3VhZ2VzIG9yIGV2ZW4gdGhlIHNhbWUgbGFuZ3VhZ2UgaW50b1xuICogZWFjaCBhbm90aGVyLlxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgR3JhbW1hclxuICogQHR5cGUge09iamVjdDxzdHJpbmcsIFJlZ0V4cCB8IEdyYW1tYXJUb2tlbiB8IEFycmF5PFJlZ0V4cCB8IEdyYW1tYXJUb2tlbj4+fVxuICogQHByb3BlcnR5IHtHcmFtbWFyfSBbcmVzdF0gQW4gb3B0aW9uYWwgZ3JhbW1hciBvYmplY3QgdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoaXMgZ3JhbW1hci5cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBpbnZva2VkIGFmdGVyIGFuIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSBoaWdobGlnaHRlZC5cbiAqXG4gKiBAY2FsbGJhY2sgSGlnaGxpZ2h0Q2FsbGJhY2tcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBzdWNjZXNzZnVsbHkgaGlnaGxpZ2h0ZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBIb29rQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2suXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tbWFya3VwLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG5cdCdjb21tZW50Jzoge1xuXHRcdHBhdHRlcm46IC88IS0tKD86KD8hPCEtLSlbXFxzXFxTXSkqPy0tPi8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdwcm9sb2cnOiB7XG5cdFx0cGF0dGVybjogLzxcXD9bXFxzXFxTXSs/XFw/Pi8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdkb2N0eXBlJzoge1xuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULWRvY3R5cGVkZWNsXG5cdFx0cGF0dGVybjogLzwhRE9DVFlQRSg/OltePlwiJ1tcXF1dfFwiW15cIl0qXCJ8J1teJ10qJykrKD86XFxbKD86W148XCInXFxdXXxcIlteXCJdKlwifCdbXiddKid8PCg/ISEtLSl8PCEtLSg/OlteLV18LSg/IS0+KSkqLS0+KSpcXF1cXHMqKT8+L2ksXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2ludGVybmFsLXN1YnNldCc6IHtcblx0XHRcdFx0cGF0dGVybjogLyheW15cXFtdKlxcWylbXFxzXFxTXSsoPz1cXF0+JCkvLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuXHRcdFx0J2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG5cdFx0XHQnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG5cdFx0fVxuXHR9LFxuXHQnY2RhdGEnOiB7XG5cdFx0cGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQndGFnJzoge1xuXHRcdHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3BlY2lhbC1hdHRyJzogW10sXG5cdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0cGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiBbXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IC9ePS8sXG5cdFx0XHRcdFx0XHRcdGFsaWFzOiAnYXR0ci1lcXVhbHMnXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXihcXHMqKVtcIiddfFtcIiddJC8sXG5cdFx0XHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuXHRcdFx0J2F0dHItbmFtZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL1teXFxzPlxcL10rLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXHQnZW50aXR5JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcblx0XHRcdGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuXHRcdH0sXG5cdFx0LyYjeD9bXFxkYS1mXXsxLDh9Oy9pXG5cdF1cbn07XG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPVxuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG5cblx0aWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuXHRcdGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkSW5saW5lZCcsIHtcblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5saW5lZCBsYW5ndWFnZSB0byBtYXJrdXAuXG5cdCAqXG5cdCAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgPHN0eWxlPmAgdGFncy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuXHQgKi9cblx0dmFsdWU6IGZ1bmN0aW9uIGFkZElubGluZWQodGFnTmFtZSwgbGFuZykge1xuXHRcdHZhciBpbmNsdWRlZENkYXRhSW5zaWRlID0ge307XG5cdFx0aW5jbHVkZWRDZGF0YUluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuXHRcdFx0cGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXHRcdGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2NkYXRhJ10gPSAvXjwhXFxbQ0RBVEFcXFt8XFxdXFxdPiQvaTtcblxuXHRcdHZhciBpbnNpZGUgPSB7XG5cdFx0XHQnaW5jbHVkZWQtY2RhdGEnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcblx0XHRcdFx0aW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcblx0XHRcdHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXG5cdFx0dmFyIGRlZiA9IHt9O1xuXHRcdGRlZlt0YWdOYW1lXSA9IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhZ05hbWU7IH0pLCAnaScpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogaW5zaWRlXG5cdFx0fTtcblxuXHRcdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG5cdH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuXHQvKipcblx0ICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdCAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG5cdFx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdFx0LyhefFtcIidcXHNdKS8uc291cmNlICsgJyg/OicgKyBhdHRyTmFtZSArICcpJyArIC9cXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSkvLnNvdXJjZSxcblx0XHRcdFx0J2knXG5cdFx0XHQpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG5cdFx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC89W1xcc1xcU10rLyxcblx0XHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHRcdCd2YWx1ZSc6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG5cdFx0XHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcblx0XHRcdFx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiBbXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0vLFxuXHRcdFx0XHRcdFx0XHRcdGFsaWFzOiAnYXR0ci1lcXVhbHMnXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC9cInwnL1xuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuUHJpc20ubGFuZ3VhZ2VzLnhtbCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcblByaXNtLmxhbmd1YWdlcy5zc21sID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5hdG9tID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5yc3MgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY3NzLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHR2YXIgc3RyaW5nID0gLyg/OlwiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInwnKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pKicpLztcblxuXHRQcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuXHRcdCdjb21tZW50JzogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuXHRcdCdhdHJ1bGUnOiB7XG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ0BbXFxcXHctXSg/OicgKyAvW147e1xcc1wiJ118XFxzKyg/IVxccykvLnNvdXJjZSArICd8JyArIHN0cmluZy5zb3VyY2UgKyAnKSo/JyArIC8oPzo7fCg/PVxccypcXHspKS8uc291cmNlKSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQncnVsZSc6IC9eQFtcXHctXSsvLFxuXHRcdFx0XHQnc2VsZWN0b3ItZnVuY3Rpb24tYXJndW1lbnQnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyhcXGJzZWxlY3RvclxccypcXChcXHMqKD8hW1xccyldKSkoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkrKD89XFxzKlxcKSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0YWxpYXM6ICdzZWxlY3Rvcidcblx0XHRcdFx0fSxcblx0XHRcdFx0J2tleXdvcmQnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTZWUgcmVzdCBiZWxvd1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3VybCc6IHtcblx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2Z1bmN0aW9uJzogL151cmwvaSxcblx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG5cdFx0XHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuXHRcdFx0XHRcdGFsaWFzOiAndXJsJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnc2VsZWN0b3InOiB7XG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRwYXR0ZXJuOiBzdHJpbmcsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdCdwcm9wZXJ0eSc6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcblx0XHQnZnVuY3Rpb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cblx0fTtcblxuXHRQcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5jc3M7XG5cblx0dmFyIG1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdGlmIChtYXJrdXApIHtcblx0XHRtYXJrdXAudGFnLmFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuXHRcdG1hcmt1cC50YWcuYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcblx0fVxuXG59KFByaXNtKSk7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jbGlrZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG5cdCdjb21tZW50JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9bLlxcXFxdL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuXHQnZnVuY3Rpb24nOiAvXFxiXFx3Kyg/PVxcKCkvLFxuXHQnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcblx0J29wZXJhdG9yJzogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG5cdCdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG5cdCdjbGFzcy1uYW1lJzogW1xuXHRcdFByaXNtLmxhbmd1YWdlcy5jbGlrZVsnY2xhc3MtbmFtZSddLFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kQS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFwuKD86Y29uc3RydWN0b3J8cHJvdG90eXBlKSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J2tleXdvcmQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi5dfFxcLlxcLlxcLlxccyopXFxiKD86YXN8YXNzZXJ0KD89XFxzKlxceyl8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHkoPz1cXHMqKD86XFx7fCQpKXxmb3J8ZnJvbSg/PVxccyooPzpbJ1wiXXwkKSl8ZnVuY3Rpb258KD86Z2V0fHNldCkoPz1cXHMqKD86WyNcXFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRdLFxuXHQvLyBBbGxvdyBmb3IgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIChTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAwODQ0NClcblx0J2Z1bmN0aW9uJzogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyooPzpcXC5cXHMqKD86YXBwbHl8YmluZHxjYWxsKVxccyopP1xcKCkvLFxuXHQnbnVtYmVyJzoge1xuXHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdC8oXnxbXlxcdyRdKS8uc291cmNlICtcblx0XHRcdCcoPzonICtcblx0XHRcdChcblx0XHRcdFx0Ly8gY29uc3RhbnRcblx0XHRcdFx0L05hTnxJbmZpbml0eS8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gYmluYXJ5IGludGVnZXJcblx0XHRcdFx0LzBbYkJdWzAxXSsoPzpfWzAxXSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBvY3RhbCBpbnRlZ2VyXG5cdFx0XHRcdC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG5cdFx0XHRcdC8wW3hYXVtcXGRBLUZhLWZdKyg/Ol9bXFxkQS1GYS1mXSspKm4/Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBkZWNpbWFsIGJpZ2ludFxuXHRcdFx0XHQvXFxkKyg/Ol9cXGQrKSpuLy5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBkZWNpbWFsIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCkgYnV0IG5vIGJpZ2ludFxuXHRcdFx0XHQvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlXG5cdFx0XHQpICtcblx0XHRcdCcpJyArXG5cdFx0XHQvKD8hW1xcdyRdKS8uc291cmNlXG5cdFx0KSxcblx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdH0sXG5cdCdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PT58JiY9P3xcXHxcXHw9P3xbIT1dPT18PDw9P3w+Pj4/PT98Wy0rKi8lJnxeIT08Pl09P3xcXC57M318XFw/XFw/PT98XFw/XFwuP3xbfjpdL1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydjbGFzcy1uYW1lJ11bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuXHQncmVnZXgnOiB7XG5cdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0Ly8gbG9va2JlaGluZFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1kdXBlLWNoYXJhY3RlcnMtY2hhcmFjdGVyLWNsYXNzXG5cdFx0XHQvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXXxcXGIoPzpyZXR1cm58eWllbGQpKVxccyopLy5zb3VyY2UgK1xuXHRcdFx0Ly8gUmVnZXggcGF0dGVybjpcblx0XHRcdC8vIFRoZXJlIGFyZSAyIHJlZ2V4IHBhdHRlcm5zIGhlcmUuIFRoZSBSZWdFeHAgc2V0IG5vdGF0aW9uIHByb3Bvc2FsIGFkZGVkIHN1cHBvcnQgZm9yIG5lc3RlZCBjaGFyYWN0ZXJcblx0XHRcdC8vIGNsYXNzZXMgaWYgdGhlIGB2YCBmbGFnIGlzIHByZXNlbnQuIFVuZm9ydHVuYXRlbHksIG5lc3RlZCBDQ3MgYXJlIGJvdGggY29udGV4dC1mcmVlIGFuZCBpbmNvbXBhdGlibGVcblx0XHRcdC8vIHdpdGggdGhlIG9ubHkgc3ludGF4LCBzbyB3ZSBoYXZlIHRvIGRlZmluZSAyIGRpZmZlcmVudCByZWdleCBwYXR0ZXJucy5cblx0XHRcdC9cXC8vLnNvdXJjZSArXG5cdFx0XHQnKD86JyArXG5cdFx0XHQvKD86XFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fS8uc291cmNlICtcblx0XHRcdCd8JyArXG5cdFx0XHQvLyBgdmAgZmxhZyBzeW50YXguIFRoaXMgc3VwcG9ydHMgMyBsZXZlbHMgb2YgbmVzdGVkIGNoYXJhY3RlciBjbGFzc2VzLlxuXHRcdFx0Lyg/OlxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwufFxcWyg/OlteW1xcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF0pKlxcXSkqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fXZbZGdpbXl1c117MCw3fS8uc291cmNlICtcblx0XHRcdCcpJyArXG5cdFx0XHQvLyBsb29rYWhlYWRcblx0XHRcdC8oPz0oPzpcXHN8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKig/OiR8W1xcclxcbiwuOzp9KVxcXV18XFwvXFwvKSkvLnNvdXJjZVxuXHRcdCksXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncmVnZXgtc291cmNlJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXihcXC8pW1xcc1xcU10rKD89XFwvW2Etel0qJCkvLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRhbGlhczogJ2xhbmd1YWdlLXJlZ2V4Jyxcblx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMucmVnZXhcblx0XHRcdH0sXG5cdFx0XHQncmVnZXgtZGVsaW1pdGVyJzogL15cXC98XFwvJC8sXG5cdFx0XHQncmVnZXgtZmxhZ3MnOiAvXlthLXpdKyQvLFxuXHRcdH1cblx0fSxcblx0Ly8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuXHQnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG5cdFx0cGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG5cdFx0YWxpYXM6ICdmdW5jdGlvbidcblx0fSxcblx0J3BhcmFtZXRlcic6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKGZ1bmN0aW9uKD86XFxzKyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopP1xccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJGEtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo9PikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/Oig/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqKVxcKFxccyp8XFxdXFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccypcXHspLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fVxuXHRdLFxuXHQnY29uc3RhbnQnOiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcblx0J2hhc2hiYW5nJzoge1xuXHRcdHBhdHRlcm46IC9eIyEuKi8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAnY29tbWVudCdcblx0fSxcblx0J3RlbXBsYXRlLXN0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH18KD8hXFwkXFx7KVteXFxcXGBdKSpgLyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9eYHxgJC8sXG5cdFx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdFx0fSxcblx0XHRcdCdpbnRlcnBvbGF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopXFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9Lyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxcJFxce3xcXH0kLyxcblx0XHRcdFx0XHRcdGFsaWFzOiAncHVuY3R1YXRpb24nXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyZXN0OiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3N0cmluZyc6IC9bXFxzXFxTXSsvXG5cdFx0fVxuXHR9LFxuXHQnc3RyaW5nLXByb3BlcnR5Jzoge1xuXHRcdHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIoPz1cXHMqOikvbSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ3Byb3BlcnR5J1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcblx0J2xpdGVyYWwtcHJvcGVydHknOiB7XG5cdFx0cGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRhbGlhczogJ3Byb3BlcnR5J1xuXHR9LFxufSk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoJ3NjcmlwdCcsICdqYXZhc2NyaXB0Jyk7XG5cblx0Ly8gYWRkIGF0dHJpYnV0ZSBzdXBwb3J0IGZvciBhbGwgRE9NIGV2ZW50cy5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzI1N0YW5kYXJkX2V2ZW50c1xuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoXG5cdFx0L29uKD86YWJvcnR8Ymx1cnxjaGFuZ2V8Y2xpY2t8Y29tcG9zaXRpb24oPzplbmR8c3RhcnR8dXBkYXRlKXxkYmxjbGlja3xlcnJvcnxmb2N1cyg/OmlufG91dCk/fGtleSg/OmRvd258dXApfGxvYWR8bW91c2UoPzpkb3dufGVudGVyfGxlYXZlfG1vdmV8b3V0fG92ZXJ8dXApfHJlc2V0fHJlc2l6ZXxzY3JvbGx8c2VsZWN0fHNsb3RjaGFuZ2V8c3VibWl0fHVubG9hZHx3aGVlbCkvLnNvdXJjZSxcblx0XHQnamF2YXNjcmlwdCdcblx0KTtcbn1cblxuUHJpc20ubGFuZ3VhZ2VzLmpzID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdGlmICh0eXBlb2YgUHJpc20gPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9tYXRjaGVzI1BvbHlmaWxsXG5cdGlmICghRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcykge1xuXHRcdEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cdH1cblxuXHR2YXIgTE9BRElOR19NRVNTQUdFID0gJ0xvYWRpbmfigKYnO1xuXHR2YXIgRkFJTFVSRV9NRVNTQUdFID0gZnVuY3Rpb24gKHN0YXR1cywgbWVzc2FnZSkge1xuXHRcdHJldHVybiAn4pyWIEVycm9yICcgKyBzdGF0dXMgKyAnIHdoaWxlIGZldGNoaW5nIGZpbGU6ICcgKyBtZXNzYWdlO1xuXHR9O1xuXHR2YXIgRkFJTFVSRV9FTVBUWV9NRVNTQUdFID0gJ+KcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSc7XG5cblx0dmFyIEVYVEVOU0lPTlMgPSB7XG5cdFx0J2pzJzogJ2phdmFzY3JpcHQnLFxuXHRcdCdweSc6ICdweXRob24nLFxuXHRcdCdyYic6ICdydWJ5Jyxcblx0XHQncHMxJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdCdwc20xJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdCdzaCc6ICdiYXNoJyxcblx0XHQnYmF0JzogJ2JhdGNoJyxcblx0XHQnaCc6ICdjJyxcblx0XHQndGV4JzogJ2xhdGV4J1xuXHR9O1xuXG5cdHZhciBTVEFUVVNfQVRUUiA9ICdkYXRhLXNyYy1zdGF0dXMnO1xuXHR2YXIgU1RBVFVTX0xPQURJTkcgPSAnbG9hZGluZyc7XG5cdHZhciBTVEFUVVNfTE9BREVEID0gJ2xvYWRlZCc7XG5cdHZhciBTVEFUVVNfRkFJTEVEID0gJ2ZhaWxlZCc7XG5cblx0dmFyIFNFTEVDVE9SID0gJ3ByZVtkYXRhLXNyY106bm90KFsnICsgU1RBVFVTX0FUVFIgKyAnPVwiJyArIFNUQVRVU19MT0FERUQgKyAnXCJdKSdcblx0XHQrICc6bm90KFsnICsgU1RBVFVTX0FUVFIgKyAnPVwiJyArIFNUQVRVU19MT0FESU5HICsgJ1wiXSknO1xuXG5cdC8qKlxuXHQgKiBMb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgVVJMIG9yIHBhdGggb2YgdGhlIHNvdXJjZSBmaWxlIHRvIGxvYWQuXG5cdCAqIEBwYXJhbSB7KHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkfSBzdWNjZXNzXG5cdCAqIEBwYXJhbSB7KHJlYXNvbjogc3RyaW5nKSA9PiB2b2lkfSBlcnJvclxuXHQgKi9cblx0ZnVuY3Rpb24gbG9hZEZpbGUoc3JjLCBzdWNjZXNzLCBlcnJvcikge1xuXHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdFx0aWYgKHhoci5zdGF0dXMgPCA0MDAgJiYgeGhyLnJlc3BvbnNlVGV4dCkge1xuXHRcdFx0XHRcdHN1Y2Nlc3MoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG5cdFx0XHRcdFx0XHRlcnJvcihGQUlMVVJFX01FU1NBR0UoeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXJyb3IoRkFJTFVSRV9FTVBUWV9NRVNTQUdFKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5zZW5kKG51bGwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gcmFuZ2UuXG5cdCAqXG5cdCAqIFRoaXMgcmV0dXJucyBhIHJhbmdlIHdpdGggaW5jbHVzaXZlIGVuZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcmFuZ2Vcblx0ICogQHJldHVybnMge1tudW1iZXIsIG51bWJlciB8IHVuZGVmaW5lZF0gfCB1bmRlZmluZWR9XG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZVJhbmdlKHJhbmdlKSB7XG5cdFx0dmFyIG0gPSAvXlxccyooXFxkKylcXHMqKD86KCwpXFxzKig/OihcXGQrKVxccyopPyk/JC8uZXhlYyhyYW5nZSB8fCAnJyk7XG5cdFx0aWYgKG0pIHtcblx0XHRcdHZhciBzdGFydCA9IE51bWJlcihtWzFdKTtcblx0XHRcdHZhciBjb21tYSA9IG1bMl07XG5cdFx0XHR2YXIgZW5kID0gbVszXTtcblxuXHRcdFx0aWYgKCFjb21tYSkge1xuXHRcdFx0XHRyZXR1cm4gW3N0YXJ0LCBzdGFydF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWVuZCkge1xuXHRcdFx0XHRyZXR1cm4gW3N0YXJ0LCB1bmRlZmluZWRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtzdGFydCwgTnVtYmVyKGVuZCldO1xuXHRcdH1cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0UHJpc20uaG9va3MuYWRkKCdiZWZvcmUtaGlnaGxpZ2h0YWxsJywgZnVuY3Rpb24gKGVudikge1xuXHRcdGVudi5zZWxlY3RvciArPSAnLCAnICsgU0VMRUNUT1I7XG5cdH0pO1xuXG5cdFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLXNhbml0eS1jaGVjaycsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHR2YXIgcHJlID0gLyoqIEB0eXBlIHtIVE1MUHJlRWxlbWVudH0gKi8gKGVudi5lbGVtZW50KTtcblx0XHRpZiAocHJlLm1hdGNoZXMoU0VMRUNUT1IpKSB7XG5cdFx0XHRlbnYuY29kZSA9ICcnOyAvLyBmYXN0LXBhdGggdGhlIHdob2xlIHRoaW5nIGFuZCBnbyB0byBjb21wbGV0ZVxuXG5cdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfTE9BRElORyk7IC8vIG1hcmsgYXMgbG9hZGluZ1xuXG5cdFx0XHQvLyBhZGQgY29kZSBlbGVtZW50IHdpdGggbG9hZGluZyBtZXNzYWdlXG5cdFx0XHR2YXIgY29kZSA9IHByZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdDT0RFJykpO1xuXHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IExPQURJTkdfTUVTU0FHRTtcblxuXHRcdFx0dmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cblx0XHRcdHZhciBsYW5ndWFnZSA9IGVudi5sYW5ndWFnZTtcblx0XHRcdGlmIChsYW5ndWFnZSA9PT0gJ25vbmUnKSB7XG5cdFx0XHRcdC8vIHRoZSBsYW5ndWFnZSBtaWdodCBiZSAnbm9uZScgYmVjYXVzZSB0aGVyZSBpcyBubyBsYW5ndWFnZSBzZXQ7XG5cdFx0XHRcdC8vIGluIHRoaXMgY2FzZSwgd2Ugd2FudCB0byB1c2UgdGhlIGV4dGVuc2lvbiBhcyB0aGUgbGFuZ3VhZ2Vcblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9ICgvXFwuKFxcdyspJC8uZXhlYyhzcmMpIHx8IFssICdub25lJ10pWzFdO1xuXHRcdFx0XHRsYW5ndWFnZSA9IEVYVEVOU0lPTlNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBsYW5ndWFnZSBjbGFzc2VzXG5cdFx0XHRQcmlzbS51dGlsLnNldExhbmd1YWdlKGNvZGUsIGxhbmd1YWdlKTtcblx0XHRcdFByaXNtLnV0aWwuc2V0TGFuZ3VhZ2UocHJlLCBsYW5ndWFnZSk7XG5cblx0XHRcdC8vIHByZWxvYWQgdGhlIGxhbmd1YWdlXG5cdFx0XHR2YXIgYXV0b2xvYWRlciA9IFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcjtcblx0XHRcdGlmIChhdXRvbG9hZGVyKSB7XG5cdFx0XHRcdGF1dG9sb2FkZXIubG9hZExhbmd1YWdlcyhsYW5ndWFnZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvYWQgZmlsZVxuXHRcdFx0bG9hZEZpbGUoXG5cdFx0XHRcdHNyYyxcblx0XHRcdFx0ZnVuY3Rpb24gKHRleHQpIHtcblx0XHRcdFx0XHQvLyBtYXJrIGFzIGxvYWRlZFxuXHRcdFx0XHRcdHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19MT0FERUQpO1xuXG5cdFx0XHRcdFx0Ly8gaGFuZGxlIGRhdGEtcmFuZ2Vcblx0XHRcdFx0XHR2YXIgcmFuZ2UgPSBwYXJzZVJhbmdlKHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2UnKSk7XG5cdFx0XHRcdFx0aWYgKHJhbmdlKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG4/fFxcbi9nKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJhbmdlIGlzIG9uZS1iYXNlZCBhbmQgaW5jbHVzaXZlIG9uIGJvdGggZW5kc1xuXHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gcmFuZ2VbMF07XG5cdFx0XHRcdFx0XHR2YXIgZW5kID0gcmFuZ2VbMV0gPT0gbnVsbCA/IGxpbmVzLmxlbmd0aCA6IHJhbmdlWzFdO1xuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGxpbmVzLmxlbmd0aDsgfVxuXHRcdFx0XHRcdFx0c3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzdGFydCAtIDEsIGxpbmVzLmxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA8IDApIHsgZW5kICs9IGxpbmVzLmxlbmd0aDsgfVxuXHRcdFx0XHRcdFx0ZW5kID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZW5kLCBsaW5lcy5sZW5ndGgpKTtcblxuXHRcdFx0XHRcdFx0dGV4dCA9IGxpbmVzLnNsaWNlKHN0YXJ0LCBlbmQpLmpvaW4oJ1xcbicpO1xuXG5cdFx0XHRcdFx0XHQvLyBhZGQgZGF0YS1zdGFydCBmb3IgbGluZSBudW1iZXJzXG5cdFx0XHRcdFx0XHRpZiAoIXByZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3RhcnQnKSkge1xuXHRcdFx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXJ0JywgU3RyaW5nKHN0YXJ0ICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGhpZ2hsaWdodCBjb2RlXG5cdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gbWFyayBhcyBmYWlsZWRcblx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfRkFJTEVEKTtcblxuXHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodCA9IHtcblx0XHQvKipcblx0XHQgKiBFeGVjdXRlcyB0aGUgRmlsZSBIaWdobGlnaHQgcGx1Z2luIGZvciBhbGwgbWF0Y2hpbmcgYHByZWAgZWxlbWVudHMgdW5kZXIgdGhlIGdpdmVuIGNvbnRhaW5lci5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IEVsZW1lbnRzIHdoaWNoIGFyZSBhbHJlYWR5IGxvYWRlZCBvciBjdXJyZW50bHkgbG9hZGluZyB3aWxsIG5vdCBiZSB0b3VjaGVkIGJ5IHRoaXMgbWV0aG9kLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtQYXJlbnROb2RlfSBbY29udGFpbmVyPWRvY3VtZW50XVxuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodDogZnVuY3Rpb24gaGlnaGxpZ2h0KGNvbnRhaW5lcikge1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gKGNvbnRhaW5lciB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVsZW1lbnRzW2krK10pOykge1xuXHRcdFx0XHRQcmlzbS5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgbG9nZ2VkID0gZmFsc2U7XG5cdC8qKiBAZGVwcmVjYXRlZCBVc2UgYFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHRgIGluc3RlYWQuICovXG5cdFByaXNtLmZpbGVIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCFsb2dnZWQpIHtcblx0XHRcdGNvbnNvbGUud2FybignUHJpc20uZmlsZUhpZ2hsaWdodCBpcyBkZXByZWNhdGVkLiBVc2UgYFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHRgIGluc3RlYWQuJyk7XG5cdFx0XHRsb2dnZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cbn0oKSk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50IHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0eXBlT2YgPSByZXF1aXJlKCdraW5kLW9mJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLXNoYWxsb3cnKTtcblxuLyoqXG4gKiBQYXJzZSBzZWN0aW9ucyBpbiBgaW5wdXRgIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBgYGBqc1xuICogdmFyIHNlY3Rpb25zID0gcmVxdWlyZSgneyU9IG5hbWUgJX0nKTtcbiAqIHZhciByZXN1bHQgPSBzZWN0aW9ucyhpbnB1dCwgb3B0aW9ucyk7XG4gKiAvLyB7IGNvbnRlbnQ6ICdDb250ZW50IGJlZm9yZSBzZWN0aW9ucycsIHNlY3Rpb25zOiBbXSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxPYmplY3R9IGBpbnB1dGAgSWYgaW5wdXQgaXMgYW4gb2JqZWN0LCBpdCdzIGBjb250ZW50YCBwcm9wZXJ0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBgY29udGVudGAgc3RyaW5nIGFuZCBhbiBhcnJheSBvZiBgc2VjdGlvbnNgIG9iamVjdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHsgcGFyc2U6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHZhciBmaWxlID0gdG9PYmplY3QoaW5wdXQpO1xuICB2YXIgZGVmYXVsdHMgPSB7c2VjdGlvbl9kZWxpbWl0ZXI6ICctLS0nLCBwYXJzZTogaWRlbnRpdHl9O1xuICB2YXIgb3B0cyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB2YXIgZGVsaW0gPSBvcHRzLnNlY3Rpb25fZGVsaW1pdGVyO1xuICB2YXIgbGluZXMgPSBmaWxlLmNvbnRlbnQuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIHNlY3Rpb25zID0gbnVsbDtcbiAgdmFyIHNlY3Rpb24gPSBjcmVhdGVTZWN0aW9uKCk7XG4gIHZhciBjb250ZW50ID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIGZ1bmN0aW9uIGluaXRTZWN0aW9ucyh2YWwpIHtcbiAgICBmaWxlLmNvbnRlbnQgPSB2YWw7XG4gICAgc2VjdGlvbnMgPSBbXTtcbiAgICBjb250ZW50ID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVNlY3Rpb24odmFsKSB7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgc2VjdGlvbi5rZXkgPSBnZXRLZXkoc3RhY2tbMF0sIGRlbGltKTtcbiAgICAgIHNlY3Rpb24uY29udGVudCA9IHZhbDtcbiAgICAgIG9wdHMucGFyc2Uoc2VjdGlvbiwgc2VjdGlvbnMpO1xuICAgICAgc2VjdGlvbnMucHVzaChzZWN0aW9uKTtcbiAgICAgIHNlY3Rpb24gPSBjcmVhdGVTZWN0aW9uKCk7XG4gICAgICBjb250ZW50ID0gW107XG4gICAgICBzdGFjayA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgIHZhciBsZW4gPSBzdGFjay5sZW5ndGg7XG4gICAgdmFyIGxuID0gbGluZS50cmltKCk7XG5cbiAgICBpZiAoaXNEZWxpbWl0ZXIobG4sIGRlbGltKSkge1xuICAgICAgaWYgKGxuLmxlbmd0aCA9PT0gMyAmJiBpICE9PSAwKSB7XG4gICAgICAgIGlmIChsZW4gPT09IDAgfHwgbGVuID09PSAyKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKGxpbmUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2gobG4pO1xuICAgICAgICBzZWN0aW9uLmRhdGEgPSBjb250ZW50LmpvaW4oJ1xcbicpO1xuICAgICAgICBjb250ZW50ID0gW107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdFNlY3Rpb25zKGNvbnRlbnQuam9pbignXFxuJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIGNsb3NlU2VjdGlvbihjb250ZW50LmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaChsbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb250ZW50LnB1c2gobGluZSk7XG4gIH1cblxuICBpZiAoc2VjdGlvbnMgPT09IG51bGwpIHtcbiAgICBpbml0U2VjdGlvbnMoY29udGVudC5qb2luKCdcXG4nKSk7XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VTZWN0aW9uKGNvbnRlbnQuam9pbignXFxuJykpO1xuICB9XG5cbiAgZmlsZS5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICByZXR1cm4gZmlsZTtcbn07XG5cbmZ1bmN0aW9uIGlzRGVsaW1pdGVyKGxpbmUsIGRlbGltKSB7XG4gIGlmIChsaW5lLnNsaWNlKDAsIGRlbGltLmxlbmd0aCkgIT09IGRlbGltKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChsaW5lLmNoYXJBdChkZWxpbS5sZW5ndGggKyAxKSA9PT0gZGVsaW0uc2xpY2UoLTEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdChpbnB1dCkge1xuICBpZiAodHlwZU9mKGlucHV0KSAhPT0gJ29iamVjdCcpIHtcbiAgICBpbnB1dCA9IHsgY29udGVudDogaW5wdXQgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQuY29udGVudCAhPT0gJ3N0cmluZycgJiYgIWlzQnVmZmVyKGlucHV0LmNvbnRlbnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBidWZmZXIgb3Igc3RyaW5nJyk7XG4gIH1cblxuICBpbnB1dC5jb250ZW50ID0gaW5wdXQuY29udGVudC50b1N0cmluZygpO1xuICBpbnB1dC5zZWN0aW9ucyA9IFtdO1xuICByZXR1cm4gaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIGdldEtleSh2YWwsIGRlbGltKSB7XG4gIHJldHVybiB2YWwgPyB2YWwuc2xpY2UoZGVsaW0ubGVuZ3RoKS50cmltKCkgOiAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VjdGlvbigpIHtcbiAgcmV0dXJuIHsga2V5OiAnJywgZGF0YTogJycsIGNvbnRlbnQ6ICcnIH07XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbCkge1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIHN0cmlwLWJvbS1zdHJpbmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3N0cmlwLWJvbS1zdHJpbmc+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCAyMDE3LCBKb24gU2NobGlua2VydC5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiBzdHIuY2hhckF0KDApID09PSAnXFx1ZmVmZicpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBzdHI7XG59O1xuIiwiaW1wb3J0e3R5cGVPZiBhcyBlLGlzRWxlbWVudCBhcyB0LGlzVmFsaWRFbGVtZW50VHlwZSBhcyBufWZyb21cInJlYWN0LWlzXCI7aW1wb3J0IHIse3VzZVN0YXRlIGFzIG8sdXNlQ29udGV4dCBhcyBzLHVzZU1lbW8gYXMgaSx1c2VFZmZlY3QgYXMgYSx1c2VSZWYgYXMgYyxjcmVhdGVFbGVtZW50IGFzIHUsdXNlRGVidWdWYWx1ZSBhcyBsLHVzZUxheW91dEVmZmVjdCBhcyBkfWZyb21cInJlYWN0XCI7aW1wb3J0IGggZnJvbVwic2hhbGxvd2VxdWFsXCI7aW1wb3J0IHAgZnJvbVwiQGVtb3Rpb24vc3R5bGlzXCI7aW1wb3J0IGYgZnJvbVwiQGVtb3Rpb24vdW5pdGxlc3NcIjtpbXBvcnQgbSBmcm9tXCJAZW1vdGlvbi9pcy1wcm9wLXZhbGlkXCI7aW1wb3J0IHkgZnJvbVwiaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3NcIjtmdW5jdGlvbiB2KCl7cmV0dXJuKHY9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49YXJndW1lbnRzW3RdO2Zvcih2YXIgciBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpJiYoZVtyXT1uW3JdKX1yZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgZz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1bZVswXV0scj0wLG89dC5sZW5ndGg7cjxvO3IrPTEpbi5wdXNoKHRbcl0sZVtyKzFdKTtyZXR1cm4gbn0sUz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZcIltvYmplY3QgT2JqZWN0XVwiPT09KHQudG9TdHJpbmc/dC50b1N0cmluZygpOk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSkmJiFlKHQpfSx3PU9iamVjdC5mcmVlemUoW10pLEU9T2JqZWN0LmZyZWV6ZSh7fSk7ZnVuY3Rpb24gYihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlfWZ1bmN0aW9uIF8oZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJzdHJpbmdcIj09dHlwZW9mIGUmJmV8fGUuZGlzcGxheU5hbWV8fGUubmFtZXx8XCJDb21wb25lbnRcIn1mdW5jdGlvbiBOKGUpe3JldHVybiBlJiZcInN0cmluZ1wiPT10eXBlb2YgZS5zdHlsZWRDb21wb25lbnRJZH12YXIgQT1cInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmKHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19BVFRSfHxwcm9jZXNzLmVudi5TQ19BVFRSKXx8XCJkYXRhLXN0eWxlZFwiLEM9XCI1LjMuNlwiLEk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJIVE1MRWxlbWVudFwiaW4gd2luZG93LFA9Qm9vbGVhbihcImJvb2xlYW5cIj09dHlwZW9mIFNDX0RJU0FCTEVfU1BFRURZP1NDX0RJU0FCTEVfU1BFRURZOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZ2b2lkIDAhPT1wcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkmJlwiXCIhPT1wcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFk/XCJmYWxzZVwiIT09cHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZJiZwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZJiZcIlwiIT09cHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFk/XCJmYWxzZVwiIT09cHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkmJnByb2Nlc3MuZW52LlNDX0RJU0FCTEVfU1BFRURZOlwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYpLE89e30sUj1cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WP3sxOlwiQ2Fubm90IGNyZWF0ZSBzdHlsZWQtY29tcG9uZW50IGZvciBjb21wb25lbnQ6ICVzLlxcblxcblwiLDI6XCJDYW4ndCBjb2xsZWN0IHN0eWxlcyBvbmNlIHlvdSd2ZSBjb25zdW1lZCBhIGBTZXJ2ZXJTdHlsZVNoZWV0YCdzIHN0eWxlcyEgYFNlcnZlclN0eWxlU2hlZXRgIGlzIGEgb25lIG9mZiBpbnN0YW5jZSBmb3IgZWFjaCBzZXJ2ZXItc2lkZSByZW5kZXIgY3ljbGUuXFxuXFxuLSBBcmUgeW91IHRyeWluZyB0byByZXVzZSBpdCBhY3Jvc3MgcmVuZGVycz9cXG4tIEFyZSB5b3UgYWNjaWRlbnRhbGx5IGNhbGxpbmcgY29sbGVjdFN0eWxlcyB0d2ljZT9cXG5cXG5cIiwzOlwiU3RyZWFtaW5nIFNTUiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQ7IFBsZWFzZSBkbyBub3QgdHJ5IHRvIGNhbGwgdGhpcyBtZXRob2QgaW4gdGhlIGJyb3dzZXIuXFxuXFxuXCIsNDpcIlRoZSBgU3R5bGVTaGVldE1hbmFnZXJgIGV4cGVjdHMgYSB2YWxpZCB0YXJnZXQgb3Igc2hlZXQgcHJvcCFcXG5cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgY2xpZW50IGFuZCBpcyB5b3VyIHRhcmdldCBmYWxzeT9cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgc2VydmVyIGFuZCBpcyB0aGUgc2hlZXQgZmFsc3k/XFxuXFxuXCIsNTpcIlRoZSBjbG9uZSBtZXRob2QgY2Fubm90IGJlIHVzZWQgb24gdGhlIGNsaWVudCFcXG5cXG4tIEFyZSB5b3UgcnVubmluZyBpbiBhIGNsaWVudC1saWtlIGVudmlyb25tZW50IG9uIHRoZSBzZXJ2ZXI/XFxuLSBBcmUgeW91IHRyeWluZyB0byBydW4gU1NSIG9uIHRoZSBjbGllbnQ/XFxuXFxuXCIsNjpcIlRyeWluZyB0byBpbnNlcnQgYSBuZXcgc3R5bGUgdGFnLCBidXQgdGhlIGdpdmVuIE5vZGUgaXMgdW5tb3VudGVkIVxcblxcbi0gQXJlIHlvdSB1c2luZyBhIGN1c3RvbSB0YXJnZXQgdGhhdCBpc24ndCBtb3VudGVkP1xcbi0gRG9lcyB5b3VyIGRvY3VtZW50IG5vdCBoYXZlIGEgdmFsaWQgaGVhZCBlbGVtZW50P1xcbi0gSGF2ZSB5b3UgYWNjaWRlbnRhbGx5IHJlbW92ZWQgYSBzdHlsZSB0YWcgbWFudWFsbHk/XFxuXFxuXCIsNzonVGhlbWVQcm92aWRlcjogUGxlYXNlIHJldHVybiBhbiBvYmplY3QgZnJvbSB5b3VyIFwidGhlbWVcIiBwcm9wIGZ1bmN0aW9uLCBlLmcuXFxuXFxuYGBganNcXG50aGVtZT17KCkgPT4gKHt9KX1cXG5gYGBcXG5cXG4nLDg6J1RoZW1lUHJvdmlkZXI6IFBsZWFzZSBtYWtlIHlvdXIgXCJ0aGVtZVwiIHByb3AgYW4gb2JqZWN0LlxcblxcbicsOTpcIk1pc3NpbmcgZG9jdW1lbnQgYDxoZWFkPmBcXG5cXG5cIiwxMDpcIkNhbm5vdCBmaW5kIGEgU3R5bGVTaGVldCBpbnN0YW5jZS4gVXN1YWxseSB0aGlzIGhhcHBlbnMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvcGllcyBvZiBzdHlsZWQtY29tcG9uZW50cyBsb2FkZWQgYXQgb25jZS4gQ2hlY2sgb3V0IHRoaXMgaXNzdWUgZm9yIGhvdyB0byB0cm91Ymxlc2hvb3QgYW5kIGZpeCB0aGUgY29tbW9uIGNhc2VzIHdoZXJlIHRoaXMgc2l0dWF0aW9uIGNhbiBoYXBwZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9zdHlsZWQtY29tcG9uZW50cy9pc3N1ZXMvMTk0MSNpc3N1ZWNvbW1lbnQtNDE3ODYyMDIxXFxuXFxuXCIsMTE6XCJfVGhpcyBlcnJvciB3YXMgcmVwbGFjZWQgd2l0aCBhIGRldi10aW1lIHdhcm5pbmcsIGl0IHdpbGwgYmUgZGVsZXRlZCBmb3IgdjQgZmluYWwuXyBbY3JlYXRlR2xvYmFsU3R5bGVdIHJlY2VpdmVkIGNoaWxkcmVuIHdoaWNoIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBQbGVhc2UgdXNlIHRoZSBjb21wb25lbnQgd2l0aG91dCBwYXNzaW5nIGNoaWxkcmVuIGVsZW1lbnRzLlxcblxcblwiLDEyOlwiSXQgc2VlbXMgeW91IGFyZSBpbnRlcnBvbGF0aW5nIGEga2V5ZnJhbWUgZGVjbGFyYXRpb24gKCVzKSBpbnRvIGFuIHVudGFnZ2VkIHN0cmluZy4gVGhpcyB3YXMgc3VwcG9ydGVkIGluIHN0eWxlZC1jb21wb25lbnRzIHYzLCBidXQgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQgaW4gdjQgYXMga2V5ZnJhbWVzIGFyZSBub3cgaW5qZWN0ZWQgb24tZGVtYW5kLiBQbGVhc2Ugd3JhcCB5b3VyIHN0cmluZyBpbiB0aGUgY3NzXFxcXGBcXFxcYCBoZWxwZXIgd2hpY2ggZW5zdXJlcyB0aGUgc3R5bGVzIGFyZSBpbmplY3RlZCBjb3JyZWN0bHkuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hcGkjY3NzXFxuXFxuXCIsMTM6XCIlcyBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuXFxuXFxuXCIsMTQ6J1RoZW1lUHJvdmlkZXI6IFwidGhlbWVcIiBwcm9wIGlzIHJlcXVpcmVkLlxcblxcbicsMTU6XCJBIHN0eWxpcyBwbHVnaW4gaGFzIGJlZW4gc3VwcGxpZWQgdGhhdCBpcyBub3QgbmFtZWQuIFdlIG5lZWQgYSBuYW1lIGZvciBlYWNoIHBsdWdpbiB0byBiZSBhYmxlIHRvIHByZXZlbnQgc3R5bGluZyBjb2xsaXNpb25zIGJldHdlZW4gZGlmZmVyZW50IHN0eWxpcyBjb25maWd1cmF0aW9ucyB3aXRoaW4gdGhlIHNhbWUgYXBwLiBCZWZvcmUgeW91IHBhc3MgeW91ciBwbHVnaW4gdG8gYDxTdHlsZVNoZWV0TWFuYWdlciBzdHlsaXNQbHVnaW5zPXtbXX0+YCwgcGxlYXNlIG1ha2Ugc3VyZSBlYWNoIHBsdWdpbiBpcyB1bmlxdWVseS1uYW1lZCwgZS5nLlxcblxcbmBgYGpzXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGltcG9ydGVkUGx1Z2luLCAnbmFtZScsIHsgdmFsdWU6ICdzb21lLXVuaXF1ZS1uYW1lJyB9KTtcXG5gYGBcXG5cXG5cIiwxNjpcIlJlYWNoZWQgdGhlIGxpbWl0IG9mIGhvdyBtYW55IHN0eWxlZCBjb21wb25lbnRzIG1heSBiZSBjcmVhdGVkIGF0IGdyb3VwICVzLlxcbllvdSBtYXkgb25seSBjcmVhdGUgdXAgdG8gMSwwNzMsNzQxLDgyNCBjb21wb25lbnRzLiBJZiB5b3UncmUgY3JlYXRpbmcgY29tcG9uZW50cyBkeW5hbWljYWxseSxcXG5hcyBmb3IgaW5zdGFuY2UgaW4geW91ciByZW5kZXIgbWV0aG9kIHRoZW4geW91IG1heSBiZSBydW5uaW5nIGludG8gdGhpcyBsaW1pdGF0aW9uLlxcblxcblwiLDE3OlwiQ1NTU3R5bGVTaGVldCBjb3VsZCBub3QgYmUgZm91bmQgb24gSFRNTFN0eWxlRWxlbWVudC5cXG5IYXMgc3R5bGVkLWNvbXBvbmVudHMnIHN0eWxlIHRhZyBiZWVuIHVubW91bnRlZCBvciBhbHRlcmVkIGJ5IGFub3RoZXIgc2NyaXB0P1xcblwifTp7fTtmdW5jdGlvbiBEKCl7Zm9yKHZhciBlPWFyZ3VtZW50cy5sZW5ndGg8PTA/dm9pZCAwOmFyZ3VtZW50c1swXSx0PVtdLG49MSxyPWFyZ3VtZW50cy5sZW5ndGg7bjxyO24rPTEpdC5wdXNoKG48MHx8YXJndW1lbnRzLmxlbmd0aDw9bj92b2lkIDA6YXJndW1lbnRzW25dKTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtlPWUucmVwbGFjZSgvJVthLXpdLyx0KX0pKSxlfWZ1bmN0aW9uIGooZSl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodD4xP3QtMTowKSxyPTE7cjx0O3IrKyluW3ItMV09YXJndW1lbnRzW3JdO3Rocm93XCJwcm9kdWN0aW9uXCI9PT1wcm9jZXNzLmVudi5OT0RFX0VOVj9uZXcgRXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZC4gU2VlIGh0dHBzOi8vZ2l0LmlvL0pVSWFFI1wiK2UrXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIrKG4ubGVuZ3RoPjA/XCIgQXJnczogXCIrbi5qb2luKFwiLCBcIik6XCJcIikpOm5ldyBFcnJvcihELmFwcGx5KHZvaWQgMCxbUltlXV0uY29uY2F0KG4pKS50cmltKCkpfXZhciBUPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLmdyb3VwU2l6ZXM9bmV3IFVpbnQzMkFycmF5KDUxMiksdGhpcy5sZW5ndGg9NTEyLHRoaXMudGFnPWV9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuaW5kZXhPZkdyb3VwPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLG49MDtuPGU7bisrKXQrPXRoaXMuZ3JvdXBTaXplc1tuXTtyZXR1cm4gdH0sdC5pbnNlcnRSdWxlcz1mdW5jdGlvbihlLHQpe2lmKGU+PXRoaXMuZ3JvdXBTaXplcy5sZW5ndGgpe2Zvcih2YXIgbj10aGlzLmdyb3VwU2l6ZXMscj1uLmxlbmd0aCxvPXI7ZT49bzspKG88PD0xKTwwJiZqKDE2LFwiXCIrZSk7dGhpcy5ncm91cFNpemVzPW5ldyBVaW50MzJBcnJheShvKSx0aGlzLmdyb3VwU2l6ZXMuc2V0KG4pLHRoaXMubGVuZ3RoPW87Zm9yKHZhciBzPXI7czxvO3MrKyl0aGlzLmdyb3VwU2l6ZXNbc109MH1mb3IodmFyIGk9dGhpcy5pbmRleE9mR3JvdXAoZSsxKSxhPTAsYz10Lmxlbmd0aDthPGM7YSsrKXRoaXMudGFnLmluc2VydFJ1bGUoaSx0W2FdKSYmKHRoaXMuZ3JvdXBTaXplc1tlXSsrLGkrKyl9LHQuY2xlYXJHcm91cD1mdW5jdGlvbihlKXtpZihlPHRoaXMubGVuZ3RoKXt2YXIgdD10aGlzLmdyb3VwU2l6ZXNbZV0sbj10aGlzLmluZGV4T2ZHcm91cChlKSxyPW4rdDt0aGlzLmdyb3VwU2l6ZXNbZV09MDtmb3IodmFyIG89bjtvPHI7bysrKXRoaXMudGFnLmRlbGV0ZVJ1bGUobil9fSx0LmdldEdyb3VwPWZ1bmN0aW9uKGUpe3ZhciB0PVwiXCI7aWYoZT49dGhpcy5sZW5ndGh8fDA9PT10aGlzLmdyb3VwU2l6ZXNbZV0pcmV0dXJuIHQ7Zm9yKHZhciBuPXRoaXMuZ3JvdXBTaXplc1tlXSxyPXRoaXMuaW5kZXhPZkdyb3VwKGUpLG89cituLHM9cjtzPG87cysrKXQrPXRoaXMudGFnLmdldFJ1bGUocykrXCIvKiFzYyovXFxuXCI7cmV0dXJuIHR9LGV9KCkseD1uZXcgTWFwLGs9bmV3IE1hcCxWPTEsQj1mdW5jdGlvbihlKXtpZih4LmhhcyhlKSlyZXR1cm4geC5nZXQoZSk7Zm9yKDtrLmhhcyhWKTspVisrO3ZhciB0PVYrKztyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYoKDB8dCk8MHx8dD4xPDwzMCkmJmooMTYsXCJcIit0KSx4LnNldChlLHQpLGsuc2V0KHQsZSksdH0sej1mdW5jdGlvbihlKXtyZXR1cm4gay5nZXQoZSl9LE09ZnVuY3Rpb24oZSx0KXt0Pj1WJiYoVj10KzEpLHguc2V0KGUsdCksay5zZXQodCxlKX0sRz1cInN0eWxlW1wiK0ErJ11bZGF0YS1zdHlsZWQtdmVyc2lvbj1cIjUuMy42XCJdJyxMPW5ldyBSZWdFeHAoXCJeXCIrQSsnXFxcXC5nKFxcXFxkKylcXFxcW2lkPVwiKFtcXFxcd1xcXFxkLV0rKVwiXFxcXF0uKj9cIihbXlwiXSopJyksRj1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciByLG89bi5zcGxpdChcIixcIikscz0wLGk9by5sZW5ndGg7czxpO3MrKykocj1vW3NdKSYmZS5yZWdpc3Rlck5hbWUodCxyKX0sWT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0odC50ZXh0Q29udGVudHx8XCJcIikuc3BsaXQoXCIvKiFzYyovXFxuXCIpLHI9W10sbz0wLHM9bi5sZW5ndGg7bzxzO28rKyl7dmFyIGk9bltvXS50cmltKCk7aWYoaSl7dmFyIGE9aS5tYXRjaChMKTtpZihhKXt2YXIgYz0wfHBhcnNlSW50KGFbMV0sMTApLHU9YVsyXTswIT09YyYmKE0odSxjKSxGKGUsdSxhWzNdKSxlLmdldFRhZygpLmluc2VydFJ1bGVzKGMscikpLHIubGVuZ3RoPTB9ZWxzZSByLnB1c2goaSl9fX0scT1mdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsfSxIPWZ1bmN0aW9uKGUpe3ZhciB0PWRvY3VtZW50LmhlYWQsbj1lfHx0LHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLG89ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUuY2hpbGROb2RlcyxuPXQubGVuZ3RoO24+PTA7bi0tKXt2YXIgcj10W25dO2lmKHImJjE9PT1yLm5vZGVUeXBlJiZyLmhhc0F0dHJpYnV0ZShBKSlyZXR1cm4gcn19KG4pLHM9dm9pZCAwIT09bz9vLm5leHRTaWJsaW5nOm51bGw7ci5zZXRBdHRyaWJ1dGUoQSxcImFjdGl2ZVwiKSxyLnNldEF0dHJpYnV0ZShcImRhdGEtc3R5bGVkLXZlcnNpb25cIixcIjUuMy42XCIpO3ZhciBpPXEoKTtyZXR1cm4gaSYmci5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLGkpLG4uaW5zZXJ0QmVmb3JlKHIscykscn0sJD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dmFyIHQ9dGhpcy5lbGVtZW50PUgoZSk7dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSksdGhpcy5zaGVldD1mdW5jdGlvbihlKXtpZihlLnNoZWV0KXJldHVybiBlLnNoZWV0O2Zvcih2YXIgdD1kb2N1bWVudC5zdHlsZVNoZWV0cyxuPTAscj10Lmxlbmd0aDtuPHI7bisrKXt2YXIgbz10W25dO2lmKG8ub3duZXJOb2RlPT09ZSlyZXR1cm4gb31qKDE3KX0odCksdGhpcy5sZW5ndGg9MH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7dHJ5e3JldHVybiB0aGlzLnNoZWV0Lmluc2VydFJ1bGUodCxlKSx0aGlzLmxlbmd0aCsrLCEwfWNhdGNoKGUpe3JldHVybiExfX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMuc2hlZXQuZGVsZXRlUnVsZShlKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zaGVldC5jc3NSdWxlc1tlXTtyZXR1cm4gdm9pZCAwIT09dCYmXCJzdHJpbmdcIj09dHlwZW9mIHQuY3NzVGV4dD90LmNzc1RleHQ6XCJcIn0sZX0oKSxXPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt2YXIgdD10aGlzLmVsZW1lbnQ9SChlKTt0aGlzLm5vZGVzPXQuY2hpbGROb2Rlcyx0aGlzLmxlbmd0aD0wfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0Lmluc2VydFJ1bGU9ZnVuY3Rpb24oZSx0KXtpZihlPD10aGlzLmxlbmd0aCYmZT49MCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodCkscj10aGlzLm5vZGVzW2VdO3JldHVybiB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKG4scnx8bnVsbCksdGhpcy5sZW5ndGgrKywhMH1yZXR1cm4hMX0sdC5kZWxldGVSdWxlPWZ1bmN0aW9uKGUpe3RoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm5vZGVzW2VdKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8dGhpcy5sZW5ndGg/dGhpcy5ub2Rlc1tlXS50ZXh0Q29udGVudDpcIlwifSxlfSgpLFU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMucnVsZXM9W10sdGhpcy5sZW5ndGg9MH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5pbnNlcnRSdWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PXRoaXMubGVuZ3RoJiYodGhpcy5ydWxlcy5zcGxpY2UoZSwwLHQpLHRoaXMubGVuZ3RoKyssITApfSx0LmRlbGV0ZVJ1bGU9ZnVuY3Rpb24oZSl7dGhpcy5ydWxlcy5zcGxpY2UoZSwxKSx0aGlzLmxlbmd0aC0tfSx0LmdldFJ1bGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8dGhpcy5sZW5ndGg/dGhpcy5ydWxlc1tlXTpcIlwifSxlfSgpLEo9SSxYPXtpc1NlcnZlcjohSSx1c2VDU1NPTUluamVjdGlvbjohUH0sWj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4pe3ZvaWQgMD09PWUmJihlPUUpLHZvaWQgMD09PXQmJih0PXt9KSx0aGlzLm9wdGlvbnM9dih7fSxYLHt9LGUpLHRoaXMuZ3M9dCx0aGlzLm5hbWVzPW5ldyBNYXAobiksdGhpcy5zZXJ2ZXI9ISFlLmlzU2VydmVyLCF0aGlzLnNlcnZlciYmSSYmSiYmKEo9ITEsZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRyksbj0wLHI9dC5sZW5ndGg7bjxyO24rKyl7dmFyIG89dFtuXTtvJiZcImFjdGl2ZVwiIT09by5nZXRBdHRyaWJ1dGUoQSkmJihZKGUsbyksby5wYXJlbnROb2RlJiZvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobykpfX0odGhpcykpfWUucmVnaXN0ZXJJZD1mdW5jdGlvbihlKXtyZXR1cm4gQihlKX07dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucz1mdW5jdGlvbih0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMCksbmV3IGUodih7fSx0aGlzLm9wdGlvbnMse30sdCksdGhpcy5ncyxuJiZ0aGlzLm5hbWVzfHx2b2lkIDApfSx0LmFsbG9jYXRlR1NJbnN0YW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nc1tlXT0odGhpcy5nc1tlXXx8MCkrMX0sdC5nZXRUYWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YWd8fCh0aGlzLnRhZz0obj0odD10aGlzLm9wdGlvbnMpLmlzU2VydmVyLHI9dC51c2VDU1NPTUluamVjdGlvbixvPXQudGFyZ2V0LGU9bj9uZXcgVShvKTpyP25ldyAkKG8pOm5ldyBXKG8pLG5ldyBUKGUpKSk7dmFyIGUsdCxuLHIsb30sdC5oYXNOYW1lRm9ySWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5uYW1lcy5oYXMoZSkmJnRoaXMubmFtZXMuZ2V0KGUpLmhhcyh0KX0sdC5yZWdpc3Rlck5hbWU9ZnVuY3Rpb24oZSx0KXtpZihCKGUpLHRoaXMubmFtZXMuaGFzKGUpKXRoaXMubmFtZXMuZ2V0KGUpLmFkZCh0KTtlbHNle3ZhciBuPW5ldyBTZXQ7bi5hZGQodCksdGhpcy5uYW1lcy5zZXQoZSxuKX19LHQuaW5zZXJ0UnVsZXM9ZnVuY3Rpb24oZSx0LG4pe3RoaXMucmVnaXN0ZXJOYW1lKGUsdCksdGhpcy5nZXRUYWcoKS5pbnNlcnRSdWxlcyhCKGUpLG4pfSx0LmNsZWFyTmFtZXM9ZnVuY3Rpb24oZSl7dGhpcy5uYW1lcy5oYXMoZSkmJnRoaXMubmFtZXMuZ2V0KGUpLmNsZWFyKCl9LHQuY2xlYXJSdWxlcz1mdW5jdGlvbihlKXt0aGlzLmdldFRhZygpLmNsZWFyR3JvdXAoQihlKSksdGhpcy5jbGVhck5hbWVzKGUpfSx0LmNsZWFyVGFnPWZ1bmN0aW9uKCl7dGhpcy50YWc9dm9pZCAwfSx0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmdldFRhZygpLG49dC5sZW5ndGgscj1cIlwiLG89MDtvPG47bysrKXt2YXIgcz16KG8pO2lmKHZvaWQgMCE9PXMpe3ZhciBpPWUubmFtZXMuZ2V0KHMpLGE9dC5nZXRHcm91cChvKTtpZihpJiZhJiZpLnNpemUpe3ZhciBjPUErXCIuZ1wiK28rJ1tpZD1cIicrcysnXCJdJyx1PVwiXCI7dm9pZCAwIT09aSYmaS5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmxlbmd0aD4wJiYodSs9ZStcIixcIil9KSkscis9XCJcIithK2MrJ3tjb250ZW50OlwiJyt1KydcIn0vKiFzYyovXFxuJ319fXJldHVybiByfSh0aGlzKX0sZX0oKSxLPS8oYSkoZCkvZ2ksUT1mdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlKyhlPjI1PzM5Ojk3KSl9O2Z1bmN0aW9uIGVlKGUpe3ZhciB0LG49XCJcIjtmb3IodD1NYXRoLmFicyhlKTt0PjUyO3Q9dC81MnwwKW49USh0JTUyKStuO3JldHVybihRKHQlNTIpK24pLnJlcGxhY2UoSyxcIiQxLSQyXCIpfXZhciB0ZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj10Lmxlbmd0aDtuOyllPTMzKmVedC5jaGFyQ29kZUF0KC0tbik7cmV0dXJuIGV9LG5lPWZ1bmN0aW9uKGUpe3JldHVybiB0ZSg1MzgxLGUpfTtmdW5jdGlvbiByZShlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoO3QrPTEpe3ZhciBuPWVbdF07aWYoYihuKSYmIU4obikpcmV0dXJuITF9cmV0dXJuITB9dmFyIG9lPW5lKFwiNS4zLjZcIiksc2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuKXt0aGlzLnJ1bGVzPWUsdGhpcy5zdGF0aWNSdWxlc0lkPVwiXCIsdGhpcy5pc1N0YXRpYz1cInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYodm9pZCAwPT09bnx8bi5pc1N0YXRpYykmJnJlKGUpLHRoaXMuY29tcG9uZW50SWQ9dCx0aGlzLmJhc2VIYXNoPXRlKG9lLHQpLHRoaXMuYmFzZVN0eWxlPW4sWi5yZWdpc3RlcklkKHQpfXJldHVybiBlLnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcz1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5jb21wb25lbnRJZCxvPVtdO2lmKHRoaXMuYmFzZVN0eWxlJiZvLnB1c2godGhpcy5iYXNlU3R5bGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoZSx0LG4pKSx0aGlzLmlzU3RhdGljJiYhbi5oYXNoKWlmKHRoaXMuc3RhdGljUnVsZXNJZCYmdC5oYXNOYW1lRm9ySWQocix0aGlzLnN0YXRpY1J1bGVzSWQpKW8ucHVzaCh0aGlzLnN0YXRpY1J1bGVzSWQpO2Vsc2V7dmFyIHM9TmUodGhpcy5ydWxlcyxlLHQsbikuam9pbihcIlwiKSxpPWVlKHRlKHRoaXMuYmFzZUhhc2gscyk+Pj4wKTtpZighdC5oYXNOYW1lRm9ySWQocixpKSl7dmFyIGE9bihzLFwiLlwiK2ksdm9pZCAwLHIpO3QuaW5zZXJ0UnVsZXMocixpLGEpfW8ucHVzaChpKSx0aGlzLnN0YXRpY1J1bGVzSWQ9aX1lbHNle2Zvcih2YXIgYz10aGlzLnJ1bGVzLmxlbmd0aCx1PXRlKHRoaXMuYmFzZUhhc2gsbi5oYXNoKSxsPVwiXCIsZD0wO2Q8YztkKyspe3ZhciBoPXRoaXMucnVsZXNbZF07aWYoXCJzdHJpbmdcIj09dHlwZW9mIGgpbCs9aCxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiYodT10ZSh1LGgrZCkpO2Vsc2UgaWYoaCl7dmFyIHA9TmUoaCxlLHQsbiksZj1BcnJheS5pc0FycmF5KHApP3Auam9pbihcIlwiKTpwO3U9dGUodSxmK2QpLGwrPWZ9fWlmKGwpe3ZhciBtPWVlKHU+Pj4wKTtpZighdC5oYXNOYW1lRm9ySWQocixtKSl7dmFyIHk9bihsLFwiLlwiK20sdm9pZCAwLHIpO3QuaW5zZXJ0UnVsZXMocixtLHkpfW8ucHVzaChtKX19cmV0dXJuIG8uam9pbihcIiBcIil9LGV9KCksaWU9L15cXHMqXFwvXFwvLiokL2dtLGFlPVtcIjpcIixcIltcIixcIi5cIixcIiNcIl07ZnVuY3Rpb24gY2UoZSl7dmFyIHQsbixyLG8scz12b2lkIDA9PT1lP0U6ZSxpPXMub3B0aW9ucyxhPXZvaWQgMD09PWk/RTppLGM9cy5wbHVnaW5zLHU9dm9pZCAwPT09Yz93OmMsbD1uZXcgcChhKSxkPVtdLGg9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCh0KXtpZih0KXRyeXtlKHQrXCJ9XCIpfWNhdGNoKGUpe319cmV0dXJuIGZ1bmN0aW9uKG4scixvLHMsaSxhLGMsdSxsLGQpe3N3aXRjaChuKXtjYXNlIDE6aWYoMD09PWwmJjY0PT09ci5jaGFyQ29kZUF0KDApKXJldHVybiBlKHIrXCI7XCIpLFwiXCI7YnJlYWs7Y2FzZSAyOmlmKDA9PT11KXJldHVybiByK1wiLyp8Ki9cIjticmVhaztjYXNlIDM6c3dpdGNoKHUpe2Nhc2UgMTAyOmNhc2UgMTEyOnJldHVybiBlKG9bMF0rciksXCJcIjtkZWZhdWx0OnJldHVybiByKygwPT09ZD9cIi8qfCovXCI6XCJcIil9Y2FzZS0yOnIuc3BsaXQoXCIvKnwqL31cIikuZm9yRWFjaCh0KX19fSgoZnVuY3Rpb24oZSl7ZC5wdXNoKGUpfSkpLGY9ZnVuY3Rpb24oZSxyLHMpe3JldHVybiAwPT09ciYmLTEhPT1hZS5pbmRleE9mKHNbbi5sZW5ndGhdKXx8cy5tYXRjaChvKT9lOlwiLlwiK3R9O2Z1bmN0aW9uIG0oZSxzLGksYSl7dm9pZCAwPT09YSYmKGE9XCImXCIpO3ZhciBjPWUucmVwbGFjZShpZSxcIlwiKSx1PXMmJmk/aStcIiBcIitzK1wiIHsgXCIrYytcIiB9XCI6YztyZXR1cm4gdD1hLG49cyxyPW5ldyBSZWdFeHAoXCJcXFxcXCIrbitcIlxcXFxiXCIsXCJnXCIpLG89bmV3IFJlZ0V4cChcIihcXFxcXCIrbitcIlxcXFxiKXsyLH1cIiksbChpfHwhcz9cIlwiOnMsdSl9cmV0dXJuIGwudXNlKFtdLmNvbmNhdCh1LFtmdW5jdGlvbihlLHQsbyl7Mj09PWUmJm8ubGVuZ3RoJiZvWzBdLmxhc3RJbmRleE9mKG4pPjAmJihvWzBdPW9bMF0ucmVwbGFjZShyLGYpKX0saCxmdW5jdGlvbihlKXtpZigtMj09PWUpe3ZhciB0PWQ7cmV0dXJuIGQ9W10sdH19XSkpLG0uaGFzaD11Lmxlbmd0aD91LnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5uYW1lfHxqKDE1KSx0ZShlLHQubmFtZSl9KSw1MzgxKS50b1N0cmluZygpOlwiXCIsbX12YXIgdWU9ci5jcmVhdGVDb250ZXh0KCksbGU9dWUuQ29uc3VtZXIsZGU9ci5jcmVhdGVDb250ZXh0KCksaGU9KGRlLkNvbnN1bWVyLG5ldyBaKSxwZT1jZSgpO2Z1bmN0aW9uIGZlKCl7cmV0dXJuIHModWUpfHxoZX1mdW5jdGlvbiBtZSgpe3JldHVybiBzKGRlKXx8cGV9ZnVuY3Rpb24geWUoZSl7dmFyIHQ9byhlLnN0eWxpc1BsdWdpbnMpLG49dFswXSxzPXRbMV0sYz1mZSgpLHU9aSgoZnVuY3Rpb24oKXt2YXIgdD1jO3JldHVybiBlLnNoZWV0P3Q9ZS5zaGVldDplLnRhcmdldCYmKHQ9dC5yZWNvbnN0cnVjdFdpdGhPcHRpb25zKHt0YXJnZXQ6ZS50YXJnZXR9LCExKSksZS5kaXNhYmxlQ1NTT01JbmplY3Rpb24mJih0PXQucmVjb25zdHJ1Y3RXaXRoT3B0aW9ucyh7dXNlQ1NTT01JbmplY3Rpb246ITF9KSksdH0pLFtlLmRpc2FibGVDU1NPTUluamVjdGlvbixlLnNoZWV0LGUudGFyZ2V0XSksbD1pKChmdW5jdGlvbigpe3JldHVybiBjZSh7b3B0aW9uczp7cHJlZml4OiFlLmRpc2FibGVWZW5kb3JQcmVmaXhlc30scGx1Z2luczpufSl9KSxbZS5kaXNhYmxlVmVuZG9yUHJlZml4ZXMsbl0pO3JldHVybiBhKChmdW5jdGlvbigpe2gobixlLnN0eWxpc1BsdWdpbnMpfHxzKGUuc3R5bGlzUGx1Z2lucyl9KSxbZS5zdHlsaXNQbHVnaW5zXSksci5jcmVhdGVFbGVtZW50KHVlLlByb3ZpZGVyLHt2YWx1ZTp1fSxyLmNyZWF0ZUVsZW1lbnQoZGUuUHJvdmlkZXIse3ZhbHVlOmx9LFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlY/ci5DaGlsZHJlbi5vbmx5KGUuY2hpbGRyZW4pOmUuY2hpbGRyZW4pKX12YXIgdmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49dGhpczt0aGlzLmluamVjdD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PXBlKTt2YXIgcj1uLm5hbWUrdC5oYXNoO2UuaGFzTmFtZUZvcklkKG4uaWQscil8fGUuaW5zZXJ0UnVsZXMobi5pZCxyLHQobi5ydWxlcyxyLFwiQGtleWZyYW1lc1wiKSl9LHRoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gaigxMixTdHJpbmcobi5uYW1lKSl9LHRoaXMubmFtZT1lLHRoaXMuaWQ9XCJzYy1rZXlmcmFtZXMtXCIrZSx0aGlzLnJ1bGVzPXR9cmV0dXJuIGUucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPXBlKSx0aGlzLm5hbWUrZS5oYXNofSxlfSgpLGdlPS8oW0EtWl0pLyxTZT0vKFtBLVpdKS9nLHdlPS9ebXMtLyxFZT1mdW5jdGlvbihlKXtyZXR1cm5cIi1cIitlLnRvTG93ZXJDYXNlKCl9O2Z1bmN0aW9uIGJlKGUpe3JldHVybiBnZS50ZXN0KGUpP2UucmVwbGFjZShTZSxFZSkucmVwbGFjZSh3ZSxcIi1tcy1cIik6ZX12YXIgX2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWV8fCExPT09ZXx8XCJcIj09PWV9O2Z1bmN0aW9uIE5lKGUsbixyLG8pe2lmKEFycmF5LmlzQXJyYXkoZSkpe2Zvcih2YXIgcyxpPVtdLGE9MCxjPWUubGVuZ3RoO2E8YzthKz0xKVwiXCIhPT0ocz1OZShlW2FdLG4scixvKSkmJihBcnJheS5pc0FycmF5KHMpP2kucHVzaC5hcHBseShpLHMpOmkucHVzaChzKSk7cmV0dXJuIGl9aWYoX2UoZSkpcmV0dXJuXCJcIjtpZihOKGUpKXJldHVyblwiLlwiK2Uuc3R5bGVkQ29tcG9uZW50SWQ7aWYoYihlKSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YobD1lKXx8bC5wcm90b3R5cGUmJmwucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnR8fCFuKXJldHVybiBlO3ZhciB1PWUobik7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmdCh1KSYmY29uc29sZS53YXJuKF8oZSkrXCIgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLlwiKSxOZSh1LG4scixvKX12YXIgbDtyZXR1cm4gZSBpbnN0YW5jZW9mIHZlP3I/KGUuaW5qZWN0KHIsbyksZS5nZXROYW1lKG8pKTplOlMoZSk/ZnVuY3Rpb24gZSh0LG4pe3ZhciByLG8scz1bXTtmb3IodmFyIGkgaW4gdCl0Lmhhc093blByb3BlcnR5KGkpJiYhX2UodFtpXSkmJihBcnJheS5pc0FycmF5KHRbaV0pJiZ0W2ldLmlzQ3NzfHxiKHRbaV0pP3MucHVzaChiZShpKStcIjpcIix0W2ldLFwiO1wiKTpTKHRbaV0pP3MucHVzaC5hcHBseShzLGUodFtpXSxpKSk6cy5wdXNoKGJlKGkpK1wiOiBcIisocj1pLG51bGw9PShvPXRbaV0pfHxcImJvb2xlYW5cIj09dHlwZW9mIG98fFwiXCI9PT1vP1wiXCI6XCJudW1iZXJcIiE9dHlwZW9mIG98fDA9PT1vfHxyIGluIGY/U3RyaW5nKG8pLnRyaW0oKTpvK1wicHhcIikrXCI7XCIpKTtyZXR1cm4gbj9bbitcIiB7XCJdLmNvbmNhdChzLFtcIn1cIl0pOnN9KGUpOmUudG9TdHJpbmcoKX12YXIgQWU9ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJihlLmlzQ3NzPSEwKSxlfTtmdW5jdGlvbiBDZShlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLHI9MTtyPHQ7cisrKW5bci0xXT1hcmd1bWVudHNbcl07cmV0dXJuIGIoZSl8fFMoZSk/QWUoTmUoZyh3LFtlXS5jb25jYXQobikpKSk6MD09PW4ubGVuZ3RoJiYxPT09ZS5sZW5ndGgmJlwic3RyaW5nXCI9PXR5cGVvZiBlWzBdP2U6QWUoTmUoZyhlLG4pKSl9dmFyIEllPS9pbnZhbGlkIGhvb2sgY2FsbC9pLFBlPW5ldyBTZXQsT2U9ZnVuY3Rpb24oZSx0KXtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WKXt2YXIgbj1cIlRoZSBjb21wb25lbnQgXCIrZSsodD8nIHdpdGggdGhlIGlkIG9mIFwiJyt0KydcIic6XCJcIikrXCIgaGFzIGJlZW4gY3JlYXRlZCBkeW5hbWljYWxseS5cXG5Zb3UgbWF5IHNlZSB0aGlzIHdhcm5pbmcgYmVjYXVzZSB5b3UndmUgY2FsbGVkIHN0eWxlZCBpbnNpZGUgYW5vdGhlciBjb21wb25lbnQuXFxuVG8gcmVzb2x2ZSB0aGlzIG9ubHkgY3JlYXRlIG5ldyBTdHlsZWRDb21wb25lbnRzIG91dHNpZGUgb2YgYW55IHJlbmRlciBtZXRob2QgYW5kIGZ1bmN0aW9uIGNvbXBvbmVudC5cIixyPWNvbnNvbGUuZXJyb3I7dHJ5e3ZhciBvPSEwO2NvbnNvbGUuZXJyb3I9ZnVuY3Rpb24oZSl7aWYoSWUudGVzdChlKSlvPSExLFBlLmRlbGV0ZShuKTtlbHNle2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KHQ+MT90LTE6MCksaT0xO2k8dDtpKyspc1tpLTFdPWFyZ3VtZW50c1tpXTtyLmFwcGx5KHZvaWQgMCxbZV0uY29uY2F0KHMpKX19LGMoKSxvJiYhUGUuaGFzKG4pJiYoY29uc29sZS53YXJuKG4pLFBlLmFkZChuKSl9Y2F0Y2goZSl7SWUudGVzdChlLm1lc3NhZ2UpJiZQZS5kZWxldGUobil9ZmluYWxseXtjb25zb2xlLmVycm9yPXJ9fX0sUmU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj1FKSxlLnRoZW1lIT09bi50aGVtZSYmZS50aGVtZXx8dHx8bi50aGVtZX0sRGU9L1shXCIjJCUmJygpKissLi86Ozw9Pj9AW1xcXFxcXF1eYHt8fX4tXSsvZyxqZT0vKF4tfC0kKS9nO2Z1bmN0aW9uIFRlKGUpe3JldHVybiBlLnJlcGxhY2UoRGUsXCItXCIpLnJlcGxhY2UoamUsXCJcIil9dmFyIHhlPWZ1bmN0aW9uKGUpe3JldHVybiBlZShuZShlKT4+PjApfTtmdW5jdGlvbiBrZShlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmKFwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fGUuY2hhckF0KDApPT09ZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSl9dmFyIFZlPWZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV8fFwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmIUFycmF5LmlzQXJyYXkoZSl9LEJlPWZ1bmN0aW9uKGUpe3JldHVyblwiX19wcm90b19fXCIhPT1lJiZcImNvbnN0cnVjdG9yXCIhPT1lJiZcInByb3RvdHlwZVwiIT09ZX07ZnVuY3Rpb24gemUoZSx0LG4pe3ZhciByPWVbbl07VmUodCkmJlZlKHIpP01lKHIsdCk6ZVtuXT10fWZ1bmN0aW9uIE1lKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTtmb3IodmFyIG89MCxzPW47bzxzLmxlbmd0aDtvKyspe3ZhciBpPXNbb107aWYoVmUoaSkpZm9yKHZhciBhIGluIGkpQmUoYSkmJnplKGUsaVthXSxhKX1yZXR1cm4gZX12YXIgR2U9ci5jcmVhdGVDb250ZXh0KCksTGU9R2UuQ29uc3VtZXI7ZnVuY3Rpb24gRmUoZSl7dmFyIHQ9cyhHZSksbj1pKChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCFlKXJldHVybiBqKDE0KTtpZihiKGUpKXt2YXIgbj1lKHQpO3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fG51bGwhPT1uJiYhQXJyYXkuaXNBcnJheShuKSYmXCJvYmplY3RcIj09dHlwZW9mIG4/bjpqKDcpfXJldHVybiBBcnJheS5pc0FycmF5KGUpfHxcIm9iamVjdFwiIT10eXBlb2YgZT9qKDgpOnQ/dih7fSx0LHt9LGUpOmV9KGUudGhlbWUsdCl9KSxbZS50aGVtZSx0XSk7cmV0dXJuIGUuY2hpbGRyZW4/ci5jcmVhdGVFbGVtZW50KEdlLlByb3ZpZGVyLHt2YWx1ZTpufSxlLmNoaWxkcmVuKTpudWxsfXZhciBZZT17fTtmdW5jdGlvbiBxZShlLHQsbil7dmFyIG89TihlKSxpPSFrZShlKSxhPXQuYXR0cnMsYz12b2lkIDA9PT1hP3c6YSxkPXQuY29tcG9uZW50SWQsaD12b2lkIDA9PT1kP2Z1bmN0aW9uKGUsdCl7dmFyIG49XCJzdHJpbmdcIiE9dHlwZW9mIGU/XCJzY1wiOlRlKGUpO1llW25dPShZZVtuXXx8MCkrMTt2YXIgcj1uK1wiLVwiK3hlKFwiNS4zLjZcIituK1llW25dKTtyZXR1cm4gdD90K1wiLVwiK3I6cn0odC5kaXNwbGF5TmFtZSx0LnBhcmVudENvbXBvbmVudElkKTpkLHA9dC5kaXNwbGF5TmFtZSxmPXZvaWQgMD09PXA/ZnVuY3Rpb24oZSl7cmV0dXJuIGtlKGUpP1wic3R5bGVkLlwiK2U6XCJTdHlsZWQoXCIrXyhlKStcIilcIn0oZSk6cCxnPXQuZGlzcGxheU5hbWUmJnQuY29tcG9uZW50SWQ/VGUodC5kaXNwbGF5TmFtZSkrXCItXCIrdC5jb21wb25lbnRJZDp0LmNvbXBvbmVudElkfHxoLFM9byYmZS5hdHRycz9BcnJheS5wcm90b3R5cGUuY29uY2F0KGUuYXR0cnMsYykuZmlsdGVyKEJvb2xlYW4pOmMsQT10LnNob3VsZEZvcndhcmRQcm9wO28mJmUuc2hvdWxkRm9yd2FyZFByb3AmJihBPXQuc2hvdWxkRm9yd2FyZFByb3A/ZnVuY3Rpb24obixyLG8pe3JldHVybiBlLnNob3VsZEZvcndhcmRQcm9wKG4scixvKSYmdC5zaG91bGRGb3J3YXJkUHJvcChuLHIsbyl9OmUuc2hvdWxkRm9yd2FyZFByb3ApO3ZhciBDLEk9bmV3IHNlKG4sZyxvP2UuY29tcG9uZW50U3R5bGU6dm9pZCAwKSxQPUkuaXNTdGF0aWMmJjA9PT1jLmxlbmd0aCxPPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvPWUuYXR0cnMsaT1lLmNvbXBvbmVudFN0eWxlLGE9ZS5kZWZhdWx0UHJvcHMsYz1lLmZvbGRlZENvbXBvbmVudElkcyxkPWUuc2hvdWxkRm9yd2FyZFByb3AsaD1lLnN0eWxlZENvbXBvbmVudElkLHA9ZS50YXJnZXQ7XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmbChoKTt2YXIgZj1mdW5jdGlvbihlLHQsbil7dm9pZCAwPT09ZSYmKGU9RSk7dmFyIHI9dih7fSx0LHt0aGVtZTplfSksbz17fTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgdCxuLHMsaT1lO2Zvcih0IGluIGIoaSkmJihpPWkocikpLGkpclt0XT1vW3RdPVwiY2xhc3NOYW1lXCI9PT10PyhuPW9bdF0scz1pW3RdLG4mJnM/bitcIiBcIitzOm58fHMpOmlbdF19KSksW3Isb119KFJlKHQscyhHZSksYSl8fEUsdCxvKSx5PWZbMF0sZz1mWzFdLFM9ZnVuY3Rpb24oZSx0LG4scil7dmFyIG89ZmUoKSxzPW1lKCksaT10P2UuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoRSxvLHMpOmUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMobixvLHMpO3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmwoaSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmIXQmJnImJnIoaSksaX0oaSxyLHksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVj9lLndhcm5Ub29NYW55Q2xhc3Nlczp2b2lkIDApLHc9bixfPWcuJGFzfHx0LiRhc3x8Zy5hc3x8dC5hc3x8cCxOPWtlKF8pLEE9ZyE9PXQ/dih7fSx0LHt9LGcpOnQsQz17fTtmb3IodmFyIEkgaW4gQSlcIiRcIiE9PUlbMF0mJlwiYXNcIiE9PUkmJihcImZvcndhcmRlZEFzXCI9PT1JP0MuYXM9QVtJXTooZD9kKEksbSxfKTohTnx8bShJKSkmJihDW0ldPUFbSV0pKTtyZXR1cm4gdC5zdHlsZSYmZy5zdHlsZSE9PXQuc3R5bGUmJihDLnN0eWxlPXYoe30sdC5zdHlsZSx7fSxnLnN0eWxlKSksQy5jbGFzc05hbWU9QXJyYXkucHJvdG90eXBlLmNvbmNhdChjLGgsUyE9PWg/UzpudWxsLHQuY2xhc3NOYW1lLGcuY2xhc3NOYW1lKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIiksQy5yZWY9dyx1KF8sQyl9KEMsZSx0LFApfTtyZXR1cm4gTy5kaXNwbGF5TmFtZT1mLChDPXIuZm9yd2FyZFJlZihPKSkuYXR0cnM9UyxDLmNvbXBvbmVudFN0eWxlPUksQy5kaXNwbGF5TmFtZT1mLEMuc2hvdWxkRm9yd2FyZFByb3A9QSxDLmZvbGRlZENvbXBvbmVudElkcz1vP0FycmF5LnByb3RvdHlwZS5jb25jYXQoZS5mb2xkZWRDb21wb25lbnRJZHMsZS5zdHlsZWRDb21wb25lbnRJZCk6dyxDLnN0eWxlZENvbXBvbmVudElkPWcsQy50YXJnZXQ9bz9lLnRhcmdldDplLEMud2l0aENvbXBvbmVudD1mdW5jdGlvbihlKXt2YXIgcj10LmNvbXBvbmVudElkLG89ZnVuY3Rpb24oZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsbz17fSxzPU9iamVjdC5rZXlzKGUpO2ZvcihyPTA7cjxzLmxlbmd0aDtyKyspbj1zW3JdLHQuaW5kZXhPZihuKT49MHx8KG9bbl09ZVtuXSk7cmV0dXJuIG99KHQsW1wiY29tcG9uZW50SWRcIl0pLHM9ciYmcitcIi1cIisoa2UoZSk/ZTpUZShfKGUpKSk7cmV0dXJuIHFlKGUsdih7fSxvLHthdHRyczpTLGNvbXBvbmVudElkOnN9KSxuKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KEMsXCJkZWZhdWx0UHJvcHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZvbGRlZERlZmF1bHRQcm9wc30sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX2ZvbGRlZERlZmF1bHRQcm9wcz1vP01lKHt9LGUuZGVmYXVsdFByb3BzLHQpOnR9fSksXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKE9lKGYsZyksQy53YXJuVG9vTWFueUNsYXNzZXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj17fSxyPSExO3JldHVybiBmdW5jdGlvbihvKXtpZighciYmKG5bb109ITAsT2JqZWN0LmtleXMobikubGVuZ3RoPj0yMDApKXt2YXIgcz10Pycgd2l0aCB0aGUgaWQgb2YgXCInK3QrJ1wiJzpcIlwiO2NvbnNvbGUud2FybihcIk92ZXIgMjAwIGNsYXNzZXMgd2VyZSBnZW5lcmF0ZWQgZm9yIGNvbXBvbmVudCBcIitlK3MrXCIuXFxuQ29uc2lkZXIgdXNpbmcgdGhlIGF0dHJzIG1ldGhvZCwgdG9nZXRoZXIgd2l0aCBhIHN0eWxlIG9iamVjdCBmb3IgZnJlcXVlbnRseSBjaGFuZ2VkIHN0eWxlcy5cXG5FeGFtcGxlOlxcbiAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyhwcm9wcyA9PiAoe1xcbiAgICBzdHlsZToge1xcbiAgICAgIGJhY2tncm91bmQ6IHByb3BzLmJhY2tncm91bmQsXFxuICAgIH0sXFxuICB9KSlgd2lkdGg6IDEwMCU7YFxcblxcbiAgPENvbXBvbmVudCAvPlwiKSxyPSEwLG49e319fX0oZixnKSksQy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiLlwiK0Muc3R5bGVkQ29tcG9uZW50SWR9LGkmJnkoQyxlLHthdHRyczohMCxjb21wb25lbnRTdHlsZTohMCxkaXNwbGF5TmFtZTohMCxmb2xkZWRDb21wb25lbnRJZHM6ITAsc2hvdWxkRm9yd2FyZFByb3A6ITAsc3R5bGVkQ29tcG9uZW50SWQ6ITAsdGFyZ2V0OiEwLHdpdGhDb21wb25lbnQ6ITB9KSxDfXZhciBIZT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24gZSh0LHIsbyl7aWYodm9pZCAwPT09byYmKG89RSksIW4ocikpcmV0dXJuIGooMSxTdHJpbmcocikpO3ZhciBzPWZ1bmN0aW9uKCl7cmV0dXJuIHQocixvLENlLmFwcGx5KHZvaWQgMCxhcmd1bWVudHMpKX07cmV0dXJuIHMud2l0aENvbmZpZz1mdW5jdGlvbihuKXtyZXR1cm4gZSh0LHIsdih7fSxvLHt9LG4pKX0scy5hdHRycz1mdW5jdGlvbihuKXtyZXR1cm4gZSh0LHIsdih7fSxvLHthdHRyczpBcnJheS5wcm90b3R5cGUuY29uY2F0KG8uYXR0cnMsbikuZmlsdGVyKEJvb2xlYW4pfSkpfSxzfShxZSxlKX07W1wiYVwiLFwiYWJiclwiLFwiYWRkcmVzc1wiLFwiYXJlYVwiLFwiYXJ0aWNsZVwiLFwiYXNpZGVcIixcImF1ZGlvXCIsXCJiXCIsXCJiYXNlXCIsXCJiZGlcIixcImJkb1wiLFwiYmlnXCIsXCJibG9ja3F1b3RlXCIsXCJib2R5XCIsXCJiclwiLFwiYnV0dG9uXCIsXCJjYW52YXNcIixcImNhcHRpb25cIixcImNpdGVcIixcImNvZGVcIixcImNvbFwiLFwiY29sZ3JvdXBcIixcImRhdGFcIixcImRhdGFsaXN0XCIsXCJkZFwiLFwiZGVsXCIsXCJkZXRhaWxzXCIsXCJkZm5cIixcImRpYWxvZ1wiLFwiZGl2XCIsXCJkbFwiLFwiZHRcIixcImVtXCIsXCJlbWJlZFwiLFwiZmllbGRzZXRcIixcImZpZ2NhcHRpb25cIixcImZpZ3VyZVwiLFwiZm9vdGVyXCIsXCJmb3JtXCIsXCJoMVwiLFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJoZWFkXCIsXCJoZWFkZXJcIixcImhncm91cFwiLFwiaHJcIixcImh0bWxcIixcImlcIixcImlmcmFtZVwiLFwiaW1nXCIsXCJpbnB1dFwiLFwiaW5zXCIsXCJrYmRcIixcImtleWdlblwiLFwibGFiZWxcIixcImxlZ2VuZFwiLFwibGlcIixcImxpbmtcIixcIm1haW5cIixcIm1hcFwiLFwibWFya1wiLFwibWFycXVlZVwiLFwibWVudVwiLFwibWVudWl0ZW1cIixcIm1ldGFcIixcIm1ldGVyXCIsXCJuYXZcIixcIm5vc2NyaXB0XCIsXCJvYmplY3RcIixcIm9sXCIsXCJvcHRncm91cFwiLFwib3B0aW9uXCIsXCJvdXRwdXRcIixcInBcIixcInBhcmFtXCIsXCJwaWN0dXJlXCIsXCJwcmVcIixcInByb2dyZXNzXCIsXCJxXCIsXCJycFwiLFwicnRcIixcInJ1YnlcIixcInNcIixcInNhbXBcIixcInNjcmlwdFwiLFwic2VjdGlvblwiLFwic2VsZWN0XCIsXCJzbWFsbFwiLFwic291cmNlXCIsXCJzcGFuXCIsXCJzdHJvbmdcIixcInN0eWxlXCIsXCJzdWJcIixcInN1bW1hcnlcIixcInN1cFwiLFwidGFibGVcIixcInRib2R5XCIsXCJ0ZFwiLFwidGV4dGFyZWFcIixcInRmb290XCIsXCJ0aFwiLFwidGhlYWRcIixcInRpbWVcIixcInRpdGxlXCIsXCJ0clwiLFwidHJhY2tcIixcInVcIixcInVsXCIsXCJ2YXJcIixcInZpZGVvXCIsXCJ3YnJcIixcImNpcmNsZVwiLFwiY2xpcFBhdGhcIixcImRlZnNcIixcImVsbGlwc2VcIixcImZvcmVpZ25PYmplY3RcIixcImdcIixcImltYWdlXCIsXCJsaW5lXCIsXCJsaW5lYXJHcmFkaWVudFwiLFwibWFya2VyXCIsXCJtYXNrXCIsXCJwYXRoXCIsXCJwYXR0ZXJuXCIsXCJwb2x5Z29uXCIsXCJwb2x5bGluZVwiLFwicmFkaWFsR3JhZGllbnRcIixcInJlY3RcIixcInN0b3BcIixcInN2Z1wiLFwidGV4dFwiLFwidGV4dFBhdGhcIixcInRzcGFuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe0hlW2VdPUhlKGUpfSkpO3ZhciAkZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLnJ1bGVzPWUsdGhpcy5jb21wb25lbnRJZD10LHRoaXMuaXNTdGF0aWM9cmUoZSksWi5yZWdpc3RlcklkKHRoaXMuY29tcG9uZW50SWQrMSl9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuY3JlYXRlU3R5bGVzPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBvPXIoTmUodGhpcy5ydWxlcyx0LG4scikuam9pbihcIlwiKSxcIlwiKSxzPXRoaXMuY29tcG9uZW50SWQrZTtuLmluc2VydFJ1bGVzKHMscyxvKX0sdC5yZW1vdmVTdHlsZXM9ZnVuY3Rpb24oZSx0KXt0LmNsZWFyUnVsZXModGhpcy5jb21wb25lbnRJZCtlKX0sdC5yZW5kZXJTdHlsZXM9ZnVuY3Rpb24oZSx0LG4scil7ZT4yJiZaLnJlZ2lzdGVySWQodGhpcy5jb21wb25lbnRJZCtlKSx0aGlzLnJlbW92ZVN0eWxlcyhlLG4pLHRoaXMuY3JlYXRlU3R5bGVzKGUsdCxuLHIpfSxlfSgpO2Z1bmN0aW9uIFdlKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspbltvLTFdPWFyZ3VtZW50c1tvXTt2YXIgaT1DZS5hcHBseSh2b2lkIDAsW2VdLmNvbmNhdChuKSksYT1cInNjLWdsb2JhbC1cIit4ZShKU09OLnN0cmluZ2lmeShpKSksdT1uZXcgJGUoaSxhKTtmdW5jdGlvbiBsKGUpe3ZhciB0PWZlKCksbj1tZSgpLG89cyhHZSksbD1jKHQuYWxsb2NhdGVHU0luc3RhbmNlKGEpKS5jdXJyZW50O3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJnIuQ2hpbGRyZW4uY291bnQoZS5jaGlsZHJlbikmJmNvbnNvbGUud2FybihcIlRoZSBnbG9iYWwgc3R5bGUgY29tcG9uZW50IFwiK2ErXCIgd2FzIGdpdmVuIGNoaWxkIEpTWC4gY3JlYXRlR2xvYmFsU3R5bGUgZG9lcyBub3QgcmVuZGVyIGNoaWxkcmVuLlwiKSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlJiYtMSE9PWUuaW5kZXhPZihcIkBpbXBvcnRcIil9KSkmJmNvbnNvbGUud2FybihcIlBsZWFzZSBkbyBub3QgdXNlIEBpbXBvcnQgQ1NTIHN5bnRheCBpbiBjcmVhdGVHbG9iYWxTdHlsZSBhdCB0aGlzIHRpbWUsIGFzIHRoZSBDU1NPTSBBUElzIHdlIHVzZSBpbiBwcm9kdWN0aW9uIGRvIG5vdCBoYW5kbGUgaXQgd2VsbC4gSW5zdGVhZCwgd2UgcmVjb21tZW5kIHVzaW5nIGEgbGlicmFyeSBzdWNoIGFzIHJlYWN0LWhlbG1ldCB0byBpbmplY3QgYSB0eXBpY2FsIDxsaW5rPiBtZXRhIHRhZyB0byB0aGUgc3R5bGVzaGVldCwgb3Igc2ltcGx5IGVtYmVkZGluZyBpdCBtYW51YWxseSBpbiB5b3VyIGluZGV4Lmh0bWwgPGhlYWQ+IHNlY3Rpb24gZm9yIGEgc2ltcGxlciBhcHAuXCIpLHQuc2VydmVyJiZoKGwsZSx0LG8sbiksZCgoZnVuY3Rpb24oKXtpZighdC5zZXJ2ZXIpcmV0dXJuIGgobCxlLHQsbyxuKSxmdW5jdGlvbigpe3JldHVybiB1LnJlbW92ZVN0eWxlcyhsLHQpfX0pLFtsLGUsdCxvLG5dKSxudWxsfWZ1bmN0aW9uIGgoZSx0LG4scixvKXtpZih1LmlzU3RhdGljKXUucmVuZGVyU3R5bGVzKGUsTyxuLG8pO2Vsc2V7dmFyIHM9dih7fSx0LHt0aGVtZTpSZSh0LHIsbC5kZWZhdWx0UHJvcHMpfSk7dS5yZW5kZXJTdHlsZXMoZSxzLG4sbyl9fXJldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJk9lKGEpLHIubWVtbyhsKX1mdW5jdGlvbiBVZShlKXtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZcIlJlYWN0TmF0aXZlXCI9PT1uYXZpZ2F0b3IucHJvZHVjdCYmY29uc29sZS53YXJuKFwiYGtleWZyYW1lc2AgY2Fubm90IGJlIHVzZWQgb24gUmVhY3ROYXRpdmUsIG9ubHkgb24gdGhlIHdlYi4gVG8gZG8gYW5pbWF0aW9uIGluIFJlYWN0TmF0aXZlIHBsZWFzZSB1c2UgQW5pbWF0ZWQuXCIpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCkscj0xO3I8dDtyKyspbltyLTFdPWFyZ3VtZW50c1tyXTt2YXIgbz1DZS5hcHBseSh2b2lkIDAsW2VdLmNvbmNhdChuKSkuam9pbihcIlwiKSxzPXhlKG8pO3JldHVybiBuZXcgdmUocyxvKX12YXIgSmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7dmFyIGU9dGhpczt0aGlzLl9lbWl0U2hlZXRDU1M9ZnVuY3Rpb24oKXt2YXIgdD1lLmluc3RhbmNlLnRvU3RyaW5nKCk7aWYoIXQpcmV0dXJuXCJcIjt2YXIgbj1xKCk7cmV0dXJuXCI8c3R5bGUgXCIrW24mJidub25jZT1cIicrbisnXCInLEErJz1cInRydWVcIicsJ2RhdGEtc3R5bGVkLXZlcnNpb249XCI1LjMuNlwiJ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpK1wiPlwiK3QrXCI8L3N0eWxlPlwifSx0aGlzLmdldFN0eWxlVGFncz1mdW5jdGlvbigpe3JldHVybiBlLnNlYWxlZD9qKDIpOmUuX2VtaXRTaGVldENTUygpfSx0aGlzLmdldFN0eWxlRWxlbWVudD1mdW5jdGlvbigpe3ZhciB0O2lmKGUuc2VhbGVkKXJldHVybiBqKDIpO3ZhciBuPSgodD17fSlbQV09XCJcIix0W1wiZGF0YS1zdHlsZWQtdmVyc2lvblwiXT1cIjUuMy42XCIsdC5kYW5nZXJvdXNseVNldElubmVySFRNTD17X19odG1sOmUuaW5zdGFuY2UudG9TdHJpbmcoKX0sdCksbz1xKCk7cmV0dXJuIG8mJihuLm5vbmNlPW8pLFtyLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLHYoe30sbix7a2V5Olwic2MtMC0wXCJ9KSldfSx0aGlzLnNlYWw9ZnVuY3Rpb24oKXtlLnNlYWxlZD0hMH0sdGhpcy5pbnN0YW5jZT1uZXcgWih7aXNTZXJ2ZXI6ITB9KSx0aGlzLnNlYWxlZD0hMX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5jb2xsZWN0U3R5bGVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnNlYWxlZD9qKDIpOnIuY3JlYXRlRWxlbWVudCh5ZSx7c2hlZXQ6dGhpcy5pbnN0YW5jZX0sZSl9LHQuaW50ZXJsZWF2ZVdpdGhOb2RlU3RyZWFtPWZ1bmN0aW9uKGUpe3JldHVybiBqKDMpfSxlfSgpLFhlPWZ1bmN0aW9uKGUpe3ZhciB0PXIuZm9yd2FyZFJlZigoZnVuY3Rpb24odCxuKXt2YXIgbz1zKEdlKSxpPWUuZGVmYXVsdFByb3BzLGE9UmUodCxvLGkpO3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJnZvaWQgMD09PWEmJmNvbnNvbGUud2FybignW3dpdGhUaGVtZV0gWW91IGFyZSBub3QgdXNpbmcgYSBUaGVtZVByb3ZpZGVyIG5vciBwYXNzaW5nIGEgdGhlbWUgcHJvcCBvciBhIHRoZW1lIGluIGRlZmF1bHRQcm9wcyBpbiBjb21wb25lbnQgY2xhc3MgXCInK18oZSkrJ1wiJyksci5jcmVhdGVFbGVtZW50KGUsdih7fSx0LHt0aGVtZTphLHJlZjpufSkpfSkpO3JldHVybiB5KHQsZSksdC5kaXNwbGF5TmFtZT1cIldpdGhUaGVtZShcIitfKGUpK1wiKVwiLHR9LFplPWZ1bmN0aW9uKCl7cmV0dXJuIHMoR2UpfSxLZT17U3R5bGVTaGVldDpaLG1hc3RlclNoZWV0OmhlfTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZcIlJlYWN0TmF0aXZlXCI9PT1uYXZpZ2F0b3IucHJvZHVjdCYmY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgaW1wb3J0ZWQgJ3N0eWxlZC1jb21wb25lbnRzJyBvbiBSZWFjdCBOYXRpdmUuXFxuUGVyaGFwcyB5b3UncmUgbG9va2luZyB0byBpbXBvcnQgJ3N0eWxlZC1jb21wb25lbnRzL25hdGl2ZSc/XFxuUmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI3JlYWN0LW5hdGl2ZVwiKSxcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInRlc3RcIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl09d2luZG93W1wiX19zdHlsZWQtY29tcG9uZW50cy1pbml0X19cIl18fDAsMT09PXdpbmRvd1tcIl9fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fXCJdJiZjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiAnc3R5bGVkLWNvbXBvbmVudHMnIGluaXRpYWxpemVkIGluIHRoaXMgYXBwbGljYXRpb24uIFRoaXMgbWF5IGNhdXNlIGR5bmFtaWMgc3R5bGVzIHRvIG5vdCByZW5kZXIgcHJvcGVybHksIGVycm9ycyBkdXJpbmcgdGhlIHJlaHlkcmF0aW9uIHByb2Nlc3MsIGEgbWlzc2luZyB0aGVtZSBwcm9wLCBhbmQgbWFrZXMgeW91ciBhcHBsaWNhdGlvbiBiaWdnZXIgd2l0aG91dCBnb29kIHJlYXNvbi5cXG5cXG5TZWUgaHR0cHM6Ly9zLWMuc2gvMkJBWHplZCBmb3IgbW9yZSBpbmZvLlwiKSx3aW5kb3dbXCJfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfX1wiXSs9MSk7ZXhwb3J0IGRlZmF1bHQgSGU7ZXhwb3J0e0plIGFzIFNlcnZlclN0eWxlU2hlZXQsbGUgYXMgU3R5bGVTaGVldENvbnN1bWVyLHVlIGFzIFN0eWxlU2hlZXRDb250ZXh0LHllIGFzIFN0eWxlU2hlZXRNYW5hZ2VyLExlIGFzIFRoZW1lQ29uc3VtZXIsR2UgYXMgVGhlbWVDb250ZXh0LEZlIGFzIFRoZW1lUHJvdmlkZXIsS2UgYXMgX19QUklWQVRFX18sV2UgYXMgY3JlYXRlR2xvYmFsU3R5bGUsQ2UgYXMgY3NzLE4gYXMgaXNTdHlsZWRDb21wb25lbnQsVWUgYXMga2V5ZnJhbWVzLFplIGFzIHVzZVRoZW1lLEMgYXMgdmVyc2lvbixYZSBhcyB3aXRoVGhlbWV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVkLWNvbXBvbmVudHMuYnJvd3Nlci5lc20uanMubWFwXG4iLCJ2YXIgbWFwID0ge1xuXHRcIi4vYXdzLzIwMjEtMDUtMjgtQVdTLUVDMi3tlZzqta3slrQt64+E66mU7J24LeyXsOqysO2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9hd3MvMjAyMS0wNS0yOC1BV1MtRUMyLe2VnOq1reyWtC3rj4TrqZTsnbgt7Jew6rKw7ZWY6riwLm1kXCIsXG5cdFwiLi9jaS1jZC8yMDIxLTA5LTAyLUNJLUNELeq4sOy0iOqwnOuFkOyXkC3rjIDtlbQt7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2NpLWNkLzIwMjEtMDktMDItQ0ktQ0Qt6riw7LSI6rCc64WQ7JeQLeuMgO2VtC3slYzslYTrs7TsnpAubWRcIixcblx0XCIuL2V0Yy8yMDIxLTA4LTA3LeyciOuPhOyasC3qsIDsg4Et642w7Iqk7YGs7YaxLeuTgOyWvOuqqOuLiO2EsC3tmZzsmqkt6re564yA7ZmULe2VmOuKlOuylS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9ldGMvMjAyMS0wOC0wNy3snIjrj4TsmrAt6rCA7IOBLeuNsOyKpO2BrO2GsS3rk4Dslrzrqqjri4jthLAt7Zmc7JqpLeq3ueuMgO2ZlC3tlZjripTrspUubWRcIixcblx0XCIuL2V0Yy8yMDIxLTA4LTE4Leq1rOq4gC3slaDrhJDrpqzti7HsiqTroZwtamVreWxs66GcLeunjOuToC3rgrQt67iU66Gc6re4LeuwqeusuOyekC3tlonrj5ntjKjthLQt7YyM7JWF7ZWY64qULeuwqeuylS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9ldGMvMjAyMS0wOC0xOC3qtazquIAt7JWg64SQ66as7Yux7Iqk66GcLWpla3lsbOuhnC3rp4zrk6At64K0Leu4lOuhnOq3uC3rsKnrrLjsnpAt7ZaJ64+Z7Yyo7YS0Le2MjOyVhe2VmOuKlC3rsKnrspUubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjAtMTItMTYt6rCc67Cc7J6Q66W8IOq0tOuhre2eiOyngOunjCDsl4bslrTshJzripQg7JWI65CY64qUIENPUlMubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMC0xMi0xNi3qsJzrsJzsnpDrpbwg6rS066Gt7Z6I7KeA66eMIOyXhuyWtOyEnOuKlCDslYjrkJjripQgQ09SUy5tZFwiLFxuXHRcIi4vZnJvbnRlbmQvMjAyMC0xMi0xNi3smrDrpqzqsIAg7ZWt7IOBIOyTsOuKlCBIVFRQIO2UhOuhnO2GoOy9nOydtCDrrZjquYwubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMC0xMi0xNi3smrDrpqzqsIAg7ZWt7IOBIOyTsOuKlCBIVFRQIO2UhOuhnO2GoOy9nOydtCDrrZjquYwubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjEtMDEtMDEtV0FT7JmAIOybueyEnOuyhC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9mcm9udGVuZC8yMDIxLTAxLTAxLVdBU+yZgCDsm7nshJzrsoQubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjItMDItMjIt7JqU6rKD7J207Ju57Yyp7J2064ukLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjItMDItMjIt7JqU6rKD7J207Ju57Yyp7J2064ukLm1kXCIsXG5cdFwiLi9mcm9udGVuZC8yMDIyLTEwLTEyLeyekOuwlOyKpO2BrOumve2KuC1BU1NFVFPqtIDrpqwt65287J2067iM65+s66asLey2lOyynC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9mcm9udGVuZC8yMDIyLTEwLTEyLeyekOuwlOyKpO2BrOumve2KuC1BU1NFVFPqtIDrpqwt65287J2067iM65+s66asLey2lOyynC5tZFwiLFxuXHRcIi4vZnJvbnRlbmQvMjAyMi0xMC0xNC1GRWNvbmYtMjAyMi1SZXNjcmlwdOqwmeydtO2VtOyalC3soJXrr7jrn4kubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMi0xMC0xNC1GRWNvbmYtMjAyMi1SZXNjcmlwdOqwmeydtO2VtOyalC3soJXrr7jrn4kubWRcIixcblx0XCIuL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1CbG9nLeunjOuTnOuKlOqyjC3quIDsk7DripQt6rKD67O064ukLe2emOuToC3sgqzrnozrk6Tsl5DqsowubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2ct66eM65Oc64qU6rKMLeq4gOyTsOuKlC3qsoPrs7Tri6Qt7Z6Y65OgLeyCrOuejOuTpOyXkOqyjC5tZFwiLFxuXHRcIi4vamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2fsl5At7Y+s7Iqk7YyFLe2VmOuKlOuylS3snbTrr7jsp4DrhKPquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2fsl5At7Y+s7Iqk7YyFLe2VmOuKlOuylS3snbTrr7jsp4DrhKPquLAubWRcIixcblx0XCIuL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1OZXh0Le2FjOuniC3snpDshLjtnogt7JWM7JWE67O06riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1OZXh0Le2FjOuniC3snpDshLjtnogt7JWM7JWE67O06riwLm1kXCIsXG5cdFwiLi9qZWt5bGwvMjAyMS0wMS0wNS1KZWt5bGwt67iU66Gc6re4LeyhsO2ajOyImC3rsYPsp4At64us6riwLS0tSElUUy5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9qZWt5bGwvMjAyMS0wMS0wNS1KZWt5bGwt67iU66Gc6re4LeyhsO2ajOyImC3rsYPsp4At64us6riwLS0tSElUUy5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTAzLTMxLUphdmFzY3JpcHQt7J6Q7KO87JOw64qULeuCtOyepS3tlajsiJgt67O17Iq17ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wMy0zMS1KYXZhc2NyaXB0LeyekOyjvOyTsOuKlC3rgrTsnqUt7ZWo7IiYLeuzteyKte2VmOq4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTAzLUVTMjAyMS3stZzsi6DsnpDrsJTsiqTtgazrpr3tirgt7IOI66Gt6rKM7LaU6rCA65CcLeq4sOuKpS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDMtRVMyMDIxLey1nOyLoOyekOuwlOyKpO2BrOumve2KuC3sg4jroa3qsozstpTqsIDrkJwt6riw64qlLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDQt7J6Q67CU7Iqk7YGs66a97Yq4Le2UhOuhnOyymOufvC3sk7DquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTA0LeyekOuwlOyKpO2BrOumve2KuC3tlITroZzsspjrn7wt7JOw6riwLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDkt7J6Q67CU7Iqk7YGs66a97Yq4LXZhci1sZXQtY29uc3Qt7KeE7KecLeywqOydtOygkC3qtazrs4TtlZjquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTA5LeyekOuwlOyKpO2BrOumve2KuC12YXItbGV0LWNvbnN0LeynhOynnC3ssKjsnbTsoJAt6rWs67OE7ZWY6riwLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMTct7J6Q67CU7Iqk7YGs66a97Yq4LWFzeW5jLWF3YWl0Ley0iOyKpO2UvOuTnC3tlbXsi6zssrTtgawubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTE3LeyekOuwlOyKpO2BrOumve2KuC1hc3luYy1hd2FpdC3stIjsiqTtlLzrk5wt7ZW17Ius7LK07YGsLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMjYt7J6Q67CU7Iqk7YGs66a97Yq4LeyZhOyghO2eiC3sg4jroZzsmrTtlajsiJgt7KCc64SI66CI7J207YSw66W8LeyVjOyVhOuztOyekC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMjYt7J6Q67CU7Iqk7YGs66a97Yq4LeyZhOyghO2eiC3sg4jroZzsmrTtlajsiJgt7KCc64SI66CI7J207YSw66W8LeyVjOyVhOuztOyekC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTMwLeyekOuwlOyKpO2BrOumve2KuC1pdGVyYWJsZeqzvC1pdGVyYXRvcuyXkC3rjIDtlbQt7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wOC0zMC3snpDrsJTsiqTtgazrpr3tirgtaXRlcmFibGXqs7wtaXRlcmF0b3Lsl5At64yA7ZW0LeyVjOyVhOuztOyekC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA5LTE2LWphdmFzY3JpcHQt7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYLeydvOuLqC3slYzslYTrs7TsnpAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA5LTE2LWphdmFzY3JpcHQt7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYLeydvOuLqC3slYzslYTrs7TsnpAubWRcIixcblx0XCIuL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMi0wMy0yNC1ub2RlanPrsoTsoIQxMHgtMTR466GcLeyYrOumrOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjItMDMtMjQtbm9kZWpz67KE7KCEMTB4LTE0eOuhnC3smKzrpqzquLAubWRcIixcblx0XCIuL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMi0wNC0wNy1qYXZhc2NyaXB0LeygleyImOunjC3snoXroKXrsJvquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIyLTA0LTA3LWphdmFzY3JpcHQt7KCV7IiY66eMLeyeheugpeuwm+q4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvdHlwZXNjcmlwdC8yMDIxLTA0LTE0LVR5cGVzY3JpcHQt7Iuc7J6R7ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL3R5cGVzY3JpcHQvMjAyMS0wNC0xNC1UeXBlc2NyaXB0LeyLnOyeke2VmOq4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvdHlwZXNjcmlwdC8yMDIxLTA0LTI3LVR5cGVzY3JpcHQt7Iuk7Iq17YC07KaILm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL3R5cGVzY3JpcHQvMjAyMS0wNC0yNy1UeXBlc2NyaXB0LeyLpOyKte2AtOymiC5tZFwiLFxuXHRcIi4vcmVhY3QvMjAyMS0wNC0yOC3si6TsoIQt66as7JWh7Yq4Le2UhOuhnOq3uOuemOuwjS1zZWN0aW9uMS4t66as7JWh7Yq4Le2UhOuhnOygne2KuC3si5zsnpHtlZjquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvcmVhY3QvMjAyMS0wNC0yOC3si6TsoIQt66as7JWh7Yq4Le2UhOuhnOq3uOuemOuwjS1zZWN0aW9uMS4t66as7JWh7Yq4Le2UhOuhnOygne2KuC3si5zsnpHtlZjquLAubWRcIixcblx0XCIuL3JlYWN0LzIwMjEtMDUtMDQt66as7JWh7Yq4LeuUlOyekOyduC3tjKjthLQtMS4tQ29udGFpbmVyK1ByZXNlbnRlci5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIxLTA1LTA0LeumrOyVoe2KuC3rlJTsnpDsnbgt7Yyo7YS0LTEuLUNvbnRhaW5lcitQcmVzZW50ZXIubWRcIixcblx0XCIuL3JlYWN0LzIwMjItMDMtMjMtcmVhY3QtcmV3aXJlZC3sgqzsmqntlbTshJwtZWplY3Tsl4bsnbQtQ1JB7JeQYmFiZWzshKTsoJUt7LaU6rCA7ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL3JlYWN0LzIwMjItMDMtMjMtcmVhY3QtcmV3aXJlZC3sgqzsmqntlbTshJwtZWplY3Tsl4bsnbQtQ1JB7JeQYmFiZWzshKTsoJUt7LaU6rCA7ZWY6riwLm1kXCIsXG5cdFwiLi9yZWFjdC8yMDIyLTA0LTAxLWNyYeyXhuydtC3rpqzslaHtirgt7ZSE66Gc7KCd7Yq4LeyEpOygle2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIyLTA0LTAxLWNyYeyXhuydtC3rpqzslaHtirgt7ZSE66Gc7KCd7Yq4LeyEpOygle2VmOq4sC5tZFwiLFxuXHRcIi4vcmVhY3QvMjAyMi0xMC0wNy3rpqzslaHtirgt7L2Y7IaU7LC9LeyXkOufrC3qt7jrjIDroZwt64aU65GQ6rOgLeqzhOyLoOqwgOyalC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIyLTEwLTA3LeumrOyVoe2KuC3svZjshpTssL0t7JeQ65+sLeq3uOuMgOuhnC3rhpTrkZDqs6At6rOE7Iug6rCA7JqULm1kXCIsXG5cdFwiLi90ZXN0aW5nLzIwMjItMDctMDgtSmVzdOuhnC3rpqzslaHtirjsl5DshJwt7Jyg64ubLe2FjOyKpO2KuO2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy90ZXN0aW5nLzIwMjItMDctMDgtSmVzdOuhnC3rpqzslaHtirjsl5DshJwt7Jyg64ubLe2FjOyKpO2KuO2VmOq4sC5tZFwiLFxuXHRcIi4vdnVlanMvMjAyMS0wMi0wOS1WdWVqc+yXkOyEnCBBV1MgTGFtYmRh7JmAIFNFU+ulvCDsgqzsmqntlbTshJwg66mU7J28IOuztOuCtOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy92dWVqcy8yMDIxLTAyLTA5LVZ1ZWpz7JeQ7IScIEFXUyBMYW1iZGHsmYAgU0VT66W8IOyCrOyaqe2VtOyEnCDrqZTsnbwg67O064K06riwLm1kXCIsXG5cdFwiLi92dWVqcy8yMDIxLTAzLTEyLVZ1ZXjrpbwg7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL3Z1ZWpzLzIwMjEtMDMtMTItVnVleOulvCDslYzslYTrs7TsnpAubWRcIixcblx0XCIuL+uptOygkS8yMDIxLTA2LTAyLTIwMjEt7ZSE66Gg7Yq47JeU65OcLeqwnOuwnOyekC3sp4HsoJEt67Cb7J2ALeq4sOyIoC3rqbTsoJEt7KeI66y4LeumrOyKpO2KuC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/rqbTsoJEvMjAyMS0wNi0wMi0yMDIxLe2UhOuhoO2KuOyXlOuTnC3qsJzrsJzsnpAt7KeB7KCRLeuwm+ydgC3quLDsiKAt66m07KCRLeyniOusuC3rpqzsiqTtirgubWRcIixcblx0XCIuL+uyiOyXrS8yMDIxLTAxLTEwLTQ164WE64+Z7JWILeqwnOuwnOyekOuhnC3snbztlZjrqbAt67Cw7Jq06rKD65OkLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL+uyiOyXrS8yMDIxLTAxLTEwLTQ164WE64+Z7JWILeqwnOuwnOyekOuhnC3snbztlZjrqbAt67Cw7Jq06rKD65OkLm1kXCIsXG5cdFwiLi/rsojsl60vMjAyMS0wOC0xNC3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMe2OuC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/rsojsl60vMjAyMS0wOC0xNC3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMe2OuC5tZFwiLFxuXHRcIi4v67KI7JetLzIwMjEtMDgtMjIt7LKY7J2M67aA7YSwLeuBneq5jOyngC3sg4HshLjtnogt7JWM7JWE67O07J6QLSBIVFRQM+yXkC3rjIDtlZwtQS1UTy1aXzLtjrgubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cv67KI7JetLzIwMjEtMDgtMjIt7LKY7J2M67aA7YSwLeuBneq5jOyngC3sg4HshLjtnogt7JWM7JWE67O07J6QLSBIVFRQM+yXkC3rjIDtlZwtQS1UTy1aXzLtjrgubWRcIixcblx0XCIuL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMTUt7KKL7J2A6rCc67Cc7J6Q656ALeustOyXh+ydvOq5jC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/smpTsppgg64qQ64G864qUIOqyg+uTpC8yMDIyLTA4LTE1Leyii+ydgOqwnOuwnOyekOuegC3rrLTsl4fsnbzquYwubWRcIixcblx0XCIuL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMjgt7JqU7KaY65Ok7Ja0LeqwnOuwnOyekOuPhC3su6TrrqTri4jsvIDsnbTshZgt64ql66Cl7J20LeykkeyalO2VmOuLpOqzoC3ripDrgbzripQt7J207JygLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMjgt7JqU7KaY65Ok7Ja0LeqwnOuwnOyekOuPhC3su6TrrqTri4jsvIDsnbTshZgt64ql66Cl7J20LeykkeyalO2VmOuLpOqzoC3ripDrgbzripQt7J207JygLm1kXCJcbn07XG5cbmZ1bmN0aW9uIHdlYnBhY2tBc3luY0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblxuXHRcdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcblx0fSk7XG59XG53ZWJwYWNrQXN5bmNDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7IH07XG53ZWJwYWNrQXN5bmNDb250ZXh0LmlkID0gXCIuL2NvbnRlbnRzL2Jsb2cgbGF6eSByZWN1cnNpdmUgXlxcXFwuXFxcXC8uKiRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vYXdzLzIwMjEtMDUtMjgtQVdTLUVDMi3tlZzqta3slrQt64+E66mU7J24LeyXsOqysO2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9hd3MvMjAyMS0wNS0yOC1BV1MtRUMyLe2VnOq1reyWtC3rj4TrqZTsnbgt7Jew6rKw7ZWY6riwLm1kXCIsXG5cdFwiLi9jaS1jZC8yMDIxLTA5LTAyLUNJLUNELeq4sOy0iOqwnOuFkOyXkC3rjIDtlbQt7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2NpLWNkLzIwMjEtMDktMDItQ0ktQ0Qt6riw7LSI6rCc64WQ7JeQLeuMgO2VtC3slYzslYTrs7TsnpAubWRcIixcblx0XCIuL2V0Yy8yMDIxLTA4LTA3LeyciOuPhOyasC3qsIDsg4Et642w7Iqk7YGs7YaxLeuTgOyWvOuqqOuLiO2EsC3tmZzsmqkt6re564yA7ZmULe2VmOuKlOuylS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9ldGMvMjAyMS0wOC0wNy3snIjrj4TsmrAt6rCA7IOBLeuNsOyKpO2BrO2GsS3rk4Dslrzrqqjri4jthLAt7Zmc7JqpLeq3ueuMgO2ZlC3tlZjripTrspUubWRcIixcblx0XCIuL2V0Yy8yMDIxLTA4LTE4Leq1rOq4gC3slaDrhJDrpqzti7HsiqTroZwtamVreWxs66GcLeunjOuToC3rgrQt67iU66Gc6re4LeuwqeusuOyekC3tlonrj5ntjKjthLQt7YyM7JWF7ZWY64qULeuwqeuylS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9ldGMvMjAyMS0wOC0xOC3qtazquIAt7JWg64SQ66as7Yux7Iqk66GcLWpla3lsbOuhnC3rp4zrk6At64K0Leu4lOuhnOq3uC3rsKnrrLjsnpAt7ZaJ64+Z7Yyo7YS0Le2MjOyVhe2VmOuKlC3rsKnrspUubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjAtMTItMTYt6rCc67Cc7J6Q66W8IOq0tOuhre2eiOyngOunjCDsl4bslrTshJzripQg7JWI65CY64qUIENPUlMubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMC0xMi0xNi3qsJzrsJzsnpDrpbwg6rS066Gt7Z6I7KeA66eMIOyXhuyWtOyEnOuKlCDslYjrkJjripQgQ09SUy5tZFwiLFxuXHRcIi4vZnJvbnRlbmQvMjAyMC0xMi0xNi3smrDrpqzqsIAg7ZWt7IOBIOyTsOuKlCBIVFRQIO2UhOuhnO2GoOy9nOydtCDrrZjquYwubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMC0xMi0xNi3smrDrpqzqsIAg7ZWt7IOBIOyTsOuKlCBIVFRQIO2UhOuhnO2GoOy9nOydtCDrrZjquYwubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjEtMDEtMDEtV0FT7JmAIOybueyEnOuyhC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9mcm9udGVuZC8yMDIxLTAxLTAxLVdBU+yZgCDsm7nshJzrsoQubWRcIixcblx0XCIuL2Zyb250ZW5kLzIwMjItMDItMjIt7JqU6rKD7J207Ju57Yyp7J2064ukLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2Zyb250ZW5kLzIwMjItMDItMjIt7JqU6rKD7J207Ju57Yyp7J2064ukLm1kXCIsXG5cdFwiLi9mcm9udGVuZC8yMDIyLTEwLTEyLeyekOuwlOyKpO2BrOumve2KuC1BU1NFVFPqtIDrpqwt65287J2067iM65+s66asLey2lOyynC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9mcm9udGVuZC8yMDIyLTEwLTEyLeyekOuwlOyKpO2BrOumve2KuC1BU1NFVFPqtIDrpqwt65287J2067iM65+s66asLey2lOyynC5tZFwiLFxuXHRcIi4vZnJvbnRlbmQvMjAyMi0xMC0xNC1GRWNvbmYtMjAyMi1SZXNjcmlwdOqwmeydtO2VtOyalC3soJXrr7jrn4kubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvZnJvbnRlbmQvMjAyMi0xMC0xNC1GRWNvbmYtMjAyMi1SZXNjcmlwdOqwmeydtO2VtOyalC3soJXrr7jrn4kubWRcIixcblx0XCIuL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1CbG9nLeunjOuTnOuKlOqyjC3quIDsk7DripQt6rKD67O064ukLe2emOuToC3sgqzrnozrk6Tsl5DqsowubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2ct66eM65Oc64qU6rKMLeq4gOyTsOuKlC3qsoPrs7Tri6Qt7Z6Y65OgLeyCrOuejOuTpOyXkOqyjC5tZFwiLFxuXHRcIi4vamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2fsl5At7Y+s7Iqk7YyFLe2VmOuKlOuylS3snbTrr7jsp4DrhKPquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvamVreWxsLzIwMjAtMTItMTctamVreWxsLUJsb2fsl5At7Y+s7Iqk7YyFLe2VmOuKlOuylS3snbTrr7jsp4DrhKPquLAubWRcIixcblx0XCIuL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1OZXh0Le2FjOuniC3snpDshLjtnogt7JWM7JWE67O06riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2pla3lsbC8yMDIwLTEyLTE3LWpla3lsbC1OZXh0Le2FjOuniC3snpDshLjtnogt7JWM7JWE67O06riwLm1kXCIsXG5cdFwiLi9qZWt5bGwvMjAyMS0wMS0wNS1KZWt5bGwt67iU66Gc6re4LeyhsO2ajOyImC3rsYPsp4At64us6riwLS0tSElUUy5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9qZWt5bGwvMjAyMS0wMS0wNS1KZWt5bGwt67iU66Gc6re4LeyhsO2ajOyImC3rsYPsp4At64us6riwLS0tSElUUy5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTAzLTMxLUphdmFzY3JpcHQt7J6Q7KO87JOw64qULeuCtOyepS3tlajsiJgt67O17Iq17ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wMy0zMS1KYXZhc2NyaXB0LeyekOyjvOyTsOuKlC3rgrTsnqUt7ZWo7IiYLeuzteyKte2VmOq4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTAzLUVTMjAyMS3stZzsi6DsnpDrsJTsiqTtgazrpr3tirgt7IOI66Gt6rKM7LaU6rCA65CcLeq4sOuKpS5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDMtRVMyMDIxLey1nOyLoOyekOuwlOyKpO2BrOumve2KuC3sg4jroa3qsozstpTqsIDrkJwt6riw64qlLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDQt7J6Q67CU7Iqk7YGs66a97Yq4Le2UhOuhnOyymOufvC3sk7DquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTA0LeyekOuwlOyKpO2BrOumve2KuC3tlITroZzsspjrn7wt7JOw6riwLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMDkt7J6Q67CU7Iqk7YGs66a97Yq4LXZhci1sZXQtY29uc3Qt7KeE7KecLeywqOydtOygkC3qtazrs4TtlZjquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTA5LeyekOuwlOyKpO2BrOumve2KuC12YXItbGV0LWNvbnN0LeynhOynnC3ssKjsnbTsoJAt6rWs67OE7ZWY6riwLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMTct7J6Q67CU7Iqk7YGs66a97Yq4LWFzeW5jLWF3YWl0Ley0iOyKpO2UvOuTnC3tlbXsi6zssrTtgawubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTE3LeyekOuwlOyKpO2BrOumve2KuC1hc3luYy1hd2FpdC3stIjsiqTtlLzrk5wt7ZW17Ius7LK07YGsLm1kXCIsXG5cdFwiLi9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMjYt7J6Q67CU7Iqk7YGs66a97Yq4LeyZhOyghO2eiC3sg4jroZzsmrTtlajsiJgt7KCc64SI66CI7J207YSw66W8LeyVjOyVhOuztOyekC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjEtMDgtMjYt7J6Q67CU7Iqk7YGs66a97Yq4LeyZhOyghO2eiC3sg4jroZzsmrTtlajsiJgt7KCc64SI66CI7J207YSw66W8LeyVjOyVhOuztOyekC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA4LTMwLeyekOuwlOyKpO2BrOumve2KuC1pdGVyYWJsZeqzvC1pdGVyYXRvcuyXkC3rjIDtlbQt7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMS0wOC0zMC3snpDrsJTsiqTtgazrpr3tirgtaXRlcmFibGXqs7wtaXRlcmF0b3Lsl5At64yA7ZW0LeyVjOyVhOuztOyekC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA5LTE2LWphdmFzY3JpcHQt7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYLeydvOuLqC3slYzslYTrs7TsnpAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIxLTA5LTE2LWphdmFzY3JpcHQt7KaJ7Iuc7Iuk7ZaJ7ZWo7IiYLeydvOuLqC3slYzslYTrs7TsnpAubWRcIixcblx0XCIuL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMi0wMy0yNC1ub2RlanPrsoTsoIQxMHgtMTR466GcLeyYrOumrOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9sYW5ndWFnZS9qYXZhc2NyaXB0LzIwMjItMDMtMjQtbm9kZWpz67KE7KCEMTB4LTE0eOuhnC3smKzrpqzquLAubWRcIixcblx0XCIuL2xhbmd1YWdlL2phdmFzY3JpcHQvMjAyMi0wNC0wNy1qYXZhc2NyaXB0LeygleyImOunjC3snoXroKXrsJvquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvbGFuZ3VhZ2UvamF2YXNjcmlwdC8yMDIyLTA0LTA3LWphdmFzY3JpcHQt7KCV7IiY66eMLeyeheugpeuwm+q4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvdHlwZXNjcmlwdC8yMDIxLTA0LTE0LVR5cGVzY3JpcHQt7Iuc7J6R7ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL3R5cGVzY3JpcHQvMjAyMS0wNC0xNC1UeXBlc2NyaXB0LeyLnOyeke2VmOq4sC5tZFwiLFxuXHRcIi4vbGFuZ3VhZ2UvdHlwZXNjcmlwdC8yMDIxLTA0LTI3LVR5cGVzY3JpcHQt7Iuk7Iq17YC07KaILm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL2xhbmd1YWdlL3R5cGVzY3JpcHQvMjAyMS0wNC0yNy1UeXBlc2NyaXB0LeyLpOyKte2AtOymiC5tZFwiLFxuXHRcIi4vcmVhY3QvMjAyMS0wNC0yOC3si6TsoIQt66as7JWh7Yq4Le2UhOuhnOq3uOuemOuwjS1zZWN0aW9uMS4t66as7JWh7Yq4Le2UhOuhnOygne2KuC3si5zsnpHtlZjquLAubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cvcmVhY3QvMjAyMS0wNC0yOC3si6TsoIQt66as7JWh7Yq4Le2UhOuhnOq3uOuemOuwjS1zZWN0aW9uMS4t66as7JWh7Yq4Le2UhOuhnOygne2KuC3si5zsnpHtlZjquLAubWRcIixcblx0XCIuL3JlYWN0LzIwMjEtMDUtMDQt66as7JWh7Yq4LeuUlOyekOyduC3tjKjthLQtMS4tQ29udGFpbmVyK1ByZXNlbnRlci5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIxLTA1LTA0LeumrOyVoe2KuC3rlJTsnpDsnbgt7Yyo7YS0LTEuLUNvbnRhaW5lcitQcmVzZW50ZXIubWRcIixcblx0XCIuL3JlYWN0LzIwMjItMDMtMjMtcmVhY3QtcmV3aXJlZC3sgqzsmqntlbTshJwtZWplY3Tsl4bsnbQtQ1JB7JeQYmFiZWzshKTsoJUt7LaU6rCA7ZWY6riwLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL3JlYWN0LzIwMjItMDMtMjMtcmVhY3QtcmV3aXJlZC3sgqzsmqntlbTshJwtZWplY3Tsl4bsnbQtQ1JB7JeQYmFiZWzshKTsoJUt7LaU6rCA7ZWY6riwLm1kXCIsXG5cdFwiLi9yZWFjdC8yMDIyLTA0LTAxLWNyYeyXhuydtC3rpqzslaHtirgt7ZSE66Gc7KCd7Yq4LeyEpOygle2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIyLTA0LTAxLWNyYeyXhuydtC3rpqzslaHtirgt7ZSE66Gc7KCd7Yq4LeyEpOygle2VmOq4sC5tZFwiLFxuXHRcIi4vcmVhY3QvMjAyMi0xMC0wNy3rpqzslaHtirgt7L2Y7IaU7LC9LeyXkOufrC3qt7jrjIDroZwt64aU65GQ6rOgLeqzhOyLoOqwgOyalC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy9yZWFjdC8yMDIyLTEwLTA3LeumrOyVoe2KuC3svZjshpTssL0t7JeQ65+sLeq3uOuMgOuhnC3rhpTrkZDqs6At6rOE7Iug6rCA7JqULm1kXCIsXG5cdFwiLi90ZXN0aW5nLzIwMjItMDctMDgtSmVzdOuhnC3rpqzslaHtirjsl5DshJwt7Jyg64ubLe2FjOyKpO2KuO2VmOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy90ZXN0aW5nLzIwMjItMDctMDgtSmVzdOuhnC3rpqzslaHtirjsl5DshJwt7Jyg64ubLe2FjOyKpO2KuO2VmOq4sC5tZFwiLFxuXHRcIi4vdnVlanMvMjAyMS0wMi0wOS1WdWVqc+yXkOyEnCBBV1MgTGFtYmRh7JmAIFNFU+ulvCDsgqzsmqntlbTshJwg66mU7J28IOuztOuCtOq4sC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy92dWVqcy8yMDIxLTAyLTA5LVZ1ZWpz7JeQ7IScIEFXUyBMYW1iZGHsmYAgU0VT66W8IOyCrOyaqe2VtOyEnCDrqZTsnbwg67O064K06riwLm1kXCIsXG5cdFwiLi92dWVqcy8yMDIxLTAzLTEyLVZ1ZXjrpbwg7JWM7JWE67O07J6QLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL3Z1ZWpzLzIwMjEtMDMtMTItVnVleOulvCDslYzslYTrs7TsnpAubWRcIixcblx0XCIuL+uptOygkS8yMDIxLTA2LTAyLTIwMjEt7ZSE66Gg7Yq47JeU65OcLeqwnOuwnOyekC3sp4HsoJEt67Cb7J2ALeq4sOyIoC3rqbTsoJEt7KeI66y4LeumrOyKpO2KuC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/rqbTsoJEvMjAyMS0wNi0wMi0yMDIxLe2UhOuhoO2KuOyXlOuTnC3qsJzrsJzsnpAt7KeB7KCRLeuwm+ydgC3quLDsiKAt66m07KCRLeyniOusuC3rpqzsiqTtirgubWRcIixcblx0XCIuL+uyiOyXrS8yMDIxLTAxLTEwLTQ164WE64+Z7JWILeqwnOuwnOyekOuhnC3snbztlZjrqbAt67Cw7Jq06rKD65OkLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL+uyiOyXrS8yMDIxLTAxLTEwLTQ164WE64+Z7JWILeqwnOuwnOyekOuhnC3snbztlZjrqbAt67Cw7Jq06rKD65OkLm1kXCIsXG5cdFwiLi/rsojsl60vMjAyMS0wOC0xNC3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMe2OuC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/rsojsl60vMjAyMS0wOC0xNC3sspjsnYzrtoDthLAt64Gd6rmM7KeALeyDgeyEuO2eiC3slYzslYTrs7TsnpAtIEhUVFAz7JeQLeuMgO2VnC1BLVRPLVpfMe2OuC5tZFwiLFxuXHRcIi4v67KI7JetLzIwMjEtMDgtMjIt7LKY7J2M67aA7YSwLeuBneq5jOyngC3sg4HshLjtnogt7JWM7JWE67O07J6QLSBIVFRQM+yXkC3rjIDtlZwtQS1UTy1aXzLtjrgubWRcIjogXCIuL2NvbnRlbnRzL2Jsb2cv67KI7JetLzIwMjEtMDgtMjIt7LKY7J2M67aA7YSwLeuBneq5jOyngC3sg4HshLjtnogt7JWM7JWE67O07J6QLSBIVFRQM+yXkC3rjIDtlZwtQS1UTy1aXzLtjrgubWRcIixcblx0XCIuL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMTUt7KKL7J2A6rCc67Cc7J6Q656ALeustOyXh+ydvOq5jC5tZFwiOiBcIi4vY29udGVudHMvYmxvZy/smpTsppgg64qQ64G864qUIOqyg+uTpC8yMDIyLTA4LTE1Leyii+ydgOqwnOuwnOyekOuegC3rrLTsl4fsnbzquYwubWRcIixcblx0XCIuL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMjgt7JqU7KaY65Ok7Ja0LeqwnOuwnOyekOuPhC3su6TrrqTri4jsvIDsnbTshZgt64ql66Cl7J20LeykkeyalO2VmOuLpOqzoC3ripDrgbzripQt7J207JygLm1kXCI6IFwiLi9jb250ZW50cy9ibG9nL+yalOymmCDripDrgbzripQg6rKD65OkLzIwMjItMDgtMjgt7JqU7KaY65Ok7Ja0LeqwnOuwnOyekOuPhC3su6TrrqTri4jsvIDsnbTshZgt64ql66Cl7J20LeykkeyalO2VmOuLpOqzoC3ripDrgbzripQt7J207JygLm1kXCJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vY29udGVudHMvYmxvZyBzeW5jIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiOyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=