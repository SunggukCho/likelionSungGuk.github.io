---
title: "똑똑하게 ASSETS관리하는 EIMA 라이브러리 추천합니다!"
date: "2022.10.12"
tags:
- 리액트
- 이미지
- EIMA
- 라이브러리
---



## 1. Intro

개발을 하다보면 png, svg 파일 등의 Assets들을 import해와서 써야 하는 경우가 빈번하게 발생합니다. 이 과정을 반복하다보면 크게 두 가지 귀찮은 상황이 발생하는데 하나는 import문이 길어진다는 것이고 또 다른 하나는 다양한 곳에서 활용되는 assets은 A, B, C… 등 n개의 여러 파일에 걸쳐서 계속 import 되고 쓰여야 한다는 것이죠. 그때마다 해당 소스의 path를 상대경로로 가지고 오는 것도 꽤나 귀찮은 반복작업입니다.

### EIMA 라이브러리 소개

이런 불편한 점을 개선할 수 있도록 도와주는 좋은 라이브러리를 찾아 공유합니다.

[https://github.com/Jonghakseo/EimaJS](https://github.com/Jonghakseo/EimaJS)

EIMA라이브러리는 하나의 디렉토리 안에 있는 assets들을 [상위dir _ 하위dir _ 이름]으로 구분지어 쉽게 import하고 이름을 검색할 수 있도록 만들어주는 똑똑한 기능을 제공합니다.

예를들어 `img/abc/def/sky.png` 라는 이미지가 있으면 `ABC_DEF_SKY_PNG` 라는 이름으로 해당 path를 불러올 수 있도록 도와줍니다.

```
// assets.js
import ABC_DEF_SKY_PNG from "img/abc/def/sky.png";

const ASSETS = {
  ABC_DEF_SKY_PNG
}
export default ASSETS
```

또 해당 디렉토리를 watch하고 있다가 새로운 리소스가 들어오면 그 리소스에 대한 이름과 path도 바로 만들어서 assets.js에 추가해주어 리소스를 추가한 뒤 또 assets.js에 추가해야되는 번거로움을 없애주었습니다.

eima를 설치하고 `eima init` 명령어를 입력하면 기본적으로 생기는 것이 eima.json입니다.

```tsx
// eima.json
{
	"target":"es6",
	"hideSize":false,
	"lintPath":"src",
	"paths":[{"assets":"src/img","out":"src/assets.js","vName":"ASSETS"}]
}
```

- target은 ECMASCRIPT 문법을 뜻하며 es6로 할 경우 익숙한 import from 으로 변환시켜 줍니다.
- 여기서 중요하게 봐야할 것은 paths인데, paths내부의 **assets은 타겟 디렉토리의 path**를 넣어주고 out은 어떤 위치에 assets를 import하여 이름과 path를 반환해주는 js파일의 path와 name, 확장자까지 적어줍니다. vName은 export할 대표 닉네임이라 보시면 됩니다.
- 위와 같이 설정하면 eima.json은 디렉토리 최상단, assets.js라는 이름의 파일은 src 아래 생기고 닉네임은 ASSETS로 설정됩니다.
- 이 설정파일을 완료한 뒤 `eima start` 명령어를 입력하면 assets.js 가 생기면서 ASSETS의 이름과 path가 생성됩니다.

> 💡주의: eima를 리액트 프로젝트 내부에 설치하면 eima 명령어가 제대로 동작하지 않습니다. 
> npm i eima -g 명령어로 글로벌로 설치하시면 eima의 명령어를 실행할 수 있습니다.



## 2. SVG 파일을 ReactComponent로 사용하기

기존에는 SVG 파일을 리액트 컴포넌트로 사용하기 위해 다음과 같은 문법을 활용하였습니다.

```tsx
import { ReactComponent as FileUpload } from '../src/img/icon/file_upload.svg';
```

하지만 새롭게 EIMA 라이브러리를 쓰게 되면서 import 자체를 ReactComponent로 해오기는 어려웠습니다. 이를 해결하기 위해서 svg의 ASSETS src 를 전달하면 ReactComponent를 만들어 주는 컴포넌트를 만들었습니다.

```tsx
import React from 'react'
import styled from 'styled-components';

interface SvgComponentProps {
  src: string;
  className: string;
  disabled?: boolean;
}

const SvgComponent = (props: SvgComponentProps) => <StyledObject type="image/svg+xml" data={props.src} className={props.className} disabled={props.disabled} />;

export default SvgComponent;

interface StyledObjectProps {
  disabled?: boolean;
}

const StyledObject = styled.object<StyledObjectProps>`
  filter: ${(props) => (props.disabled ? `invert(50%) sepia(0%) saturate(50%) hue-rotate(0deg) brightness(100%) contrast(100%)` : ``)};
`;
```

여기서 특이한 점은 object를 썼다는 점인데요, svg를 사용하는 다양한 방식이 있었지만 svg의 색상을 제어해야했던 상황에서 object 태그가 그나마 유용하다고 여겨졌습니다.

[웹에서 SVG 사용하기](https://svgontheweb.com/ko/)



### 2-1. Object태그 에러 핸들링

object태그로 disabled가 props로 왔을 때 색상 변경까지 진행할 수 있어서 이제 다 되었구나 생각하고 있었을 때 예상치 못한 상황이 하나 펼쳐졌습니다. 마우스 커서를 보면 아이콘 바로 위에 위치했을 때는 포인터 커서가 아닌 일반커서형태로 나오고 클릭도 되지 않습니다. 해당 아이콘 영역을 벗어나면 다시 일반 버튼과 동일하게 동작하게 되는 것이죠.

<video src="/assets/img/object태그이슈.mp4" width="100%" autoplay controls loop></video>

바로 svg가 상위의 버튼 컴포넌트의 클릭 이벤트를 막고 있었습니다.

따라서 css에 `pointer-events: none;` 을 추가해주고 나서야 드디어 정상적으로 동작할 수 있게 되었습니다.

[How to bind click event to object tag?](https://stackoverflow.com/questions/25916403/how-to-bind-click-event-to-object-tag#:~:text=1.%20Issue%3A%20Event%20handling)



### 2-2. 아이콘마다 색상이 다른 이슈

SvgComponent로 아이콘을 래핑해서 ReactComponent화 해주어도 문제가 되는 것은 색상 이슈였습니다. 아이콘의 색상이 원하던 색이 그대로 나오지 않는 상황이었는데 원인은 크게 두 가지가 있었습니다.

1. svg는 기존 class에 선언된 css 영향을 받지 않는다.
2. svg 파일별로 각각의 색상값이 존재하고 그 값이 다르다.

```tsx
// ex: file_download.svg
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"> ...

// ex2: ic-cal-area.svg
<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">...
```

예를 들어 file_download.svg 파일은 기본적으로 검정색 색상이 fill로 적용되어있고 이와는 달리 ic-cal-area 파일은 fill 색상이 따로 지정되어있지 않는 특성을 가지고 있습니다.

따라서 각각의 svg파일에 기본 색상값 #CCC를 넣어주고 해당 값이 변해야 하는 상황(예를 들어 disabled)에서는 filter 어트리뷰트를 사용하여 색상값을 변경해주었습니다.

<aside>
💡 SVGR 라이브러리를 활용하면 SVG 파일을 ReactComponent로 변경하여 사용할 수 있게 됩니다. 하지만 개인적으로 EIMA 라이브러리를 설치한데다가 SVGR까지 두 개를 설치하는게 좀 꺼려졌고, 좀 더 원했던것은 각각의 SVG파일이 ReactComponent가 되는 것이 아니라 SVG의 Path만으로 쉽게 ReactComponent를 만들고 싶어서 이번에는 위와 같이 작업하였습니다.
</aside>
```javascript
<img className="loading-img" src={ASSETS.ICON_LOADING_PNG} alt="loading-img" />
```


이런식으로 기존 svg의 경로를 찾아서 src에 직접 넣는 것보다 vsCode와 EIMA의 도움을 받아 내가 추가한 assets의 경로와 이름으로 손쉽게 찾아올 수 있다는 점이 상당히 편리해졌다는 것입니다. 또한 여러개의 페이지에 동일한 이미지 assets들이 import 되고 있는데 이런 부분들은 추후 assets의 경로나 파일이 변경되면 번거롭게 모두 수정해주어야 하고 그에 따라 버그 발생확률도 올라갈 수 있다는 단점이 있습니다. 하지만 이렇게 동일한 asset에 대해 같은 이름을 사용한다면 변경사항이 있더라도 모두 동일하게 적용될 수 있습니다.

이와 같은 과정을 반복하면서 기존 Assets들을 대체해줍니다.

### 3-2. ReactComponent로 import해서 사용하던 SVG 파일 수정 예시

```tsx
// 기존
import { ReactComponent as DoubleArrowRight } from "./img/icon/double_arrow_right.svg"
<DoubleArrowRight className="icon" />
```

<video src="/assets/img/ReactComponent-eima.mp4" width="100%" autoplay controls loop></video>

```tsx
// 변환
import SvgComponent from './components/SvgComponent';
import ASSETS from './assets';

<SvgComponent className="icon" src={ASSETS.ICON_DOUBLE_ARROW_RIGHT_SVG} disabled={this.state.endPageNum - 10 < this.props.curPage || this.state.endPageNum === this.props.curPage} />
```

이렇게 SVG의 src path를 SvgComponent에 props으로 내려주는 방식으로 아이콘을 쉽게 ReactComponent화 해서 활용할 수 있습니다.



## 4. 사용법

Eima를 도입하고자 한다면 다음과 같이 쓸 수 있습니다.

터미널을 두  개 이상 켭니다.

그래서 하나는 로컬 서버로 사용하고 또 다른 하나는 eima를 사용합니다. (저는 git용으로 3개씩 켜서 쓰고 있습니다.)

![eima사용법.png](/assets/img/eima사용법.png)

이렇게 되면 assets가 바라보고 있는 디렉토리에 새로운 assets이 추가될 때마다 assets.js 에 해당 assets의 패스와 이름이 자동으로 추가되어 손쉽게 사용할 수 있게 됩니다.

제가 한 번 써보고 괜찮으면 저희 팀에도 소개하려고 했는데 개인적으로 상당히 만족하고 있어서 팀에 소개 후 도입하려고 합니다.

좋은 라이브러리를 만들어주신 [서종학](https://nookpi.tistory.com/97?category=906072) 님께 다시 한 번 감사드립니다 🙇
