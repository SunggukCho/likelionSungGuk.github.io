---
title: "요것이 웹팩이다!"
date: "2022-02-22"
tags:
  - webpack
---



이 글은 [프론트엔드 개발 환경의 이해](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html#5-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8)를 메인으로 해서 간단한 html, css, js를 활용한 프로젝트를 만들어보며 제가 이해한 대로 웹팩을 설명해 놓은 글입니다.



# 요것이 웹팩 (Webpack)이다!

## 1. 웹팩이란?

![요것이웹팩이다](/assets/img/요것이웹팩이다.png)

오픈 소스 자바스크립트 **모듈 번들러**로써 여러개로 나누어져 있는 파일들을 **하나의 자바스크립트 코드로 압축하고 최적화하는 라이브러리**입니다.

이러한 Bundler의 가장 대표적인 것이 `웹팩`이고, `Parcel`, `Rollup`등이 더 있습니다.

![과거 일반적인 모습의 html, css, js 구조
각각의 파일들을 따로 받아오는 것은 네트워크 낭비가 크다.](/assets/img/요것이웹팩이다%201.png)

과거 일반적인 모습의 html, css, js 구조
각각의 파일들을 따로 받아오는 것은 네트워크 낭비가 크다.

### 1.1 웹팩을 사용하는 이유?

1. **여러 파일의 자바스크립트 코드를 압축하여 최적화** 할 수 있기 때문에 **로딩에 대한 네트워크 비용을 줄일 수 있습니다. 
⇒ 로딩 속도를 높일 수 있습니다.**
2. **모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽습니다.**
    - 예를 들어, 기능별로 나눈다고 하면 Create.js, Read.js, Update.js, Delete.js 스크립트를 각각 만들어서 해당 기능에 필요한 코드들끼리 모아두고 다른 것들끼리는 분리해서  javascript 파일을 용도별로 구분해서 작성하는 것이 개발자 입장에서는 편리합니다. 어차피 따로 만들어도 Webpack으로 Build(Bundling)을 하면 **하나의 JS 파일**로 만들어 주니까요.
3. **최신 자바스크립트 문법을 지원하지 않는 브라우저에서 사용할 수 있는 코드로 쉽게 변환시켜 줍니다.**
    - 브라우저의 종류에 따라, 브라우저 버전에 따라서 최신 Javascript문법을 지원하지 않을 수도 있습니다. Webpack을 사용해서 빌드하면 최신 Javascript 문법을 사용한 코드를 이전 버전에서도 호환이 가능하도록 변경해줍니다.
4. **JS 모듈화 이슈**
    - Javascript를 각각 불러오도록 하면 불러오는 순서에 따라 영향을 받는 이슈.
    - 스코프가 같은 위치에 동일 변수가 있으면 변수가 원하는 대로 작동하지 않습니다.
    - Code Example
      
        ```html
        # index.html
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta http-equiv="X-UA-Compatible" content="IE=edge">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Document</title>
        </head>
        <body>
          <h1 id="title">Hello world!</h1>
        
          <script src="./js/A.js"></script>
          <script src="./js/B.js"></script>
          <script src="./js/C.js"></script>
            
        </body>
        </html>
        ```
        
        ```jsx
        // A.js
        const text = "AAAAA";
        let target = document.getElementById("title")
        target.innerText = text
        ```
        
        ```jsx
        // B.js
        const text = "BBBBB";
        let target = document.getElementById("title")
        target.innerText = text
        ```
        
        ```jsx
        // C.js
        const text = "CCCCC";
        let target = document.getElementById("title")
        target.innerText = text
        ```
        
        - 이 경우 H1태그에는 어떤 텍스트가 들어갈까요?
            - 정답
              
                AAAAA
            
            - 이유
              - A/B/C 모두 글로벌 영역에서 text 변수를 const 로 지정하고 있습니다. 동일 영역에서 const로의 변수 선언은 가장 먼저 불린 A.js의 `const text = "AAAAA"`가 선언됩니다.

## 2. 웹팩의 구성

### **2.1. entry** ➡️

> entry 속성은 웹팩에서 웹 자원을 변환하는 데 필요한 진입점이자 자바스크립트 파일 경로입니다.
> 

entry 속성에서 번들링하고 싶은 파일들을 선언합니다.

웹팩은 엔트리를 통해서 필요한 모듈들을 로딩하고, 하나의 파일로 묶는 과정을 진행합니다.

### **2.2. output 🎯**

> output 속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미합니다.
> 

번들된 결과물을 처리할 위치를 output에 기록합니다.

### **2.3. loader 🚩**

> 웹팩이 웹 애플리케이션을 해석할 때 JS 파일이 아닌 HTML, CSS, IMG, 폰트 등을 변환할 수 있도록 도와주는 속성입니다.
> 

웹팩은 모든 파일을 모듈로 관리하지만 JS 만 알고 있어서 **다른 파일들을 웹팩이 이해할 수 있도록 변경해주는 것이 로더의 역할**입니다.

### **2.4. plugin 🔗**

> 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성입니다.
> 

로더랑 비교하면 **로더는 파일을 해석하고 변환하는 과정에 해당**하고 **플러그인은 해당 결과물의 형태를 바꾸는 과정에 해당**합니다.

## 3. Webpack 실습으로 알아보기

```bash
$ npm i webpack webpack-cli --save-dev
```

[💡github 바로가기](https://github.com/likelionSungGuk/webpack/tree/2aa56fbf4f0166f5082c2d43d9e6a3a181404e55)

### 3.1 `webpack.config.js` 파일 직접 작성

```jsx
// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'development',

  entry: {
    main: './js/A.js',
  },

  output: {
    filename: '[name].js',  // entry의 이름을 뜻합니다. (여기서는 main)
    path: path.resolve('./dist'), // .resolve 를 이용해서 절대 경로를 작성 (OS)
													// 기본적으로 dist로 설정되어있으나 웹에서는 public으로 많이 함
  },
};
```

- mode:  `'production' | 'development' | 'none'` 중 하나를 선택.
    - production
        - DefinePlugin 의 process.env.NODE_ENV 를 production 으로 설정합니다.
        - `최적화를 가장 중점적`으로 두고 빌드하는 속성
          - production 모드에서는 코드가 가장 짧고 간결하게 빌드됩니다.
    - development
        - DefinePlugin 의 process.env.NODE_ENV 를 development 로 설정합니다.
        - `빠른 빌드`를 중심으로 두고 빌드하는 속성
          - development 모드에서 실제로 빌드를 해보면 수 많은 주석이 함께 작성됩니다.
          - 개발자가 개발하면서 진행상황을 최대한 알아볼 수 있도록 지원합니다.
    - none
        - 기본 최적화 옵션으로 설정합니다.
    
- entry: 엔트리는 애플리케이션 번들링을 시작할 지점을 의미합니다. 즉, 어떤 파일들을 bundling할 것인가에 대한 경로입니다.
  
    entry의 이름이 main이고, 이 main은 `./js/A.js` 입니다. 즉, build를 하면 dist 폴더 아래에 main이라는 이름으로 A.js가 bundling됩니다.
    
    - SPA와 MPA Entry차이
      
        ```
        module.exports = {
          // SPA
          entry: './index.js'
        
          // MPA
          entry: {
            main: './main.js',
            contact: './contact.js'
          }
        }
        ```
        

💡[웹팩으로 번들링 했을 때와 안했을 때의 차이](https://github.com/likelionSungGuk/webpack/tree/654efb034e021cd4d45cc3d736810824673c9d6d)

```html
# Bundling 전 index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1 id="title">Hello world!</h1>
  <h3 id="B"></h3>
  <h3 id="C"></h3>

  <script src="./js/A.js"></script>
    
</body>
</html>
```

- 돌발QUIZ: 예상되는 화면은?
  
    ![요것이웹팩이다](/assets/img/요것이웹팩이다%202.png)
    

```html
# Bundling 후
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1 id="title">Hello world!</h1>
  <h3 id="B"></h3>
  <h3 id="C"></h3>

  <script src="./main.js"></script>
    
</body>
</html>
```

- 돌발QUIZ: 예상되는 화면은?
  
    ![요것이웹팩이다](/assets/img/요것이웹팩이다%203.png)
    

⇒ 번들링을 하면 Import로 연결되어있는 Javascript 파일들을 모두 하나(`main.js`)로 모아주기 때문에 B.js와 C.js에 있는 BBB와 CCC가 모두 화면에 나옵니다.

![요것이웹팩이다](/assets/img/요것이웹팩이다%204.png)

### 3.2 loader & plugin

위에서 언급했듯이 로더는 자바스크립트가 아닌 파일들을 번들링해주는 기능을 합니다.

대표적인 것이 html, css, img파일 등이 있죠.

로더는 아래와 같은 규칙으로 작성됩니다.

[💡커스텀 로더 코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/c522b7b520103488528b1bedbf0e839ee1bd1b80)

```jsx
module : {
	rules: {
		test: '가지고올 파일 형식 정규식',
		use: [
			{
				loader: '사용할 로더 이름',
				options: { 사용할 로더 옵션 }
			}
		]
	}
}
```

커스텀 로더를 하나 만들어 보겠습니다.

```jsx
// customLoader.js
module.exports = function customLoader(content) {
  console.log("customLoader 동작!")
  return content
}
```

단순히 로그를 찍은 뒤 content를 그대로 반환하는 간단한 로더입니다.

```jsx
// webpack.config.js
module: {
  rules: [{
    test: /\.js$/, // .js 확장자로 끝나는 모든 파일
    use: [path.resolve('./customLoader.js')] // 방금 만든 로더를 적용한다
  }]
}
```

js로 끝나는 모든 확장자는 이 로더를 한 번씩 돌리도록 하는 설정입니다.

- 돌발 QUIZ: build를  때 “customLoader 동작!”이라는 로그는 몇 번 나올까요?
  
    ![요것이웹팩이다](/assets/img/요것이웹팩이다%205.png)
    

앞서 언급했듯이 로더는 주로 Javascript가 아닌 파일들을 위해 만들어져있는데 예시를 자바스크립트로 만들어 버렸네요. 자주쓰이는 Loader들을 살펴보며 실제로는 어떻게 활용되는지 알아보겠습니다.

## 4. 자주쓰이는 Loader

### 4.1 css-loader

[💡css-loader 코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/231957299996bad792a750638e4f72d0c43a9e3b)

```bash
$ npm install -D css-loader
```

- 돌발QUIZ: `-D`는 무슨 뜻일까요?
  
    D, --save-dev (Package will appear in your `devDependencies`)
    
    개발의존성 모드.
    
    개발할 때만 필요한 패키지가 있습니다. 이런 경우에는 -D를 붙여서 설치하면 
    
    런타임에도 필요한 패키지가 있을 경우에는 -D를 생략하면 됩니다.
    
    dev에서만 필요하고 prod에서는 필요하지 않은 패키지의 경우 이렇게 설치하여 사용합니다.
    
    - `npm install {패키지}` == `npm install --save {패키지}`
    - `npm install -D {패키지}` == `npm install --save-dev {패키지}`
    
    ![요것이웹팩이다](/assets/img/요것이웹팩이다%206.png)
    

설치를 하고 `webpack.config.js` 에 로더 설정을 추가해줍니다.

```jsx
module: {
    rules: [
      {
        test: /\.css$/, 
        use: ["css-loader"], // css-loader를 적용한다
      },
    ],
  }
```

build후 main.js

![요것이웹팩이다](/assets/img/요것이웹팩이다%207.png)

- `style.css`파일이 같이 빌드되어있는 것을 확인할 수 있습니다.

그렇다면 배경이 초록색으로 변경되었을까요?

![요것이웹팩이다](/assets/img/요것이웹팩이다%208.png)

NO. ???

style-loader에서 알아봅시다.

### 4.2 **style-loader**

[💡style-loader코드 바로가기](https://github.com/likelionSungGuk/webpack/tree/06209b896af27a128ccd0a05012b3bdb3e1f1fe3)

모듈로 변경된 스타일 시트는 돔에 추가되어야만 브라우저가 해석할 수 있습니다. `css-loader`로 처리하면 CSS가 자바스크립트 코드로 변경만 되었을 뿐 돔에 적용되지는 않은 상황이다. 때문에 스타일이 적용되지 않은 것입니다.

style-loader는 javascript로 변경된 스타일을 돔에 추가하는 로더입니다.

❕그러므로 css-loader와 style-loader는 대부분 함께 사용됩니다.

```bash
$ npm install -D css-loader
```

설치 후 webpack.config.js 추가

```jsx
module: {
  rules: [
    {
      test: /\.css$/, // .css 확장자로 끝나는 모든 파일
      use: ["style-loader", "css-loader"], // style-loader를 앞에 추가한다
    },
  ],
}
```

특이한 점은 뒤에 설치된 style-loader를 use 배열의 앞쪽에 적었다는 점입니다. 이 배열은 뒤에서 부터 읽어들여 로더를 실행한다고 합니다. 따라서 css를 js로 바꾸는 css-loader먼저 실행하고 그 뒤에 style-loader를 실행해야 하므로 위와 같은 순서대로 작성해줘야 합니다.

```jsx
$ npm run build
```

![드디어 못생긴 초록색 배경 스타일(background: green)이 적용되었네요.](/assets/img/요것이웹팩이다%209.png)

드디어 못생긴 초록색 배경 스타일(background: green)이 적용되었네요.

이 외에 file-loader, url-loader, babel-loader들이 자주 사용되는 로더라고 합니다.

## 5. 플러그인

로더가 “파일” 단위로 처리한다면 플러그인은 “번들된 결과물”을 처리합니다.

특징점인 것은 플러그인 배열에는 생성자를 사용해서 만들어줘야 한다는 점입니다.

```jsx
// webpack.config.js 
var webpack = require('webpack'); 
var HtmlWebpackPlugin = require('html-webpack-plugin'); 
module.exports = {
  mode : '', 
	entry : {}, 
	output : {}, 
	module : {},
 plugins : [ 
	new HtmlWebpackPlugin(), 
	new webpack.ProgressPlugin(), 
	new webpack.optimize.UglifyJsPlugin()
	 // ... ] 
}

```

[💡플러그인 바로가기](https://github.com/likelionSungGuk/webpack/tree/47df871e7cb317e490948627b9cc3165a2829c23)

가장 이해하기 편한 `HtmlWebpackPlugin`의 사용 사례를 살펴보겠습니다.

```bash
$ npm install --save-dev html-webpack-plugin
```

`HtmlWebpackPlugin` 은 번들링 했을 때 최종적으로 완성된 Html을 같이 export해주는 기능을 제공합니다.

플러그인은 각각의 플러그인별로 사용법이 많이 차이가 난다고 합니다. 따라서 webpack 공식 사이트에서 제공해주는 Guide를 따라 가며 진행할 것을 권장드립니다.

[HtmlWebpackPlugin | webpack](https://webpack.js.org/plugins/html-webpack-plugin)

![요것이웹팩이다](/assets/img/요것이웹팩이다%2010.png)

상단에 require, 하단에 생성자 생성을 진행해줍니다.

```jsx
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  mode: 'development',

  entry: {
    main: './src/js/A.js',
  },
  output: {
    filename: '[name].js',
    path: path.resolve('./dist'),
  },
  module: {
    rules: [
      {
        test: /\.css$/, // .css 확장자로 끝나는 모든 파일
        use: ["style-loader", "css-loader"], // style-loader를 앞에 추가한다
      },
    ],
  },
  plugins: [new HtmlWebpackPlugin()]
};
```

이후 `npm run build`

```html
// index.html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Webpack App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"><script defer src="main.js"></script></head>
  <body>
  </body>
</html>
```

기존에는 따로 만들어줬던 index.html 이었지만 이번에는 플러그인이 직접 index.html을 생성해주었습니다. index.html을 브라우저로 열어보겠습니다.

![요것이웹팩이다](/assets/img/요것이웹팩이다%2011.png)

이상하게도 스타일은 그대로 적용이 되었는데, 기존 h1태그 들이 사라져 있습니다.

우리가 원하는 것은 기본 index.html을 템플릿으로 해서 새롭게 빌드해주는 것이었는데 그렇게 동작하지 않았네요.

이것을 가능하게 하려면 템플릿을 지정하는 설정을 추가해줘야 합니다.

`webpack.config.js`

```jsx
plugins: [new HtmlWebpackPlugin({
  template: './index.html', // 템플릿이 될 html path를 지정
  filename: './output.html' // 빌드될 html의 이름/path 지정
}
```

의도적으로 이름을 `output.html` 로 지어봤습니다.

![요것이웹팩이다](/assets/img/요것이웹팩이다%2012.png)

`output.html`

```jsx
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<script defer src="main.js"></script></head>
<body>
  <h1 id="title">Hello world!</h1>
  <h3 id="B"></h3>
  <h3 id="C"></h3>

  <script src="./js/A.js"></script>
    
</body>
</html>
```

우리가 원하던 대로 index.html 템플릿을 그대로 가져왔네요.

—-END—-

---

참고자료

[npm-install | npm Docs](https://docs.npmjs.com/cli/v8/commands/npm-install)

[npm install (plugin) --save와 --save-dev 차이점](https://ithub.tistory.com/165)

[개발(Development) 모드는 어떻게 작동할까?](https://ui.toast.com/weekly-pick/ko_20191212)

[프론트엔드 개발환경의 이해: 웹팩(기본)](https://jeonghwan-kim.github.io/series/2019/12/10/frontend-dev-env-webpack-basic.html#5-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8)

[Writing a Plugin | webpack](https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture)