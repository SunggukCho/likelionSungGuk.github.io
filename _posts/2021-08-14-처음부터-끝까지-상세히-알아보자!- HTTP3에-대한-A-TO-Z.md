---
title: 처음부터 끝까지 상세히 알아보자! - HTTP/3에 대한 A TO Z (1)
date: 2021-08-14 23:18:01
permalink: /:short_year-:month-:day/:title
categories: [frontend, web/network]
tags: [HTTP3, 프로토콜]
---

# (번역) HTTP/3 FROM A To Z: Core Concepts (Part 1) by Robin Marx

원문링크: [https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)

이 글은 *Robin Marx*의 [**HTTP/3 FROM A To Z: Core Concepts (Part1)**](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)을 번역하였습니다.



## TL;DR

- **HTTP3가 왜 필요한가?** - 엄밀히 말하면 우리에게 필요한 것은 실제로 HTTP/3가 아니라 "TCP/2"였으며 그 과정에서 TCP자체를 업그레이드 하는 것보다는 HTTP 버전업이 더 손쉬운 방법이었습니다. (네트워크 계층 구조에 따르면 HTTP는 TCP프로토콜 위에서 동작하는데 HTTP/3가 HTTP 프로토콜의 발전보다는 기저에 깔린 TCP의 발전이 더 필요했고 HTTP/3는 좀 더 로우 레벨의 프로토콜에서 발전이 있었음을 의미합니다.) 우리가 HTTP/3에 대해 기대하는 주요 기능(더 빠른 연결 설정, 더 적은 HoL 차단, 연결 마이그레이션 등)은 실제로 모두 QUIC(TCP의 단점을 보완한 새로운 프로토콜)에서 제공됩니다.
- **QUIC과 UDP** -  HTTP/3는 TCP를 UDP로 바꿨다고 해서 HTTP/2보다 엄청나게 빠르지 않습니다.(정보처리기사에서 많이 나오는 프로토콜 간의 차이인데 UDP는 속도가 빠른 프로토콜입니다.) 대신 QUIC이라는 훨씬 더 발전된 TCP 버전을 재구상하고 구현했습니다. 그리고 이 QUIC은 더 쉽게 배포할 수 있도록 인터넷에서 광범위하게 지원되는 다른 하나의 전송 계층 프로토콜인 UDP 위에서 실행합니다. (TCP를 업그레이드 하는 것은 사실상 매우 어렵기 때문입니다.)
- **BIG CHANGES** - 이전 버전의 HTTP에서는 데이터 통신과 TSL 암호화과정이 분리되어 있었습니다. 따라서 TSL암호화를 진행하다보면 성능이 떨어지는 것이 당연했습니다. 하지만 QUIC은 always-on-TSL 원칙에 맞춰 기본적으로 TSL를 탑재하였습니다. 따라서 연결이 더 빨라지고 보안 성능이 뛰어나다는 장점이 있으나 암호화 오버헤드가 더 큰 문제가 생기는 것, 인터넷 환경이 더 중앙집중화 되는 것 등의 단점이 예상되고 있습니다.



*본문 START!*



## Quick Summary

약 5년여간의 개발 끝에, 새로운 HTTP/3 프로토콜이 거의 막바지 단계에 이르렀다. 이미 실험적 기능으로 몇몇의 기능은 제공되었음에도 불구하고 HTTP/3의 가용성과 사용은 2021년에 증가할 것으로 기대되고 있습니다. 

> 그래서 HTTP/3가 정확히 뭔데? 
> 왜 HTTP/2 가 나온지 얼마 안되서 곧바로 또 나온걸까? 
> 우리가 어떻게 쓸 수 있고 어떻게 써야 하는거지? 
> 그리고 특히 웹 퍼포먼스를 어떻게 향상시키는거지?

자 이제 알아봅시다!



## 💀 HTTP/3에 대한 잘못된 기대가 퍼지고 있다!

이 주제에 대한 몇 가지 블로그 게시물을 읽거나 컨퍼런스 등을 듣고 어느 정도 답을 알고 있다고 생각할 수도 있습니다. "HTTP/3는 패킷 손실이 있을 때 HTTP/2보다 훨씬 빠르다." 또는 "HTTP/3 연결은 대기 시간이 짧고 설정하는 데 시간이 덜 걸린다.", 아마도 "HTTP/3 데이터를 더 빨리 보낼 수 있고 더 많은 리소스를 병렬로 보낼 수 있습니다."

위와 같은 문장과 아티클들은 종종 중대한 기술적 디테일들을 건너 뛰거나 혹은 정확한 문맥 파악을 위한 뉘앙스를 빠뜨리거나 부분적으로 맞는 얘기들이다. 종종 그들은 HTTP/3가 성능면에서 엄청난 혁명인 것처럼 보이게 말하지면 실제로는 그렇게까지 급견한 진화는 아닌(그러나 여전히 유용한!) 진화입니다. 이것은 자칫 위험합니다. 왜냐하면 새로운 프로토콜이 실질적으로 이렇게까지 높은 기대치를 충족시키기지 못해서 살아남지 못할 수도 있기 떄문입니다. 따라서 나는 이것들이 많은 사람들을 결국 실망시켜서 새로온 사람들에게 맹목적인 오해를 아주 오래도록 각인시키게 될까 두렵습니다.

나는 HTTP/2에서 똑같은 일이 일어나는 것을 보았습니다. 당시 서버 푸시, 병렬 스트림 및 우선 순위 지정과 같은 흥미로운 새 기능으로 놀라운 성능 혁명으로 예고되었습니다. 특히 '리소스 번들링을 중지하고 여러 서버에서 리소스 분할을 중지하고 페이지 로드 프로세스를 크게 간소화할 수 있었습니다. 스위치만 누르면 웹사이트가 마법처럼 50% 빨라집니다!'와 같이 너무 큰 기대를 불러모았죠.

5년이 지나고 나서, 우리는 서버푸시가 실질적으로 그렇게 작동하지 않는다는 것과 스트림 및 우선 순위 지정은 종종 잘못 구현된다는 것을 압니다. 그리고 결과적으로 어떤 상황에서는 (감소된) 리소스 번들링 및 샤딩조차도 일부 상황에서 여전히 좋은 방법입니다. 마찬가지로 PreloadHint 힌트와 같이 프로토콜 동작을 조정하는 다른 메커니즘에는 종종 숨겨진 깊이와 버그가 포함되어 있어 올바르게 사용하기 어렵습니다. <u>때문에 나는 이런 잘못된 오보를 막아 HTTP/3에 대한 비현실적인 기대감이 널리 퍼지기 전에 막는 것이 중요하다고 판단</u>했습니다.

이 글에서 나는 **<u>새로운 프로토콜과 특히 그 퍼포먼스적 특징</u>**에 대해 이야기할 것입니다. 그리고 HTTP3의 유망한 새로운 컨셉과 그렇지만 동시에 슬프게도 대부분의 웹 페이지에와 유저에게는 제한된 임팩트만을 줄 것에 대해 이야기하겠습니다. HTTP3는 또한 준비하고 사용하기 까지 꽤 어렵습니다. 때문에 새로운 프로토콜을 이해하기 위해 단단히 준비하세요!

이 시리즈는 **<u>크게 3가지 파트</u>**로 나뉩니다:

### 01. HTTP/3 history and core concepts HTTP/3에 관한 역사와 핵심 컨셉

: 일반적으로 HTTP/3 및 프로토콜을 처음 접하는 사람들을 대상으로 하며 기본 사항들에 대해 설명합니다.

### 02. HTTP/3 Perfomance features: 퍼포먼스적 특징

: 더 깊이 있고 기술적인 파트입니다. 기본 사항을 이미 알고 있는 사람들은 1번을 스킵하고 여기부터 시작해도 좋습니다.

### 03. Practical HTTP/3 deployment options: 실질적 배포 옵션

: HTTP/3를 직접 배포하고 테스트하는 것과 관련된 문제를 설명합니다. 웹 페이지와 리소스도 변경해야 할 수도 있는데, 그렇게 하는 방법과 그렇게 해야 하는 이유에 대해 자세히 설명합니다.

이 시리즈는 프로토콜에 대한 깊은 이해가 필요없는 웹 개발자들을 타겟으로 쓰였습니다. 그러나, 충분한 양의 기술적 디테일과 많은 외부링크들을 포함하고 있으므로 advanced readers들 역시 충분히 배울 것이 있을 겁니다.



## ❓ HTTP/3 도대체 왜 필요한건데?

종종 드는 생각인데, "HTTP2가 나온 2015 이후에 왜이렇게 빨리 HTTP3가 필요해진거지?" 이 질문에 대해서 사실 당신이 새로운 HTTP버전이 굳이 필요하지는 않지만 TCP의 업그레이드가 필요하다는 것을 깨닫기 전까지는 이상하다고 느낄것이다. 

(새로운 HTTP로 보기보단 TCP의 업그레이드 버전이라는 관점에서 보면 HTTP3가 2버전 이후 빠르게 다시 나오는 것을 이해할 수 있다는 의미로 해석됩니다.)

TCP는 HTTP와 같이 다른 프로토콜에 대한 안정성(reliability) 및 순서 전달(in-order delivery)과 같은 중요한 서비스를 제공하는 주요 프로토콜입니다. 이 프로토콜이 사용자 대역폭 사용량을 스마트하고 공정하게 제한하는덕분에 수많은 사람이 인터넷에 동시 접속을해도 사용할 수 있습니다.

프로토콜의 이러한 "계층화(Layering)"는 해당 기능을 쉽게 재사용할 수 있도록 하기 위해 수행됩니다. 상위 계층 프로토콜(예: HTTP)은 하위 계층 프로토콜(예: TLS)이 이미 이를 수행하기 때문에 복잡한 기능(예: 암호화)을 다시 구현할 필요가 없습니다. 또 다른 예로 인터넷의 대부분의 응용 프로그램은 내부적으로 TCP를 사용하여 모든 데이터가 완전히 전송되도록 합니다. 이러한 이유로 TCP는 인터넷에서 가장 널리 사용되고 배포된 프로토콜 중 하나입니다.

![프로토콜레이어](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ef36d1e-d91e-43e0-8732-f3e66ba9ea64/protocol-stack-h2-h3.png)

TCP는 수십 년 동안 웹의 초석이었지만 2000년대 후반에 그 단점(원문 age를 의역함.)을 보여주기 시작했습니다. QUIC라는 이름의 새로운 전송 프로토콜은 TCP와 몇 가지 주요 면에서 충분히 다르기 때문에 그 위에서 직접 HTTP/2를 실행하는 것이 매우 어려울 수 있습니다. 따라서 **HTTP/3 자체는 사람들이 열광하는 대부분의 새로운 기능을 포함하는 새로운 QUIC 프로토콜과 호환되도록 HTTP/2를 비교적 작게 개조한 것**입니다.

QUIC은 인터넷 초창기부터 존재했던 TCP가 실제로 최대 효율성을 염두에 두고 구축되지 않았기 때문에 발생하는 효율성 때문에 그 가치가 있습니다. 예를 들어 TCP는 새 연결을 설정하기 위해 **`핸드셰이크`**가 필요합니다. 이는 클라이언트와 서버가 모두 존재하고 데이터를 교환할 의사와 능력이 있는지 확인하기 위해 수행됩니다. 그러나 연결에서 다른 작업을 수행하기 전(preflight)에 완료하려면 전체 네트워크 왕복이 필요합니다. 클라이언트와 서버가 지리적으로 멀리 떨어져 있는 경우 각 RTT(왕복 시간)에 100밀리초 이상이 소요되어 눈에 띄는 지연이 발생할 수 있습니다.

두 번째 예로, TCP는 실제로 동시에 여러 파일을 전송하는 데 사용하더라도 전송하는 모든 데이터를 단일 "파일" 또는 바이트 스트림으로 봅니다(예: 인터넷 웹페이지에서 많은 리소스를 다운로드 받는 것). 실제로 이것은 단일 파일의 데이터를 포함하는 TCP 패킷이 손실되면 해당 패킷이 복구될 때까지 다른 모든 파일도 지연됨을 의미합니다. 이를 **<u>헤드 오브 라인(HoL) 차단</u>**이라고 합니다. 이러한 비효율성은 실제로 관리할 수 있지만(그렇지 않으면 TCP를 30년 이상 사용하지 않았을 것입니다) HTTP와 같은 상위 수준 프로토콜에 눈에 띄는 방식으로 영향을 미칩니다.(앞에서 하나만 손상되더라도 뒤에 모두가 지연되는 상태. 정보처리기사에 자주 출제되는 내용이 나오네요 ;;)

시간이 지남에 따라 이러한 문제 중 일부를 개선하고 새로운 성능 기능을 도입하기 위해 TCP를 발전 및 업그레이드하려고 했습니다. 예를 들어 TCP Fast Open은 상위 계층 프로토콜이 처음부터 데이터를 보낼 수 있도록 하여 핸드셰이크 오버헤드를 제거합니다. 또 다른 노력은 MultiPath TCP라고 합니다. 여기서 아이디어는 휴대 전화에 일반적으로 Wi-Fi와 (4G) 셀룰러 연결이 모두 있다는 것입니다. 그러므로 추가 처리량과 견고성을 위해 두 가지를 동시에 사용하지 않을 이유가 없겠다는 생각이 당연히 들겠죠?

이러한 TCP 확장을 구현하는 것은 그리 어렵지 않습니다. 그러나 <u>실제로 인터넷 규모로 배포하는 것은 매우 어렵습니다</u>. TCP는 널리 사용되기 때문에 연결된 거의 모든 장치에는 자체 프로토콜 구현이 탑재되어 있습니다. 이러한 구현이 너무 오래되었거나 업데이트가 부족하거나 버그가 있는 경우 확장을 실제로 사용할 수 없습니다. 달리 말하면, 모든 구현은 확장이 유용하려면 확장에 대해 알아야 합니다. 최종 사용자 장치(예: 컴퓨터 또는 웹 서버)에 대해서만 이야기하는 경우 수동으로 비교적 쉽게 업데이트할 수 있기 때문에 이는 큰 문제가 되지 않습니다. 그러나 자체 TCP 코드도 탑재된 클라이언트와 서버 사이에 다른 많은 장치가 있습니다(예: 방화벽, 로드 밸런서, 라우터, 캐싱 서버, 프록시 등). <u>이러한 미들박스는 업데이트하기가 더 어렵고 때로는 더 엄격합니다</u>. 예를 들어 장치가 방화벽인 경우 (알 수 없는) 확장을 포함하는 모든 트래픽을 차단하도록 구성될 수 있습니다. 실제로, 엄청난 수의 활성 미들박스가 새로운 확장에 대해 더 이상 유지되지 않는 TCP에 대한 특정 가정을 하는 것으로 나타났습니다. <u>결과적으로 충분한 (미들박스) TCP 구현이 실제로 대규모로 확장을 사용하도록 업데이트되기까지는 몇 년에서 10년 이상이 걸릴 수 있습니다. TCP를 진화시키는 것은 사실상 불가능해졌다고 말할 수 있습니다.</u>

결과적으로 이러한 문제를 해결하려면 직접적인 업그레이드가 아니라 TCP에 대한 대체 프로토콜이 필요하다는 것이 분명해졌습니다. 그러나 TCP 기능과 다양한 구현의 복잡성으로 인해 처음부터 새롭고 더 나은 것을 만드는 것은 기념비적인 일이 될 것입니다. 그래서 2010년대 초반에 이 작업을 연기하기로 결정했습니다. 결국 TCP뿐만 아니라 HTTP/1.1에도 문제가 있었습니다. 우리는 작업을 분할하고 먼저 HTTP/1.1을 "수정"하여 현재 HTTP/2가 되도록 선택했습니다. 이 작업이 완료되면 현재 QUIC인 TCP를 대체하는 작업을 시작할 수 있습니다. 원래 QUIC 위에서 HTTP/2를 직접 실행할 수 있기를 희망했지만 주로 기능 중복으로 인해 실제로는 구현이 너무 비효율적이었습니다. 대신 <u>HTTP/2는 QUIC와 호환되도록 몇 가지 주요 영역에서 조정</u>되었습니다. 이 조정된 버전은 주로 마케팅 이유와 명확성을 위해 HTTP/3(QUIC 대신 HTTP/2)으로 명명되었습니다. 따라서 <u>HTTP/1.1과 HTTP/2의 차이점은 HTTP/2와 HTTP/3의 차이점보다 훨씬 더 중요합니다.</u>



## :bulb: What Is QUIC?

당신은 아마 이게 왜 중요한지 궁금할 것입니다. 이러한 기능이 HTTP/3 에 있는지 QUIC에 있는지 그런걸 누가 신경 쓰나요? QUIC은 TCP와 마찬가지로 HTTP 및 웹 페이지 로딩 외에도 많은 사용 사례에 사용될 수 있고 앞으로도 사용될 일반 전송 프로토콜이기 때문에 이것이 중요하다고 생각합니다. 예를 들어 DNS, SSH, SMB, RTP 등은 모두 QUIC를 통해 실행할 수 있습니다. 따라서 내가 읽은 HTTP/3에 대한 대부분의 오해가 여기에 있기 때문에 QUIC에 대해 좀 더 자세히 살펴보겠습니다.

아마 QUIC가 *UDP(User Datagram Protocol)*라는 또 다른 프로토콜 위에서 실행된다는 것을 들어보셨을 것입니다. 이것은 사실이지만 많은 사람들이 주장하는 성능 이유는 아닙니다. 이상적으로 QUIC는 위에서 공유한 이미지에 표시된 프로토콜 스택의 IP 위에서 직접 실행되는 완전히 독립적인 새로운 전송 프로토콜이었을 것입니다. 그러나 그렇게 하면 <u>TCP를 발전시키려고 할 때 직면했던 것과 동일한 문제가 발생했을 것</u>(미들웨어 problems)입니다. QUIC를 인식하고 허용하려면 인터넷의 모든 장치를 먼저 업데이트해야 합니다. 운이 좋게도 **<u>인터넷에서 광범위하게 지원되는 다른 하나의 전송 계층 프로토콜인 UDP 위에 QUIC를 구축</u>**할 수 있습니다.

많은 출처에서 HTTP/3가 성능 때문에 UDP 위에 구축되었다고 주장합니다. HTTP/3는 UDP와 마찬가지로 연결을 설정하지 않고 패킷 재전송을 기다리지 않기 때문에 더 빠르다고 합니다. 하지만 이러한 주장은 잘못된 것입니다. 위에서 말했듯이 **<u>UDP는 QUIC에서 사용</u>**되며, HTTP/3은 주로 인터넷의 (거의) 모든 장치에 이미 알려져 있고 구현되기 때문에 배포가 더 쉬워지기를 희망하기 때문입니다. UDP 위에 얹어진 QUIC은 기본적으로 TCP의 강력하고 대중적인(그러나 다소 느린) 거의 모든 기능을 다시 구현합니다. **QUIC는 수신된 패킷과 재전송에 대한 승인을 사용하여 손실된 패킷이 여전히 도착하도록 하는 절대적으로 신뢰**할 수 있습니다. QUIC는 여전히 연결을 설정하고 **<u>매우 복잡한 핸드셰이크를 사용</u>**합니다. 

마지막으로 QUIC는 발신자가 네트워크나 수신자에 과부하를 주지 않도록 하는, 소위 흐름 제어 및 혼잡 제어 메커니즘을 사용하지만, 이로 인해 원시 UDP로 할 수 있는 것보다 TCP를 느리게 합니다. 핵심은 QUIC이 이러한 기능을 TCP보다 더 똑똑하고 더 성능이 좋은 방식으로 구현한다는 것입니다. 수십 년의 배포 경험과 TCP의 모범 사례를 몇 가지 핵심 새 기능과 결합합니다. 이 기사의 뒷부분에서 이러한 기능에 대해 더 자세히 설명합니다.



## The Big Changes

그렇다면 QUIC은 TCP보다 정확히 어떤 점이 얼마나 향상된다는 겁니까? 뭐가 그렇게 다른건가요? 시리즈의 다음 부분에서 자세히 논의할 QUIC(0-RTT 데이터, 연결 마이그레이션, 패킷 손실 및 느린 네트워크에 대한 복원력 향상)에는 몇 가지 새로운 구체적인 기능과 기회가 있습니다. 그러나 이러한 모든 새로운 사항은 기본적으로 4가지 주요 변경 사항으로 요약됩니다.

1. QUIC deeply integrates with TLS. QUIC는 TLS와 긴밀하게 통합됩니다.
2. QUIC supports multiple *independent* byte streams. QUIC는 여러 개의 독립적인 바이트 스트림을 지원합니다.
3. QUIC uses connection IDs. QUIC는 연결 ID를 사용합니다.
4. QUIC uses frames. QUIC는 프레임을 사용합니다.

좀 더 자세히 알아보자.

### TLS 없이 QUIC도 없다

언급했듯이 TLS는 인터넷을 통해 전송되는 데이터의 보안 및 암호화를 담당합니다. HTTPS를 사용하는 경우 일반 텍스트 HTTP 데이터는 TCP로 전송되기 전에 먼저 TLS로 암호화됩니다.

![TSL, TCP and QUIC](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f2240cb4-eb62-4054-ad19-0e72190e0a4f/connection-setup.png)

인터넷 초창기 시절에는 트래픽을 암호화처리 비용이 많이 들었습니다. 또한 모든 유스 케이스에 반드시 필요한 것으로 여겨지지 않았습니다. 역사적으로 TLS는 TCP 위에서 선택적으로 사용할 수 있는 완전히 별도의 프로토콜이었습니다. 이것이 HTTP(TLS 없음)와 HTTPS(TLS 포함)를 구분하는 이유입니다. 시간이 지나면서 인터넷 보안에 대한 우리의 태도는 변화했습니다. "보안이 된 것(HTTPS)가 기본이다"라고 말이죠. 따라서 HTTP/2는 이론적으로 TSL없이 TCP를 통해 직접 실행할 수 있지만 실제로 이 모드를 지원하는 웹 브라우저는 없습니다. 어떤 면에서 브라우저 제조업체는 성능을 희생하면서까지 보안상의 안전을 위해 일부러 절충안을 택했습니다.

always-on TSL로의 분명한 진보 덕분에 QUIC의 설계자(designer)가 이 트렌드를 한 단계 더 발전시키기로 결정한 것은 어찌보면 당연한 것일지도 모릅니다. 단순히 HTTP/3에 대한 일반 텍스트 모드를 정의하지 않는 대신 QUIC 자체에 암호화를 깊숙이 뿌리기로 선택했습니다. QUIC의 첫 번째 Google 전용 버전은 이를 위해 맞춤 설정을 사용했지만 표준화된 QUIC는 기존 TLS 1.3 자체를 직접 사용합니다. 이를 위해 이전 이미지에서 볼 수 있듯이 <u>프로토콜 스택의 프로토콜 간의 일반적인 명확한 분리를 깨뜨립니다</u>. TLS 1.3은 여전히 TCP 위에서 독립적으로 실행할 수 있지만 QUIC는 대신 TLS 1.3을 캡슐화합니다. <u>달리 말하면 TLS 없이 QUIC를 사용할 방법이 없습니다. QUIC(및 확장하여 HTTP/3)는 항상 완전히 암호화됩니다</u>. 또한 QUIC는 거의 모든 패킷 헤더 필드도 암호화합니다. 전송 계층 정보(예: TCP에 대해 암호화되지 않은 패킷 번호)는 더 이상 QUIC의 중개자가 읽을 수 없습니다(일부 패킷 헤더 플래그도 암호화됨).

![*Unlike TCP + TLS, QUIC also encrypts its transport-layer meta data in the packet header and payload.*](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fbf86b42-8f20-4b27-aea5-f1fc164b2683/tcp-vs-quic-packetization.png)

이 모든 것을 위해 QUIC는 먼저 수학적 암호화 매개변수를 설정하기 위해 <u>TCP를 사용하는 것처럼 TLS 1.3 핸드셰이크를 사용</u>합니다. 그러나 이후에는 QUIC가 패킷 자체를 인수하여 암호화하는 반면 TLS-over-TCP에서는 TLS가 자체 암호화를 수행합니다. 이 겉보기에 작은 차이는 더 낮은 프로토콜 계층에서 시행되는 상시 작동 암호화에 대한 근본적인 개념적 변화를 나타냅니다.

이 방법은 QUIC에 **<u>몇 가지 이득을 제공</u>**합니다.

###  이점1. QUIC is more secure for its users. 유저는 attacker와 도청자로부터 더욱 안전합니다.

일반 텍스트 QUIC를 실행할 수 있는 방법이 없으므로 공격자와 도청자가 들을 수 있는 옵션도 적습니다.

### 이점2. QUIC’s connection set-up is faster. 연결이 더 빠릅니다.

TLS-over-TCP 방식에서는 두 프로토콜 모두에서 분리된 핸드셰이크가 필요했다면 QUIC은 전송과 암호화 핸드셰이크를 하나로 결합하여 왕복 시 코스트를 절약할 수 있습니다.

### 이점3. QUIC can evolve more easily. 새롭게 진화하기 쉽다.

완전히 암호화 되어있기 때문에 네트워크의 미들박스는 더 이상 TCP에서와 같이 내부 작동을 관찰하고 해석할 수 없습니다. 결과적으로 업데이트에 실패했기 때문에 최신 버전의 QUIC에서 더 이상 중단될 수 없습니다. 향후 QUIC에 새로운 기능을 추가하려면 모든 미들박스 대신 최종 장치만 업데이트하면 됩니다.

하지만 동시에 **<u>잠재적 DOWNSIDE도 예상</u>**됩니다.

### 단점1. Many networks will hesitate to allow QUIC. 다수의 네트워크에서 QUIC도입을 꺼릴 것이다.

원치 않는 트래픽을 감지하는 것이 더 어려워지기 때문에 <u>회사는 방화벽에서 이를 차단하려고 할 수 있습니다</u>. 평균 지연 및 패킷 손실 비율과 같은 메트릭을 더 이상 쉽게 사용할 수 없어 <u>문제를 감지하고 진단하기가 더 어려워지기 때문에 ISP 및 중간 네트워크가 이를 차단할 수 있습니다.</u>

### 단점2. QUIC has a higher encryption overhead. 암호화 오버헤드가 더 크다.

QUIC는 TLS로 각 개별 패킷을 암호화하는 반면 TLS-over-TCP는 동시에 여러 패킷을 암호화할 수 있습니다.

### 단점 3. QUIC makes the web more centralized. QUIC이 웹을 더 중앙집중화 시킬 것이다.

첫째로 내가 자주 접한 불만은 "QUIC은 다른 사람과 데이터를 공유하지 않고 <u>데이터에 대한 전체 액세스 권한을 부여</u>하기 때문에 Google에서 푸시하고 있습니다."와 같은 것입니다. QUIC는 TLS-over-TCP(QUIC는 현상을 유지한다)보다 외부 관찰자로부터 더 많은(또는 적게!) 사용자 수준 정보(예: 방문 중인 URL)를 숨기지 않습니다.

둘째로, Google이 QUIC 프로젝트를 시작했지만 오늘 우리가 이야기하는 최종 프로토콜은 IETF(Internet Engineering Task Force)의 훨씬 더 광범위한 팀에서 설계했습니다. IETF의 QUIC는 기술적으로 Google의 QUIC와 매우 다릅니다. 그러나 IETF의 사람들은 대부분 Google 및 Facebook과 같은 대기업과 Cloudflare 및 Fastly와 같은 CDN에서 온 사람들입니다. QUIC의 복잡성으로 인해, 예를 들어 실제로 HTTP/3을 올바르고 성능적으로 배포하는 데 필요한 노하우를 가진 회사는 주로 앞서 언급한 회사들일 것입니다. 이것은 아마도 이러한 회사들로의 더 많은 <u>중앙 집중화</u>로 이어질 것이 우려되는 사항입니다.



---

여기까지도 내용이 많은데 이게 절반 정도입니다... 

나머지 내용도 곧 번역해서 업로드하겠습니다..!







