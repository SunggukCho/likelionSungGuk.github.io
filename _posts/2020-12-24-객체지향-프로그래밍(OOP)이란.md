---
title: 그놈의 객체지향 프로그래밍(OOP)이란?
date: 2020-12-24 22:18:01
permalink: /:short_year-:month-:day/:title
categories:
- 면접

tags: [java, OOP, 객체지향, 객체지향 프로그래밍, 면접, 추상화, 오버라이딩]
---

# 그놈의 OOP(Object Oriented Programming)

> 객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, **프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법**입니다.

반대되는 개념은 `절차지향 프로그래밍`인데 그 정의는,  
`입력을 받아 명시된 순서대로 처리한 다음, 그 결과를 내는 프로그래밍 방식`입니다.

***요약**: 

- 프로그래밍을 설계하는 개념이자 방법론 중 하나
- 데이터를 추상화
  - 상태
  - 행위 등을 가지고 있음
- 각각의 객체들간에는 관계성이 있음
  - 집합
  - 사용
  - 상속



## 특징

`객체 지향`은 특정 언어가 아니라 하나의 `개념`으로 이해되어야 합니다. 
하나의 프로그래밍 방법론이지 `특정 언어(예를 들면 Java) == 객체 지향` 이라는 공식도 적절하지 않습니다. '절차지향 언어'라는 말이 어색한 것처럼 말이죠.
큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 해결법을 도입한 것입니다. 
객체를 한번 독립성/신뢰성이 높게 만들어 놓기만 하면 그 이후엔 그 객체를 수정 없이 재사용할 수 있으므로 개발 기간과 비용이 큰 폭으로 줄어들게 됩니다.
![image-20201225144753576](/assets/img/image-20201225144753576.png)

### 1. 클래스 Class

> 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 **속성**(attribute)과 **행위**(behavior)를 변수와 메서드로 정의한 것



#### *클래스/ 객체/ 인스턴스 차이

1. **클래스(Class)**
   개념: 객체를 만들어 내기 위한 설계도 혹은 틀, 연관되어 있는 변수와 메서드의 집합

2. **객체(Object)**
   개념: 소프트웨어 세계에 구현할 대상, 클래스에 선언된 모양 그대로 생성된 실체

   - 특징
     ‘클래스의 인스턴스(instance)’ 라고도 부른다.
     객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
     oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.

3. **인스턴스(Instance)**

   - 개념
     설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
     즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.
     실체화된 인스턴스는 메모리에 할당된다.

   - 특징
     인스턴스는 객체에 포함된다고 볼 수 있다.
     oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 ‘인스턴스’라고 부른다.
     추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.
     ‘~의 인스턴스’ 의 형태로 사용된다.
     객체는 클래스의 인스턴스다.
     객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
     실행 프로세스는 프로그램의 인스턴스다.
     즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
     인스턴스는 어떤 원본(추상적인 개념)으로부터 ‘생성된 복제본’을 의미한다.


### 2. 추상화 Abstraction

> 객체에서 공통된 속성과 행위를 추출하는 것을 의미한다. 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것

예를 들어, 게임 프로그램을 개발하며 캐릭터가 소지하는 다양한 무기들이 있다. 
칼, 삽, 곡갱이, 총, 활 등 여러가지 무기들이 존재하는데 이들의 기능적인 내용은 다르지만 `공통적인 속성과 행위(예를 들면 공격 기능)`를 개념으로 `무기`라는 클래스를 정의할 수 있다. 
이렇게 추상화는 다른 객체들과 구분되는 핵심적인 부분에 집중하여, 복잡도를 관리할 수 있게 해준다.

*abstract 클래스/abstract 메서드와는 다른 개념이다

### 3. 상속 Inheritance

> 상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것

##### 상속은 왜 하는 것일까?

비슷한 기능이 필요한 경우 우리는 상속을 받아 처리할 수 있다. 
하지만 `절차지향 프로그래밍`에서도 라이브러리를 import해서 이렇게 재사용할 수 있는데도 상속을 하는 이유는 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속 받은 그 기능만을 수정해서 다시 정의 후 사용하면 된다. 이렇게 자식 클래스에서 부모로부터 상속받은 메소드를 재정의 하는 것을 `오버라이딩(overriding)`이라고 한다. 또한 라이브러리는 버전에 따라 조금씩 변화가 있는데 이 때문에 잘못 변경하면 잘 되던 기능들이 갑자기 이유도 없이 안되는 예상치 못한 오류를 마주칠 수도 있다.

### 4. 캡슐화 Encapsulation

> 객체 지향 프로그래밍에서 연관성이 있는 `기능과 특성의 모음(메소드, 변수)`을 "클래스"라는 "캡슐"에 분류해서 넣는 것
> 실제로 구현되는 부분을 외부에 드러나지 않도록  캡슐로 감싸 이용방법만을 알려주는 것

객체가 맡은 역할을 수행하기 위한 하나의 목적을 갖고 있는 것들을 하나의 클래스에 몰아 넣고 외부에서 접근할 수 있도록 감싸줍니다.
또한 데이터를 절대로 외부에서 직접 접근을 하면 안되고 `오로지 함수를 통해서만 접근`해야하는데 이를 가능하게 해주는 것이 바로 캡슐화입니다.

### 캡슐화는 왜 하는 것일까?

프로그램 내부 코드와 변수 등이 여기저기 분산되어 있는 경우 이것들을 재사용하기 어렵기 때문에 여러 중복이 발생할 수 있습니다.
하지만 캡슐화를 통해 한 곳에 몰아넣게 되면 중복을 줄일 수 있고 재사용성을 높일 수 있다.

***정보은닉**(hiding): 접근 제어 지시자[public, private, protected]를 통해 외부로부터의 접근을 제한하여 객체내에서만 접근이 가능하도록 해주는 것

```java
public class Addition {
    
}
class ABC{  
   private double num = 100;
   private int square(int a){
	return a*a;
   }
}  
public class Addition {

   protected int addTwoNumbers(int a, int b){
	return a+b;
   }
}
```

![image-20201225132450211](/assets/img/image-20201225132450211.png)

### 5. 다형성 Polymorphism

>  하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것

* **오버라이딩(overriding)**: 자식 클래스에서 부모로부터 상속받은 메소드를 재정의 하는 것
* **오버로딩(overloading)**: 같은 이름의 함수를 여러개 정의하고 매개변수(args)의 타입/개수 등을 다르게하여 매개변수에 따라 다르게 호출하는 방법.



---

## 장점

### 1. 코드 재사용 용이

객체지향 프로그래밍은 **대형 프로젝트에 적합**합니다

- 독립적인 객체 단위로 모듈화 할 수 있고 상속이 가능하다는 특징때문에*여러 개발자와 협업해 규모가 큰 프로젝트를 진행할 수 있음
- 여러 사람, 여러 회사에서 업무분담이 쉬움

### 2. 유지보수 쉬움

독립성 덕분에 유지 보수가 쉽고 간결한 편입니다. (절차지향 프로그래밍에 비해)



## 단점

#### 1. 처리 속도가 상대적으로 느릴 수 있음

#### 2. 객체가 많으면 용량이 커질 수 있음

#### 3. 설계 시 시간과 노력이 많이 든다



---

## 객체지향 프로그래밍 5대 원리 SOLID

> 아래 제시되는 다섯가지의 입증된 원리들을 따른다면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨어를 만들 수 있습니다.

### S: Single Responsibility Principle 단일 책임의 원칙

> *THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE.*
> 클래스를 변경해야 하는 이유는 반드시 한 가지여야 한다.

작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임(변화의 축: axis of change)을 수행하는 데 집중되어 있어야 한다는 원칙입니다.
클래스는 자신의 이름이 나타내는 일을 해야 합니다. 올바른 클래스 이름은 해당 클래스의 책임을 나타낼 수 있는 가장 좋은 방법입니다. 각 클래스는 하나의 개념을 나타내어야 합니다. 사용되지 않는 속성이 결정적 증거입니다. 무조건 책임을 분리한다고 SRP가 적용되는 건 아닙니다. 각 개체 간의 응집력이 있다면 병합이 순 작용의 수단이 되고 결합력이 있다면 분리가 순 작용의 수단이 됩니다.
다음은 SRP 적용 전 Class의 모습과 SRP적용 후 Class의 모습입니다.

![SRP적용 전](/assets/img/image-20201225154753398.png)

![SRP 적용 후](/assets/img/srp2_after_src-e1400596694467.png)

### O: Open Close Principle 개방폐쇄의 원칙

> *YOU SHOULD BE ABLE TO EXTEND A CLASSES BEHAVIOR, WITHOUT MODIFYING IT.*
> 클래스 동작을 수정하지 않고 확장 할 수 있어야합니다.

소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리입니다.
요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻입니다. OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이라고 설명하고 있습니다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리라 할 수 있습니다.
아래 그림은 OCP적용 전 Guitar, Violin의 클래스를 `현악기StringInstrument`라는 상위 클래스를 만들어 해결하는 OCP 적용 사례입니다.

![OCP 적용전](/assets/img/ocp_before-e1400596091419.png)

![OCP적용후](/assets/img/ocp_after-e1400596262977.png)

### L: The Liskov Substitution Principle 리스코브 치환의 원칙

> *FUNCTIONS THAT USE POINTERS OR REFERENCES TO BASE CLASSES MUST BE ABLE TO USE OBJECTS OF DERIVED CLASSES WITHOUT KNOWING IT.*
> 기본 클래스에 대한 포인터 또는 참조를 사용하는 기능은 이를 알지 못해도 파생 클래스의 개체를 사용할 수 있어야 합니다.

서브 타입은 언제나 기반 타입과 호환될 수 있어야 한다는 원칙입니다. 
달리 말하면 서브 타입은 기반 타입이 약속한 규약(public 인터페이스, 물론 메소드가 던지는 예외까지 포함됩니다.)을 지켜야 합니다.

1. 만약 두 개체가 똑 같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둡니다.
2. 똑같은 연산을 제공하지만, 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현 합니다. (인터페이스 상속)
3. 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만듭니다.

```java
void f(){  
    LinkedList list = new LinkedList();
    // …
    modify(list);
}

void modify(LinkedList list){  
    list.add(…);
    doSomethingWith(list);
}
```

List만 사용할 것이라면 이 코드도 문제는 없습니다. 하지만 만약 속도 개선을 위해 HashSet을 사용해야 하는 경우가 발생한다면 LinkedList를 다시 HashSet으로 어떻게 바꿀 수 있을까요? LinkedList와 HashSet은 모두 Collection인터페이스를 상속하고 있으므로 다음과 같이 작성하는 것이 바람직합니다.

```java
void f(){  
     Collection collection = new HashSet();
     //…
     modify(list);
}

Void modify(Collection collection){  
     collection.add(…);
     doSomethingWith(collection);
}
```

이제 컬렉션 생성 부분만 고치면 마음대로 어떤 컬렉션 구현 클래스든 사용할 수 있습니다. 
이 프로그램에서 LSP와 OCP 모두를 찾아볼 수 있는데 우선 컬렉션 프레임워크가 LSP를 준수하지 않았다면 Collection 인터페이스를 통해 수행하는 범용 작업이 제대로 수행될 수 없습니다. 하지만 모두 LSP를 준수하기 때문에 이들을 제외한 모든 Collection 연산에서는 앞의 modify() 메소드가 잘 동작하게 됩니다. 
그리고 이를 통해 modify()는 변화에 닫혀 있으면서, 컬렉션의 변경과 확장에는 열려 있는 구조(OCP)가 됩니다. 
물론 Collection이 지원하지 않는 연산을 사용한다면 한 단계 계층 구조를 내려가야 합니다. 
그렇다 하더라도 ArrayList, LinkedList, Vector 대신 이들이 구현하고 있는 List를 사용하는 것이 현명한 방법입니다.

### I: Interface Segregation Principle 인터페이스 분리의 원칙

> *CLIENTS SHOULD NOT BE FORCED TO DEPEND UPON INTERFACES THAT THEY DO NOT USE.*
> 클라이언트는 사용하지 않는 인터페이스에 의존해서는 안됩니다.

ISP원리는 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리입니다. 즉 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 합니다. 
ISP를 `하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다`라고 정의할 수 도 있습니다. 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면, 이들을 따로 인터페이스로 빼내어 클라이언트가 기대하는 메시지만을 전달할 수 있도록 합니다. SRP가 클래스의 단일책임을 강조한다면 `ISP는 인터페이스의 단일책임을 강조`합니다.

### D: Dependency Inversion Principle 의존성역전의 원칙

> A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.
> 높은 수준의 모듈은 낮은 수준의 모듈에 의존해서는 안됩니다. 둘 다 추상에 의존해야합니다.
>
> B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS.
> 추상화는 세부 사항에 의존해서는 안됩니다. 세부 사항은 추상화에 따라 달라져야합니다.

의존 관계의 역전 Dependency Inversion 이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의역전입니다. `실제 사용 관계는 바뀌지 않으며`, 추상을 매개로 메시지를 주고 받음으로써 `관계를 최대한 느슨하게 만드는 원칙`입니다.

![](/assets/img/jdchoi_20140305_layer.png)

---

## 객체간의 관계

> 객체 지향 프로그램에서는 객체는 다른 객체와 다른 객체와 관계를 맺고 있다.

#### 집합 관계 : 완성품과 부품의 관계

#### 사용 관계 : 객체가 다른 객체를 사용하는 관계

#### 상속 관계 : 종류 객체와 국체적인 사물 객체 관계 

![관계](/assets/img/image-20201225144705459.png)

---

references

[객체 지향 프로그래밍이 뭔가요? (꼬리에 꼬리를 무는 질문 1순위, 그놈의 OOP)](https://jeong-pro.tistory.com/95)

[객체지향 개발 5대 원리: SOLID](http://www.nextree.co.kr/p6960/)

[[JAVA] 객체지향 프로그래밍이란?](https://gangnam-americano.tistory.com/15)

[What is Object Oriented Programming? OOP Explained in Depth](https://www.educative.io/blog/object-oriented-programming)