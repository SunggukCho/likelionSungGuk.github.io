---
title: 자바스크립트 프로와 나의 차이는...?
date: 2021-08-05 20:18:01
permalink: /:short_year-:month-:day/:title
categories: [web/network, frontend, 면접]
tags: [javascript, 자바스크립트]
---


# 자바스크립트를 프로처럼 세련되게 쓰는 법
유튜브 드림코딩 엘리 영상을 보다 좋은 내용이 있어 정리하여 공유합니다.

[TOC]


## 조건문에서 조건이 두 개라면 과감하게 삼항연산자 사용

```javascript
// not good...
function (score) {
	if (score > 5) {
        result = 'thumbup'
    } else if {
        result = 'thumbdown'
    }
    return result;
}


// Better !!
function (score) {
	return score > 5 ? 'thumbup': 'thumbdown';
}

```



## Nullish Coalescing operator를 사용해보자

```javascript
// not good...
function printMessage(text) {
    let message = text;
    if (text == null || text == undefined) {
        message = 'Nothing to display';
    }
    console.log(message);
}


// Better !
function printMessage(text) {
    const message = text ?? 'Nothing to Display';
    console.log(message);
}

```

- 위 코드와 아래 코드는 동일하게 동작한다.
- text가 null or undefined이면 'Nothing to Display'를 할당하는 코드인데, 위 코드는 message를 일단 받고, null/undefined check 후 message에 할당한다.
- 하지만 아래 코드 같은 경우 text를 바로 체크하여 message에 선언과 할당이 동시에 가능하기 때문에 message를 const로 선언할 수 있고 가독성도 좋다.



### Logical Operator OR<||>와 Nullish Coalescing Operator의 차이

**OR**

- Left: falsy 하면 오른쪽이 true

**Nullish Coalescing (??)**

- Left: null, undefiend 이면 오른쪽이 true



null & undefined는 모두 falsy에 포함된다. 이외에도 0, -0, NaN, 빈문자열('') 등도 모두 falsy에 포함된다. 다시 말해 falsy가 좀 더 광범위한 범위를 포괄한다.

**따라서 두 연산자가 비슷해보이지만 조금 다른 결과를 초래할 수 있으므로 차이를 정확하게 이해하고 사용하는 것이 중요하다!**



## Object Destructuring으로 변수 할당/선언하기

```javascript
// Not good...
function displayPerson(person) {
    const name = person.name;
    const age = person.age;
    displayAvatar(name);
    displayName(name);
    displayProfile(name, age);
}

// Better !!
function displayPerson(person) {
    const { name, age } = person;
    displayAvatar(name);
    displayName(name);
    displayProfile(name, age);
}
```



## Object 결합은 Object.assign 혹은 Spread Syntax를 사용하자

```javascript
// Not Good...
const item = {
    ...
}
const detail = {
	...    
}

const newObject = {
    type: item.type,
    size: item.size,
    price: detail.price,
    made: detail.made,
    gender: detail.gender
}


// Better !!
 // 1. Object.assign
const newObj = Object.assign(item, detail);

 // 2. Spread Syntax
const newObj2 = {...item, ...detail};
```



## Optional Chaining

```javascript
// Not good...
function displayJobTitle(person) {
    if (person.job && person.job.title) {
        console.log(person.job.title);
    }
}

// Better !!
function displayJobTitle(person) {
 	if (person.job?.title){
        console.log(person.job.title)
	}   
}

// Optional Chaining + Nullish Coalescing
function displayJobTitle(person) {
 	const title = person.job?.title ?? 'No Job yet'
	console.log(title)
}
```

- 이 내용은 오늘 낮에도 내가 Not Good으로 코드를 짰던 내용이었어서 더욱 공감하며 들었던 내용입니다.
- person에 job이 있을 수도 있고, 없을 수도 있는 경우 일단 person.job을 먼저 체킹하고 person.job.title을 체킹하는 코드입니다. 이게 일반적으로 정말 많이 사용됩니다. 특히 typescript와 함께 쓰이면 job이나 job.title이 null or undefined 될 수 있어서 이 내용에 타입을 미리 설정해주는 것이 생각보다 고역입니다.
- ?를 통해서 person.job이 있는지 없는지를 동시에 처리할 수 있게 됩니다.

- 가장 아래에는 optional chaining과 Nullsih Coalescing을 한 번에 사용하는 경우입니다. person.job이 있는지 체크하고 person.job.title이 있는지까지 한 번에 체크해서 없는 경우에 'No job yet'을 출력할 수 있습니다.



## Array 관련 연산은 map, filter, reduce를 적극 활용하자!

Javascript의 배열 methods (map, filter, reduce)들은 정말 강력합니다. 

전통적인 for loop보다는 이 친구들을 적극적으로 활용하면 언어의 특징을 잘 이해하고 사용하는 프로다운 면모를 보여줄 수 있습니다.

```javascript
// Not good...
const arr = [1,2,3,4,5]
	// 짝수 구하기
const even = [];
for (let i = 0 ; i <items.length; i++) {
    if (items[i] % 2 === 0) {
        even.push(items[i]);
    }
}

// Better !!
const even = arr.filter(item => item % 2 == 0)

```

- 코딩테스트를 주로 python을 기반으로 준비했었는데 프론트엔드 개발자로 취업을 하다보면 Javascript 단일 언어로 코테를 많이 제공합니다. 이때 초반에는 저도 위와 같은 코드를 자연스럽게 썼었는데.... 하.... 이제와서 돌이켜 생각해보니까 이게 문제가 풀린다고 해도 제가 면접관이라면 위와 같이 javascript를 쓰는 개발자와 같이 일하는게 꺼려질 것 같다는 생각이 드네요 ㅎㅎ



---

Ref.

[드림코딩엘리](https://www.youtube.com/watch?v=BUAhpB3FmS4&t=2s)
