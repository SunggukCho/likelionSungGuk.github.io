---
title: 처음부터 끝까지 상세히 알아보자! - HTTP/3에 대한 A TO Z (2)
date: 2021-08-22 23:18:01
permalink: /:short_year-:month-:day/:title
categories: [frontend, web/network]
tags: [HTTP3, 프로토콜]
---

# (번역) HTTP/3 FROM A To Z: Core Concepts (Part 1) by Robin Marx

원문링크: [https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)

이 글은 *Robin Marx*의 [**HTTP/3 FROM A To Z: Core Concepts (Part1)**](https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/)을 두 포스트로 나눠 번역하였습니다.

앞부분 첫 번째 포스트는 [처음부터 끝까지 상세히 알아보자! - HTTP/3에 대한 A TO Z (1)](https://likelionsungguk.github.io/21-08-14/%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-%EB%81%9D%EA%B9%8C%EC%A7%80-%EC%83%81%EC%84%B8%ED%9E%88-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90!-HTTP3%EC%97%90-%EB%8C%80%ED%95%9C-A-TO-Z)에서 보실 수 있습니다.



*2부 START!*



## :bulb: QUIC은 다중 바이트 스트림을 구분할 수 있습니다

HTTP/1.1의 리소스 로드 프로세스는 매우 간단합니다. 각 파일은 자체 TCP가 연결되고 파일 전체가 다운로드 됩니다. 예를 들어, A, B, C 파일이 있다면 우리는 3개의 TCP연결이 있습니다 (HTTP/1.1에서). 실제로 브라우저는 사용할 수 있는 동시 연결 수(병렬로 다운로드할 수 있는 파일 수)에 대한 제한을 부과합니다 (일반적으로 페이지 로드당 약 6~30개). 그런 다음 이전 파일이 완전히 전송되면 연결을 다시 사용하여 새 파일을 다운로드합니다. 이러한 제한은 결국 30개 이상의 리소스를 로드하는 최신 페이지의 웹 성능을 방해하기 시작했습니다.

이러한 상황을 개선하는 것이 HTTP/2의 주요 목표 중 하나였습니다. 프로토콜은 더 이상 각각의 모든 파일에 대해 새 TCP 연결을 열지 않고 단일 TCP 연결을 통해 다른 리소스를 다운로드하여 이를 수행합니다. 이것은 "멀티플렉싱"이라는 여러개 바이트 스트림에 의해 수행됩니다. 그것은 우리가 그것을 전송할 때 다른 파일의 데이터를 혼합하는 멋진 방법을 뜻합니다. 세 가지 예제 파일의 경우 단일 TCP 연결을 통해 들어오는 데이터는 AABBCCAABBCC처럼 보일 수 있습니다(다른 많은 순서 체계가 가능하지만). 이것은 충분히 간단해 보이고 실제로 아주 잘 작동하여 HTTP/2를 일반적으로 HTTP/1.1만큼 빠르거나 약간 빠르지만 오버헤드는 훨씬 적습니다.

이미지를 통해 차이점을 확인해봅시다.

![http1.1과 http2의 차이점](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/900ea8f0-3782-4505-b1b6-99ca2954bbce/multiplexing-basic.png)

<u>그러나, TCP 쪽에 문제가 있습니다.</u> 알다시피 TCP는 오래된 프로토콜이고 웹 페이지를 로딩하기 위해 만들어진 것이 아니기 때문에 A, B, C가 무엇인지 알지 못합니다. TCP는 내부적으로 그냥 단순한 하나의 파일 X를 전송하고 있다고 생각하고 있어 실제로 HTTP 수준에서 AABBCCAABBCC로 전달되는 것인지 XXXXXXXXXXXX로 보이는 것인지에 대해 신경 쓰지 않습니다. 대부분의 경우에서는 이게 큰 문제가 되지는 않습니다. <u>하지만 네트워크 상에서 패킷로스가 있을 경우에는 문제가 됩니다.</u>

모든 데이터 전송은 문제없었지만 3번째 패킷(file B의 첫 데이터를 담고 있는)이 손실되었다고 생각해봅시다. TCP는 이 손실을 메꾸기 위해 손실 데이터의 새로운 복사본을 재전송합니다. 그러나 이 재전송은 도착까지 시간이 꽤 걸립니다. 아마 이글을 읽는 독자분께서는 A랑 C파일 LOSS만 없었다면 '그게 뭐 대수라고', '그냥 다시 B 파일을 재전송하면 되는거 아니냐' 생각할 수도 있습니다. 

하지만 안타깝게도 재전송 로직은 TCP 계층에서 발생하고 앞서 언급했듯이 <u>TCP는 A, B, C에 대해 알지 못하기 때문에</u> 그렇지 않습니다!(-> 문제가 됩니다!) <u>대신 TCP는 단일 X 파일의 일부가 손실되었다고 생각</u>하므로 구멍이 채워질 때까지 X의 나머지 데이터가 처리되지 않도록 해야 한다고 생각합니다. 달리 말하면, HTTP/2 수준에서 우리는 이미 A와 C를 처리할 수 있다는 것을 알고 있지만 TCP는 이것을 알지 못하므로 잠재적인 것보다 일 처리가 더 느립니다. 이러한 문제를 **HOL(Head of Line) Blocking**이라고 합니다. HOL에 대해 더 자세히 알고 싶으면 [Head-of-line example](https://calendar.perfplanet.com/2020/head-of-line-blocking-in-quic-and-http-3-the-details/) 에서 알아보세요.

<u>전송 계층에서 HoL 차단을 해결하는 것은 QUIC의 주요 목표 중 하나였습니다.</u> TCP와 달리 QUIC는 여러 개의 독립적인 바이트 스트림을 다중화하고 있음을 잘 알고 있습니다. 물론 CSS, JavaScript 및 이미지를 전송하고 있다는 사실까지는 알지 못합니다만 스트림이 분리되어 있다는 것을 알고 있습니다. 이와 같이 QUIC는 스트림별로 패킷 손실 감지와 복구 논리를 수행할 수 있습니다. 위의 시나리오에서는 스트림 B에 대한 데이터만 보류하고 TCP와 달리 A 및 C에 대한 모든 데이터를 가능한 한 빨리 HTTP/3 계층에 전달합니다. 이렇게 되면 이론적으로 퍼포먼스 향상을 기대할 수 있습니다. 

![HOL](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7981cb82-395c-4484-8873-46fd92804b4d/hol-blocking-basic.png)



## ❓ QUIC은 CONNECTION MIGRATION을 지원합니다.

QUIC의 세 번째 주요 개선 사항은 연결이 더 오래 유지될 수 있다는 사실입니다. 따라서 문제는 이러한 패킷이 올바른 목적지에 어떻게 도착하는가 하는 것입니다. 

인터넷에서 IP 주소는 두 개의 고유한 시스템 간에 패킷을 라우팅하는 데 사용됩니다. 그러나 당신의 전화기와 서버에 대한 IP 두 가지만로는 충분하지 않습니다.  왜냐하면 당신과 서버 모두 양쪽 끝에서 동시에 여러 네트워크 프로그램을 실행할 수 있기를 희망하기 때문입니다. 이것이 각각의 개별 연결마다 양쪽 끝점에서 <u>포트 번호가 할당되어 연결(Connection)과 해당 연결이 속한 응용 프로그램(Application)을 구별하는 이유</u>입니다. 서버 응용 프로그램은 일반적으로 기능에 따라 고정 포트 번호(예: HTTP(S)의 경우 포트 80 및 443, DNS의 경우 포트 53)를 갖는 반면 클라이언트는 일반적으로 각 연결에 대해 포트 번호를 (반)임의로 선택합니다.

따라서 머신과 애플리케이션 간에 고유한 연결을 정의하려면 **(1)클라이언트 IP 주소** + **(2)클라이언트 포트** + **(3)서버 IP 주소** + **(4)서버 포트**의 <u>4가지가 필요</u>합니다.

TCP에서 연결은 4-튜플로만 식별됩니다. 따라서 이 네 가지 매개변수 중 하나만 변경되면 연결이 무효화되고 다시 설정해야 합니다(새 핸드셰이크 포함). 이를 이해하려면 `주차장 문제 예시`를 활용하면 좋습니다. 한 번 상상해 보세요. 현재 건물 안에서 Wi-Fi로 스마트폰을 사용하고 있습니다. 따라서 이 Wi-Fi 네트워크에 IP 주소가 있습니다. 이제 외부로 이동하면 휴대전화가 셀룰러 4G 네트워크로 전환될 것입니다. 이것은 새로운 네트워크이기 때문에 완전히 새로운 IP 주소를 갖게 됩니다. 이제 서버는 이전에 본 적이 없는 클라이언트 IP에서 들어오는 TCP 패킷을 보게 됩니다(물론 두 포트와 서버 IP는 동일하게 유지될 수 있지만).

![wifi에서 셀룰러로의 통신전환](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9413b221-47e9-427b-b958-b0e62fe7f681/1-migration-tcp.png)

그렇다면 서버는 새로운 IP패킷이 이 기존의 "연결"에 속한다는 것을 어떻게 알 수 있을까요? 이러한 패킷이 동일한(임의) 클라이언트 포트(쉽게 발생할 수 있음)를 선택한 셀룰러 네트워크의 다른 클라이언트로부터의 새 연결에 속하지 않는다는 것을 어떻게 알 수 있을까요? 안타깝게도, TCP로는 이것을 알 수 없습니다. TCP는 우리가 셀룰러 네트워크와 스마트폰을 꿈꾸기도 전에 발명되었기 때문에 클<u>라이언트가 IP가 변경되었음을 서버에 알릴 수 있는 메커니즘이 없습니다.</u> 기존 4-튜플에 전송된 TCP 재설정 또는 fin 명령이 더 이상 클라이언트에 도달하지도 않기 때문에 연결을 "닫을" 방법조차 없습니다. 따라서 실제로 모든 네트워크 변경은 기존 TCP 연결을 더 이상 사용할 수 없음을 의미합니다. 새 연결을 설정하려면 새 TCP(및 TLS) 핸드셰이크를 실행해야 하며 응용 프로그램 수준 프로토콜에 따라 진행 중인 작업을 다시 시작해야 합니다. 예를 들어 HTTP를 통해 대용량 파일을 다운로드하는 경우 해당 파일을 처음부터 다시 요청해야 할 수 있습니다. 또 다른 예로는 네트워크를 전환할 때 짧은 정전이 발생할 수 있는 라이브 화상 회의가 있습니다. 하지만 위와 같은 상황에서 TCP 연결을 다시 시작하면 심각한 영향을 미칠 수 있습니다. **<u>이 문제를 해결하기 위해 QUIC에서는 연결 식별자(CID)라는 새로운 개념을 도입</u>**했습니다. 각 연결에는 두 끝점 사이에서 고유하게 식별하는 4-튜플 위에 다른 번호가 할당됩니다. 결정적으로 <u>이 CID는 QUIC 자체의 전송 계층에서 정의되기 때문에 네트워크 간에 이동할 때 변경되지 않습니다</u>!  아래 이미지를 통해 네트워크 원리를 확인해보세요. 이를 가능하게 하기 위해 CID는 모든 QUIC 패킷의 전면에 포함됩니다.

![QUIC과 CID](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e6ae0ec1-3b85-49a9-9707-ee21ce5b02b3/2-migration-single-cid.png)

<u>QUIC의 이 설정을 사용하면 4-튜플의 항목 중 하나가 변경되더라도 QUIC 서버와 클라이언트는 CID만 보고 동일한 이전 연결임을 알고 계속 사용할 수 있습니다.</u> 새로운 핸드셰이크가 필요하지 않으며 다운로드 상태를 그대로 유지할 수 있습니다. 이 기능을 일반적으로 연결 마이그레이션이라고 합니다. 

물론 CID도 극복해야 할 다른 과제가 있습니다. 예를 들어, 실제로 하나의 CID만 사용한다면 해커와 도청자가 네트워크를 통해 사용자를 추적하고 확장하여 그들의 (대략적인) 물리적 위치를 추론하는 것이 매우 쉬워질 것입니다. 이러한 프라이버시 악용을 방지하기 위해 QUIC은 새 네트워크가 사용될 때마다 CID를 변경합니다.

??? 이 얘기는 아마도 이 글을 읽는 독자분들을 혼란스럽게 할 수 있습니다. 방금까지 CID가 네트워크에서 동일해야 한다고 말하지 않았었나요? 흠... 글쎄요, 그것은 지나친 단순화였습니다. 실제로 내부적으로 발생하는 것은 클라이언트와 서버가 모두 동일한 개념적 "연결"에 매핑되는 (임의로 생성된) CID의 공통 목록에 동의한다는 것입니다. 예를 들어 둘 다 실제로 CID K, C 및 D가 모두 연결 X에 매핑된다는 것을 알고 있습니다. 따라서 클라이언트는 Wi-Fi에서 패킷에 K로 태그를 지정할 수 있지만 4G에서는 C를 사용하도록 전환할 수 있습니다. 이러한 공통 목록은 QUIC에서 완전히 암호화되어 협상되므로 잠재적인 공격자는 K와 C가 실제로 X인지 알지 못하지만 클라이언트와 서버는 이를 알고 연결을 계속 유지할 수 있습니다. (wifi에서 셀룰러로 전환될 때 똑같은 CID 안에 여러개의 마커를 두고 해당 마커를 포함하기만 하면 같은 사용자라고 식별. 다만 외부에서는 이것을 정정확히 구분할 수 없어 해커로부터 좀 더 안전.)

![QUIC과 CID2](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/715f189e-4ae6-4c4c-8db8-9fd8170049d8/3-migration-multi-cid.png)

라이언트와 서버가 스스로 선택한 CID 목록이 다르기 때문에(포트 번호가 다른 것과 유사) 훨씬 더 복잡해집니다. 이는 주로 대규모 서버 설정에서 라우팅 및 로드 밸런싱을 지원하기 위한 것입니다.



## :bulb: QUIC은 유연하고 진화할 수 있습니다.

QUIC의 마지막 측면은 진화하기 쉽도록 특별히 제작되었다는 것입니다. 이것은 여러 가지 방법으로 수행됩니다. 먼저 논의한 바와 같이 QUIC가 거의 완전히 암호화되어 있다는 사실은 최신 버전의 QUIC를 배포하려는 경우 모든 미들박스가 아니라 끝점(클라이언트 및 서버)만 업데이트하면 된다는 것을 의미합니다. 그것은 여전히 시간이 걸리지 만 일반적으로 몇 년이 아닌 몇 개월 정도입니다. 

둘째, TCP와 달리 QUIC는 단일 고정 패킷 헤더를 사용하여 모든 프로토콜 메타 데이터를 전송하지 않습니다. 대신 QUIC는 패킷 헤더가 짧고 패킷 페이로드 내부에 다양한 "프레임"(예: 소형 특수 패킷)을 사용하여 추가 정보를 전달합니다. 예를 들어, 아래 이미지와 같이 ACK 프레임(승인용), NEW_CONNECTION_ID 프레임(연결 마이그레이션 설정을 돕기 위해) 및 STREAM 프레임(데이터 전달용)이 있습니다.

이것은 모든 패킷이 가능한 모든 메타 데이터를 전달하는 것은 아니기 때문에 주로 최적화로 수행됩니다. 그러나 프레임 사용의 매우 유용한 부작용은 새로운 프레임 유형을 QUIC에 대한 확장으로 정의하는 것이 미래에 매우 쉬울 것이라는 점입니다. 예를 들어 매우 중요한 프레임은 DATAGRAM 프레임으로, 암호화된 QUIC 연결을 통해 신뢰할 수 없는 데이터를 전송할 수 있습니다.

![QUIC evlolve1](https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/88c76a7a-2752-4e5b-a829-290cd4951af3/quic-framing.png)



셋째, QUIC는 사용자 지정 TLS 확장을 사용하여 소위 전송 매개변수라 불리는 것을 전달합니다. 이를 통해 클라이언트와 서버는 QUIC 연결을 위한 구성을 선택할 수 있습니다. 이것은 어떤 기능이 활성화되었는지(예: 연결 마이그레이션 허용 여부, 지원되는 확장 등) 협상하고 일부 메커니즘(예: 지원되는 최대 패킷 크기, 흐름 제어 제한)에 대해 가장 합리적인 기본값을 전달할 수 있다는 것을 의미합니다. QUIC 표준은 이들의 긴 목록을 정의하지만 확장을 통해 새 항목을 정의할 수도 있으므로 프로토콜을 더욱 유연하게 만들 수 있습니다.

마지막으로, QUIC 자체의 실제 요구 사항은 아니지만 대부분의 구현은 현재 "사용자 공간"에서 수행됩니다(일반적으로 "커널 공간"에서 수행되는 TCP와 반대). 이는 주로 TCP보다 QUIC 구현 변형 및 확장을 실험하고 배포하는 것이 훨씬 쉽다는 것을 의미합니다.



## Conclusion
이 부분에서 배운 내용을 요약해 보겠습니다. 우리는 주로 어디에나 존재하는 TCP 프로토콜과 오늘날의 많은 문제가 알려지지 않은 시기에 HTTP프로토콜이 어떻게 설계되었는지에 대해 이야기했습니다. 하지만 TCP를 발전시키려고 시도하면서 거의 모든 장치에 업데이트해야 하는 자체 TCP 구현이 탑재되어 있기 때문에 TCP자체를 발전시키는 것이 실제로 어렵다는 것이 분명해졌습니다.

TCP를 계속 개선하면서 이 문제를 우회하기 위해 <u>새로운 QUIC 프로토콜</u>(실제로는 TCP 2.0)을 만들었습니다. <u>QUIC를 더 쉽게 배포할 수 있도록 UDP 프로토콜(대부분의 네트워크 장치도 지원함) 위에서 실행되며 향후 발전할 수 있도록 기본적으로 거의 완전히 암호화되며 유연한 프레이밍을 사용</u>합니다.

이 외에도 <u>QUIC는 핸드셰이크, 안정성 및 혼잡 제어와 같은 알려진 TCP 기능을 대부분 따라</u>합니다. 암호화 및 프레이밍 외에 두 가지 주요 변경 사항은 다중 바이트 스트림 인식과 연결 ID 도입입니다. 그러나 이러한 변경 사항은 QUIC 위에서 HTTP/2를 직접 실행하는 것을 방지하기에 충분하여 HTTP/3(실제로는 QUIC을 통한 HTTP/2임)을 만들어야 했습니다.

**QUIC의 새로운 접근 방식은 여러 가지 성능 향상을 제공**하지만 잠재적인 이점은 QUIC 및 HTTP/3에 대한 기사에서 일반적으로 전달되는 것보다 더 미묘한 차이가 있습니다. 이제 기본 사항을 알았으므로 이 시리즈의 다음 부분에서 이러한 뉘앙스를 더 깊이 논의할 수 있습니다. 계속 지켜봐 주세요!



---

긴 글 읽어주셔서 감사합니다.







